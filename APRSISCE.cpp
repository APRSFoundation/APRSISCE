//#define DEBUG_TIMINGS

//#define TRACE_MESSAGES
#ifdef TRACE_MESSAGES
int TraceMessages = 1;
int StopTraceMessages = 4;	/* 5 second increments */
#endif

/* 		sprintf(Buffer,"user %s pass %s vers APRSMonitor v0.1", CALLSIGN, PASSWORD); */
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// 
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning(disable : 4995)

#define INITGUID
#include "sysheads.h"

#ifndef UNDER_CE
#include <tlhelp32.h>
#include "dbghelp.h"
#endif

//#define WIN32_LEAN_AND_MEAN
//#include <windows.h>
//#include <strsafe.h>

//#include <math.h>
//#include <stdio.h>
//#include <stdlib.h>

#include "resource.h"

#include "LLUtil.h"
#include "parsedef.h"
#include "parse.h"
#include "tcputil.h"
#include "OSMUtil.h"
#include "Address.h"
#include "EchoLink.h"
#include "Geocaches.h"
#include "GPXFiles.h"
#include "MsgBox.h"
#include "Satellite.h"
#include "ShapFile.h"
#include "TraceLog.h"

#include "agw.h"
#include "kiss.h"
#include "port.h"
#include "text.h"

#include "sun.h"

#include "filter.h"
FILTER_INFO_S TestFilter={0};
FILTER_INFO_S IStoRFFilter={0};

#include "Config.h"

//#ifndef UNDER_CE
#define DO_OSM
//#endif

#ifdef UNDER_CE
#define SHADOW_SCREEN
#else
#define SHADOW_SCREEN
#endif

#define SUPPORT_RFID

#define SUPPORT_HOURLY_PACKET_COUNT

#define HOURLY_PACKETS 8

#ifdef USING_COMM_MGR
#include <connmgr.h>
#include <connmgr_status.h>
#endif

#ifdef USING_GPSAPI
#include <gpsapi.h>
#endif

#if defined(USING_SHELL) || defined(CE50)
#include <aygshell.h>
#ifdef USING_SHELL
UINT      g_uMsgMetricChange = RegisterWindowMessage(SH_UIMETRIC_CHANGE);
#endif
#endif

#ifdef USING_POWER
#include <pm.h>
POWER_BROADCAST_POWER_INFO pbpi = {0};
DWORD PowerNotificationThread(LPVOID pVoid);
#endif

#ifdef MONITOR_PHONE
#include <regext.h>
#include <SNApi.h>
static HREGNOTIFY hNotifySignalStrength = NULL;
static HREGNOTIFY hNotifyOperatorName = NULL;
static HREGNOTIFY hNotifyCellBroadcast = NULL;
#endif

#ifndef UNDER_CE
#include <Richedit.h>
#include <time.h>
//#define NTDDI_VERSION NTDDI_WIN2K
//#define NTDDI_VERSION NTDDI_WINXP
//#define NTDDI_VERSION NTDDI_VISTA
#include <Shellapi.h>
#include <Commctrl.h>
#endif

#include <Commdlg.h>

static void CalculateCPU(float *pKernelT, float *pUserT, float *pKernelD, float *pUserD);

#define GPSRate 1000
#define GPS_TIMER 10
#define TcpPollRate 5000	/* Was 100 */
#define TCP_TIMER 11
#define PurgeRate 30000
#define PURGE_TIMER 12
#define INVALID_TIMER 13
#define PowerRate (1*60*1000L)
#define POWER_TIMER 14
#define CROSSHAIR_TIMER 15
#define DriveRate (2000L/16)	/* 16 is scaling factor */
#define DRIVE_TIMER 16

#define MIN_SNR 0.0
#define MAX_SNR 40.0

#define RFPORT_INTERNAL 1111
#define APRSISWP 8765

#ifdef MONITOR_PHONE
static TCHAR szOldOperatorName[256] = TEXT("*NoPhone*");
static TCHAR szOldCellBroadcast[256] = TEXT("*NoCell*");
#endif
static DWORD dwOldSignalStrength=0;

static char *SpecMessageGroups[] = { "APRSIS-CE", "APRSIS-32", "ALL", "CQ", "QST" };

static APRS_PARSED_INFO_S APRSize;	/* For sizing calculatios below */
//#define CAPABILITY_SIZE (sizeof(APRSize.Capabilities))
#define COMMENT_SIZE (sizeof(APRSize.CleanComment))
#define PLATFORM_SIZE (sizeof(APRSize.Platform))
#ifndef STATION_SIZE
#define STATION_SIZE (sizeof(APRSize.srcCall))
#endif
#define STATUS_SIZE (sizeof(APRSize.StatusReport))

BOOL ForceTransmit = FALSE;
__int64 LastForce = 0;
BOOL GPSTransitionTransmit = FALSE;
BOOL ConnectionTransitionTransmit = FALSE;
SYSTEMTIME stLastActivity = {0};
__int64 LastAPRSReceive = 0;
TCHAR OriginalPath[MAX_PATH] = {0};

long PacketsXmit=0, PacketsRecv=0, PacketsDupe=0;
long PacketsIGated=0, PacketsPassed=0, PacketsQNOT=0, UDPSeq=0;

typedef struct DUPE_CHECK_S
{	unsigned long DupeUseCount;	/* For matching to Scrolling Stations */
	unsigned long CRC32;	/* Payload footprint */
	char Station[STATION_SIZE];
	char Owner[STATION_SIZE];
	char ToCall[STATION_SIZE];
	char qConstruct[STATION_SIZE];
	char IGate[STATION_SIZE];
	short RFDupeCount;
	short ISDupeCount;
	unsigned long PortsHeard;	/* bit map of ports that copied packet */
	__int64 lastMsec;	/* 0 is display-suppressed, 1 will purge */
	BOOL LastFromRF;	/* TRUE if pLastPacket from RF */
	BOOL Digipeated;	/* TRUE if this has already been digipeated */
	unsigned long LastISPort;	/* Index of last IS Port to received */
	int PacketSize;	/* Size of pPacket buffer */
	int PacketUse;	/* Length of current packet */
	char *pPacket;	/* Buffer for last received packet */
} DUPE_CHECK_S;

long DupeInUse = 0;
long DupeUseMax = 0;
long DupeStart = 0;
long DupeSize = 0;
DUPE_CHECK_S *Dupes = NULL;
unsigned long DupeUseCount = 0;	/* Steadily increasing counter */

FILTER_INFO_S ScrollerFilter={0};

/*   0      4 */
/*   1      8 */
/*   2      16 */
/*   3      32 */
/*   4      64 */
/*   5      96 */
/*   6      128 */
/*  Total  348=5.8 minutes */
/*   1      8 */
/*   2      16 */
/*   2.5    8 */
/*   3      32 */
/*   4      64 */
/*   5      96 */
/*   6      128 */
/*  Total  352=5.867 minutes */
static long NextMsgSend[] = { 8, 16, 8, 32, 64, 96, 128 };
/* Added 8 after 16 for 8+16+8=32 to get an early one into APRS-IS 12/10/2010 */
/* Removed 4 8/26/2010 */

#define MAX_MSG_RETRIES (ARRAYSIZE(NextMsgSend)-1)
#define NEXT_MSG_SEND(Retry) (llGetMsec() + (NextMsgSend[(Retry)<=MAX_MSG_RETRIES?(Retry):MAX_MSG_RETRIES])*1000)

#ifdef OLD_WAY
#define MAX_MSG_RETRIES 5
#define INITIAL_MSG_DELAY 31	/* Defeats APRS-IS 30 second DUPE detection */
#define EXTRA_MSG_DELAY 15		/* Add 15 seconds for each additional retry */
#define NEXT_MSG_SEND(Retry) (RtGetMsec() + (INITIAL_MSG_DELAY+EXTRA_MSG_DELAY*Retry)*1000)
/* Retries	Seconds */
/*   0      31 */
/*   1      46 */
/*   2      61 */
/*   3      76 */
/*   4      91 */
/*   5	   106 */
/*  Total  411=6.85 minutes */
#endif

static unsigned long PacketsDigid = 0;
static unsigned long PacketsRGated = 0;	/* Packets gated to RF */
static unsigned long MessagesGated = 0;	/* Messages gated to RF */
static unsigned long PositionsGated = 0;/* "Free" Positions gated to RF */
static __int64 LastIGateTransmitted = 0, LastRFIDTransmitted = 0;

int TransmitSize;
int TransmitCount;
char **TransmitQueue;

static int PendingMsgCount=0, PendingMsgSize = 0;
typedef struct PENDING_MESSAGE_S
{	char MsgAckFrom[16];
	char MsgAckID[8];	/* mm{nn for Reply-Ack */
	int Ack;	/* TRUE if Ack was requested */
	int OneShot;	/* TRUE if only one set of retries */
	int RFOnly;	/* TRUE if RFOnly was requested */
	int ISOnly;	/* TRUE if ISOnly was requested */
	int SuppressChat;	/* TRUE to keep message out of chat */
	int Retries;
	int Retriggered;
	int Subordinated;
	__int64 msNextSend;
	__int64 msLastIS;
	SYSTEMTIME stQueued;
	char aTo[16];
	TCHAR uTo[16];
	char aFrom[16];
//	TCHAR Msg[128];
	char Message[256];
	char MessageBody[256];
} PENDING_MESSAGE_S;
static PENDING_MESSAGE_S *PendingMsgs = NULL;
#define DEFAULT_WRAP_WIDTH 67
static void RemovePendingMessage(int m, char *Reason);
static BOOL SendAPRSMessageFrom(/*HWND hwnd,*/ char *From, char *To, int PrefixLen, TCHAR *wMsg, BOOL Ack, BOOL RFOnly=FALSE, BOOL ISOnly=FALSE, BOOL SuppressChat=FALSE, size_t WrapWidth=DEFAULT_WRAP_WIDTH, BOOL OneShot=FALSE);
static BOOL SendAPRSMessageOneShot(char *From, char *To, int PrefixLen, TCHAR *wMsg);
static BOOL SendAPRSMessage(/*HWND hwnd,*/ char *To, int PrefixLen, TCHAR *wMsg, BOOL Ack, BOOL RFOnly=FALSE, BOOL ISOnly=FALSE, BOOL SuppressChat=FALSE);
BOOL CALLBACK SendMessageDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp);

#ifdef UNDER_CE
#ifdef USING_COMM_MGR
CONNMGR_CONNECTIONINFO ConnInfo = {0};
HANDLE hConnection = {0};
WPARAM LastConnMgrStatus = -1;
#define WM_CONNMGR_NOTIFICATION WM_USER
#endif
#define WM_POWER_CHANGE WM_USER+1
#endif
#define WM_TILES_LOADED WM_USER+2
#define WM_REMEMBER_MESSAGE WM_USER+3
#define WM_PORT_STATUS WM_USER+4
#define WM_PORT_SUB_STATUS WM_USER+5
#define WM_PORT_RECEIVED WM_USER+6
#define WM_PORT_XMIT_COUNT WM_USER+7
#define WM_MSG_NOTIFICATION WM_USER+8
#define WM_BULL_NOTIFICATION WM_USER+9
#define WM_NOTIFY_SIGNAL_STRENGTH WM_USER+10
#define WM_NOTIFY_OPERATOR_NAME WM_USER+11
#define WM_NOTIFY_CELL_BROADCAST WM_USER+12
#define WM_ASYNC_MSG_BOX WM_USER+13
#define WM_FIX_SEND_BUTTON WM_USER+14
#define WM_FIX_CHAT_BUTTONS WM_USER+15
#define WM_REFRESH_CHAT WM_USER+16
#define WM_AUTO_ZOOM WM_USER+17
#define WM_CENTER_STATION WM_USER+18
#define WM_FINISH_STARTUP WM_USER+19
#define WM_ADD_FRIEND WM_USER+20
#define WM_REFRESH_CIRCLE WM_USER+21
#define WM_SET_CONTROLS WM_USER+22

// {02350F9D-638A-4c80-A96A-A16A1CDD873F}
static const GUID myGUID = 
{ 0x2350f9d, 0x638a, 0x4c80, { 0xa9, 0x6a, 0xa1, 0x6a, 0x1c, 0xdd, 0x87, 0x3f } };

#ifdef UNDER_CE
#define NOTIFICATION_INTERVAL (/*8**/60*60*1000)
#else
#define NOTIFICATION_INTERVAL (8*60*60*1000)
#endif
__int64 NextNotification = 0;
BOOL WasConnected = FALSE;
BOOL HadGPSFix = FALSE;
HANDLE hExitProgram;

static BOOL APRSEnabled = FALSE;
#ifdef SUPPORT_APRSTRACE
static FILE *APRSTraceFile = NULL;	/* Trace APRS-IS strings here when disabled */
#endif
static BOOL GPSEnabled = FALSE;
static BOOL GPSRunning = FALSE;
static long GPSSatInUse = 0;
#ifdef OBSOLETE
static BOOL AGWEnabled = FALSE;
static BOOL KISSEnabled = FALSE;
static BOOL TEXTEnabled = FALSE;
#endif
static BOOL OSMFetchEnabled = FALSE;
static BOOL CSVEnabled = FALSE;
static char *CSVTrackFileName = NULL;
static FILE *CSVTrackFile = NULL;	/* Log all coordinates here when GPS is enabled */
static BOOL BeaconEnabled = FALSE;
static BOOL TelemetryEnabled = FALSE;
static BOOL LabelsEnabled = FALSE;
static BOOL AltitudeEnabled = FALSE;
static BOOL IGateEnabled = FALSE;
static BOOL IGateReceiveOnly = FALSE;

static void TransmitIGate(BOOL Force=FALSE);
void FixMaxWidthStation(HWND hwnd);

#define RFPortRunnable(pPort) ((pPort)->IsEnabled && (!(pPort)->RequiresInternet || ActiveConfig.Enables.Internet))

static void FixIGateEnabled(void)
{	unsigned long p;
	BOOL NewEnabled = FALSE;
	BOOL NewReceiveOnly = !ActiveConfig.APRSIS.IStoRFEnabled;

	if (ActiveConfig.Enables.RFPorts)
	if (ActiveConfig.Enables.Internet)
	if (ActiveConfig.Enables.APRSIS)
	if (ActiveConfig.APRSIS.IStoRFEnabled
	|| ActiveConfig.APRSIS.RFtoISEnabled)
	for (p=0; p<ActiveConfig.RFPorts.Count; p++)
	{	PORT_CONFIG_INFO_S *pPort=&ActiveConfig.RFPorts.Port[p];
		if (RFPortRunnable(pPort))	/* Actually Enabled */
		if (!pPort->NotRF || pPort->RfBaud==-1)	/* Actually an RF Port */
		if (pPort->IStoRFEnabled || pPort->RFtoISEnabled)	/* And IGating */
		{	NewEnabled = TRUE;
			TraceLogThread("IGateEnabled", TRUE, "%s[%s] IGating %s at %ld baud\n", pPort->Name, pPort->Protocol, (pPort->XmitEnabled && pPort->IStoRFEnabled)?"Bi-Directional":"Receive-Only", (long) pPort->RfBaud);
			if (pPort->XmitEnabled
			&& pPort->IStoRFEnabled)
				NewReceiveOnly = FALSE;
		} //else TraceLogThread("IGateEnabled", TRUE, "%s[%s] Neither IStoRF nor RFtoIS Enabled\n", pPort->Name, pPort->Protocol);
		//else TraceLogThread("IGateEnabled", TRUE, "%s[%s] NotRF(%ld) and not IS-Server (RfBaud=%ld)\n", pPort->Name, pPort->Protocol, (long) pPort->NotRF, (long) pPort->RfBaud);
		//else TraceLogThread("IGateEnabled", TRUE, "%s[%s] Not Runnable (%s) (%sInternet %s)\n", pPort->Name, pPort->Protocol, pPort->IsEnabled?"Enabled":"DISABLED", pPort->RequiresInternet?"Required ":"", ActiveConfig.Enables.Internet?"Enabled":"DISABLED");
	} //else TraceLogThread("IGateEnabled", TRUE, "GLOBAL APRS-IS Neither IStoRF nor RFtoIS Enabled\n");
	//else TraceLogThread("IGateEnabled", TRUE, "GLOBAL APRS-IS Disabled\n");
	//else TraceLogThread("IGateEnabled", TRUE, "GLOBAL Internet Access Disabled\n");
	//else TraceLogThread("IGateEnabled", TRUE, "GLOBAL Enables / Ports / All Unchecked\n");
	
	if (!NewEnabled) NewReceiveOnly = FALSE;
	else if (ActiveConfig.Enables.RFReceiveOnly) NewReceiveOnly = TRUE;

	TraceLogThread("IGateEnabled", TRUE, "***** IGate %s %s *****\n",
		NewEnabled?"Enabled":"Disabled", NewReceiveOnly?"Receive-Only":"Bi-Directional");

	if (NewEnabled != IGateEnabled
	|| NewReceiveOnly != IGateReceiveOnly)
	{	IGateEnabled = NewEnabled;
		IGateReceiveOnly = NewReceiveOnly;
		TransmitIGate(TRUE);
		FixMaxWidthStation(NULL);
	}

	if (ActiveConfig.DigiXforms.Count)	/* See if we need to prime Digi traces */
	for (p=0; p<ActiveConfig.RFPorts.Count; p++)
	{	PORT_CONFIG_INFO_S *pPort=&ActiveConfig.RFPorts.Port[p];
		if (RFPortRunnable(pPort))	/* Actually Enabled */
		if (!pPort->NotRF || pPort->RfBaud==-1)	/* Actually an RF Port */
		{	IsTraceLogEnabled("Digi(NOT)");
			IsTraceLogEnabled("Digi");
			break;
		}
	}
}

//HWND g_hwndMb = NULL;
//HMENU cInfo->hMenu = NULL;

HANDLE hGPS = {0};
#ifdef USING_GPSAPI
GPS_DEVICE gpsDevice;
#endif

HINSTANCE g_hInstance;
HWND gModelessDialog = NULL;

extern "C"
{
void WINAPI Create_Dump(PEXCEPTION_POINTERS pException, BOOL File_Flag, BOOL Show_Flag);
int cdecl IsStationFollowed(char *StationID);
HICON MakeSymbolIcon(HWND hwnd, int Symbol);
BOOL TransmitString(char *Buffer);
char * cdecl FormatFilter(void);
#ifndef UNDER_CE
void CreateNotifyIcon(HWND hwnd, TCHAR *Tip, UINT id, UINT Msg, HICON hIcon);
void PopupNotifyIcon(HWND hwnd, char *Title, char *Text, UINT id);
void DestroyNotifyIcon(HWND hwnd, UINT id);
#endif
}

static const TCHAR g_szClassName[] = TEXT(PROGNAME);
static const TCHAR g_szTrackerName[] = TEXT("Tracker");
static const TCHAR g_szBullName[] = TEXT("BULLETINS");
#ifdef USING_CHAT
static const TCHAR g_szChatName[] = TEXT("CHATS");
#endif
#ifndef UNDER_CE
static const TCHAR g_szPortStatusName[] = TEXT("Port-Status");
#endif

GPS_POSITION LastGoodPosition = {0};
struct
{	double lat, lon;
	char Station[STATION_SIZE];
	char Owner[STATION_SIZE];
} MyDestination = {0};

/*
> -0 Home Station, Home Station running IGate.
> -1 Digipeater, Home Station running a Relay Digi, Wx Digipeater
> -2 Digipeater [#2 or] on 70CM
> -3 Digipeater [#3]
> -4 HF to VHF Gateway
> -5 IGate (Not home station)
> -6 is for Operations via Satellite
> -7 Kenwood D7 HH
> -8 is for boats, sailboats and ships (maybe 802.11 in the future)
> -9 is for Mobiles
> -10 is for operation via The internet only
> -11 is for APRStouch-tone users (and the occasional Balloons)
> -12 Portable Units such as Laptops, Camp Sites etc.
> -13 Un-asigned
> -14 is for Truckers
> -15 is for HF
*/

//#define LOGON "user KJ4ERJ-12 pass 24231 APRSISCE v0.1"
//#define FILTER "#filter r/27.99673/-80.659072/500 b/KJ4ERJ* f/KJ4ERJ-12/10"
//#define FILTER "#filter m/100 b/KJ4ERJ* f/KJ4ERJ-12/10"
#define PING "#"

#define POS_TIMESTAMPED_WITH_MESSAGING '@'
#define POS_TIMESTAMPED_NO_MESSAGING '/'
#define POS_NO_TIME_WITH_MESSAGING '='
#define POS_NO_TIME_NO_MESSAGING '!'

static TCHAR MaxWidthStationID[STATION_SIZE+3] = TEXT("KJ4ERJ-12");	/* +3 for *9null */
static size_t MaxWidthStationLength = 9;	/* Length of default MaxWidthStationID */
static int MaxWidthStationWidth = 0;

static TCHAR MaxWidthIGateID[STATION_SIZE+3] = TEXT("");	/* +3 for ?future? */
static size_t MaxWidthIGateLength = 0;
static int MaxWidthIGateWidth = 0;

static TCHAR MaxSpeedText[8] = TEXT("99");
static int MaxSpeedWidth = 0;
static double MaxSpeed = 99.0;

typedef enum PACKET_TYPE_V
{	BEACON_PACKET,
	STATUS_PACKET,
	DX_PACKET,
	MESSAGE_PACKET,
	MESSAGE_ACK_PACKET,
	BULLETIN_PACKET,
	CAPABILITY_PACKET,
	OBJECT_PACKET,
	TELEMETRY_PACKET,
	DIGIPEAT_PACKET,
	IS2RF_IGATE_PACKET
} PACKET_TYPE_V;

typedef enum MESSAGE_TYPE_V
{	MESSAGE_TACTICAL,	/* TACTICAL definition messages */
	MESSAGE_ME,			/* Messages addressed to me */
	MESSAGE_COMPANION,	/* Messages addressed to my companion(s) */
	MESSAGE_MY,			/* Messages to my base callsign */
	MESSAGE_NWS,		/* Messages from NWS */
	MESSAGE_INTERNAL,	/* Version Check messages */
	MESSAGE_RUNNING,	/* KJ4ERJ-sourced Running messages */
	MESSAGE_GROUP,		/* User-specified message groups */
	MESSAGE_SPECIAL,	/* Hard-coded special groups */
	MESSAGE_RF,			/* RF-Eavesdropped messages */
	MESSAGE_EAVESDROP,	/* Eavesdropped messages */
	MESSAGE_UNSPECIFIED
} MESSAGE_TYPE_V;

typedef struct MESSAGE_INFO_S
{	SYSTEMTIME stLocal;
	char *From;
	char *To;
	char *Text;
	char *NWSObject;
	MESSAGE_TYPE_V Type;
	long Index;
	BOOL AddedToChat;
	BOOL PendingAutoReply;
#ifdef USING_SHELL
	SHNOTIFICATIONDATA *pNotification;
#endif
} MESSAGE_INFO_S;

typedef struct BULLETIN_INFO_S
{	SYSTEMTIME st;
	char aFrom[STATION_SIZE];
	char ID;
	char aGroup[STATION_SIZE];
	char *Text;
#ifdef USING_SHELL
	SHNOTIFICATIONDATA *pNotification;
#endif
} BULLETIN_INFO_S;

MESSAGE_INFO_S *Messages;
int MessageCount;
int MessageSize;
BOOL PendingAutoReply = FALSE;

BULLETIN_INFO_S *Bulletins;
int BulletinCount;
int BulletinSize;
BOOL NewBulletins;

#ifdef UNDER_CE
#define __fileDECL  __cdecl
#define __COMPARE(context, p1, p2) (*compare)(p1, p2)

void * __fileDECL bsearch (
    const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__fileDECL *compare)(const void *, const void *)
    )
{
    char *lo = (char *)base;
    char *hi = (char *)base + (num - 1) * width;
    char *mid;
    size_t half;
    int result;

    while (lo <= hi)
    {
        if ((half = num / 2) != 0)
        {
            mid = lo + (num & 1 ? half : (half - 1)) * width;
            if (!(result = __COMPARE(context, key, mid)))
                return(mid);
            else if (result < 0)
            {
                hi = mid - width;
                num = num & 1 ? half : half-1;
            }
            else
            {
                lo = mid + width;
                num = half;
            }
        }
        else if (num)
            return (__COMPARE(context, key, lo) ? NULL : lo);
        else
            break;
    }

    return NULL;
}

#undef __fileDECL
#undef __COMPARE
#endif

unsigned long PacketPathCount = 0;	/* Pointed to by Stations */

unsigned long CoordCount = 0;
unsigned long CoordSize = 0;
unsigned long PossibleFreeCoord = 0;
//COORDINATE_S **Coords = NULL;
COORDINATE_S **SortedCoords = NULL;

unsigned long CoordSearches = 0;
unsigned long CoordPurges = 0;
unsigned long CoordFinds = 0;

#define COORDS(n,s,f) \
	if (n != s->pCoord) \
	{	unsigned long x; \
		TraceLogThread("Coords", TRUE, "%s(%s) %p(%.6lf %.6lf) != %p(%.6lf %.6lf) by(%lf %lf)\n", \
						#f, s->Station, s->pCoord, s->pCoord->lat, s->pCoord->lon, \
						n, n->lat, n->lon, n->lat-s->pCoord->lat, n->lon-s->pCoord->lon); \
		for (x=0; x<CoordCount; x++) \
		{	if (SortedCoords[x] == s->pCoord) \
				TraceLogThread("Coords", TRUE, "[%ld] %s->pCoord(%p)->%.6lf %.6lf\n", \
								x, #s, SortedCoords[x], s->pCoord->lat, s->pCoord->lon); \
			if (SortedCoords[x] == n) \
				TraceLogThread("Coords", TRUE, "[%ld] %s(%p)->%.6lf %.6lf\n", \
								x, #n, SortedCoords[x], n->lat, n->lon); \
			if (SortedCoords[x]->lat == s->pCoord->lat \
			&& SortedCoords[x]->lon == s->pCoord->lon) \
				TraceLogThread("Coords", TRUE, "[%ld] %p->%.6lf %.6lf\n", \
								x, SortedCoords[x], SortedCoords[x]->lat, SortedCoords[x]->lon); \
		}  \
	}

static int CompareSortedCoords(const void *One, const void *Two)
{	COORDINATE_S *Left = *(COORDINATE_S **)One;
	COORDINATE_S *Right = *(COORDINATE_S **)Two;
	if (Left->lat < Right->lat) return -1;
	if (Left->lat > Right->lat) return 1;
	if (Left->lon < Right->lon) return -1;
	if (Left->lon > Right->lon) return 1;
	return 0;
}

static int CompareSortedCoords2(const void *One, const void *Two)
{	COORDINATE_S *Left = *(COORDINATE_S **)One;
	COORDINATE_S *Right = *(COORDINATE_S **)Two;
	if (Left->TileCoord.y < Right->TileCoord.y) return -1;
	if (Left->TileCoord.y > Right->TileCoord.y) return 1;
	if (Left->TileCoord.x < Right->TileCoord.x) return -1;
	if (Left->TileCoord.x > Right->TileCoord.x) return 1;
	return 0;
}

static struct
{	char *From;
	unsigned long Finds;
	unsigned long News;
} CoordStats[16] = { 0 };

static unsigned long PurgeFreeCoords(char *From, char *Xtra)
{	unsigned long FreeCount = 0;
	unsigned long c;
	CoordPurges++;
	for (c=CoordCount-1; ((long)c)>=0; c--)
	{	if (!SortedCoords[c]->References)
		{	COORDINATE_S *pCoord = SortedCoords[c];	/* Save before stomping */
			FreeCount++;
			memmove(&SortedCoords[c], &SortedCoords[c+1], (CoordCount-c-1)*sizeof(*SortedCoords));
			SortedCoords[--CoordCount] = pCoord;	/* And put it at the end */
		}
	}
	if (FreeCount)
		TraceLogThread("Coords", FALSE, "%s(%s) Purged %ld free Coords leaving %ld\n", From, Xtra, FreeCount, CoordCount);
	else TraceLogThread("Coords", PossibleFreeCoord!=0, "%s(%s) Found NO FREE Coords in %ld (%ld Possibly free)\n", From, Xtra, CoordCount, (long) PossibleFreeCoord);
	PossibleFreeCoord = 0;
	return FreeCount;
}

static void DeReferenceCoord(char *From, char *Xtra, COORDINATE_S *pCoord)
{
	if (pCoord)
	{	if (!--pCoord->References)
		{	PossibleFreeCoord++;
			//if (strcmp(Xtra,CALLSIGN)) TraceLogThread("Coords", TRUE, "%s(%s) Dereferenced %p->%.6lf %.6lf\n", From, Xtra, pCoord, pCoord->lat, pCoord->lon);
		}
	}
}

static COORDINATE_S *GetCoordIndex(double lat, double lon, char *From, char *Xtra, COORDINATE_S *Previous)
{	unsigned long c, d;
	COORDINATE_S **p;
	COORDINATE_S Find;
	COORDINATE_S *pFind = &Find;
	unsigned long s;

	if (Previous) DeReferenceCoord(From, Xtra, Previous);

	for (s=0; s<ARRAYSIZE(CoordStats); s++)
	if (CoordStats[s].From)
	{	if (CoordStats[s].From == From
		|| (*CoordStats[s].From == *From
			&& !strcmp(CoordStats[s].From, From)))
		{	break;
		}
	} else break;
	if (!CoordStats[s].From)
	{	CoordStats[s].From = From;
	} else if (s >= ARRAYSIZE(CoordStats))
	{	s = ARRAYSIZE(CoordStats)-1;
		if (strcmp(CoordStats[s].From, "*OverFlow*"))
			TraceLogThread("Coords", TRUE, "CoordStats[%ld] OVERFLOW!\n", ARRAYSIZE(CoordStats));
		CoordStats[s].From = "*OverFlow*";
	}
	CoordStats[s].Finds++;

	CoordSearches++;
	Find.lat = lat; Find.lon = lon;
	p = (COORDINATE_S **) bsearch(&pFind, SortedCoords, CoordCount, sizeof(*SortedCoords), CompareSortedCoords);
	if (p)
	{	CoordFinds++;
		(*p)->References++;
		return *p;
	}

	memset(&Find, 0, sizeof(Find));
	Find.lat = lat;
	Find.lon = lon;
	LatLonToTileCoord(lat, lon, &Find.TileCoord);
	if (Find.TileCoord.x>>8 != long2tilex(lon, 24/*MAX_OSM_ZOOM*/))
		TraceLogThread("Coords", TRUE, "%s(%s):TileCoord.x(%ld) != long2tilex(%ld) @ %.6lf %.6lf\n",
						From, Xtra, (long) (Find.TileCoord.x>>8),
						long2tilex(lon, 24/*MAX_OSM_ZOOM*/), lat, lon);
	if (Find.TileCoord.y>>8 != lat2tiley(lat, 24/*MAX_OSM_ZOOM*/))
		TraceLogThread("Coords", TRUE, "%s(%s):TileCoord.y(%ld) != lat2tiley(%ld) @ %.6lf %.6lf\n",
						From, Xtra, (long) (Find.TileCoord.y>>8),
						lat2tiley(lat, 24/*MAX_OSM_ZOOM*/), lat, lon);

	p = (COORDINATE_S **) bsearch(&pFind, SortedCoords, CoordCount, sizeof(*SortedCoords), CompareSortedCoords2);
	if (p)
	{	CoordFinds++;
		TraceLogThread("Coords", TRUE, "Second Chance Find!  %.6lf %.6lf != %.6lf %.6lf but %ld %ld = %ld %ld\n",
						Find.lat, Find.lon, (*p)->lat, (*p)->lon,
						Find.TileCoord.x, Find.TileCoord.y, (*p)->TileCoord.x, (*p)->TileCoord.y);
		(*p)->References++;
		return *p;
	}

	if (PossibleFreeCoord && CoordCount >= CoordSize)
		PurgeFreeCoords(From, Xtra);	/* Before growing, purge unreferenced */

	c = CoordCount++;
	if (CoordCount > CoordSize)
	{	unsigned long i;
		__int64 msStart = llGetMsec();
	static unsigned long Growth = 256;
		unsigned long OldSize = CoordSize;
		COORDINATE_S *NewCoords = (COORDINATE_S *) calloc(sizeof(*NewCoords),Growth);
		CoordSize += Growth;
//		Coords = (COORDINATE_S **)realloc(Coords, sizeof(*Coords)*CoordSize);
		SortedCoords = (COORDINATE_S **)realloc(SortedCoords, sizeof(*SortedCoords)*CoordSize);
		for (i=0; i<Growth; i++)
		{	unsigned long j = i+OldSize;
			SortedCoords[j] = /*Coords[j] = */ &NewCoords[i];
		}
		TraceLogThread("Coords", FALSE, "Grew Coords to %ld (Hits:%lu/%lu Purges:%lu) in %ld msec\n", CoordSize,
						(long) CoordFinds, (long) CoordSearches, (long) CoordPurges, (long) (llGetMsec()-msStart));
		for (i=0; i<ARRAYSIZE(CoordStats); i++)
		if (CoordStats[i].From)
			TraceLogThread("Coords", FALSE, "[%ld] %s %lu/%lu\n",
							i, CoordStats[i].From, CoordStats[i].News, CoordStats[i].Finds);
	}
	CoordStats[s].News++;
	unsigned long dStart=0;
	if (CoordCount > 16)	/* Avoid looking at CoordCount-1, the new entry */
	{	int Chunks = 8;
		for (d=Chunks-1; d>0; d--)
		{	if (CompareSortedCoords(&pFind, &SortedCoords[d*CoordCount/Chunks]) >= 0)
			{	dStart = d*CoordCount/Chunks;
				break;
			}
		}
		//dStart = 0;
//		if (CompareSortedCoords(&pFind, &SortedCoords[3*CoordCount/4]) >= 0) dStart = 3*CoordCount/4;
//		else if (CompareSortedCoords(&pFind, &SortedCoords[2*CoordCount/4]) >= 0) dStart = 2*CoordCount/4;
//		else if (CompareSortedCoords(&pFind, &SortedCoords[CoordCount/4]) >= 0) dStart = CoordCount/4;
	}

	for (d=dStart; d<CoordCount-1; d++)
	{	int f = CompareSortedCoords(&pFind, &SortedCoords[d]);
		if (f == 0) TraceLogThread("Coords", TRUE, "Inserting DUPLICATE?  %lf %lf\n", pFind->lat-SortedCoords[d]->lat, pFind->lon-SortedCoords[d]->lon);
		if (f <= 0) break;
	}
	pFind = SortedCoords[CoordCount-1];	/* Remember the new one */
	memmove(&SortedCoords[d+1], &SortedCoords[d], sizeof(*SortedCoords)*(CoordCount-d-1));	/* Clobbers it */
	SortedCoords[d] = pFind;
	*SortedCoords[d] = Find;
#ifdef VERBOSE
	if (CoordCount < 16)
	{	unsigned long i;
		TraceLogThread("Coords", TRUE, "New[%ld] %.6lf %.6lf (%lu %lu)\n", c,
							Find.lat, Find.lon,
							Find.TileCoord.x, Find.TileCoord.y);
		for (i=0; i<CoordCount; i++)
			TraceLogThread("Coords", TRUE, "%2ld[%ld] [%ld] %.6lf %.6lf (%lu %lu)\n", CoordCount, d, i,
							SortedCoords[i]->lat, SortedCoords[i]->lon,
							SortedCoords[i]->TileCoord.x, SortedCoords[i]->TileCoord.y);
	}
	if (CoordCount == 16)
	{	unsigned long i;
		//qsort(SortedCoords, CoordCount, sizeof(*SortedCoords), CompareSortedCoords);
		for (i=0; i<CoordCount; i++)
			TraceLogThread("Coords", TRUE, "[%ld] %.6lf %.6lf (%lu %lu)\n", i,
							SortedCoords[i]->lat, SortedCoords[i]->lon,
							SortedCoords[i]->TileCoord.x, SortedCoords[i]->TileCoord.y);
	}
#endif
	SortedCoords[d]->References++;
	return SortedCoords[d];
}

typedef struct STATION_SCROLLER_S
{	int HeardOnRF;
	int Digipeated:1;
	int HeardViaTCP:1;
	int HeardAsThird:1;
	short RFDupeCount;
	short ISDupeCount;
	unsigned long DupeUseCount;	/* Fast and Easy lookup from Dupes */
	int CloseIndex;	/* Index to pCloseStations */
	COLORREF BackColor;	/* Background for painting (default=white) */
	double Lat, Lon;	/* Use for paint color if non-zero, else black */
	SYSTEMTIME stPacket;		/* System timestamp of receipt */
	char Station[STATION_SIZE];
	char Owner[STATION_SIZE];
	char Label[16];		/* See Nickname's label */
	char IGateOrDigi[STATION_SIZE+1];	/* May be used! */
	char Packet[1024];	/* I know, it shouldn't be hard-coded, but... */
	int pUsedHops;	/* Path (w/aliases) 0 if direct */
	int aUsedHops;	/* Actual (de-aliased) 0 if direct */
} STATION_SCROLLER_S;

//#ifdef UNDER_CE
//#define STATION_COUNT 40	/* 32 is too small for WebDT */
//#else
//#define STATION_COUNT 64
//#endif
unsigned long PacketScrollerSize=0;	/* Based on rectangle height/font height & ActiveConfig.PacketScrollerSize */
STATION_SCROLLER_S *Stations=NULL;
STATION_SCROLLER_S *PaintingStations=NULL;
RECT *rcPaintingStations=NULL;

BOOL PaintingStationsFrozen = FALSE;
unsigned long PendingStationsCount = 0;	/* Count of Stations needing to go into PaintingStations */

void InvalidateStations(HWND hwnd, BOOL ForceIt = TRUE);
static void ReSizePacketScroller(HWND hwnd)
{	if (ActiveConfig.PacketScrollerSize < 2) ActiveConfig.PacketScrollerSize = 2;
	if (PacketScrollerSize < ActiveConfig.PacketScrollerSize)
	{	TraceLog("Activity", TRUE, hwnd, "Resizing PacketScroller From %ld to %ld\n", PacketScrollerSize, ActiveConfig.PacketScrollerSize);
		Stations = (STATION_SCROLLER_S*)realloc(Stations,sizeof(*Stations)*ActiveConfig.PacketScrollerSize);
		PaintingStations = (STATION_SCROLLER_S*)realloc(PaintingStations,sizeof(*PaintingStations)*ActiveConfig.PacketScrollerSize);
		rcPaintingStations = (RECT*)realloc(rcPaintingStations,sizeof(*rcPaintingStations)*ActiveConfig.PacketScrollerSize);
		memset(&Stations[PacketScrollerSize],0,sizeof(*Stations)*(ActiveConfig.PacketScrollerSize-PacketScrollerSize));
		memset(&PaintingStations[PacketScrollerSize],0,sizeof(*PaintingStations)*(ActiveConfig.PacketScrollerSize-PacketScrollerSize));
		memset(&rcPaintingStations[PacketScrollerSize],0,sizeof(*rcPaintingStations)*(ActiveConfig.PacketScrollerSize-PacketScrollerSize));
		PacketScrollerSize = ActiveConfig.PacketScrollerSize;
		InvalidateStations(hwnd, TRUE);
	}
}

typedef struct MENU_ITEM_S
{	BOOL Active:1;
	BOOL HasBitmaps:1;
	UINT BaseID;
	UINT Index;
} MENU_ITEM_S;

typedef struct CLIENT_INFO_S
{	BOOL Active;
	BOOL Running;	/* TRUE if window creation completed */
#ifndef UNDER_CE
	BOOL Flashing;	/* TRUE if the window is flashing */
	BOOL FlashingAcked;	/* TRUE if window flash was acked */
#endif
	HWND hwnd;
	HWND hwndCB;
	HMENU hMenu;
	HWND hwndViewChooser;	/* NULL if not active */
	HWND hwndPathConfig;	/* NULL if not active */
	int MenuOffset;
	unsigned int MenuCount;
	unsigned int MenuSize;
	MENU_ITEM_S *MenuItems;
	int	Index;	/* 0=Main, 1+=Additional */
	UINT_PTR InvalidTimer;	/* non-zero if timer is running */
	BOOL CrossHairs;
	BOOL AutoZoomViewIn;
	BOOL AutoZoomViewOut;
	BOOL AutoZoomViewCtr;
	BOOL AutoZoomME;	/* Include ME in AutoZoom calculations */

	__int64 msLastSigChange;	/* Time of last "significant" change */
								/* Significant == affects coordinate mapping */

	GPS_POSITION LastCenterPosition;

	struct
	{	__int64 msLastPaint;
		__int64 msNextPaint;
		BOOL StationsValid;
		char *InvalidReason;
		BOOL DeadReckoning;
		BOOL StormSpinning;
		__int64 msPathExpire;	/* ms till next path expiration */
		__int64 msNotAllStart;	/* timestamp starting NotAll display */
		__int64 msNotAllExpire;	/* ms till NotAll should disappear */
		HDC hdcShadow;
		RECT rcShadow;
		HBITMAP hShadowMap;
		HGDIOBJ hOrgMap;
		RECT rcAll;
		unsigned long PaintCount, ShadowCount;
		__int64 msPaintTotal, msShadowTotal;
	} Circle;

	struct
	{	long LastCount, msLast;
		long LastShadow, msLastShadow;
		SYSTEMTIME stLast;
#define CLEAR_SECONDS 4
	} Time;

	BOOL Locked;
	BOOL CenterRanging;
	BOOL CenterTracking;
	BOOL Awaiting;
	char CenterID[16];
	struct STATION_INFO_S *CenterStation;

	BOOL Driving;	/* TRUE if window is driving along a MultiLine */
	int DrivePoint;	/* Current start point of drive */
	int DriveCount;
	int DriveDelay;	/* Count down to split timer resolution */
	int DriveSize;
	int LastQueued;
	LAT_LON_S *DrivePoints;
	long StartTilesFetched;	/* Count of fetched tiles at start of drive */
	double DistanceDriven;	/* Total miles driven along route */
	SYSTEMTIME stDriveStart;	/* Time of the start of the drive */

	unsigned long Orientation;
	unsigned long Percent;

	long WheelDelta;
	BOOL Captured;
	BOOL Dragging;
	__int64 msDragComplete;	/* llGetMsec() when done dragging */
	int RestorePercent;
	POINT ptCapture;
	struct INFO_BLOCK *ibCapture;
	LRESULT (*CaptureHandler)(struct INFO_BLOCK *Info, HWND hwnd, struct CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);

	WPARAM prevSize, curSize;

#ifdef SHADOW_SCREEN
	HBITMAP hShadowMap;
	long shadowWidth, shadowHeight;
#endif

#ifdef DO_OSM
	TILE_SERVER_INFO_S tsInfo;
	OSM_TILE_SET_S *ts;
#endif
	int zoom;
	double Scale;
#if MAX_TRACKERS > 1
	RECT rcSize;
#endif
	unsigned __int64 viewBits;
	unsigned __int64 viewBitsPainted;
//	unsigned long viewBits2;
	unsigned long viewShrieks;
	BOOL viewMicE[32];	/* This must be larger or equal to ARRAYSIZE(MicEActions) in config.c */
	BOOL viewSymbols[MAX_SYMBOL_INDEX+1];
	BOOL viewPlatforms[PLATFORM_MAX+1];
	BOOL ShowMyObjects;

#ifdef OLD_WAY
	BOOL ShowPaths;
	BOOL ShowPacket;
	BOOL Paths.LclRF;
	BOOL Paths.All.Selected;
	BOOL Paths.Direct.Enabled;
	BOOL Paths.First.Enabled;
	BOOL Paths.Middle.Enabled;
	BOOL Paths.Final.Enabled;
	unsigned long Paths.MaxAge;
	unsigned long PathOpacity;
	unsigned long PathReasonabilityLimit;
#else
	PATH_CONFIG_INFO_S Paths;
#endif
//	BOOL coordinatesMoved;	/* TRUE if coordinates move by enough precision digits */
//	double forecastDistance, projDistance, projBearing;
//	double deltaDistance, deltaBearing, deltaHeading;

} CLIENT_INFO_S;

	DWORD SatellitesInViewPRNs[GPS_MAX_SATELLITES];
	GPS_POSITION gpsPosition;

	double Odometer;

#ifdef FOR_INFORMATION_ONLY
/*
Chr	Color	Type of Line	Use in NWS Messages
a	red	solid	Tornado Warning
b	red	dashed	Tornado Watch
c	red	double dashed	
d	yellow	solid	Severe Thunderstorm Warning
e	yellow	dashed	Severe Thunderstorm Watch  (Example Packet)
f	yellow	double dashed 	
g	blue	solid	Test Warning
h	blue	dashed	Test Watch
i	blue	double dashed 	
j	green	solid	
k	green	dashed	Mesoscale Discussion Areas
l	green	double dashed 	
*/
#endif

#ifdef OLD_WAY
typedef struct MULTILINE_POINT_S
{	double Lat, Lon;
} MULTILINE_POINT_S;
#endif

typedef SHAPEFILE_POINT_S MULTILINE_POINT_S;

typedef struct MULTILINE_INFO_S
{	struct
	{	char LineType;
		char ObjType;
		double Scale;
	} MultiLine;
//	char cLineType;
//	char cObjType;
//	double Scale;

	struct
	{	char Type;
		char Color;
		int Width;	/* For lines */
		double xOff, yOff;
	} Area;

	BOOL Errors;		/* TRUE if Source had errors */
	char *SourceString;	/* Original definition for update matching */

	BOOL Filled;	/* TRUE if filled polygons (vs simple lines) */
	int style;	/* Line Style (PS_...) */
	COLORREF color;

	MULTILINE_POINT_S At, Min, Max;
	RECT tileMinMax;	/* At MAX_OSM_ZOOM zoom */

	int Segments;	/* 1 means no array */
	int *SegEnds;	/* Only if Segments > 1 */
	int Count;
	MULTILINE_POINT_S *Points;
	OSM_TILE_COORD_S *tCoords;
	struct
	{	RECT rcMinMax;	/* Cached for POINT optimization */
		int *ptEnds;	/* Cached for POINT optimization */
		POINT *pts;		/* Cached for POINT optimization */
#ifdef SUPPORT_RECTANGLE_FILL
		RECT *rcBounds;	/* Cached for POINT optimization */
#endif
	} Tracker[MAX_TRACKERS];
} MULTILINE_INFO_S;

#ifndef NO_PATH_TRACKING

typedef enum PATH_LINE_TYPE_V
{	PATH_LINE_DIRECT = '0',
	PATH_LINE_FIRST = 'F',
	PATH_LINE_MIDDLE = 'M',
	PATH_LINE_LAST = 'L'
} PATH_LINE_TYPE_V;

typedef struct PATH_LINE_S
{	char FromRF;
	PATH_LINE_TYPE_V Type;
	unsigned short UseCount;
	unsigned short Length;	/* In miles */
	struct
	{	unsigned long SeenIndex;
		COORDINATE_S *pCoord;
	} from, to;
	__int64 msec;		/* For aging calculations */
} PATH_LINE_S;

typedef struct PACKET_PATH_S
{	char FromRF;
	char References;	/* Up to 9, really */
	char HopCount;		/* Some may have NULL pCoords */
	struct
	{	unsigned long SeenIndex;	/* Who it is */
		COORDINATE_S *pCoord;		/* Where it was */
	} Hops[11];	/* source->path*7->dest+q-Construct+IGate */
	__int64 msec;		/* For aging calculations */
} PACKET_PATH_S;

#endif

typedef struct NWS_TIMES_S
{	SYSTEMTIME stIssued;	/* Only for NWS objects */
	SYSTEMTIME stExpires;	/* Only for NWS objects */
} NWS_TIMES_S;

typedef struct STATION_INFO_S
{	SYSTEMTIME stLast;		/* System timestamp of last receipt */
	SYSTEMTIME stPos;		/* System time of last position update */
	__int64 lastMsec;		/* 0 for free entry, llGetMsec() of last update */
	__int64 lastRFMsec;		/* last time heard on RF */
	int Index;				/* TEMPORARY! */
	char Station[STATION_SIZE];		/* NULL if free entry */
	char Owner[STATION_SIZE];		/* NULL if free entry */
	char IGate[STATION_SIZE];		/* Most recent gate */
	char dstCall[STATION_SIZE];		/* Most recent dstCall */
	unsigned long SeenIndex;		/* Index to SeenStations list */
	unsigned char sLastPacket;		/* String buffer sizes */
	unsigned char sLastPositPacket;		/* String buffer sizes */
	unsigned char sPath;			/* String buffer sizes */
	unsigned char sRFpath;			/* String buffer sizes */
	unsigned char sComment;			/* String buffer sizes (# TCHARs) */
	unsigned char sStatusReport;	/* String buffer sizes (# TCHARs) */
	unsigned char sCapabilities;	/* String buffer sizes (# TCHARs) */
	char *pLastPacket;		/* Last received packet */
	char *pLastPositPacket;		/* Last received posit packet */
	char *pPath;				/* Most recent path spec */
	char *pRFpath;			/* Most recent RF path spec */
	TCHAR *pComment;		/* Most recent (non-blank) comment */
	TCHAR *pStatusReport;		/* Most recent (non-blank) status */
	TCHAR *pCapabilities;		/* Most recent (non-blank) capabilities */
	APRS_PLATFORM_V tPlatform;		/* enum for type of platform */
	unsigned long ShriekMask;		/* Bit mask of defined shrieks */
	char *pPlatform;			/* Platform if parser could identify it */
	char ReplyAck[2];		/* Not null terminated, may be null */
	TIME_INFO_S Time;		/* only valid if non-zero */
	unsigned char MicEIndex;	/* May be 0 for not defined */
	char HeardOnRF;			/* 0=No, 1=direct, else hops+2 */
	short Dupes;				/* Count of duplicates heard via IS */
	short RFDupes;			/* Count of duplicates heard via RF */
	short course;			/* Last reported course and speed */
	short speed;			/* Last reported course and speed */
	char latlonExtended;	/* True if !DAO! parsed */
	char Ambiguity;		/* 0=accurate, 0.1, 1.0, 10.0, 60.0 nautical miles */
	char gsAmbiguity;	/* # characters of GridSquare */
	COLORREF TrackColor;	/* RGB of user-specified color */
	unsigned long RFCRC32;	/* CRC of most recently heard packet via RF */
	unsigned long CRC32;	/* CRC of most recently heard packet via IS */
	int isymbol;			/* Symbol and page & overlay */
	BOOL LastFromRF:1;		/* TRUE if pLastPacket from RF */
	BOOL HeardAsThird:1;	/* TRUE if heard as a third party packet */
	BOOL HeardAsRFDigi:1;	/* TRUE if digi on RF port */
	BOOL HeardAsIGate:1;	/* TRUE if seen after a q-construct */
	BOOL HeardAsDigi:1;		/* TRUE if seen as used or before used in path */
	BOOL HeardAsTCPIP:1;	/* TRUE if heard with TCPIP in the path */
	BOOL HeardRemoteRF:1;	/* TRUE if heard without TCPIP in the path, but not FromRF */
	BOOL HeardInternal:1;	/* TRUE if heard as an INTERNAL packet */
	BOOL MessageGated:1;	/* TRUE if a message FROM this station was gated to RF */
							/* Cleared when a position packet is also gated */
	BOOL MessagePending:1;	/* TRUE if a message is pending FOR this station */
							/* This can trigger re-transmit on packet */
	BOOL NeedPosGate:1;		/* TRUE if a message was gated that needs a free position */
	BOOL isMine:1;			/* TRUE if base station ID is same as base(CALLSIGN) */
	BOOL isCenter:1;		/* TRUE if station is centered in any window */
	BOOL isBuddy:1;			/* TRUE if base station ID is substring in Filter */
	BOOL isFriend:1;		/* TRUE if station is in the Friends list for coordinate caching */
	BOOL isClient:1;		/* TRUE if station is same client */
	BOOL wasRecalled:1;		/* TRUE if station is from SavedPosits */
	BOOL isSignpost:1;		/* TRUE if the station is a valid signpost \m */
	BOOL isEmergencySymbol;	/* TRUE if MicEIndex is due to \! Emergency Symbol */
	BOOL isRFID:1;			/* TRUE if station is an RFID (symbol HA/RA or dstCall=APRFIx */
	BOOL isNWS:1;			/* TRUE if station smells like NWS */
	BOOL isNWSIssued:1;		/* TRUE if time > NWS Issue time */
	BOOL isANSRVR:1;		/* TRUE if station is subscribed to ANSRVR group */
	BOOL isObject:1;		/* TRUE if station has owner (object or item) */
	BOOL isMyObject:1;		/* TRUE if Object is owned by CALLSIGN */
	BOOL isKilled:1;		/* TRUE if object had the Kill flag set */
	BOOL hasMessaging:1;	/* TRUE if supports messaging */
	BOOL hasStatusReport:1;	/* TRUE if a valid StatusReport ('>') packet was received */
	BOOL hasTelemetry:1;	/* TRUE if telemetry has been received */
	BOOL hadAltitude:1;		/* TRUE if station has had valid Altitude */
	BOOL BRGNRQParsed:1;	/* TRUE if BRGNRQ provided */
	BOOL CSEParsed:1;		/* TRUE if course/speed provided */
	BOOL DFSParsed:1;		/* TRUE if DFS provided */
	BOOL PHGParsed:1;		/* TRUE if PHG provided */
	BOOL AreaObjParsed:1;	/* TRUE if area object (Tyy/cxx) */
	BOOL WeatherParsed:1;	/* TRUE if Weather parsed */
	BOOL TrackColorLocked:1;	/* TRUE if user set track color */
	BOOL TrackColorAltitude:1;	/* TRUE if track should be colored by altitude */
	BOOL AutoSaveGPX:1;		/* TRUE to (re)save GPX on Movement */
	NICKNAME_INFO_S *Nickname;
	MULTILINE_INFO_S *MultiLine;
	WEATHER_INFO_S *Weather;
	FREQUENCY_INFO_S *Frequency;	/* If provided */
	STORM_INFO_S *Storm;
	BRGNRQ_INFO_S *pBRGNRQ;	/* If provided */
	PHG_INFO_S *pPHG;		/* If provided */
	NWS_TIMES_S *pNWSTimes;	/* NWS Issued/Expire times */
	COORDINATE_S *pCoord;	/* Points to unique coord matching lat/lon */
	double alt;				/* Last reported altitude */
	double speedCalculated;	/* Calculated speed */
	double speedAverage;	/* Average of N speeds */
	double courseCalculated;	/* Calculated course */
//	double lat, lon, alt;	/* Last reported lat/lon */
//	long tileX, tileY, tileZ;		/* At MAX_OSM_ZOOM zoom */
	struct
	{	double lat, lon;
		double speed;
		__int64 msec;		/* For speed calculations */
	} Last, Bad;			/* For track change detection */

	struct
	{	BOOL ptvalid:1;			/* TRUE if pt has been validated */
		BOOL rcsymvalid:1;		/* TRUE if rc has been validated */
		BOOL rclblvalid:1;		/* TRUE if rcLabel has been validated */
		BOOL viewed:1;			/* TRUE if station matches View filter */
		BOOL inCircle:1;		/* TRUE if station is in circle rectangle */
		BOOL visible:1;			/* TRUE if station is visible on-screen */
		BOOL alwaysvisible:1;	/* TRUE if station is visible off-screen */
		BOOL centered:1;		/* TRUE if the station is centered */
//		POINT pt;
		RECT rcSym;				/* Target icon rectangle */
		RECT rcLbl;				/* Target label rectangle */ 
	} TInfo[MAX_TRACKERS];

#ifdef SUPPORT_RFID
	struct
	{	enum { GRID=1, CSESPD=2 } Type;	/* 1 = grid, 2 = course/speed */
		union
		{	struct
			{	int dlat, dlon, offset, rows, cols;
			} Grid;
			struct
			{	int course, speed;
			} CseSpd;
		};
	} RFID;
#endif

#ifdef SUPPORT_HOURLY_PACKET_COUNT
	struct
	{	unsigned long Dupes;	/* Both IS and RF */
		unsigned long IS, TCPIP;
		unsigned short RF, RFDigi, Digi, IGate;
	} Packets[HOURLY_PACKETS];			/* Track recent 8 hours counts */
#endif

	TRACK_INFO_S *Tracks;
	int TrackCount;
	int TrackDupes;
	int TrackInvalids;
	int TrackSize;

#ifndef NO_PATH_TRACKING
	PATH_LINE_S *Paths;
	int PathCount;
	int PathSize;
	PACKET_PATH_S *PacketPath;	/* Only most recent one */
#endif

} STATION_INFO_S;

#define HasNickLabel(s) (ActiveConfig.View.Nicknames&&(s)->Nickname&&(s)->Nickname->Enabled&&(s)->Nickname->OverrideLabel)
#define HasNickLabelNonBlank(s) (HasNickLabel(s)&&*(s)->Nickname->Label)
#define HasNickComment(s) (ActiveConfig.View.Nicknames&&(s)->Nickname&&(s)->Nickname->Enabled&&(s)->Nickname->OverrideComment&&*(s)->Nickname->Comment)
#define HasNickSymbol(s) (ActiveConfig.View.Nicknames&&(s)->Nickname&&(s)->Nickname->Enabled&&(s)->Nickname->OverrideSymbol)
#define HasNickColor(s) (ActiveConfig.View.Nicknames&&(s)->Nickname&&(s)->Nickname->Enabled&&(s)->Nickname->OverrideColor)

static int GetStationSymbol(STATION_INFO_S *Station)
{	if (!HasNickSymbol(Station)) return Station->isymbol;
	return SymbolInt(Station->Nickname->Symbol.Table, Station->Nickname->Symbol.Symbol);
}

#ifdef MONITOR_PHONE
typedef struct CELLULAR_INFO_S
{	SYSTEMTIME st;		/* UTC of data point */
	COORDINATE_S *pCoord;
	DWORD dwSignalStrength;
	TCHAR *szOperatorName;
	BOOL bFreeName;
} CELLULAR_INFO_S;

CELLULAR_INFO_S *Cellulars;
int CellularCount;
int CellularSize;
#endif

BOOL QueueInternalMessage(char *Buffer, BOOL FreeIt);

unsigned long ShriekCount = 0;
struct
{	char *Name;
	unsigned long Mask;	/* Bit mask (based on original index) */
} Shrieks[32] = {0};

static unsigned long GetShriekMask(char *Name, char *StationID=NULL, char *Comment=NULL)
{	unsigned long i;

	if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
	for (i=0; i<ActiveConfig.MicEs.Count; i++)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[i];
		if (!_stricmp(Action->Tag, Name)) return 0;
	}

	for (i=0; i<ShriekCount; i++)
		if (!_stricmp(Name,Shrieks[i].Name))
			return Shrieks[i].Mask;
	if (ShriekCount < ARRAYSIZE(Shrieks))
	{	if (strlen(Name) == 5 && toupper(Name[1]) == 'W')	/* !Wxx! nor !wxx! (!DAO! collisions) */
			return 0;
		if (strlen(Name) <= 3)	/* Disallow !x! */
			return 0;
		for (i=1; i<strlen(Name)-1; i++)
			if (!isalnum(Name[i]&0xff))	/* Only alphanumeric !shrieks! */
				return 0;
		i = ShriekCount++;
		Shrieks[i].Name = _strupr(_strdup(Name));
		Shrieks[i].Mask = 1<<i;
if (StationID)
TraceLogThread("Activity", TRUE, "%s Defined New Shriek[%ld]=%s From(%s)\n", StationID, ShriekCount, Name, Comment?Comment:"*NULL*");
else TraceLogThread("Activity", TRUE, "New Shriek[%ld]=%s\n", ShriekCount, Name);
		if (ShriekCount == ARRAYSIZE(Shrieks))
		{	char *Buffer = (char*)malloc(80);
			StringCbPrintfA(Buffer, 80, "Warning: %ld/%ld Shrieks Defined",
							(long) ShriekCount, (long) ARRAYSIZE(Shrieks));
			QueueInternalMessage(Buffer,TRUE);
		}
		return Shrieks[i].Mask;
	}
	return 0;
}

static unsigned long GetStringShriekMask(char *Comment, STATION_INFO_S *Station=NULL, char *FullComment=NULL)
{	unsigned long Mask = 0;
	char *s = strchr(Comment,'!');
	while (s)
	{	char *e = strchr(s+1,'!');
		if (e && e > s+2)	/* Found one and not !! nor !x! */
		{	char *p;
			for (p=s; p<e; p++)
				if (isspace(*p&0xff))
					break;
			if (!isspace(*p&0xff))
			{	int Len = e-s+1;
				if (Len <= 16)
				{	char *Name = (char*)malloc(Len+1);
					strncpy(Name, s, Len);
					Name[Len] = '\0';
					unsigned long ShriekMask = GetShriekMask(Name, Station?Station->Station:NULL, FullComment);
					if (ShriekMask)
						Mask |= ShriekMask;
					else
						TraceError(NULL, "%s Found ZERO-MASK %.*s in %s, Overflowed %ld/%ld?\n",
							Station?Station->Station:"",
							(int)(e-s+2), s, Comment, ShriekCount, ARRAYSIZE(Shrieks));
					free(Name);
				} else 
					TraceError(NULL, "%ld Character %.*s Overflows Length Limit\n",
								Len, (int)(e-s+2), s);
				e = strchr(e+1,'!');	 /* forward to next one */
			}
		}
		s = e;
	}
	return Mask;
}

#define VB_ALL			0
#define VB_BUDDIES		1
#define VB_DUPLICATES	2
#define VB_INVALIDS		3
#define VB_MESSAGEABLE	4
#define VB_NWS			5
#define VB_OBJECTS		6
#define VB_SHRIEKS		7
#define VB_TELEMETRY	8
#define VB_TRACKS		9
#define VB_ECHOLINKS	10
#define VB_GEOCACHES	11

#define VB_RF_ALL		12
#define VB_RF_DIRECT	13
#define VB_RF_LOCAL		14
#define VB_RF_THIRD		15
#define VB_RF_ONLY		16
#define VB_RF_DIGI		17
#define VB_RF_INTERNET	18
#define VB_RF_IGATE		19
#define VB_INTERNET_ONLY	20
#define VB_RFID			21
#define VB_MARINE		22
#define VB_MOBILE		23
#define VB_WEATHER		24
#define VB_FLIGHT		25
#define VB_CUSTOM		26
#define VB_AMBIGUOUS	27
#define VB_NICKNAMES	28
#define VB_ANSRVR_MEMBERS	29
#define VB_PLATFORMS	30
/* Purposely skip 31 */
#define VB_SYMBOLS		32
#define VB_ALTITUDES	33
#define VB_PATHS		34
#define VB_FREQUENCIES	35
#define VB_FREQSPEC		36
#define VB_MICE			37

#define VIEW_ALL			(1<<VB_ALL)
#define VIEW_BUDDIES		(1<<VB_BUDDIES)
#define VIEW_DUPLICATES		(1<<VB_DUPLICATES)
#define VIEW_INVALIDS		(1<<VB_INVALIDS)
#define VIEW_MESSAGEABLE	(1<<VB_MESSAGEABLE)
#define VIEW_NWS			(1<<VB_NWS)
#define VIEW_OBJECTS		(1<<VB_OBJECTS)
#define VIEW_SHRIEKS		(1<<VB_SHRIEKS)
#define VIEW_TELEMETRY		(1<<VB_TELEMETRY)
#define VIEW_TRACKS			(1<<VB_TRACKS)
#define VIEW_ECHOLINKS		(1<<VB_ECHOLINKS)
#define VIEW_GEOCACHES		(1<<VB_GEOCACHES)
#define VIEW_RF_ALL			(1<<VB_RF_ALL)
#define VIEW_RF_DIRECT		(1<<VB_RF_DIRECT)
#define VIEW_RF_LOCAL		(1<<VB_RF_LOCAL)
#define VIEW_RF_THIRD		(1<<VB_RF_THIRD)
#define VIEW_RF_ONLY		(1<<VB_RF_ONLY)
#define VIEW_RF_DIGI		(1<<VB_RF_DIGI)
#define VIEW_RF_INTERNET	(1<<VB_RF_INTERNET)
#define VIEW_RF_IGATE		(1<<VB_RF_IGATE)
#define VIEW_INTERNET_ONLY	(1<<VB_INTERNET_ONLY)
#define VIEW_RFID			(1<<VB_RFID)
#define VIEW_MARINE			(1<<VB_MARINE)
#define VIEW_MOBILE			(1<<VB_MOBILE)
#define VIEW_WEATHER		(1<<VB_WEATHER)
#define VIEW_FLIGHT			(1<<VB_FLIGHT)
#define VIEW_CUSTOM			(1<<VB_CUSTOM)
#define VIEW_AMBIGUOUS		(1<<VB_AMBIGUOUS)
#define VIEW_NICKNAMES		(1<<VB_NICKNAMES)
#define VIEW_ANSRVR_MEMBERS	(1<<VB_ANSRVR_MEMBERS)
#define VIEW_PLATFORMS		(1<<VB_PLATFORMS)
#define VIEW_SYMBOLS		(((unsigned __int64)1)<<((unsigned __int64)VB_SYMBOLS))
#define VIEW_ALTITUDES		(((unsigned __int64)1)<<((unsigned __int64)VB_ALTITUDES))
#define VIEW_PATHS			(((unsigned __int64)1)<<((unsigned __int64)VB_PATHS))
#define VIEW_FREQUENCIES	(((unsigned __int64)1)<<((unsigned __int64)VB_FREQUENCIES))
#define VIEW_FREQSPEC		(((unsigned __int64)1)<<((unsigned __int64)VB_FREQSPEC))
#define VIEW_MICE			(((unsigned __int64)1)<<((unsigned __int64)VB_MICE))

#ifdef SUPERFLUOUS_CODE
char *MyStrStr(char *Haystack, char *Needle)
{	int l = strlen(Needle);
TraceLogThread("Menu",TRUE,"Searing for(%s) In(%s)\n", Needle, Haystack);
	if (l)
	{	char *t;
		for (t=strchr(Haystack,*Needle); t; t=strchr(t+1,*Needle))
			if (!strncmp(t,Needle,l))
				return t;
	}
	return NULL;
}
#endif

static char *DynamicMenuMicE(CLIENT_INFO_S *cInfo, char *String, char *Delimiter)
{	if (String)	/* Need to restore string into cInfo's viewMicE array */
	{	unsigned long i;
		if (*String != '(' || !strchr(String,')')) return NULL;
		String = _strdup(String+1);
		*strchr(String,')') = '\0';
		if (*String)
		{	//TraceLogThread("Menu", TRUE, "Restore MicE:%s\n", String);
			for (i=0; i<ActiveConfig.MicEs.Count; i++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[i];
				char *f = strstr(String,Action->Name);
				if (f)	/* Found a possible hit */
				if (f==String || f[-1] == ',')	/* Start of string */
				{	int l = strlen(Action->Name);
					if (f[l]==',' || !f[l])
					{	cInfo->viewMicE[i] = TRUE;
					}
				}
			}
		}
		free(String);
		return NULL;
	} else	/* We're supposed to return a restorable string */
	{	unsigned long i;
		size_t Remaining = 1+1+1;	/* ()\0 */
		char *Buffer, *Next;

		for (i=0; i<ActiveConfig.MicEs.Count; i++)
		{	if (cInfo->viewMicE[i])
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[i];
				Remaining += strlen(Action->Name)+1;
			}
		}
		Next = Buffer = (char*)malloc(Remaining);
		*Buffer = '\0';	/* Just in case there aren't any */
		for (i=0; i<ActiveConfig.MicEs.Count; i++)
		{	if (cInfo->viewMicE[i])
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[i];
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%s%s", *Buffer?Delimiter:"",
								Action->Name);
			}
		}
		//TraceLogThread("Menu", TRUE, "Save MicEs:%s\n", Buffer);
		return Buffer;
	}
}

static char *DynamicMenuPlatforms(CLIENT_INFO_S *cInfo, char *String, char *Delimiter)
{	if (String)	/* Need to restore string into cInfo's viewPlatforms array */
	{	int i;
		if (*String != '(' || !strchr(String,')')) return NULL;
		String = _strdup(String+1);
		*strchr(String,')') = '\0';
		if (*String)
		{	//TraceLogThread("Menu", TRUE, "Restore Platforms:%s\n", String);
			for (i=PLATFORM_UNKNOWN; i<=PLATFORM_MAX; i++)
			{	char *p = GetPlatformString((APRS_PLATFORM_V)i,NULL);
				char *f = strstr(String,p);
				if (f)	/* Found a possible hit */
				if (f==String || f[-1] == ',')	/* Start of string */
				{	int l = strlen(p);
					if (f[l]==',' || !f[l])
					{	cInfo->viewPlatforms[i] = TRUE;
					}
				}
			}
		}
		free(String);
		return NULL;
	} else	/* We're supposed to return a restorable string */
	{	int i;
		size_t Remaining = 1+1+1;	/* ()\0 */
		char *Buffer, *Next;

		for (i=PLATFORM_UNKNOWN; i<=PLATFORM_MAX; i++)
		{	if (cInfo->viewPlatforms[i])
			{	Remaining += strlen(GetPlatformString((APRS_PLATFORM_V)i,NULL))+1;
			}
		}
		Next = Buffer = (char*)malloc(Remaining);
		*Buffer = '\0';	/* Just in case there aren't any */
		for (i=PLATFORM_UNKNOWN; i<=PLATFORM_MAX; i++)
		{	if (cInfo->viewPlatforms[i])
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%s%s", *Buffer?Delimiter:"",
								GetPlatformString((APRS_PLATFORM_V)i,NULL));
		}
		//TraceLogThread("Menu", TRUE, "Save Platforms:%s\n", Buffer);
		return Buffer;
	}
}

static char *DynamicMenuShrieks(CLIENT_INFO_S *cInfo, char *String, char *Delimiter)
{	if (String)	/* Need to restore string into cInfo's viewShrieks bits */
	{	if (*String != '(' || !strchr(String,')')) return NULL;
		String = _strdup(String+1);
		*strchr(String,')') = '\0';
		if (*String)
		{	//TraceLogThread("Menu", TRUE, "Restore Shrieks:%s\n", String);
			cInfo->viewShrieks = GetStringShriekMask(String);
		}
		free(String);
		return NULL;
	} else	/* We're supposed to return a restorable string */
	{	unsigned long s;
		size_t Remaining = 1+1+1;	/* ()\0 */
		char *Buffer, *Next;

		for (s=0; s<ShriekCount; s++)
		{	if (cInfo->viewShrieks & Shrieks[s].Mask)
			{	Remaining += strlen(Shrieks[s].Name)+1;
			}
		}
		Next = Buffer = (char*)malloc(Remaining);
		*Buffer = '\0';	/* Just in case there aren't any */
		for (s=0; s<ShriekCount; s++)
		{	if (cInfo->viewShrieks & Shrieks[s].Mask)
			{	Remaining += strlen(Shrieks[s].Name)+1;
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%s%s", *Buffer?Delimiter:"",
								Shrieks[s].Name);
			}
		}
		//TraceLogThread("Menu", TRUE, "Save Shrieks:%s\n", Buffer);
		return Buffer;
	}
}

static char *DynamicMenuSymbols(CLIENT_INFO_S *cInfo, char *String, char *Delimiter)
{	if (String)	/* Need to restore string into cInfo's viewSymbols array */
	{	int i;
		if (*String != '(' || !strchr(String,')')) return NULL;
		String = _strdup(String+1);
		*strchr(String,')') = '\0';
		if (*String)
		{	//TraceLogThread("Menu", TRUE, "Restore Symbols:%s\n", String);
			for (i=0; i<ARRAYSIZE(cInfo->viewSymbols); i++)
			{	char *p = GetSymbolName(APRSSymbolIndexToInt(i));
				char *f = strstr(String,p);
				if (f)	/* Found a possible hit */
				if (f==String || f[-1] == ',')	/* Start of string */
				{	int l = strlen(p);
					if (f[l]==',' || !f[l])
					{	cInfo->viewSymbols[i] = TRUE;
					}
				}
			}
		}
		free(String);
		return NULL;
	} else	/* We're supposed to return a restorable string */
	{	int i;
		size_t Remaining = 1+1+1;	/* ()\0 */
		char *Buffer, *Next;

		for (i=0; i<ARRAYSIZE(cInfo->viewSymbols); i++)
		{	if (cInfo->viewSymbols[i])
			{	Remaining += strlen(GetSymbolName(APRSSymbolIndexToInt(i)))+1;
			}
		}
		Next = Buffer = (char*)malloc(Remaining);
		*Buffer = '\0';	/* Just in case there aren't any */
		for (i=0; i<ARRAYSIZE(cInfo->viewSymbols); i++)
		{	if (cInfo->viewSymbols[i])
			{	char *SymName = GetSymbolName(APRSSymbolIndexToInt(i));
				char *f = strstr(Buffer,SymName);
				int l = strlen(SymName);
				if (f	/* Found */
				&& (f==Buffer || f[-1]==Delimiter[strlen(Delimiter)-1])
				&& (!f[l] || f[l]==*Delimiter))
				{
				} else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%s%s", *Buffer?Delimiter:"",
									SymName);
			}
		}
		//TraceLogThread("Menu", TRUE, "Save Symbols:%s\n", Buffer);
		return Buffer;
	}
}

#define MENU(x) VB_##x, VIEW_##x, ID_VIEW_##x
struct
{	int bit;
	unsigned __int64 mask;
	UINT menuID;
	char *name;
	char *(*SubRoutine)(CLIENT_INFO_S *cInfo, char *String, char *Delimiter);
} ViewMenuBits[] = {
{ MENU(ALL), "All" },
{ MENU(BUDDIES), "Buddies" },
{ MENU(DUPLICATES), "Duplicates" },
{ MENU(INVALIDS), "Invalids" },
{ MENU(MESSAGEABLE), "Message-able" },
{ MENU(NWS), "NWS Objects" },	/* MUST Match NWS MultiTrack's default View options below */
{ MENU(OBJECTS), "Objects" },
{ MENU(SHRIEKS), "Shrieks", DynamicMenuShrieks },
{ MENU(TELEMETRY), "Telemetry" },
{ MENU(TRACKS), "Tracks" },
{ MENU(ECHOLINKS), "EchoLinks..." },
{ MENU(GEOCACHES), "GeoCaches..." },
{ MENU(RF_ALL), "RF-All" },
{ MENU(RF_DIRECT), "RF-Direct" },
{ MENU(RF_LOCAL), "RF-Local" },
{ MENU(RF_THIRD), "RF-3rd Party" },
{ MENU(RF_DIGI), "Xport-Digipeater" },
{ MENU(RF_ONLY), "Xport-RF Only" },
{ MENU(RF_INTERNET), "Xport-RF + -IS" },
{ MENU(RF_IGATE), "Xport-IGate" },
{ MENU(INTERNET_ONLY), "Xport--IS Only" },
{ MENU(RFID), "Symbols-RFID" },
{ MENU(MARINE), "Symbols-Marine" },
{ MENU(MOBILE), "Symbols-Mobile" },
{ MENU(WEATHER), "Symbols-Weather" },
{ MENU(FLIGHT), "Symbols-Flight" },
{ MENU(CUSTOM), "Symbols-Custom" },
{ MENU(AMBIGUOUS), "Ambiguous" },
{ MENU(NICKNAMES), "NickNamed" },
{ MENU(ANSRVR_MEMBERS), "ANSRVR Members" },
{ MENU(PLATFORMS), "Platforms", DynamicMenuPlatforms },
{ MENU(SYMBOLS), "Symbols", DynamicMenuSymbols },
{ MENU(ALTITUDES), "Altitudes" },
{ MENU(PATHS), "Paths" },
{ MENU(FREQUENCIES), "Freq w/Issues" },
{ MENU(FREQSPEC), "FreqSpec" },
{ MENU(MICE), "MicE", DynamicMenuMicE } };
#undef MENU

char *MakeViewString(CLIENT_INFO_S *cInfo, __int64 Bits, BOOL MultiLine=FALSE)
{	int i;
	size_t Remaining = 1;	/* The null terminator */
	char *Buffer, *Next;
	if (!Bits) return _strdup("0");
	for (i=0; i<ARRAYSIZE(ViewMenuBits); i++)
	{	if (Bits & ViewMenuBits[i].mask)
			Remaining += strlen(ViewMenuBits[i].name)+1;
			if (ViewMenuBits[i].SubRoutine)
			{	char *Extra = ViewMenuBits[i].SubRoutine(cInfo, NULL, ",");
				if (Extra)
				{	Remaining += 1+strlen(Extra)+1;
					free(Extra);
				}
			}
	}
	Next = Buffer = (char*)malloc(Remaining);
	*Buffer = '\0';	/* Just in case there aren't any */
	for (i=0; i<ARRAYSIZE(ViewMenuBits); i++)
	{	if (Bits & ViewMenuBits[i].mask)
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s%s", *Buffer?(MultiLine?"\n":","):"",
							ViewMenuBits[i].name);
			if (ViewMenuBits[i].SubRoutine)
			{	char *Extra = ViewMenuBits[i].SubRoutine(cInfo, NULL, ",");
				//TraceLogThread("Menu", TRUE, "%s Saved %s\n", ViewMenuBits[i].name, Extra?Extra:"*NULL*");
				if (Extra)
				{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"(%s)", Extra);
					free(Extra);
				}
			}
		}
	}
	//TraceLogThread("Menu", TRUE, "MakeViewString Returning:%s\n", Buffer);
	return Buffer;
}

__int64 MakeViewBits(CLIENT_INFO_S *cInfo, char *String)
{	int i;
	__int64 Mask = 0;
	if (!String) return VIEW_ALL;
	if (!strcmp(String,"0")) return Mask;
	for (i=0; i<ARRAYSIZE(ViewMenuBits); i++)
	{	char *f = strstr(String,ViewMenuBits[i].name);
		if (f)	/* Found a possible hit */
		if (f==String || f[-1] == ',')	/* Start of string */
		{	int l = strlen(ViewMenuBits[i].name);
			if (f[l]==',' || f[l] == '(' || !f[l])
			{	Mask |= ViewMenuBits[i].mask;
				if (f[l] == '(' && ViewMenuBits[i].SubRoutine)
				{	ViewMenuBits[i].SubRoutine(cInfo, &f[l], NULL);
					//TraceLogThread("Menu", TRUE, "%s Loaded %s\n", ViewMenuBits[i].name, &f[l]);
				}
			}
		}
	}
	return Mask;
}

HWND	hwndTracker[MAX_TRACKERS];
CLIENT_INFO_S cInfos[MAX_TRACKERS];
//HWND	hwndMain;
#define hwndMain hwndTracker[0]
int TrackersActive = 1;

int GetMultiTrackIndex(char *StationID, STATION_INFO_S *Station=NULL, int fromIndex=-1)
{	int tr;
	if (Station)	/* First try for the specific station */
	{	for (tr=0; tr<MAX_TRACKERS; tr++)
		if (cInfos[tr].Active)
		if (cInfos[tr].Index != fromIndex)
		{	if (cInfos[tr].CenterStation == Station
			&& (cInfos[tr].CenterTracking
				|| cInfos[tr].AutoZoomViewIn
				|| cInfos[tr].AutoZoomViewOut
				|| cInfos[tr].AutoZoomViewCtr))
				return tr;
		}
	}
/*	Now see if we've got a window waiting for the station */
	for (tr=0; tr<MAX_TRACKERS; tr++)
	if (cInfos[tr].Active)
	if (cInfos[tr].Index != fromIndex)
	{	if ((cInfos[tr].CenterTracking
			&& cInfos[tr].CenterStation
			&& !_stricmp(cInfos[tr].CenterStation->Station, StationID))
		|| (cInfos[tr].Awaiting
			&& !_strnicmp(cInfos[tr].CenterID, StationID,
								sizeof(cInfos[tr].CenterID))))
			return tr;
	}
	return -1;
}

HWND GetMultiTrackWindow(char *StationID, STATION_INFO_S *Station=NULL, int fromIndex=-1)
{	int tr = GetMultiTrackIndex(StationID, Station, fromIndex);
	if (tr != -1) return cInfos[tr].hwnd;
	return NULL;
}

int cdecl IsStationFollowed(char *StationID)
{	return GetMultiTrackIndex(StationID) != -1;
}

typedef struct SEEN_STATION_S
{	char Station[STATION_SIZE];
} SEEN_STATION_S;
unsigned long SeenStationCount = 0;
unsigned long SeenStationSize = 0;
SEEN_STATION_S *SeenStations = NULL;

unsigned long GetSeenStationIndex(char *Station)
{	unsigned long s;
	for (s=0; s<SeenStationCount; s++)
		if (!strncmp(SeenStations[s].Station, Station, sizeof(SeenStations[s].Station)))
			return s;
	s = SeenStationCount++;
	if (SeenStationCount > SeenStationSize)
	{	SeenStationSize += 32;
		SeenStations = (SEEN_STATION_S *)realloc(SeenStations,sizeof(*SeenStations)*SeenStationSize);
	}
	strncpy(SeenStations[s].Station, Station, sizeof(SeenStations[s].Station));

	if (!s && strcmp(SeenStations[s].Station,CALLSIGN))
		TraceLogThread("SeenStations", TRUE, "SeenStations[%ld] = %s\n", (long) s, SeenStations[s].Station);
	return s;
}

char *GetSeenStationName(int s)	/* Return value must be freed */
{	return _strdup(SeenStations[s].Station);
}

unsigned long CloseStationCount = 0;
unsigned long CloseStationSort = 0;
unsigned long CloseStationSize = 0;
BOOL CloseStationFreeze = FALSE;

BOOL FirstRun = FALSE;	/* TRUE if this is first activation */
BOOL BeaconSuspended = FALSE;	/* TRUE if waiting for Transmit */
struct
{	double lat, lon;
	int zoom;
} OriginalScreen;
HWND hwndFirstRun = NULL;
BOOL RestartProgram = FALSE;	/* TRUE to restart on close */
BOOL NewVersionDownloaded = FALSE;	/* TRUE if a new version is here */
STATION_INFO_S **pCloseStations;
STATION_INFO_S *MyStation = NULL;	/* My station (pCloseStations[0]) */
//STATION_INFO_S *CenterStation[MAX_TRACKERS] = {0};	/* Default to center on ME */
//BOOL CenterTracking[MAX_TRACKERS] = {TRUE};		/* True if tracking CenterStation */

static char * SaveTrackToGPX(HWND hwnd, STATION_INFO_S *Station);
static BOOL QueueToTransmit(PACKET_TYPE_V, char *Buffer, BOOL RFOnly=FALSE, BOOL ISOnly=FALSE, BOOL NoQueue=TRUE);
static void TriggerDXReport(BOOL Force);
static void TransmitDXReport(BOOL Force);
static void TransmitStatusReport(BOOL Force);
static BOOL TransmitFilter(BOOL SendToServer=FALSE);
static unsigned long TransmitObjects(HWND hwnd, BOOL OnTimer=FALSE, BOOL AllIntervaled=FALSE, char *Group=NULL);
static STATION_INFO_S *TransmitObject(OBJECT_CONFIG_INFO_S *Obj, BOOL LocalOnly=FALSE, BOOL ISOnly=FALSE);
static void TransmitWeather(BOOL Force = FALSE);

#ifdef SUPPORT_HOURLY_PACKET_COUNT
typedef struct DX_PACKET_INFO_S
{	SYSTEMTIME st;	/* When Distance was set */
	double lat, lon;
	unsigned short Count;
	double Distance, Bearing;
	char Station[STATION_SIZE];
} DX_PACKET_INFO_S;
typedef struct PORT_PACKET_COUNT_S
{	unsigned long wpPort;	/* Index to port (+1 to avoid zeros?) */
	char *Name;
	HWND hwnd;
	int DXSize;
	int DXCount;
	DX_PACKET_INFO_S *DXList;
	DX_PACKET_INFO_S DX[HOURLY_PACKETS];		/* Track recent 8 hours DX */
	unsigned long RcvPackets[HOURLY_PACKETS];	/* Track recent 8 hours receives */
	unsigned long XmtPackets[HOURLY_PACKETS];	/* Track recent 8 hours xmits */
	unsigned long PktPosition[HOURLY_PACKETS];
	unsigned long PktObject[HOURLY_PACKETS];
	unsigned long PktItem[HOURLY_PACKETS];
	unsigned long PktMessage[HOURLY_PACKETS];
	unsigned long PktQuery[HOURLY_PACKETS];
	unsigned long PktStatus[HOURLY_PACKETS];
	unsigned long PktTelemetry[HOURLY_PACKETS];
	unsigned long PktUser[HOURLY_PACKETS];
	unsigned long PktNWS[HOURLY_PACKETS];
	unsigned long PktWeather[HOURLY_PACKETS];
	unsigned long PktOther[HOURLY_PACKETS];
} PORT_PACKET_COUNT_S;
unsigned long PortPacketCount = 0;
unsigned long PortPacketSize = 0;
PORT_PACKET_COUNT_S *PortPackets = NULL;

#ifdef TRACK_FIND_STATIONS
unsigned long Find1Stations[HOURLY_PACKETS];
unsigned long Find2Stations[HOURLY_PACKETS];
unsigned long SortStations[HOURLY_PACKETS];
unsigned long NewStations[HOURLY_PACKETS];
unsigned long OldStations[HOURLY_PACKETS];
#endif

WORD LastPacketHour = -1;	/* Hour that we last heard packets */
SYSTEMTIME stHourlyStart[HOURLY_PACKETS] = {0};

unsigned long PktPosition[HOURLY_PACKETS];
unsigned long PktObject[HOURLY_PACKETS];
unsigned long PktItem[HOURLY_PACKETS];
unsigned long PktMessage[HOURLY_PACKETS];
unsigned long PktQuery[HOURLY_PACKETS];
unsigned long PktStatus[HOURLY_PACKETS];
unsigned long PktTelemetry[HOURLY_PACKETS];
unsigned long PktUser[HOURLY_PACKETS];
unsigned long PktNWS[HOURLY_PACKETS];
unsigned long PktWeather[HOURLY_PACKETS];
unsigned long PktOther[HOURLY_PACKETS];

#endif

unsigned long ulSaveConfigTimeout;
SYSTEMTIME stSaveConfig = {0};
char *szSaveConfigWhy = NULL;

BOOL SaveConfiguration(HWND hwnd, CONFIG_INFO_S *pConfig, char *Why, unsigned long Timeout=60)
{	if (!ulSaveConfigTimeout
	|| Timeout < ulSaveConfigTimeout)
		ulSaveConfigTimeout = Timeout;
	GetSystemTime(&stSaveConfig);
	szSaveConfigWhy = Why;
	return TRUE;
}


BOOL IsStationVisible(CLIENT_INFO_S *cInfo, STATION_INFO_S *Station)
{	BOOL ShowIt = FALSE;

	Station->TInfo[cInfo->Index].viewed = (Station == cInfo->CenterStation);
	if (Station == MyStation
	|| Station == cInfo->CenterStation)
	{	Station->TInfo[cInfo->Index].alwaysvisible = TRUE;
		return TRUE;
	}

	if (!Station->isKilled	/* If Center short-circuit is removed */
							/* It must still ignore the Killed flag */
	|| Station->isMyObject)
	{
		if (cInfo->viewBits & VIEW_ALL) ShowIt = TRUE;
		else if (cInfo->viewBits)	/* Don't bother if NONE */
		{
//#define HIT(f) {ShowIt=TRUE; TraceLog("HIT",FALSE,hwnd,"Hit(%s) %s@%ld\n",Station->Station,#f,(long)__LINE__);}
#define HIT(f) ShowIt=TRUE;
			if (!ShowIt && ((cInfo->viewBits & VIEW_ALTITUDES) && Station->hadAltitude)) HIT(Altitude)
			if (!ShowIt && ((cInfo->viewBits & VIEW_AMBIGUOUS) && Station->Ambiguity)) HIT(Ambiguous)
			if (!ShowIt && ((cInfo->viewBits & VIEW_BUDDIES) && Station->isBuddy)) HIT(Buddy)
			if (!ShowIt && ((cInfo->viewBits & VIEW_DUPLICATES) && Station->TrackDupes)) HIT(Dupes)
			if (!ShowIt && ((cInfo->viewBits & VIEW_FREQSPEC) && Station->Frequency && !Station->Frequency->Issues)) HIT(FreqSpec)
			if (!ShowIt && ((cInfo->viewBits & VIEW_FREQUENCIES) && Station->Frequency && Station->Frequency->Issues)) HIT(Frequencies)
			if (!ShowIt && ((cInfo->viewBits & VIEW_INVALIDS) && Station->TrackInvalids)) HIT(Invalids)
			if (!ShowIt && ((cInfo->viewBits & VIEW_MESSAGEABLE) && Station->hasMessaging)) HIT(Messages)
			if (!ShowIt && ((cInfo->viewBits & VIEW_NICKNAMES) && Station->Nickname && Station->Nickname->Enabled)) HIT(Nickname)
			if (!ShowIt && ((cInfo->viewBits & VIEW_NWS) && Station->isNWS)) HIT(MultiLine)
			if (!ShowIt && ((cInfo->viewBits & VIEW_OBJECTS) && Station->isObject)) HIT(Object)
			if (!ShowIt && ((cInfo->viewBits & VIEW_TELEMETRY) && Station->hasTelemetry)) HIT(Telemetry)
			if (!ShowIt && ((cInfo->viewBits & VIEW_TRACKS) && Station->TrackCount)) HIT(Tracks)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RFID) && Station->isRFID)) HIT(RFID)
			if (!ShowIt && ((cInfo->viewBits & VIEW_ANSRVR_MEMBERS) && Station->isANSRVR)) HIT(ANSRVR)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_ALL) && Station->HeardOnRF)) HIT(RFAll)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_DIRECT) && Station->HeardOnRF==1)) HIT(RFDirect)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_LOCAL) && Station->HeardOnRF && Station->HeardOnRF <= LOCAL_MAX_HOPS+1)) HIT(RFLocal)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_THIRD) && Station->HeardAsThird)) HIT(RFThird)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_ONLY) && (Station->HeardOnRF || Station->HeardRemoteRF) && !Station->HeardAsTCPIP)) HIT(RFOnly)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_INTERNET) && (Station->HeardOnRF || Station->HeardRemoteRF) && Station->HeardAsTCPIP)) HIT(Internet)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_DIGI) && (Station->HeardAsDigi || Station->HeardAsRFDigi))) HIT(Digi)
			if (!ShowIt && ((cInfo->viewBits & VIEW_RF_IGATE) && Station->HeardAsIGate)) HIT(IGate)
			if (!ShowIt && ((cInfo->viewBits & VIEW_INTERNET_ONLY) && Station->HeardAsTCPIP && !Station->HeardOnRF && !Station->HeardRemoteRF)) HIT(ISOnly)

			if (!ShowIt && (cInfo->viewBits & VIEW_ECHOLINKS)
			&& Station->Station[0]=='E' && Station->Station[1]=='L'
			&& (Station->Station[2]=='-' || isdigit(Station->Station[2]&0xff))
			&& !strcmp(Station->Owner, "ECHOLINK"))
				HIT(EchoLink)

			if (!ShowIt && ((cInfo->viewBits & VIEW_MICE)
			&& (cInfo->viewMicE[Station->MicEIndex])))
				HIT(MicE)

			if (!ShowIt && (cInfo->viewBits & VIEW_PLATFORMS)
			&& !Station->isObject)
				ShowIt = cInfo->viewPlatforms[Station->tPlatform];

			if (!ShowIt && ((cInfo->viewBits & VIEW_SHRIEKS)
			&& (Station->ShriekMask&cInfo->viewShrieks)))
				HIT(Shrieks)

			if (!ShowIt && (cInfo->viewBits & VIEW_SYMBOLS))
			{	int index = APRSSymbolIndex(Station->isymbol);
				ShowIt = cInfo->viewSymbols[index];
			}

			if (!ShowIt && (cInfo->viewBits & VIEW_MARINE))
			{	char Sym = Station->isymbol & 0xFF;
				char Tab = Station->isymbol >> 8;
				if (strchr(Tab?ActiveConfig.View.Marine.Alternate
							:ActiveConfig.View.Marine.Primary, Sym))
					HIT(Marine)
			}
			if (!ShowIt && (cInfo->viewBits & VIEW_MOBILE))
			{	char Sym = Station->isymbol & 0xFF;
				char Tab = Station->isymbol >> 8;
				if (strchr(Tab?ActiveConfig.View.Mobile.Alternate
							:ActiveConfig.View.Mobile.Primary, Sym))
					HIT(Mobile)
			}
			if (!ShowIt && (cInfo->viewBits & VIEW_WEATHER))
			{	char Sym = Station->isymbol & 0xFF;
				char Tab = Station->isymbol >> 8;
				if (strchr(Tab?ActiveConfig.View.Weather.Alternate
							:ActiveConfig.View.Weather.Primary, Sym))
					HIT(Weather)
			}
			if (!ShowIt && (cInfo->viewBits & VIEW_FLIGHT))
			{	char Sym = Station->isymbol & 0xFF;
				char Tab = Station->isymbol >> 8;
				if (strchr(Tab?ActiveConfig.View.Flight.Alternate
							:ActiveConfig.View.Flight.Primary, Sym))
					HIT(Flight)
			}
			if (!ShowIt && (cInfo->viewBits & VIEW_CUSTOM))
			{	char Sym = Station->isymbol & 0xFF;
				char Tab = Station->isymbol >> 8;
				if (strchr(Tab?ActiveConfig.View.Custom.Alternate
							:ActiveConfig.View.Custom.Primary, Sym))
					HIT(Custom)
			}

			if (!ShowIt && (cInfo->viewBits & VIEW_PATHS) && Station->PathCount)
			{	BOOL pathHit = cInfo->Paths.MaxAge == -1 || cInfo->Paths.MaxAge == 0;
				if (!pathHit)
				{	__int64 msOldest = llGetMsec() - cInfo->Paths.MaxAge*1000;
					long p;
					for (p=0; p<Station->PathCount; p++)
					{	if (Station->Paths[p].msec >= msOldest)
						if (!cInfo->Paths.LclRF || Station->Paths[p].FromRF)
						{	if (cInfo->Paths.ShowAllLinks) pathHit = TRUE;
							else switch(Station->Paths[p].Type)
							{
							case PATH_LINE_DIRECT:	pathHit = cInfo->Paths.Direct.Enabled; break;
							case PATH_LINE_FIRST:	pathHit = cInfo->Paths.First.Enabled; break;
							case PATH_LINE_MIDDLE:	pathHit = cInfo->Paths.Middle.Enabled; break;
							case PATH_LINE_LAST:	pathHit = cInfo->Paths.Final.Enabled; break;
							}
							if (pathHit) break;
						}
					}
				}
				if (pathHit) HIT(Paths)
			}
		}
		if (ShowIt	/* Are we still showing? */
		&& Station != MyStation		/* Can't remove ME */
		&& Station != cInfo->CenterStation/* Can't remove center */
		&& ActiveConfig.AltNet[0])	/* Even if AltNet filtered */
			ShowIt = !_strnicmp(ActiveConfig.AltNet, Station->dstCall, sizeof(ActiveConfig.AltNet));
	}

	Station->TInfo[cInfo->Index].viewed = ShowIt;

//	If DF isn't knocked about above, then EVERY DF object stays visible
	if (Station->BRGNRQParsed || Station->DFSParsed)
	{	Station->TInfo[cInfo->Index].alwaysvisible = ShowIt;
		if (ShowIt) return ShowIt;	/* Skip distance checks if selected */
	} else Station->TInfo[cInfo->Index].alwaysvisible = FALSE;	/* Just in case it was centered */

/*	Note: ME and Center short-circuited above */
	if (ShowIt)	/* Good by View, check for distance */
	{	if (cInfo->ts && cInfo->ts->Count && cInfo->Percent > 0)
		{	if (Station->MultiLine)
			{	RECT rcTemp;
#ifdef VERBOSE
IntersectRect(&rcTemp,
			&Station->MultiLine->tileMinMax,
			&cInfo->ts->tileMinMax);
TraceLogThread("tileMinMax", FALSE, "[%ld]Station(%s) %ld %ld -> %ld %ld vs %ld %ld -> %ld %ld gives %ld %ld -> %ld %ld\n",
			   cInfo->Index, Station->Station,
			   Station->MultiLine->tileMinMax.left,
			   Station->MultiLine->tileMinMax.top,
			   Station->MultiLine->tileMinMax.right,
			   Station->MultiLine->tileMinMax.bottom,
			   cInfo->ts->tileMinMax.left,
			   cInfo->ts->tileMinMax.top,
			   cInfo->ts->tileMinMax.right,
			   cInfo->ts->tileMinMax.bottom,
			   rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom);
#endif
				return IntersectRect(&rcTemp,
									&Station->MultiLine->tileMinMax,
									&cInfo->ts->tileMinMax);
			} else	return OSMIsTileInSet(cInfo->ts, Station->pCoord->TileCoord.x>>8, 
											Station->pCoord->TileCoord.y>>8, 24);
											/* Set LatLonToTileCoord for 24! */
		} else
		{	double distance, bearing;
			AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
							cInfo->LastCenterPosition.dblLongitude,
							Station->pCoord?Station->pCoord->lat:0,
							Station->pCoord?Station->pCoord->lon:0,
							&distance, &bearing);
			return (distance <= cInfo->Scale);	/* Visible */
		}
	}
	return FALSE;
}

static void SetCenterTracking(HWND hwnd, STATION_INFO_S *Station, BOOL AutoZoom = TRUE);

static void InvalidateCircle(HWND hwnd, BOOL ForceIt = TRUE, BOOL NoOptimize=FALSE, long msDelay=500);

static void SetNextCirclePaint(CLIENT_INFO_S *cInfo, long msDelay=0, char *Why=NULL)
{	__int64 msNow = llGetMsec();
	__int64 NextPaint = msNow + msDelay;
	if (cInfo->Circle.msNextPaint > NextPaint)
	{	cInfo->Circle.StationsValid = FALSE;
		cInfo->Circle.msNextPaint = NextPaint;
		if (Why) cInfo->Circle.InvalidReason = Why;
/*
	This is new and may not be wanted
*/
		InvalidateCircle(cInfo->hwnd,FALSE,FALSE,msDelay);
	}
}

static BOOL UpdateStationVisibility(STATION_INFO_S *Station, char *Why, BOOL Moved=FALSE, BOOL NewOne=FALSE, BOOL ForcePaint=FALSE)
{	BOOL Updated = FALSE;

	for (int tr=0; tr<MAX_TRACKERS; tr++)
	if (cInfos[tr].Active)
	{
		if (NewOne
		&& cInfos[tr].Awaiting
		&& (!_strnicmp(cInfos[tr].CenterID, Station->Station,
					sizeof(cInfos[tr].CenterID))
		|| (HasNickLabelNonBlank(Station)
			&& !_strnicmp(cInfos[tr].CenterID,
							Station->Nickname->Label,
							sizeof(cInfos[tr].CenterID)))))
		{	SetCenterTracking(hwndTracker[tr], Station);
			Updated = TRUE;
		} else
		{	BOOL Visible = IsStationVisible(&cInfos[tr], Station);
			if (Station->TInfo[tr].visible
			|| Station->TInfo[tr].alwaysvisible
			|| Visible)
			{	if (Moved || NewOne || ForcePaint
				|| (!Station->TInfo[tr].visible != !Visible))
				{	Station->TInfo[tr].inCircle = Station->TInfo[tr].ptvalid = Station->TInfo[tr].rcsymvalid = Station->TInfo[tr].rclblvalid = FALSE;
					SetNextCirclePaint(&cInfos[tr], 250, Why);
					InvalidateCircle(hwndTracker[tr],FALSE,FALSE,250);
				} else InvalidateCircle(hwndTracker[tr]);
				Station->TInfo[tr].visible = Visible;
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]UpdateStationVisibilty(%s) %s %sVisible\n", (int) tr, Why, Station->Station, Station->TInfo[tr].visible?"":"NOT ");
				Updated = TRUE;
			}
		}
	}
	return Updated;
}

static BOOL InvalidateStationPoints(int tr, char *Why, BOOL Instant)
{	BOOL Changed = FALSE;

	for (unsigned int s=0; s<CloseStationCount; s++)
	{	STATION_INFO_S *Station = pCloseStations[s];
		BOOL WasVisible = Station->TInfo[tr].visible
						|| Station->TInfo[tr].alwaysvisible;
		Station->TInfo[tr].visible = IsStationVisible(&cInfos[tr], Station);
		if (!Station->TInfo[tr].visible != !WasVisible) Changed = TRUE;
		Station->TInfo[tr].inCircle = Station->TInfo[tr].ptvalid = Station->TInfo[tr].rcsymvalid = Station->TInfo[tr].rclblvalid = FALSE;
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]InvalidateStationPoints(%s) %s %sVisible %s\n", (int) tr, Why, Station->Station, Station->TInfo[tr].visible?"":"NOT ", Changed?"CHANGED":"");
	}
	if (Changed || Instant)
	{	cInfos[tr].Circle.StationsValid = FALSE;	/* Force circle paint */
		cInfos[tr].Circle.InvalidReason = Why;
		cInfos[tr].Circle.msNextPaint = 0/*llGetMsec()*/;	/* And REALLY force it! */
	}
#ifdef DEBUG_CIRCLE_PAINT
	TraceLogThread("CirclePaint", FALSE, "InvalidateStationPoints[%ld] %s %s %s\n",
			   tr, Why, Instant?"NOW":"", Changed?"CHANGED":"");
#endif
	return Changed;
}

BOOL GetCenterPosition(double *pLat, double *pLon)
{
	*pLat = cInfos[0].LastCenterPosition.dblLatitude;
	*pLon = cInfos[0].LastCenterPosition.dblLongitude;
	return TRUE;
}

BOOL SetCenterPosition(double pLat, double pLon, int zoom, char *Station, char *Owner)
{
	cInfos[0].CenterRanging = TRUE;	/* Always on 0 */
	if (!cInfos[0].Locked)
		cInfos[0].CenterTracking = FALSE;	/* Manually set center, quit tracking */
	cInfos[0].LastCenterPosition.dblLatitude = pLat;
	cInfos[0].LastCenterPosition.dblLongitude = pLon;
	if (zoom) cInfos[0].zoom = zoom;
	InvalidateCircle(cInfos[0].hwnd, TRUE, TRUE);
	if (Station && Owner)
		PostMessage(hwndMain, WM_CENTER_STATION, (WPARAM)_strdup(Station), (LPARAM)_strdup(Owner));
	cInfos[0].msLastSigChange = llGetMsec();
	return TRUE;
}

static char *SkipWhite(char *p)
{	while (*p && isspace(*p & 0xff)) p++;
	return p;
}

static char *StrSave(unsigned char *size, char **pbuf, char *str CALLER)
{	size_t cLen = strlen(str)+1;
	if (cLen > *size)
	{	if (*pbuf) free(*pbuf);
#ifdef _DEBUG
		*pbuf = (char*)_malloc_dbg(cLen,_NORMAL_BLOCK MY_CALLER);
#else
		*pbuf = (char*)malloc(cLen);
#endif
	*size = cLen;
	}
	strncpy(*pbuf, str, cLen);
	return *pbuf;
}

static TCHAR *UTF8Save(unsigned char *size, TCHAR **pbuf, char *str CALLER)
{	size_t cLen = strlen(str)+1;
	if (cLen > *size)
	{	if (*pbuf) free(*pbuf);
#ifdef _DEBUG
		*pbuf = (TCHAR*)_malloc_dbg(cLen*sizeof(TCHAR),_NORMAL_BLOCK MY_CALLER);
#else
		*pbuf = (TCHAR*)malloc(cLen*sizeof(TCHAR));
#endif
		*size = cLen;
	}
	StringCbPrintExUTF8(*pbuf, cLen*sizeof(TCHAR), NULL, NULL, -1, str, NULL);
	return *pbuf;
}

typedef struct TELEMETRY_S
{	char Station[STATION_SIZE];
	char *PARM, *UNIT, *EQNS, *BITS;
	SYSTEMTIME stDefinition;
	SYSTEMTIME stLast;
	TELEMETRY_INFO_S Telemetry;
} TELEMETRY_S;
#ifdef DEFINITIONS
KJ4ERJ-2>APZAPM,qAS,KJ4ERJ-FE::KJ4ERJ-2 :PARM.Direct,Local,Recent,IS-RF,RF-IS,B1,B2,B3,B4,B5,B6,B7,B8
KJ4ERJ-2>APZAPM,qAS,KJ4ERJ-FE::KJ4ERJ-2 :UNIT.Stations,Stations,Stations,Packets/Minute,Packets/Minute,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A
KJ4ERJ-2>APZAPM,qAS,KJ4ERJ-FE::KJ4ERJ-2 :EQNS.0,1,0,0,1,0,0,1,0,0,0.1,0,0,0.1,0
KJ4ERJ-2>APZAPM,qAS,KJ4ERJ-FE::KJ4ERJ-2 :BITS.11111111,Battery State Tracking
#endif

unsigned long TelemetryCount = 0;
unsigned long TelemetrySize = 0;
TELEMETRY_S *Telemetry;

unsigned int FindTelemetryCall(char *Station, BOOL AllowCreate)
{	unsigned int t;

	for (t=0; t<TelemetryCount; t++)
		if (!strncmp(Station, Telemetry[t].Station, sizeof(Telemetry[t].Station)))
			break;
	if (t>=TelemetryCount)
	{	if (!AllowCreate) return -1;
		t = TelemetryCount++;
		if (TelemetryCount > TelemetrySize)
		{	TelemetrySize += 8;
			Telemetry = (TELEMETRY_S *)realloc(Telemetry,sizeof(*Telemetry)*TelemetrySize);
		}
		memset(&Telemetry[t],0,sizeof(Telemetry[t]));
		strncpy(Telemetry[t].Station, Station, sizeof(Telemetry[t].Station));
	}
	return t;
}

size_t PurgeTelemetry(BOOL Force = FALSE)
{	BOOL Result = FALSE;
	unsigned long MaxAge = Force?0:ActiveConfig.Aging.TelemetryDefDays*24*60*60;

	__int64 msNow = llGetMsec();
static __int64 LastPurge;
	if (!LastPurge) LastPurge = msNow-60*60*1000 + 3*60*1000;	/* Trigger in 4 minutes */
	if (!Force && llMsecSince(LastPurge, msNow) < 60*60*1000) return 0;
	LastPurge = msNow;

	Result = PurgeTelemetryDefinitions(NULL, &ActiveConfig, MaxAge);
	return Result;
}

static int CompareCloseStation(STATION_INFO_S *Stat, char *Station, char *Owner)
{	int Result = strncmp(Stat->Station, Station, sizeof(Stat->Station));
	if (!Result && *Owner && *Stat->Owner) Result = strncmp(Stat->Owner, Owner, sizeof(Stat->Owner));
#ifdef VERBOSE
	TraceLogThread("Find", TRUE, "Compare %p(%.*s:%.*s) vs (%.*s:%.*s) is %ld\n",
					Stat, STRING(Stat->Station), STRING(Stat->Owner),
					STATION_SIZE, Station, STATION_SIZE, Owner, Result);
#endif
	return Result;
}

static int CompareCloseStations(const void *One, const void *Two)
{	STATION_INFO_S *Left = *(STATION_INFO_S **)One;
	STATION_INFO_S *Right = *(STATION_INFO_S **)Two;
	return CompareCloseStation(Left, Right->Station, Right->Owner);
}

STATION_INFO_S* FindStationCall(char *Station, char *Owner = NULL, BOOL Object = FALSE)
{	unsigned int s;

	if (!Station || !*Station) return NULL;

	if (Object) Owner = "";
	else if (!Owner) Owner = Station;
/*
	Do an efficient binary search first
*/
#ifdef TRACK_FIND_STATIONS
	Find1Stations[0]++;
#endif

	if (CloseStationSort)
	{	STATION_INFO_S sFind;
		strncpy(sFind.Station, Station, sizeof(sFind.Station));
		strncpy(sFind.Owner, Owner, sizeof(sFind.Owner));
		STATION_INFO_S *Find = &sFind;
		STATION_INFO_S **Found;
		Found = (STATION_INFO_S **)bsearch(&Find, &pCloseStations[1], CloseStationSort-1, sizeof(*pCloseStations), CompareCloseStations);
		if (Found) return *Found;
/*
	MyStation isn't included in the sorted list
*/
		if (MyStation && !CompareCloseStation(MyStation, Station, Owner))
			return MyStation;
	}
/*
	Didn't find it in the binary, check for an overflow (or misteak)
*/
#ifdef TRACK_FIND_STATIONS
	Find2Stations[0]++;
#endif
	for (s=CloseStationSort; s<CloseStationCount; s++)
	if (!CompareCloseStation(pCloseStations[s], Station, Owner))
	{
#ifdef VERBOSE
		if (s < CloseStationSort)
			TraceLogThread("Find", TRUE,
				"nnnnNOoooo!  Found %s:%s at [%ld/%ld/%ld] or %s:%s\n",
				Station, Owner, s, CloseStationSort, CloseStationCount,
				pCloseStations[s]->Station, pCloseStations[s]->Owner);
		else TraceLogThread("Find", TRUE,
				"Overflow found %s:%s at [%ld/%ld/%ld] or %s:%s\n",
				Station, Owner, s, CloseStationSort, CloseStationCount,
				pCloseStations[s]->Station, pCloseStations[s]->Owner);
#endif
		return pCloseStations[s];
	}
	return NULL;	/* Flag for not found */
}

static char *FormatStationHeard(STATION_INFO_S *Station)
{	size_t Remaining = 80;
	char *Start = (char*) malloc(Remaining);
	char *Next = Start;
	*Next = '\0';

	if (Station->HeardInternal) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sInternal", Next!=Start?" ":"");
	if (Station->HeardOnRF) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sLclRF[%ld]", Next!=Start?" ":"", (long) Station->HeardOnRF-1);
	if (Station->HeardAsRFDigi) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sLclDigi[%ld]", Next!=Start?" ":"", (long) Station->Packets[0].RFDigi);
	if (Station->HeardAsThird) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%s3rd", Next!=Start?" ":"");
	if (Station->HeardAsIGate) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sIGATE[%ld]", Next!=Start?" ":"", (long) Station->Packets[0].IGate);
	if (Station->HeardAsDigi) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sDigi[%ld]", Next!=Start?" ":"", (long) Station->Packets[0].Digi);
	if (Station->HeardAsTCPIP) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sTCP", Next!=Start?" ":"");
	if (Station->HeardRemoteRF) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%sRemRF", Next!=Start?" ":"");
	return Start;
}

static char *MakeNewObjectName(char *Type)
{	int v;
	char SSID[10];
	char Call[16];
	char *Name = (char*)malloc(16);
	strcpy(Call,CALLSIGN);
	if (strchr(Call,'-')) *strchr(Call,'-') = '\0';	/* No -SSID */
	if (strlen(Call) > 3) memmove(Call,&Call[strlen(Call)-3],4);

	for (v=1; v<36*36; v++)
	{	StringCbPrintfA(Name, 10, "%.3s.%.2s.%.2s",
						Call, Type, _ltoa(v,SSID,36));
		if (!FindStationCall(Name,NULL,TRUE)
		&& !FindConfigObject(&ActiveConfig,Name))
			break;
	}
	if (v >= 36*36)
	{	free(Name);
		Name = NULL;
	}
	return Name;
}

BOOL GetMyCoordinates(double *pLat, double *pLon)
{	if ((LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
	{	*pLat = LastGoodPosition.dblLatitude;
		*pLon = LastGoodPosition.dblLongitude;
		return TRUE;
	}
	return FALSE;
}

typedef struct FRIEND_COORDINATE_S
{	char Station[STATION_SIZE];
	double lat, lon;
} FRIEND_COORDINATE_S;
FRIEND_COORDINATE_S *Friends = NULL;
static long FriendCount = 0;
static long FriendSize = 0;

static BOOL IsFriendStation(char *Friend)
{	long f;

	for (f=0; f<FriendCount; f++)
	{	if (!strncmp(Friends[f].Station, Friend, sizeof(Friends[f].Station)))
			return TRUE;
	}
	return FALSE;
}

static BOOL SetFriendCoordinates(char *Friend, double Lat, double Lon)
{	long f;

	for (f=0; f<FriendCount; f++)
	{	if (!strncmp(Friends[f].Station, Friend, sizeof(Friends[f].Station)))
		{	break;
		}
	}
	if (f >= FriendCount)	/* Need a new entry */
	{	if (FriendCount+1 >= FriendSize)
		{	FriendSize += 32;
			Friends = (FRIEND_COORDINATE_S *) realloc(Friends,sizeof(*Friends)*FriendSize);
		}
		memset(&Friends[FriendCount], 0, sizeof(Friends[FriendCount]));
		strncpy(Friends[FriendCount].Station, Friend, sizeof(Friends[FriendCount].Station));
		f = FriendCount++;	/* Make it visible */
	}
	Friends[f].lat = Lat;
	Friends[f].lon = Lon;
	return TRUE;
}

BOOL GetFriendCoordinates(char *Friend, double *pLat, double *pLon)
{	long f;

	if (strlen(Friend) > sizeof(Friends[0].Station)) return FALSE;	/* NEVER found! */

	for (f=0; f<FriendCount; f++)
	{	if (!strncmp(Friends[f].Station, Friend, sizeof(Friends[f].Station)))
		{	break;
		}
	}
	if (f >= FriendCount)	/* Need a new entry */
	{	PostMessage(hwndMain, WM_ADD_FRIEND, 0, (LPARAM) _strdup(Friend));
		return FALSE;
	}
	if (pLat) *pLat = Friends[f].lat;
	if (pLon) *pLon = Friends[f].lon;
	return Friends[f].lat!=0.0 || Friends[f].lon!=0.0;
}

static void FixStationsCloseIndices(void)
{	unsigned long i;
	for (i=0; i<PacketScrollerSize; i++)
	if (Stations[i].Station[0])
	{	STATION_INFO_S *Stat = FindStationCall(Stations[i].Station,
												Stations[i].Owner);
		Stations[i].CloseIndex = Stat?Stat->Index:-1;
		if (Stat && HasNickLabelNonBlank(Stat))
			strncpy(Stations[i].Label, Stat->Nickname->Label,
					sizeof(Stations[i].Label));
	}
	for (i=0; i<PacketScrollerSize; i++)
	if (PaintingStations[i].Station[0])
	{	STATION_INFO_S *Stat = FindStationCall(PaintingStations[i].Station,
												PaintingStations[i].Owner);
		PaintingStations[i].CloseIndex = Stat?Stat->Index:-1;
		if (Stat && HasNickLabelNonBlank(Stat))
			strncpy(PaintingStations[i].Label, Stat->Nickname->Label,
					sizeof(PaintingStations[i].Label));
	}
}

static BOOL SortCloseStations(void)
{static __int64 msLastSort;
	BOOL Result = FALSE;

	if (!CloseStationFreeze
	&& CloseStationSort != CloseStationCount)
	{	__int64 msNow = llGetMsec();
		__int64 msDelta = llMsecSince(msLastSort, msNow);
		int NewCount = CloseStationCount-CloseStationSort;
		if ((NewCount > 16 && msDelta > 400)
		|| msDelta > 5000)
		{	msLastSort = msNow;
#ifdef TRACK_FIND_STATIONS
			SortStations[0]++;
#endif
			qsort(&pCloseStations[1], CloseStationCount-1, sizeof(*pCloseStations), CompareCloseStations);
			CloseStationSort = CloseStationCount;
			for (unsigned int i=0; i<CloseStationCount; i++)
				pCloseStations[i]->Index = i;
			FixStationsCloseIndices();
			Result = TRUE;	/* We actually sorted and fixed things */

//__int64 msElapsed = llMsecSince(msLastSort, llGetMsec());
//TraceLogThread("Config", TRUE, "Sorted %ld/%ld Stations in %ld msec\n", (long) NewCount, (long) CloseStationCount-1, (long) msElapsed);
		}
	}
	return Result;
}

/* Remember to copy the default values down if this prototype is removed */
void InvalidatePortStatus(BOOL ForceIt = TRUE);
/* Remember to copy the default values down if this prototype is removed */

static void FreezeCloseStations(HWND hwnd)
{	CloseStationFreeze++;
	InvalidatePortStatus();
}

static void ThawCloseStations(HWND hwnd)
{	if (!--CloseStationFreeze) SortCloseStations();
	InvalidatePortStatus();
}

static BOOL DoesStationMessage(STATION_INFO_S *Station)
{
	if (!strncmp(Station->Station, CALLSIGN, sizeof(Station->Station)))
		return FALSE;	/* Cannot message ourselves (yet) */
	if (Station->hasMessaging) return TRUE;
	if (LocateSimpleStringEntry(&ActiveConfig.MessageCalls, Station->Station) != -1)
	{	Station->hasMessaging = TRUE;
		return TRUE;
	}
	return FALSE;
}

static BOOL IsValidLatLon(double Latitude, double Longitude)
{	return Latitude>=-85 && Latitude<=85 && Longitude >=-180 && Longitude <= 180;
}

#ifdef SUPPORT_HOURLY_PACKET_COUNT
static char *BuildHourlyStationString(STATION_INFO_S *Station, char *Prefix=NULL)
{
//#ifdef UNDER_CE
//	return NULL;
//#else
	if (!Prefix) Prefix = "";
	size_t Avail = 33*5*HOURLY_PACKETS+120+strlen(Prefix);
	char *Next = (char*)malloc(Avail), *LastGood=NULL;
	char *Body = Next;
	unsigned int h, rfT=0, rdT=0, dgT=0, isT=0, igT=0, TT, T=0;

	if (Prefix && *Prefix) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%s", Prefix);

	for (h=0; h<HOURLY_PACKETS; h++)
	{	isT += Station->Packets[h].IS;
		igT += Station->Packets[h].IGate;
		dgT += Station->Packets[h].Digi;
		rdT += Station->Packets[h].RFDigi;
		rfT += Station->Packets[h].RF;
	}
	TT = isT+igT+dgT+rdT+rfT;
	if (TT == 0) { free(Body); return NULL; }
	{	char *Start = Next;
		if (isT) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%sI", Next==Start?"":"+");
		if (igT) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%sG", Next==Start?"":"+");
		if (dgT) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%sD", Next==Start?"":"+");
		if (rdT) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%sd", Next==Start?"":"+");
		if (rfT) StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, "%sR", Next==Start?"":"+");
	}
	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS, ":");

	for (h=0; T<TT && h<HOURLY_PACKETS; h++)
	{	char *Start = Next;
		unsigned int sT = 0;

		if (isT)
		{	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
								"%s%ld", Next==Start?" ":"+", Station->Packets[h].IS);
			sT += Station->Packets[h].IS;
		}
		if (igT)
		{	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
								"%s%ld", Next==Start?" ":"+", Station->Packets[h].IGate);
			sT += Station->Packets[h].IGate;
		}
		if (dgT)
		{	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
								"%s%ld", Next==Start?" ":"+", Station->Packets[h].Digi);
			sT += Station->Packets[h].Digi;
		}
		if (rdT)
		{	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
								"%s%ld", Next==Start?" ":"+", Station->Packets[h].RFDigi);
			sT += Station->Packets[h].RFDigi;
		}
		if (rfT)
		{	StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
								"%s%ld", Next==Start?" ":"+", Station->Packets[h].RF);
			sT += Station->Packets[h].RF;
		}
		if (sT) LastGood = Next;
		T += sT;
	}
	if  (LastGood) *LastGood = '\0';	/* Shorten the string */
	return Body;
//#endif
}
#endif

static BOOL isOperatorPresent(void)
{
#if !defined(UNDER_CE) && 0
	QUERY_USER_NOTIFICATION_STATE quns;
	HRESULT hr = SHQueryUserNotificationState(&quns);
	BOOL OperatorPresent = (hr!=S_OK) || (quns!=QUNS_NOT_PRESENT);
#else
	BOOL OperatorPresent = TRUE;
#endif
	return OperatorPresent;
}

#ifdef USING_POWER
#define POWER_COUNT 200
struct
{	SYSTEMTIME st;
	BYTE BatteryLifePercent;
} Powers[POWER_COUNT] = { 0 };
int PowerCount = 0;
#endif

#ifdef UNDER_CE
	SYSTEM_POWER_STATUS_EX2 sps2;
#else
	SYSTEM_POWER_STATUS sps;
#define sps2 sps
#endif
//#ifdef UNDER_CE
//	SYSTEM_POWER_STATUS_EX sps;
//#else
//	SYSTEM_POWER_STATUS sps;
//#endif

#ifndef NO_PATH_TRACKING
void DeReferencePacketPath(STATION_INFO_S *Station)
{	if (Station->PacketPath)
	{	PACKET_PATH_S *PktPath = Station->PacketPath;
		int h;
#ifdef NOT_ANY_MORE
		//Station->PacketPath = NULL;
		for (h=0; h<PktPath->HopCount; h++)
			if (!strcmp(SeenStations[PktPath->Hops[h].SeenIndex].Station,CALLSIGN))
			{	TraceLogThread("PathError", TRUE, "Hop[%ld] Station[%ld] is ME(%s)! at %.6lf %.6lf\n",
								(long) h, PktPath->Hops[h].SeenIndex,
								SeenStations[PktPath->Hops[h].SeenIndex].Station,
								PktPath->Hops[h].pCoord->lat, PktPath->Hops[h].pCoord->lon);
				ShowTraceLog("PathError");
			}
#endif
		for (h=0; h<PktPath->HopCount; h++)
			if (PktPath->Hops[h].SeenIndex == Station->SeenIndex)
				break;
		if (h >= PktPath->HopCount)
		{	TraceLogThread("PathError", TRUE, "Station(%s)Seen[%ld] DeReferencing non-Referenced PacketPath(%p)\n",
							Station->Station, (long) Station->SeenIndex, PktPath);
			ShowTraceLog("PathError");
		}
		else if (!--PktPath->References)
		{	for (int h=0; h<PktPath->HopCount; h++)
			if (PktPath->Hops[h].pCoord)
			{	DeReferenceCoord("DeReferencePacketPath",Station->Station,PktPath->Hops[h].pCoord);
			}
			free(PktPath);
			PacketPathCount--;
		} else if (PktPath->References < 0)
		{	TraceLogThread("PathError", TRUE, "DereferencePacketPath:%ld References?\n", (long) PktPath->References);
			ShowTraceLog("PathError");
		}
	}
}

BOOL ReferencePacketPathHop(char *StationID, STATION_INFO_S *Station, PACKET_PATH_S *PktPath, char *Pkt)
{
static char MaxHops = 0;
	if (PktPath->HopCount >= MaxHops)
	{	int h;
		char Buffer[512] = {0};
		char *Next = Buffer;
		size_t Avail = sizeof(Buffer);
		for (h=0; h<PktPath->HopCount; h++)
			StringCbPrintfExA(Next, Avail, &Next, &Avail, STRSAFE_IGNORE_NULLS,
							"%s%s", Avail==sizeof(Buffer)?"":" ",
							SeenStations[PktPath->Hops[h].SeenIndex].Station);
//		TraceLogThread("LongPaths", TRUE, "ReferencePacketPathHop:%ld Hops Exceeded! %s after %s in %s\n",
//						MaxHops, StationID, Buffer, Pkt);
	}
	if (PktPath->HopCount >= sizeof(PktPath->Hops)/sizeof(PktPath->Hops[0]))
		return FALSE;
	else
	{	int h = PktPath->HopCount++;	/* We add a hop regardless */
		if (PktPath->HopCount > MaxHops) MaxHops = PktPath->HopCount;
		if (Station)
		{	if (Station->PacketPath != PktPath)
			{	DeReferencePacketPath(Station);
				Station->PacketPath = PktPath;
				PktPath->References++;
			}// else TraceLogThread("Paths", TRUE, "ReferencePacketPathHop:Station(%s) double-referencing PktPath(%p)[%ld] %s %s\n",
			//						Station->Station, PktPath, (long) h, from, Pkt);
			PktPath->Hops[h].SeenIndex = Station->SeenIndex;
			PktPath->Hops[h].pCoord = Station->pCoord;
			PktPath->Hops[h].pCoord->References++;
		} else
		{	PktPath->Hops[h].SeenIndex = GetSeenStationIndex(StationID);
//		TraceLogThread("Paths", TRUE, "ReferencePacketPathHop:NULL Station[%ld] from %s Seen[%ld] in %s\n", (long) h, StationID, (long) PktPath->Hops[h].SeenIndex, Pkt);
		}
		return TRUE;
	}
}
#endif

static COLORREF GetInvalidColor(TRACK_VALIDITY_V Invalid)
{
	switch (Invalid)
	{
	case TRACK_OK:		return RGB(192,255,192);	/* Green is OK */
	case TRACK_DUP:		return RGB(255,192,255);	/* Purple is DUP */
	case TRACK_QUICK:	return RGB(255,192,192);	/* Pink is QUICK */
	case TRACK_FAST:	return RGB(255,128,128);	/* Red is FAST */
	case TRACK_RESTART:	return RGB(128,255,255);	/* Aqua is RESTART */
	default:
		return RGB(128,128,128);					/* Gray is unknown */
	}
}

static void ShuffleScreenElements(HWND hwnd)
{	RECT rc;
	GetClientRect(hwnd, &rc);
	SendMessage(hwnd, WM_SIZE, 0, MAKELONG(rc.right-rc.left,rc.bottom-rc.top));
	InvalidateRect(hwnd, NULL, TRUE);
}

typedef struct INFO_BLOCK
{	TCHAR *uLabel;
	char *aLabel;
	LRESULT (*Handler)(struct INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
	BOOL PaintRect;
	BOOL AlwaysInvalidate;
	struct
	{	RECT rc;
		__int64 msWhen;
		int InvalidCount;
		BOOL EraseIt;
	} Tracker[MAX_TRACKERS];
} INFO_BLOCK;

LRESULT DefaultHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT BottomHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT ClearHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT CircleHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT SpeedHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT AltitudeHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT LatLonHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT DestinationHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT GridSquareHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT HeadingHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT StationHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT SliderHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT ScaleHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT APRSHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT SatViewHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT SatUseHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT FixHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT TimeHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT MessageHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT StatUsageHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT PowerHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);
LRESULT OdometerHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp);

INFO_BLOCK rcs[22] = { { TEXT("Bottom"), "Bottom", BottomHandler, FALSE }, 
					{ TEXT("Circle"), "Circle", CircleHandler, FALSE },
					{ TEXT("Clear1"), "Clear1", ClearHandler, FALSE },
					{ TEXT("Clear2"), "Clear2", ClearHandler, FALSE },
					{ TEXT("Speed"), "Speed", SpeedHandler, TRUE, TRUE },
					{ TEXT("Stations"), "Stations", StationHandler, TRUE, TRUE },
					{ TEXT("Heading"), "Heading", HeadingHandler, TRUE, TRUE },
					{ TEXT("Altitude"), "Altitude", AltitudeHandler, TRUE },
					{ TEXT("LatLon"), "LatLon", LatLonHandler, TRUE },
					{ TEXT("GridSquare"), "GridSquare", GridSquareHandler, TRUE },
					{ TEXT("Message"), "Message", MessageHandler, FALSE, TRUE },
					{ TEXT("Destination"), "Destination", DestinationHandler, TRUE },
					{ TEXT("APRS"), "APRS", APRSHandler, TRUE, TRUE },
					{ TEXT("Slider"), "Slider", SliderHandler, TRUE },
					{ TEXT("Sat In View"), "Sat In View", SatViewHandler, TRUE },
					{ TEXT("Sat In Use"), "Sat In Use", SatUseHandler, TRUE },
					{ TEXT("Scale"), "Scale", ScaleHandler, TRUE },
					{ TEXT("Fix"), "Fix", FixHandler, TRUE },
					{ TEXT("Time"), "Time", TimeHandler, TRUE, TRUE },
					{ TEXT("Power"), "Power", PowerHandler, TRUE },
					{ TEXT("StatUsage"), "StatUsage", StatUsageHandler, TRUE },
					{ TEXT("Odometer"), "Odometer", OdometerHandler, TRUE } };
#define RC_COUNT (sizeof(rcs)/sizeof(rcs[0]))
#define rc_BottomPanel	0
#define rc_Circle		1
#define rc_Clear1		2
#define rc_Clear2		3
#define rc_Speed		4
#define rc_Stations		5
#define rc_Heading		6
#define rc_Altitude		7
#define rc_LatLon		8
#define rc_GridSquare	9
#define rc_Message		10
#define rc_Destination	11
#define rc_APRS			12
#define rc_Slider		13
#define rc_SatInView	14
#define rc_SatInUse		15
#define rc_Scale		16
#define rc_Fix			17
#define rc_Time			18
#define rc_Power		19
#define rc_StatUsage	20
#define rc_Odometer		21

#define rcBottomPanel(tr)	rcs[rc_BottomPanel].Tracker[tr].rc
#define rcCircle(tr)		rcs[rc_Circle].Tracker[tr].rc
#define rcSpeed(tr)			rcs[rc_Speed].Tracker[tr].rc
#define rcStations(tr)		rcs[rc_Stations].Tracker[tr].rc
#define rcHeading(tr)		rcs[rc_Heading].Tracker[tr].rc
#define rcAltitude(tr)		rcs[rc_Altitude].Tracker[tr].rc
#define rcLatLon(tr)		rcs[rc_LatLon].Tracker[tr].rc
#define rcGridSquare(tr)	rcs[rc_GridSquare].Tracker[tr].rc
#define rcMessage(tr)		rcs[rc_Message].Tracker[tr].rc
#define rcDestination(tr)	rcs[rc_Destination].Tracker[tr].rc
#define rcAPRS(tr)			rcs[rc_APRS].Tracker[tr].rc
#define rcSlider(tr)		rcs[rc_Slider].Tracker[tr].rc
#define rcSatInView(tr)		rcs[rc_SatInView].Tracker[tr].rc
#define rcSatInUse(tr)		rcs[rc_SatInUse].Tracker[tr].rc
#define rcScale(tr)			rcs[rc_Scale].Tracker[tr].rc
#define rcFix(tr)			rcs[rc_Fix].Tracker[tr].rc
#define rcTime(tr)			rcs[rc_Time].Tracker[tr].rc
#define rcPower(tr)			rcs[rc_Power].Tracker[tr].rc
#define rcStatUsage(tr)		rcs[rc_StatUsage].Tracker[tr].rc
#define rcOdometer(tr)		rcs[rc_Odometer].Tracker[tr].rc
#define rcClear1(tr)		rcs[rc_Clear1].Tracker[tr].rc
#define rcClear2(tr)		rcs[rc_Clear2].Tracker[tr].rc

#if MAX_TRACKERS <= 1
#define GetTrStartEnd(h,ps,pe) *(ps)=0,*(pe)=1
#else
static void GetTrStartEnd(HWND hwnd, int *trStart, int *trEnd)
{	*trStart = 0; *trEnd = 1;	/* Default to hwndMain [0] */

	if (!hwnd)
	{	*trStart = 0; *trEnd = MAX_TRACKERS;
	} else for (int tr=0; tr<MAX_TRACKERS; tr++)
	if (hwndTracker[tr] == hwnd)
	{	*trStart = tr; *trEnd = tr+1; break;
	}
}
#endif

#ifdef UNUSED
static void ActualValidateRects(HWND hwnd)
{	int trStart, trEnd;
	GetTrStartEnd(hwnd, &trStart, &trEnd);

	for (int tr=trStart; tr<trEnd; tr++)
	if (cInfos[tr].Active)
	if (hwndTracker[tr] && IsWindow(hwndTracker[tr]))
	{
		for (int r=0; r<RC_COUNT; r++)
		{		rcs[r].Tracker[tr].InvalidCount = 0;
		}
		if (cInfos[tr].InvalidTimer)
		{	if (!KillTimer(hwndTracker[tr], cInfos[tr].InvalidTimer))
				TraceError(hwnd,"KillTimer[%ld](0x%lX) Failed Error=%ld\n", (long) tr, (long) cInfos[tr].InvalidTimer, (long) GetLastError());
			cInfos[tr].InvalidTimer = 0;
		}
	}
}
#endif

static void ActualInvalidateRects(int tr, BOOL ForceIt, __int64 msNow=0)
{	if (!msNow) msNow = llGetMsec();

	if (cInfos[tr].Active)
	if (hwndTracker[tr] && IsWindow(hwndTracker[tr]))
	{	BOOL OnePending = FALSE;
		for (int r=0; r<RC_COUNT; r++)
		{
			if (rcs[r].Tracker[tr].InvalidCount)
			{	if (ForceIt || msNow >= rcs[r].Tracker[tr].msWhen)
				{	rcs[r].Tracker[tr].InvalidCount = 0;
					if (!IsRectEmpty(&rcs[r].Tracker[tr].rc))
						InvalidateRect(hwndTracker[tr], &rcs[r].Tracker[tr].rc, FALSE);
				} else OnePending = TRUE;
			}
		}
#ifdef KILL_TIMER
		if (!OnePending && cInfos[tr].InvalidTimer)
		{	if (!KillTimer(hwndTracker[tr], cInfos[tr].InvalidTimer))
				TraceError(hwnd,"KillTimer[%ld](0x%lX) Failed Error=%ld\n", (long) tr, (long) cInfos[tr].InvalidTimer, (long) GetLastError());
			cInfos[tr].InvalidTimer = 0;
		}
#endif
		if (ForceIt && cInfos[tr].Running) UpdateWindow(hwndTracker[tr]);
	}
}

static void ActualInvalidateRects(HWND hwnd, BOOL ForceIt)
{	__int64 msNow = llGetMsec();
	int trStart, trEnd;
	GetTrStartEnd(hwnd, &trStart, &trEnd);

	for (int tr=trStart; tr<trEnd; tr++)
		ActualInvalidateRects(tr, ForceIt, msNow);
#ifdef OLD_WAY
	if (cInfos[tr].Active)
	if (hwndTracker[tr] && IsWindow(hwndTracker[tr]))
	{	BOOL OnePending = FALSE;
		for (int r=0; r<RC_COUNT; r++)
		{
			if (rcs[r].Tracker[tr].InvalidCount)
			{	if (ForceIt || msNow >= rcs[r].Tracker[tr].msWhen)
				{	rcs[r].Tracker[tr].InvalidCount = 0;
					if (!IsRectEmpty(&rcs[r].Tracker[tr].rc))
						InvalidateRect(hwndTracker[tr], &rcs[r].Tracker[tr].rc, FALSE);
				} else OnePending = TRUE;
			}
		}
#ifdef KILL_TIMER
		if (!OnePending && cInfos[tr].InvalidTimer)
		{	if (!KillTimer(hwndTracker[tr], cInfos[tr].InvalidTimer))
				TraceError(hwnd,"KillTimer[%ld](0x%lX) Failed Error=%ld\n", (long) tr, (long) cInfos[tr].InvalidTimer, (long) GetLastError());
			cInfos[tr].InvalidTimer = 0;
		}
#endif
		if (ForceIt && cInfos[tr].Running) UpdateWindow(hwndTracker[tr]);
	}
#endif
}

static void MyInvalidateRect(HWND hwnd, int rcIndex, BOOL EraseIt, BOOL ForceIt, long msDelay=500)
{	int r = rcIndex;
	int trStart, trEnd;
	GetTrStartEnd(hwnd, &trStart, &trEnd);

	if (r >= 0 && r < RC_COUNT)
	for (int tr=trStart; tr<trEnd; tr++)
	if (cInfos[tr].Active)
	if (hwndTracker[tr] && IsWindow(hwndTracker[tr]))
	if (!IsRectEmpty(&rcs[r].Tracker[tr].rc))
	{	if (rcs[r].AlwaysInvalidate)
		{	InvalidateRect(hwndTracker[tr], &rcs[r].Tracker[tr].rc, EraseIt);
			rcs[r].Tracker[tr].InvalidCount = 0;
		} else
		{	__int64 msWhen = llGetMsec() + msDelay;
			if (EraseIt) rcs[r].Tracker[tr].EraseIt = EraseIt;
			if (!rcs[r].Tracker[tr].InvalidCount++	/* Mark this needing invalidation */
			|| msWhen < rcs[r].Tracker[tr].msWhen)
				rcs[r].Tracker[tr].msWhen = msWhen;
			if (!cInfos[tr].InvalidTimer)	/* Redundant one? Defer it */
			{	cInfos[tr].InvalidTimer = SetTimer(hwndTracker[tr], INVALID_TIMER, 100, NULL);
				if (!cInfos[tr].InvalidTimer)
				{	TraceError(hwnd, "Double-SetTimer[%ld], LastError = %ld\n", (long) tr, GetLastError());
					cInfos[tr].InvalidTimer = SetTimer(hwndTracker[tr], INVALID_TIMER, 100, NULL);
					TraceError(hwnd, "Double-SetTimer, Timer[%ld]=0x%lX LastError = %ld\n", (long) tr, (long) cInfos[tr].InvalidTimer, GetLastError());
				}
			}
		}
	}
	if (ForceIt)
	{	ActualInvalidateRects(hwnd, ForceIt-TRUE);
	}
}

void InvalidateStatUsage(BOOL ForceIt = FALSE)
{	MyInvalidateRect(NULL, rc_StatUsage, FALSE, ForceIt);
}

void InvalidatePower(BOOL ForceIt = TRUE)
{	MyInvalidateRect(NULL, rc_Power, FALSE, ForceIt);
}

void InvalidateDestination(BOOL ForceIt = TRUE)
{	MyInvalidateRect(NULL, rc_Destination, FALSE, ForceIt);
}

static void InvalidateCircle(HWND hwnd, BOOL ForceIt/* = TRUE*/, BOOL NoOptimize/*=FALSE*/, long msDelay/*=500*/)
{
	if (ForceIt&&NoOptimize) msDelay = 0;
	if (NoOptimize)
	{	for (int tr=0; tr<MAX_TRACKERS; tr++)
		if (cInfos[tr].Active)
		if (!hwnd || hwndTracker[tr]==hwnd)
		{	SetNextCirclePaint(&cInfos[tr], msDelay, "InvalidateCircle");	/* Force redraw */
		}
	}
	MyInvalidateRect(hwnd, rc_Circle, FALSE, ForceIt,
					(ForceIt&&NoOptimize)?0:msDelay);
}

void InvalidatePortStatus(BOOL ForceIt)
{	MyInvalidateRect(NULL, rc_APRS, FALSE, ForceIt);
}

void InvalidateTime(BOOL ForceIt = FALSE)	/* for when GPS is disabled */
{	MyInvalidateRect(NULL, rc_APRS, FALSE, FALSE);	/* Count the APRS activity bar */
	MyInvalidateRect(NULL, rc_Time, FALSE, ForceIt);
}

void InvalidateStations(HWND hwnd, BOOL ForceIt/*=TRUE*/)
{	/*InvalidatePortStatus(hwnd, FALSE); *//* Not sure why this was done in APRSLogPacket */
	MyInvalidateRect(hwnd, rc_Stations, FALSE, ForceIt);
}

static void RecoverPendingStations(HWND hwnd)
{	if (!PendingStationsCount) return;	/* Shouldn't even be called! */

	if (PendingStationsCount < PacketScrollerSize)
	{	memmove(&PaintingStations[PendingStationsCount], &PaintingStations[0],
				sizeof(PaintingStations[0])*(PacketScrollerSize-PendingStationsCount));
		memmove(&rcPaintingStations[PendingStationsCount], &rcPaintingStations[0],
				sizeof(rcPaintingStations[0])*(PacketScrollerSize-PendingStationsCount));
	} else PendingStationsCount = PacketScrollerSize;
	memcpy(&PaintingStations[0], &Stations[0],
			sizeof(PaintingStations[0])*PendingStationsCount);
	memset(&rcPaintingStations[0], 0, sizeof(rcPaintingStations[0])*PendingStationsCount);
	PendingStationsCount = 0;
}

void InvalidateScale(HWND hwnd, BOOL ForceIt = TRUE)
{
	MyInvalidateRect(hwnd, rc_Slider, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_Scale, FALSE, ForceIt);
}

void InvalidateCenter(HWND hwnd, BOOL ForceIt = TRUE)
{
	MyInvalidateRect(hwnd, rc_Scale, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_Stations, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_LatLon, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_Destination, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_GridSquare, FALSE, FALSE);
	MyInvalidateRect(hwnd, rc_Circle, FALSE, ForceIt);
}

void InvalidateGPS(BOOL ForceIt = TRUE)
{
	MyInvalidateRect(NULL, rc_APRS, FALSE, FALSE);	/* for time ticking */
	MyInvalidateRect(NULL, rc_Speed, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_Heading, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_Altitude, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_SatInView, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_SatInUse, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_Fix, FALSE, FALSE);
	MyInvalidateRect(NULL, rc_Time, FALSE, ForceIt);
}

void InvalidateMessage(BOOL ForceIt = TRUE)
{	MyInvalidateRect(NULL, rc_Message, FALSE, ForceIt);
}

void InvalidateBulletin(BOOL ForceIt = TRUE)
{}

void InvalidateOdometer(BOOL ForceIt = TRUE)
{	MyInvalidateRect(NULL, rc_Odometer, FALSE, ForceIt);
}

void MarkActivity(void)
{	unsigned __int64 Delta = SecondsSince(&stLastActivity);
	BOOL isAutoAnswer = FALSE;
static	BOOL wasAutoAnswer = FALSE;

	GetSystemTime(&stLastActivity);
	if (ActiveConfig.Messaging.AutoAnswer.Reply[0])
		if (ActiveConfig.Messaging.AutoAnswer.Delay != LONG_MAX)
			isAutoAnswer = TRUE;
	if (Delta > 5 || isAutoAnswer != wasAutoAnswer)
		InvalidateMessage(isAutoAnswer != wasAutoAnswer);
	wasAutoAnswer = isAutoAnswer;
}

#ifdef UNDER_CE
inline int GetMenuItemCount(HMENU hMenu)  
{	UINT i = 0;
	MENUITEMINFO mii = {0};
	mii.cbSize = sizeof(mii);  
	while (GetMenuItemInfo(hMenu, i, TRUE, &mii))
		i++;
	return i;
}
UINT GetMenuItemID(HMENU hMenu,int nPos)
{	MENUITEMINFO mii = {0};
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_ID;
	if (GetMenuItemInfo(hMenu, nPos, TRUE, &mii))
		return mii.wID;
	return 0;
}
#endif

#define MENUID(i) (i+ID_DYNAMIC_BASE)
#define MENU_POS_FIRST 0
#define MENU_POS_LAST (-1)
#define MENU_POS_APPEND MENU_POS_LAST

typedef void (*CALLBACK_MENU_R)(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer);

typedef struct CALLBACK_MENU_INFO_S
{	CALLBACK_MENU_R Callback;
	CLIENT_INFO_S *cInfo;
	LPARAM index;
	void *pointer;
	BOOL Freeable;
} CALLBACK_MENU_INFO_S;

static CALLBACK_MENU_INFO_S *GetCallbackMenuInfo(HMENU hMenu, UINT item, BOOL fByPosition)
{	MENUITEMINFO mii = {0};
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_DATA;
	GetMenuItemInfo(hMenu, item, fByPosition, &mii);
	return (CALLBACK_MENU_INFO_S*) mii.dwItemData;
}

static UINT AddCallbackMenuItem
(	HMENU hMenu, UINT uPosition,
	UINT uFlags, LPWSTR lpNewItem,
	CALLBACK_MENU_R Callback,
	CLIENT_INFO_S *cInfo=NULL, LPARAM index=0,
	void * pointer=NULL, BOOL Freeable=FALSE
)
{	MENUITEMINFO mii = {0};
	CALLBACK_MENU_INFO_S *cmi = (CALLBACK_MENU_INFO_S *)malloc(sizeof(*cmi));
static	long MenuCount = 0;

	cmi->cInfo = cInfo;
	cmi->Callback = Callback;
	cmi->index = index;
	cmi->pointer = pointer;
	cmi->Freeable = Freeable;

//	TraceLogThread("Menu", TRUE, "InsertMenuItem(%S)\n", lpNewItem);

#ifdef UNDER_CE
	mii.wID = ++MenuCount;	/* We need the ID to get the Menu item */
	if (!InsertMenu(hMenu, uPosition, uFlags | MF_BYPOSITION , mii.wID, lpNewItem))
	{	TraceLogThread("Menu", TRUE, "InsertMenuItem(%S) Failed, Last Error=%ld\n", lpNewItem, (long) GetLastError());
		free(cmi);
	} else
	{	mii.cbSize = sizeof(mii);
		mii.fMask = MIIM_DATA;
		mii.dwItemData = (ULONG_PTR) cmi;
		if (!SetMenuItemInfo(hMenu, mii.wID, MF_BYCOMMAND, &mii))
		{	TraceLogThread("Menu", TRUE, "SetMenuItemInfo(%S) Failed, LastError=%ld\n",
							lpNewItem, GetLastError());
		}
	}
#else
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_DATA | MIIM_FTYPE | MIIM_ID | MIIM_STATE | MIIM_STRING;
	mii.fType = MFT_STRING;
	mii.fState = uFlags;
	mii.wID = ++MenuCount;	/* We need the ID to get the Menu item */
	mii.dwItemData = (ULONG_PTR) cmi;
	mii.dwTypeData = lpNewItem;
	mii.cch = wcslen(lpNewItem);

	if (!InsertMenuItem(hMenu, uPosition, TRUE, &mii))
	{	TraceLogThread("Menu", TRUE, "InsertMenuItem(%S) Failed, Last Error=%ld\n", lpNewItem, (long) GetLastError());
		free(cmi);
	}
#endif
	return MenuCount;
}

void FreeMenuBitmaps(HMENU hMenu)
{
#ifndef UNDER_CE
	MENUITEMINFO mii = {0};
	mii.cbSize = sizeof(mii); 
	mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
	for (UINT i=0; GetMenuItemInfo(hMenu, i, TRUE, &mii); i++)
	{
#ifdef TALK_TO_ME
		if (mii.fType == MFT_STRING)	/* This is what we're looking for */
		{	mii.dwTypeData = (TCHAR*)malloc(sizeof(TCHAR)*++mii.cch);
			if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
				TraceLogThread("Menu", FALSE, "mii[%ld] is %S\n", i, mii.dwTypeData);
			free(mii.dwTypeData);
			mii.dwTypeData = NULL;
		}
#endif
		if (mii.hbmpChecked	/* If it has matching bitmaps, it's our symbol */
		&& mii.hbmpChecked == mii.hbmpUnchecked)
		{	if (!DeleteObject(mii.hbmpChecked))
				TraceError(NULL, "Failed To Delete Menu[%ld] Bitmap\n", i);
		}
		if (mii.dwItemData)	/* Callback menu item */
		{	CALLBACK_MENU_INFO_S *cmi = (CALLBACK_MENU_INFO_S *)mii.dwItemData;
			if (cmi->Freeable) free((void*)cmi->pointer);
			free((void*)mii.dwItemData);
		}
		if (mii.hSubMenu)
		{	FreeMenuBitmaps(mii.hSubMenu);
		}
	}
#endif
}

int ClearMenuItems(CLIENT_INFO_S *cInfo, HMENU hmenu, UINT BaseID, int Originals=-1)
{	int DeleteCount = 0;
	for (unsigned int i=0; i<cInfo->MenuCount; i++)
	if (cInfo->MenuItems[i].Active
	&& cInfo->MenuItems[i].BaseID == BaseID)
	{	if (cInfo->MenuItems[i].HasBitmaps)
		{	MENUITEMINFO mii = {0};
			mii.cbSize = sizeof(mii); 
			mii.fMask = MIIM_CHECKMARKS;
			if (GetMenuItemInfo(hmenu, MENUID(i), FALSE, &mii))
			{	if (mii.hbmpChecked)	/* If it has checked */
				{	if (!DeleteObject(mii.hbmpChecked))
						TraceLogThread("Menu", TRUE, "Failed To Delete Menu[%ld] Base[%ld] Index[%ld] Bitmap\n", (long) i, (long) BaseID, (long) cInfo->MenuItems[i].Index);
				} else TraceLogThread("Menu", TRUE, "Menu[%ld] Base[%ld] Index[%ld] HasBitmaps, but NOT!\n", (long) i, (long) BaseID, (long) cInfo->MenuItems[i].Index);
			}
		}
		DeleteMenu(hmenu, MENUID(i), MF_BYCOMMAND);
		cInfo->MenuItems[i].Active = FALSE;
		DeleteCount++;
	}
	if (Originals != -1)
	{	int cMenuItems = GetMenuItemCount(hmenu); 
		for (int p=cMenuItems-1; p>=Originals; p--)	/* N original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
	}
	return DeleteCount;
}

int AddMenuItem(CLIENT_INFO_S *cInfo, HMENU hmenu, UINT BaseID, UINT Index, UINT uPosition, UINT uFlags, LPCTSTR lpNewItem)
{	unsigned int i, freei=-1;

	for (i=0; i<cInfo->MenuCount; i++)
	{	if (!cInfo->MenuItems[i].Active) freei = i;
		else if (cInfo->MenuItems[i].BaseID == BaseID
		&& cInfo->MenuItems[i].Index == Index)
		{	freei = i;
			break;	/* Jump out to use this one */
		}
	}
	if (freei != -1) i = freei;

	if (i >= cInfo->MenuCount)
	{	i = cInfo->MenuCount++;
		if (cInfo->MenuCount > cInfo->MenuSize)
		{	cInfo->MenuSize += 64;
			cInfo->MenuItems = (MENU_ITEM_S*)realloc(cInfo->MenuItems,sizeof(*cInfo->MenuItems)*cInfo->MenuSize);
			memset(&cInfo->MenuItems[cInfo->MenuCount-1], 0, sizeof(*cInfo->MenuItems)*(cInfo->MenuSize-cInfo->MenuCount));
		}
	}

	if (InsertMenu(hmenu, uPosition, uFlags | MF_BYPOSITION, MENUID(i), lpNewItem))
	{	cInfo->MenuItems[i].Active = TRUE;
		cInfo->MenuItems[i].HasBitmaps = FALSE;
		cInfo->MenuItems[i].BaseID = BaseID;
		cInfo->MenuItems[i].Index = Index;
		return MENUID(i);
	} else
	{	TraceLogThread("Menu", TRUE, "InsertMenu[%ld] Base[%ld] Index[%ld] (%S) Failed, LastError=%ld\n",
					(long) i, (long) BaseID, (long) Index,
					(uFlags&MF_STRING)?lpNewItem:TEXT("*NoText*"));
		return 0;
	}
}

static int PopulateMicEMenu(CLIENT_INFO_S *cInfo, HMENU hmenu, int BaseOffset)
{	unsigned char i, MyCount = (unsigned char) min(ActiveConfig.MicEs.Count,ARRAYSIZE(cInfo->viewMicE));
	unsigned short *Counts = (unsigned short*)calloc(MyCount,sizeof(*Counts));
	int SetCount = 0;
	unsigned long s;
	unsigned long HasMicE = 0;

	for (s=0; s<CloseStationCount; s++)
	if (pCloseStations[s]->MicEIndex)	/* Mic-E Station? */
	{	HasMicE++;
		if (pCloseStations[s]->MicEIndex >= 0
		&& pCloseStations[s]->MicEIndex < MyCount)
			Counts[pCloseStations[s]->MicEIndex]++;
	}

	{	size_t Remain;
		TCHAR Name[80];
		TCHAR *Next = Name;
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("None (%ld)"), HasMicE);
		if (!ActiveConfig.Enables.MicENotification)
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT(" NoNotif"));
		if (!ActiveConfig.Enables.MicEEmergency)
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT(" Ignore(Emerg)"));
		DeleteMenu(hmenu, 0, MF_BYPOSITION);
		InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING, ID_VIEW_MICE_NONE, Name);
	}

	for (i=0; i<MyCount; i++)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[i];
		if (Action->InternalMessage
		|| Action->MultiTrackNew
		|| Action->MultiTrackActive
#ifndef UNDER_CE
		|| Action->FlashOnCenter
#endif
		|| Action->Highlight
		|| cInfo->viewMicE[i]
		|| Counts[i])
		{
		size_t Remain = 100*sizeof(TCHAR);
		TCHAR *Name = (TCHAR *) malloc(Remain);
		TCHAR *Next = Name;
		double Percent = Counts[i]*100.0 / (HasMicE?HasMicE:1);
		if (Percent >= 10.0)
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("%S %.0lf%% (%ld)"),
						Action->Name, (double) Percent, 
						(long) Counts[i]);
		else if (Percent >= 1.0)
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("%S %.1lf%% (%ld)"),
						Action->Name, (double) Percent,
						(long) Counts[i]);
		else StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("%S (%ld)"),
						Action->Name, (long) Counts[i]);
		if (!Action->Enabled)
		{	StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" NoNotif"));
		} else
		{	if (Action->InternalMessage)
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Msg"));
			if (Action->MultiTrackNew)
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" New"));
			if (Action->MultiTrackActive)
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Active"));
#ifndef UNDER_CE
			if (Action->FlashOnCenter)
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Flash"));
#endif
			if (Action->Highlight)
			{	StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" %S"), Action->Color);
				if (!Action->ColorFixed)
				{	Action->RGB = GetColorRGB(&ActiveConfig, Action->Color, "MicE");
					Action->ColorFixed = TRUE;
				}
				if (!Action->RGB	/* Failed translation? */
				&& _stricmp(Action->Color,"black"))	/* and not really black? */
				{	StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("(*BLACK*)"));
				}
			}
		}

		BOOL Checked = cInfo->viewMicE[i];
		InsertMenu(hmenu,-1, MF_BYPOSITION | (Checked?MF_CHECKED:0) | MF_STRING, ID_VIEW_MICE_NONE+i+1, Name);
		if (Checked) SetCount++;
		free(Name);
		}
	}
	free(Counts);
	return SetCount;
}

static BOOL ProcessViewMicEMenu(HWND hwnd, CLIENT_INFO_S *cInfo, DWORD id)
{
	if (id > ID_VIEW_MICE_NONE && id <= ID_VIEW_MICE_NONE+ActiveConfig.MicEs.Count+1)
	{	unsigned char i;
		id -= ID_VIEW_MICE_NONE+1;	/* 0 relative */

		cInfo->viewMicE[id] = !cInfo->viewMicE[id];
		for (i=0; i<ARRAYSIZE(cInfo->viewMicE); i++)
			if (cInfo->viewMicE[i]) break;
		if (i < ARRAYSIZE(cInfo->viewMicE))
			cInfo->viewBits |= VIEW_MICE;
		else cInfo->viewBits &= ~VIEW_MICE;
		if (cInfo->viewBits & VIEW_MICE) cInfo->viewBits &= ~VIEW_ALL;
		CheckMenuItem (cInfo->hMenu, ID_VIEW_ALL, cInfo->viewBits&VIEW_ALL?MF_CHECKED:MF_UNCHECKED);
		return TRUE;
	}
	return FALSE;
}

typedef struct APRS_SHRIEK_COUNT_S
{	char *Name;
	unsigned long index;
	unsigned short Count;
} APRS_SHRIEK_COUNT_S;

static int CompareAPRSShriekCount(const void *One, const void *Two)
{	APRS_SHRIEK_COUNT_S *Left = (APRS_SHRIEK_COUNT_S *)One;
	APRS_SHRIEK_COUNT_S *Right = (APRS_SHRIEK_COUNT_S *)Two;
	int Result = (int) Right->Count - (int) Left->Count;

	if (!Result)	/* matching counts */
	{	Result = _stricmp(Left->Name, Right->Name);
	}
	return Result;
}

static int PopulateShriekMenu(CLIENT_INFO_S *cInfo, HMENU hmenu, int BaseOffset)
{	unsigned long MyCount = ShriekCount;
	APRS_SHRIEK_COUNT_S *Counts = (APRS_SHRIEK_COUNT_S *)calloc(sizeof(*Counts),MyCount);
	int SetCount = 0;
	unsigned long i, s;
	unsigned long HasShriek = 0;

	for (i=0; i<MyCount; i++)
	{	Counts[i].Name = Shrieks[i].Name;
		Counts[i].index = i;
	}

	for (s=0; s<CloseStationCount; s++)
	if (pCloseStations[s]->ShriekMask)	/* Any bits set? */
	{	HasShriek++;
		for (i=0; i<MyCount; i++)
		if (pCloseStations[s]->ShriekMask & Shrieks[i].Mask)
		Counts[i].Count++;
	}

	qsort(Counts, ShriekCount, sizeof(*Counts), CompareAPRSShriekCount);

	for (i=0; i<MyCount; i++)
	{	TCHAR Name[80];
		double Percent = Counts[i].Count*100.0 / (HasShriek?HasShriek:1);
		if (Percent >= 10.0)
		StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"),
						Counts[i].Name, (double) Percent, 
						(long) Counts[i].Count);
		else if (Percent >= 1.0)
			StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"),
						Counts[i].Name, (double) Percent,
						(long) Counts[i].Count);
		else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"),
						Counts[i].Name, (long) Counts[i].Count);

		BOOL Checked = cInfo->viewShrieks&Shrieks[Counts[i].index].Mask;
		InsertMenu(hmenu,-1, MF_BYPOSITION | (Checked?MF_CHECKED:0) | MF_STRING, ID_VIEW_SHRIEKS_NONE+Counts[i].index+1, Name);
		if (Checked) SetCount++;
	}
	free(Counts);
	return SetCount;
}

static BOOL ProcessViewShriekMenu(HWND hwnd, CLIENT_INFO_S *cInfo, DWORD id)
{
	if (id > ID_VIEW_SHRIEKS_NONE && id <= ID_VIEW_SHRIEKS_NONE+ShriekCount+1)
	{	id -= ID_VIEW_SHRIEKS_NONE+1;	/* 0 relative */

		cInfo->viewShrieks ^= Shrieks[id].Mask;
		if (cInfo->viewShrieks)
			cInfo->viewBits |= VIEW_SHRIEKS;
		else cInfo->viewBits &= ~VIEW_SHRIEKS;
		if (cInfo->viewBits & VIEW_SHRIEKS) cInfo->viewBits &= ~VIEW_ALL;
		CheckMenuItem (cInfo->hMenu, ID_VIEW_ALL, cInfo->viewBits&VIEW_ALL?MF_CHECKED:MF_UNCHECKED);
		return TRUE;
	}
	return FALSE;
}

typedef struct APRS_SYMBOL_COUNT_S
{	int iSym;
	int index;
	char *tSym;
	unsigned short Count;
} APRS_SYMBOL_COUNT_S;

static char *tSymUnknown = "*Unknown*";

static int CompareAPRSSymbolCount(const void *One, const void *Two)
{	APRS_SYMBOL_COUNT_S *Left = (APRS_SYMBOL_COUNT_S *)One;
	APRS_SYMBOL_COUNT_S *Right = (APRS_SYMBOL_COUNT_S *)Two;
	int Result = (int) Right->Count - (int) Left->Count;

	if (!Left->tSym) Left->tSym = tSymUnknown;
	if (!Right->tSym) Right->tSym = tSymUnknown;

	if (Left->tSym == tSymUnknown && Right->tSym == tSymUnknown) return Result;
	if (Left->tSym == tSymUnknown) return -1;
	if (Right->tSym == tSymUnknown) return 1;

	if (!Result)	/* matching counts */
	{	Result = _stricmp(Left->tSym, Right->tSym);
	}
	return Result;
}

static int PopulateSymbolMenu(CLIENT_INFO_S *cInfo, HMENU hmenu, int BaseOffset)
{	APRS_SYMBOL_COUNT_S *Counts = (APRS_SYMBOL_COUNT_S *)calloc(sizeof(*Counts),MAX_SYMBOL_INDEX+1);
	int iSymbol = cInfo->CenterStation?cInfo->CenterStation->isymbol:0;
	int SetCount = 0;
	unsigned long s;

	for (s=0; s<CloseStationCount; s++)
	{	int i = APRSSymbolIndex(pCloseStations[s]->isymbol);
		if (!Counts[i].Count++)	/* First time only */
		{	Counts[i].index = i;	/* To keep track across sort */
			Counts[i].iSym = pCloseStations[s]->isymbol;/* Don't recalc later */
			if (i < MAX_SYMBOL_INDEX)
				Counts[i].tSym = GetDisplayableSymbol(Counts[i].iSym);
			else Counts[i].tSym = tSymUnknown;
		}
	}

	qsort(Counts, MAX_SYMBOL_INDEX+1, sizeof(*Counts), CompareAPRSSymbolCount);

	for (s=0; s<=MAX_SYMBOL_INDEX; s++)
	if (Counts[s].Count)
	{	TCHAR Name[80];
		double Percent = Counts[s].Count*100.0 / CloseStationCount;
		if (Percent >= 10.0)
		StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"),
						Counts[s].tSym, (double) Percent, 
						(long) Counts[s].Count);
		else if (Percent >= 1.0)
			StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"),
						Counts[s].tSym, (double) Percent,
						(long) Counts[s].Count);
		else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"),
						Counts[s].tSym, (long) Counts[s].Count);

		InsertMenu(hmenu,Counts[s].iSym==iSymbol?BaseOffset:-1, MF_BYPOSITION | (cInfo->viewSymbols[Counts[s].index]?MF_CHECKED:0) | MF_STRING, ID_VIEW_SYMBOLS_NONE+Counts[s].index+1, Name);
		if (cInfo->viewSymbols[Counts[s].index]) SetCount++;

		if (Counts[s].tSym != tSymUnknown) free(Counts[s].tSym);
	}
	free(Counts);
	return SetCount;
}

static BOOL ProcessViewSymbolMenu(HWND hwnd, CLIENT_INFO_S *cInfo, DWORD id)
{
	if (id > ID_VIEW_SYMBOLS_NONE && id <= ID_VIEW_SYMBOLS_NONE+MAX_SYMBOL_INDEX+1)
	{	unsigned long i;
		id -= ID_VIEW_SYMBOLS_NONE+1;	/* 0 relative */

		cInfo->viewSymbols[id] = !cInfo->viewSymbols[id];
		for (i=0; i<ARRAYSIZE(cInfo->viewSymbols); i++)
			if (cInfo->viewSymbols[i]) break;
		if (i < ARRAYSIZE(cInfo->viewSymbols))
			cInfo->viewBits |= VIEW_SYMBOLS;
		else cInfo->viewBits &= ~VIEW_SYMBOLS;
		if (cInfo->viewBits & VIEW_SYMBOLS) cInfo->viewBits &= ~VIEW_ALL;
		CheckMenuItem (cInfo->hMenu, ID_VIEW_ALL, cInfo->viewBits&VIEW_ALL?MF_CHECKED:MF_UNCHECKED);
		return TRUE;
	}
	return FALSE;
}

typedef struct APRS_PLATFORM_COUNT_S
{	APRS_PLATFORM_V tPlatform;
	unsigned long Count;
	char *Text;
	char *Group;
	unsigned long gCount;
} APRS_PLATFORM_COUNT_S;

static int CompareAPRSPlatformCount(const void *One, const void *Two)
{	APRS_PLATFORM_COUNT_S *Left = (APRS_PLATFORM_COUNT_S *)One;
	APRS_PLATFORM_COUNT_S *Right = (APRS_PLATFORM_COUNT_S *)Two;
	if (Left->Group && Left->Group == Right->Group)
	{	if (Left->Count < Right->Count) return 1;
		else if (Left->Count > Right->Count) return -1;
	} else if (Left->gCount < Right->gCount) return 1;
	else if (Left->gCount > Right->gCount) return -1;
	return _stricmp(Left->Text,Right->Text);
}

typedef struct TWO_STRINGS_S
{	APRS_PLATFORM_V tPlatform;
	char *String1;
	char *String2;
} TWO_STRINGS_S;

static int CompareTwoStrings(const void *One, const void *Two)
{	TWO_STRINGS_S *Left = (TWO_STRINGS_S *)One;
	TWO_STRINGS_S *Right = (TWO_STRINGS_S *)Two;
	int r = 0;
	if (!r) r = _stricmp(Left->String1, Right->String1);
	if (!r)
	{	if (Left->tPlatform < Right->tPlatform) r = -1;
		else if (Left->tPlatform > Right->tPlatform) r = 1;
	}
	if (!r) r = _stricmp(Left->String2, Right->String2);
	return r;
}

static void AddTwoString(unsigned long *pCount, unsigned long *pSize, TWO_STRINGS_S **pStrings, APRS_PLATFORM_V tPlatform, char *String1, char *String2)
{	unsigned long i = *pCount;
	*pCount += 1;
	if (*pCount > *pSize)
	{	*pSize += 16;
		*pStrings = (TWO_STRINGS_S *) realloc(*pStrings,*pSize*sizeof(**pStrings));
	}
	(*pStrings)[i].tPlatform = tPlatform;
	(*pStrings)[i].String1 = String1;
	(*pStrings)[i].String2 = String2;
}

static void TwoStringToMenu(HMENU hmenu, UINT Flags, UINT ID, unsigned long pCount, TWO_STRINGS_S *pStrings)
{	unsigned long i;

	qsort(pStrings, pCount, sizeof(*pStrings), CompareTwoStrings);
	for (i=0; i<pCount; i++)
	{	TCHAR Name[80];
		char *c = strchr(pStrings[i].String1,'(');
		int len = c?(c-pStrings[i].String1):strlen(pStrings[i].String1);

		if (i==pCount-1
		|| (c&&strncmp(pStrings[i].String1,pStrings[i+1].String1,len))
		|| (!c&&strcmp(pStrings[i].String1,pStrings[i+1].String1)))
		{	StringCbPrintf(Name, sizeof(Name), TEXT("%S (%S)"), pStrings[i].String1, pStrings[i].String2);
			AppendMenu(hmenu, Flags, ID, Name);
		} else
		{	HMENU hSub = CreatePopupMenu();
			unsigned long Count = 1;

//			if (i==pCount-1 || !c)
			{	StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"),
								pStrings[i].String1+len,
								pStrings[i].String2);
				AppendMenu(hSub, Flags, ID, Name);
				while (i<pCount-1
				&& !strncmp(pStrings[i].String1,pStrings[i+1].String1,len))
				{	StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"),
									pStrings[i+1].String1+len,
									pStrings[i+1].String2);
					AppendMenu(hSub, Flags, ID, Name);
					Count++; i++;
				}
			}
#ifdef NEEDS_WORK
			else
			{	int oi = i;
				while (i<pCount-1
				&& !strncmp(pStrings[oi].String1,pStrings[i+1].String1,len))
				{	HMENU hSub2 = CreatePopupMenu();
					unsigned long Count2 = 1;

					StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"),
									pStrings[i].String1+len,
									pStrings[i].String2);
					AppendMenu(hSub2, Flags, ID, Name);
					Count++;
					while (i<pCount-1
					&& !strncmp(pStrings[i].String1,pStrings[i+1].String1,len)
					&& !strcmp(pStrings[i].String1,pStrings[i+1].String1))
					{	StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"),
										pStrings[i+1].String1+len,
										pStrings[i+1].String2);
						AppendMenu(hSub2, Flags, ID, Name);
						Count++; Count2++; i++;
					}
					if (Count2 == 1)
					{	DestroyMenu(hSub2);
						StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"),
										pStrings[i+1].String1+len,
										pStrings[i+1].String2);
						AppendMenu(hSub, Flags, ID, Name);
					} else
					{	StringCbPrintf(Name, sizeof(Name), TEXT("%S\t(%ld)"),
										pStrings[i].String1+len,
										Count2);
						AppendMenu(hSub, Flags | MF_POPUP, (UINT_PTR) hSub2, Name);
					}
					i++;	/* Account for original one */
				}
				i--;	/* Need to leave it for outer loop to increment */
			}
#endif

			StringCbPrintf(Name, sizeof(Name), TEXT("%.*S\t(%ld)"),
							len, pStrings[i].String1,
							Count);
			AppendMenu(hmenu, Flags | MF_POPUP, (UINT_PTR) hSub, Name);
		}
	}
	free(pStrings);
}

static int PopulatePlatformMenu(CLIENT_INFO_S *cInfo, HMENU hmenu)
{	unsigned long p;
	unsigned long NonObjectCount = 0;
	APRS_PLATFORM_COUNT_S *Counts = (APRS_PLATFORM_COUNT_S *) calloc(PLATFORM_MAX+1,sizeof(*Counts));
	int SetCount = 0;

	for (p=0; p<=(unsigned long) PLATFORM_MAX; p++)
	{	Counts[p].tPlatform = (APRS_PLATFORM_V) p;
		Counts[p].Text=GetPlatformString(Counts[p].tPlatform,&Counts[p].Group);
		for (unsigned long s=0; s<CloseStationCount; s++)
		if (pCloseStations[s]->tPlatform == (APRS_PLATFORM_V) p)
		if (!pCloseStations[s]->isObject)
		{	Counts[p].Count++;
			NonObjectCount++;
		}
	}
	for (p=0; p<=(unsigned long) PLATFORM_MAX; p++)
	if (Counts[p].Group)
	{	unsigned long q;
		Counts[p].gCount = Counts[p].Count;
		for (q=p+1; q<=(unsigned long) PLATFORM_MAX; q++)
		if (Counts[q].Group == Counts[p].Group)
		{	Counts[p].gCount += Counts[q].Count;
		}
	}
	for (p=0; p<=(unsigned long) PLATFORM_MAX; p++)
	if (Counts[p].Group)
	{	unsigned long q;
		for (q=p+1; q<=(unsigned long) PLATFORM_MAX; q++)
		if (Counts[q].Group == Counts[p].Group)
		{	Counts[q].gCount = Counts[p].gCount;
		}
	} else Counts[p].gCount = Counts[p].Count;

	qsort(Counts, (unsigned long)PLATFORM_MAX+1, sizeof(*Counts), CompareAPRSPlatformCount);

	{	TCHAR Name[80];
		StringCbPrintf(Name, sizeof(Name), TEXT("None (%ld)"), NonObjectCount);
		DeleteMenu(hmenu, 0, MF_BYPOSITION);
		AppendMenu(hmenu, MF_STRING, ID_VIEW_PLATFORMS_NONE, Name);
	}

	for (p=0; p<=(unsigned long) PLATFORM_MAX; p++)
	if (Counts[p].Text && Counts[p].gCount && Counts[p].Count)
	{	double Percent = (double) Counts[p].gCount * 100.0 / (double) NonObjectCount;
		TCHAR Name[80];

		if (Counts[p].tPlatform==PLATFORM_OTHER)
		{	unsigned long q;
			HMENU hSub = CreatePopupMenu();
			unsigned long StringCount=0, StringSize=0;
			TWO_STRINGS_S *Strings=NULL;

			if (Percent >= 10.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else if (Percent >= 1.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Counts[p].Text, Counts[p].gCount);

			AppendMenu(hmenu, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_POPUP | MF_STRING, (UINT_PTR) hSub, Name);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;

			for (q=1; q<CloseStationCount; q++)	/* Skip ME */
			if (pCloseStations[q]->tPlatform == Counts[p].tPlatform)
			if (!pCloseStations[q]->isObject)
			{	AddTwoString(&StringCount, &StringSize, &Strings,
							pCloseStations[q]->tPlatform,
							pCloseStations[q]->pPlatform,
							pCloseStations[q]->Station);
			}
			TwoStringToMenu(hSub, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_STRING, ID_VIEW_PLATFORMS_NONE+((unsigned long)Counts[p].tPlatform+1), StringCount, Strings);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;
		} else if (Counts[p].tPlatform==PLATFORM_UNKNOWN)
		{	unsigned long q;
			HMENU hSub = CreatePopupMenu();
			unsigned long StringCount=0, StringSize=0;
			TWO_STRINGS_S *Strings=NULL;

			if (Percent >= 10.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else if (Percent >= 1.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Counts[p].Text, Counts[p].gCount);

			AppendMenu(hmenu, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_POPUP | MF_STRING, (UINT_PTR) hSub, Name);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;

			for (q=1; q<CloseStationCount; q++)	/* Skip ME */
			if (pCloseStations[q]->tPlatform == Counts[p].tPlatform)
			if (!pCloseStations[q]->isObject)
			{	AddTwoString(&StringCount, &StringSize, &Strings,
							pCloseStations[q]->tPlatform,
							pCloseStations[q]->dstCall,
							pCloseStations[q]->Station);
			}
			TwoStringToMenu(hSub, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_STRING, ID_VIEW_PLATFORMS_NONE+((unsigned long)Counts[p].tPlatform+1), StringCount, Strings);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;
		} else if (Counts[p].tPlatform==PLATFORM_EXPERIMENTAL)
		{	unsigned long q;
			HMENU hSub = CreatePopupMenu();
			unsigned long StringCount=0, StringSize=0;
			TWO_STRINGS_S *Strings=NULL;

			if (Percent >= 10.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else if (Percent >= 1.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Counts[p].Text, Counts[p].gCount);

			AppendMenu(hmenu, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_POPUP | MF_STRING, (UINT_PTR) hSub, Name);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;

			for (q=1; q<CloseStationCount; q++)	/* Skip ME */
			if (pCloseStations[q]->tPlatform == Counts[p].tPlatform)
			if (!pCloseStations[q]->isObject)
			{	AddTwoString(&StringCount, &StringSize, &Strings,
							pCloseStations[q]->tPlatform,
							pCloseStations[q]->dstCall,//+3,	// +3 eliminates APZxxx
							pCloseStations[q]->Station);
			}
			TwoStringToMenu(hSub, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_STRING, ID_VIEW_PLATFORMS_NONE+((unsigned long)Counts[p].tPlatform+1), StringCount, Strings);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;
		} else if (Counts[p].Group && Counts[p].gCount != Counts[p].Count)
		{	unsigned long q;
			BOOL OneEnabled = FALSE;
			HMENU hSub = CreatePopupMenu();

			if (Percent >= 10.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Counts[p].Group, Percent, Counts[p].gCount);
			else if (Percent >= 1.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Counts[p].Group, Percent, Counts[p].gCount);
			else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Counts[p].Group, Counts[p].gCount);

			for (q=p; q<=(unsigned long) PLATFORM_MAX && Counts[p].Group==Counts[q].Group; q++)
			if (Counts[q].Text && Counts[q].Count)
			{	double Percent = (double) Counts[q].Count * 100.0 / (double) Counts[q].gCount;
				TCHAR Name[80];
				char *Text = Counts[q].Text;
				if (!strncmp(Text,Counts[p].Group,strlen(Counts[p].Group)))
				{	Text = SkipWhite(Text+strlen(Counts[p].Group));
				}
				
				if (Percent >= 10.0)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Text, Percent, Counts[q].Count);
				else if (Percent >= 1.0)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Text, Percent, Counts[q].Count);
				else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Text, Counts[q].Count);

				if (cInfo->viewPlatforms[(unsigned long)Counts[q].tPlatform]) OneEnabled = TRUE;
				AppendMenu(hSub, (cInfo->viewPlatforms[(unsigned long)Counts[q].tPlatform]?MF_CHECKED:0) | MF_STRING, ID_VIEW_PLATFORMS_NONE+((unsigned long)Counts[q].tPlatform+1), Name);
			if (cInfo->viewPlatforms[(unsigned long)Counts[q].tPlatform])
				SetCount++;
			}
			AppendMenu(hmenu, (OneEnabled?MF_CHECKED:0) | MF_POPUP | MF_STRING, (UINT_PTR) hSub, Name);
			if (OneEnabled) SetCount++;
			p = q-1;	/* p++ will move back up */
		} else
		{	if (Percent >= 10.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.0lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else if (Percent >= 1.0)
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %.1lf%% (%ld)"), Counts[p].Text, Percent, Counts[p].gCount);
			else StringCbPrintf(Name, sizeof(Name), TEXT("%S (%ld)"), Counts[p].Text, Counts[p].gCount);
			AppendMenu(hmenu, (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform]?MF_CHECKED:0) | MF_STRING, ID_VIEW_PLATFORMS_NONE+((unsigned long)Counts[p].tPlatform+1), Name);
			if (cInfo->viewPlatforms[(unsigned long)Counts[p].tPlatform])
				SetCount++;
		}
	}
	free(Counts);
	return SetCount;
}

static BOOL ProcessViewPlatformMenu(HWND hwnd, CLIENT_INFO_S *cInfo, DWORD id)
{
	if (id > ID_VIEW_PLATFORMS_NONE && id <= ID_VIEW_PLATFORMS_NONE+(unsigned long)PLATFORM_MAX+1)
	{	unsigned long i;
		id -= ID_VIEW_PLATFORMS_NONE+1;	/* 0 relative */

		cInfo->viewPlatforms[id] = !cInfo->viewPlatforms[id];
		for (i=0; i<ARRAYSIZE(cInfo->viewPlatforms); i++)
			if (cInfo->viewPlatforms[i]) break;
		if (i < ARRAYSIZE(cInfo->viewPlatforms))
			cInfo->viewBits |= VIEW_PLATFORMS;
		else cInfo->viewBits &= ~VIEW_PLATFORMS;
		if (cInfo->viewBits & VIEW_PLATFORMS) cInfo->viewBits &= ~VIEW_ALL;
		CheckMenuItem (cInfo->hMenu, ID_VIEW_ALL, cInfo->viewBits&VIEW_ALL?MF_CHECKED:MF_UNCHECKED);
		return TRUE;
	}
	return FALSE;
}

// function declarations
#ifdef UNDER_CE
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);
#else
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
#endif
void ShowHideBulletinIcon(HWND hwnd, BOOL Show);
HANDLE FindPrevInstance(TCHAR *szTitle);
HWND CreateMainWindow(int nShowCmd, TCHAR *szTitle, LPARAM Index);
BOOL OnCreateMainWindow(HWND hwnd, CREATESTRUCT *cs);
BOOL FinishMainWindowStartup(HWND hwnd, char *ViewString);
void PaintMainWindow(HWND hwnd);
LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
void RestoreSavedPosits(HWND hwnd);

HWND RestoreOrCreateTrackerWindow(char *Station, char *Owner=NULL, int fromIndex=-1);
HWND CreateTrackerWindow(char *Station, char *Owner=NULL, int fromIndex=-1, char *ViewString=NULL, int zoom=-1, RECT *rcPlace=NULL);
BOOL OnCreateTrackerWindow(HWND hwnd, CREATESTRUCT *cs);
void RestoreTrackers(void);
void PaintTrackerWindow(HWND hwnd);
LRESULT CALLBACK TrackerWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

HWND PopupViewChooser(HWND hwnd, int msgRefresh, unsigned __int64 *pViewBits);

static void DefineME(HWND hwnd);

HBITMAP LoadPaintImage(int Page);
void FreePaintImage();

// global variables
//HINSTANCE g_hInstance;
HBITMAP   g_hBitmapPaints[6] = {0};

DWORD     g_dwFontSize;
DWORD     g_dwCurrentImage = 0;
__int64 msStartRunning = 0;

#ifdef SUPPORT_APRSTRACE
char *GetAPRSTraceFile(HWND hwnd)
{static	char tFile[MAX_PATH+32];

#ifdef UNDER_CE
	TCHAR *Path = (TCHAR *) malloc(sizeof(*Path)*MAX_PATH);
	if (SHGetSpecialFolderPath(hwnd, Path, CSIDL_PERSONAL, TRUE))
	{	StringCbPrintfA(tFile, sizeof(tFile), "%S/APRSTrace.txt", Path);
	} else
#endif
		strncpy(tFile,"APRSTrace.txt",sizeof(tFile));
#ifdef UNDER_CE
	free(Path);
#endif
	return tFile;
}
#endif

char *GetPktLogFileName(HWND hwnd)
{
static	SYSTEMTIME st = {0};
static	char tFile[MAX_PATH+32];

	if (st.wYear == 0)
	{	char temp[64];
		GetSystemTime(&st);
		StringCbPrintfA(temp,sizeof(temp),"%s-%04d%02d%02d-%02d%02d.pkt",
						CALLSIGN,
						(int) st.wYear, (int) st.wMonth, (int) st.wDay,
						(int) st.wHour, (int) st.wMinute);
#ifdef UNDER_CE
		TCHAR *Path = (TCHAR *) malloc(sizeof(*Path)*MAX_PATH);
		if (SHGetSpecialFolderPath(hwnd, Path, CSIDL_PERSONAL, TRUE))
		{	StringCbPrintfA(tFile, sizeof(tFile), "%S/%s", Path, temp);
		} else
#endif
			strncpy(tFile,temp,sizeof(tFile));
#ifdef UNDER_CE
		free(Path);
#endif
	}
	return tFile;
}

char *GetGPXFileName(HWND hwnd, char *StationID, SYSTEMTIME *stStart = NULL)
{	SYSTEMTIME st;
	char temp[64];
static	char tFile[MAX_PATH+32];

	if (!stStart) GetSystemTime(&st);
	else st = *stStart;

	StringCbPrintfA(temp,sizeof(temp),"%s-%04d%02d%02d-%02d%02d.gpx",
					StationID,
					(int) st.wYear, (int) st.wMonth, (int) st.wDay,
					(int) st.wHour, (int) st.wMinute);
#ifdef UNDER_CE
	TCHAR *Path = (TCHAR *) malloc(sizeof(*Path)*MAX_PATH);
	if (SHGetSpecialFolderPath(hwnd, Path, CSIDL_PERSONAL, TRUE))
	{	StringCbPrintfA(tFile, sizeof(tFile), "%S/%s", Path, temp);
	} else
#endif
		strncpy(tFile,temp,sizeof(tFile));
#ifdef UNDER_CE
	free(Path);
#endif
	return tFile;
}

char *GetTrackFileName(HWND hwnd)
{	SYSTEMTIME st;
	char temp[20];
static	char tFile[MAX_PATH+32];

	GetSystemTime(&st);
	StringCbPrintfA(temp,sizeof(temp),"%04d%02d%02d-%02d%02d.csv",
					(int) st.wYear, (int) st.wMonth, (int) st.wDay,
					(int) st.wHour, (int) st.wMinute);
#ifdef UNDER_CE
	TCHAR *Path = (TCHAR *) malloc(sizeof(*Path)*MAX_PATH);
	if (SHGetSpecialFolderPath(hwnd, Path, CSIDL_PERSONAL, TRUE))
	{	StringCbPrintfA(tFile, sizeof(tFile), "%S/%s", Path, temp);
	} else
#endif
		strncpy(tFile,temp,sizeof(tFile));
#ifdef UNDER_CE
	free(Path);
#endif
	return tFile;
}

char *MsgToText(UINT Msg)
{	int i;
static char Buffer[80];
static struct
{	char *Name;
	UINT Msg;
} WindowsMsgs[] = {
{ "WM_NULL",0x0000 },
{ "WM_CREATE",0x0001 },
{ "WM_DESTROY",0x0002 },
{ "WM_MOVE",0x0003 },
{ "WM_SIZE",0x0005 },
{ "WM_ACTIVATE",0x0006 },
{ "WM_SETFOCUS",0x0007 },
{ "WM_KILLFOCUS",0x0008 },
{ "WM_ENABLE",0x000A },
{ "WM_SETREDRAW",0x000B },
{ "WM_SETTEXT",0x000C },
{ "WM_GETTEXT",0x000D },
{ "WM_GETTEXTLENGTH",0x000E },
{ "WM_PAINT",0x000F },
{ "WM_CLOSE",0x0010 },
{ "WM_QUERYENDSESSION",0x0011 },
{ "WM_QUIT",0x0012 },
{ "WM_QUERYOPEN",0x0013 },
{ "WM_ERASEBKGND",0x0014 },
{ "WM_SYSCOLORCHANGE",0x0015 },
{ "WM_ENDSESSION",0x0016 },
{ "WM_SHOWWINDOW",0x0018 },
{ "WM_WININICHANGE",0x001A },
{ "WM_DEVMODECHANGE",0x001B },
{ "WM_ACTIVATEAPP",0x001C },
{ "WM_FONTCHANGE",0x001D },
{ "WM_TIMECHANGE",0x001E },
{ "WM_CANCELMODE",0x001F },
{ "WM_SETCURSOR",0x0020 },
{ "WM_MOUSEACTIVATE",0x0021 },
{ "WM_CHILDACTIVATE",0x0022 },
{ "WM_QUEUESYNC",0x0023 },
{ "WM_GETMINMAXINFO",0x0024 },
{ "WM_PAINTICON",0x0026 },
{ "WM_ICONERASEBKGND",0x0027 },
{ "WM_NEXTDLGCTL",0x0028 },
{ "WM_SPOOLERSTATUS",0x002A },
{ "WM_DRAWITEM",0x002B },
{ "WM_MEASUREITEM",0x002C },
{ "WM_DELETEITEM",0x002D },
{ "WM_VKEYTOITEM",0x002E },
{ "WM_CHARTOITEM",0x002F },
{ "WM_SETFONT",0x0030 },
{ "WM_GETFONT",0x0031 },
{ "WM_SETHOTKEY",0x0032 },
{ "WM_GETHOTKEY",0x0033 },
{ "WM_QUERYDRAGICON",0x0037 },
{ "WM_COMPAREITEM",0x0039 },
{ "WM_COMPACTING",0x0041 },
{ "WM_COMMNOTIFY",0x0044 },
{ "WM_WINDOWPOSCHANGING",0x0046 },
{ "WM_WINDOWPOSCHANGED",0x0047 },
{ "WM_POWER",0x0048 },
{ "WM_COPYDATA",0x004A },
{ "WM_CANCELJOURNAL",0x004B },
{ "WM_NOTIFY",0x004E },
{ "WM_INPUTLANGCHANGEREQUEST",0x0050 },
{ "WM_INPUTLANGCHANGE",0x0051 },
{ "WM_TCARD",0x0052 },
{ "WM_HELP",0x0053 },
{ "WM_USERCHANGED",0x0054 },
{ "WM_NOTIFYFORMAT",0x0055 },
{ "WM_CONTEXTMENU",0x007B },
{ "WM_STYLECHANGING",0x007C },
{ "WM_STYLECHANGED",0x007D },
{ "WM_DISPLAYCHANGE",0x007E },
{ "WM_GETICON",0x007F },
{ "WM_SETICON",0x0080 },
{ "WM_NCCREATE",0x0081 },
{ "WM_NCDESTROY",0x0082 },
{ "WM_NCCALCSIZE",0x0083 },
{ "WM_NCHITTEST",0x0084 },
{ "WM_NCPAINT",0x0085 },
{ "WM_NCACTIVATE",0x0086 },
{ "WM_GETDLGCODE",0x0087 },
{ "WM_NCMOUSEMOVE",0x00A0 },
{ "WM_NCLBUTTONDOWN",0x00A1 },
{ "WM_NCLBUTTONUP",0x00A2 },
{ "WM_NCLBUTTONDBLCLK",0x00A3 },
{ "WM_NCRBUTTONDOWN",0x00A4 },
{ "WM_NCRBUTTONUP",0x00A5 },
{ "WM_NCRBUTTONDBLCLK",0x00A6 },
{ "WM_NCMBUTTONDOWN",0x00A7 },
{ "WM_NCMBUTTONUP",0x00A8 },
{ "WM_NCMBUTTONDBLCLK",0x00A9 },
{ "WM_KEYFIRST",0x0100 },
{ "WM_KEYDOWN",0x0100 },
{ "WM_KEYUP",0x0101 },
{ "WM_CHAR",0x0102 },
{ "WM_DEADCHAR",0x0103 },
{ "WM_SYSKEYDOWN",0x0104 },
{ "WM_SYSKEYUP",0x0105 },
{ "WM_SYSCHAR",0x0106 },
{ "WM_SYSDEADCHAR",0x0107 },
{ "WM_KEYLAST",0x0108 },
{ "WM_IME_STARTCOMPOSITION",0x010D },
{ "WM_IME_ENDCOMPOSITION",0x010E },
{ "WM_IME_COMPOSITION",0x010F },
{ "WM_IME_KEYLAST",0x010F },
{ "WM_INITDIALOG",0x0110 },
{ "WM_COMMAND",0x0111 },
{ "WM_SYSCOMMAND",0x0112 },
{ "WM_TIMER",0x0113 },
{ "WM_HSCROLL",0x0114 },
{ "WM_VSCROLL",0x0115 },
{ "WM_INITMENU",0x0116 },
{ "WM_INITMENUPOPUP",0x0117 },
{ "WM_MENUSELECT",0x011F },
{ "WM_MENUCHAR",0x0120 },
{ "WM_ENTERIDLE",0x0121 },
{ "WM_CTLCOLORMSGBOX",0x0132 },
{ "WM_CTLCOLOREDIT",0x0133 },
{ "WM_CTLCOLORLISTBOX",0x0134 },
{ "WM_CTLCOLORBTN",0x0135 },
{ "WM_CTLCOLORDLG",0x0136 },
{ "WM_CTLCOLORSCROLLBAR",0x0137 },
{ "WM_CTLCOLORSTATIC",0x0138 },
{ "WM_MOUSEFIRST",0x0200 },
{ "WM_MOUSEMOVE",0x0200 },
{ "WM_LBUTTONDOWN",0x0201 },
{ "WM_LBUTTONUP",0x0202 },
{ "WM_LBUTTONDBLCLK",0x0203 },
{ "WM_RBUTTONDOWN",0x0204 },
{ "WM_RBUTTONUP",0x0205 },
{ "WM_RBUTTONDBLCLK",0x0206 },
{ "WM_MBUTTONDOWN",0x0207 },
{ "WM_MBUTTONUP",0x0208 },
{ "WM_MBUTTONDBLCLK",0x0209 },
{ "WM_MOUSEWHEEL",0x020A },
{ "WM_MOUSELAST",0x0209 },
{ "WM_MOUSELAST",0x020A },
{ "WM_PARENTNOTIFY",0x0210 },
{ "WM_ENTERMENULOOP",0x0211 },
{ "WM_EXITMENULOOP",0x0212 },
{ "WM_NEXTMENU",0x0213 },
{ "WM_SIZING",0x0214 },
{ "WM_CAPTURECHANGED",0x0215 },
{ "WM_MOVING",0x0216 },
{ "WM_POWERBROADCAST",0x0218 },
{ "WM_DEVICECHANGE",0x0219 },
{ "WM_IME_SETCONTEXT",0x0281 },
{ "WM_IME_NOTIFY",0x0282 },
{ "WM_IME_CONTROL",0x0283 },
{ "WM_IME_COMPOSITIONFULL",0x0284 },
{ "WM_IME_SELECT",0x0285 },
{ "WM_IME_CHAR",0x0286 },
{ "WM_IME_KEYDOWN",0x0290 },
{ "WM_IME_KEYUP",0x0291 },
{ "WM_MDICREATE",0x0220 },
{ "WM_MDIDESTROY",0x0221 },
{ "WM_MDIACTIVATE",0x0222 },
{ "WM_MDIRESTORE",0x0223 },
{ "WM_MDINEXT",0x0224 },
{ "WM_MDIMAXIMIZE",0x0225 },
{ "WM_MDITILE",0x0226 },
{ "WM_MDICASCADE",0x0227 },
{ "WM_MDIICONARRANGE",0x0228 },
{ "WM_MDIGETACTIVE",0x0229 },
{ "WM_MDISETMENU",0x0230 },
{ "WM_ENTERSIZEMOVE",0x0231 },
{ "WM_EXITSIZEMOVE",0x0232 },
{ "WM_DROPFILES",0x0233 },
{ "WM_MDIREFRESHMENU",0x0234 },
{ "WM_MOUSEHOVER",0x02A1 },
{ "WM_MOUSELEAVE",0x02A3 },
{ "WM_CUT",0x0300 },
{ "WM_COPY",0x0301 },
{ "WM_PASTE",0x0302 },
{ "WM_CLEAR",0x0303 },
{ "WM_UNDO",0x0304 },
{ "WM_RENDERFORMAT",0x0305 },
{ "WM_RENDERALLFORMATS",0x0306 },
{ "WM_DESTROYCLIPBOARD",0x0307 },
{ "WM_DRAWCLIPBOARD",0x0308 },
{ "WM_PAINTCLIPBOARD",0x0309 },
{ "WM_VSCROLLCLIPBOARD",0x030A },
{ "WM_SIZECLIPBOARD",0x030B },
{ "WM_ASKCBFORMATNAME",0x030C },
{ "WM_CHANGECBCHAIN",0x030D },
{ "WM_HSCROLLCLIPBOARD",0x030E },
{ "WM_QUERYNEWPALETTE",0x030F },
{ "WM_PALETTEISCHANGING",0x0310 },
{ "WM_PALETTECHANGED",0x0311 },
{ "WM_HOTKEY",0x0312 },
{ "WM_PRINT",0x0317 },
{ "WM_PRINTCLIENT",0x0318 },
{ "WM_HANDHELDFIRST",0x0358 },
{ "WM_HANDHELDLAST",0x035F },
{ "WM_AFXFIRST",0x0360 },
{ "WM_AFXLAST",0x037F },
{ "WM_PENWINFIRST",0x0380 },
{ "WM_PENWINLAST",0x038F },
{ "WM_APP",0x8000 },

#ifdef UNDER_CE
#ifdef USING_COMM_MGR
{ "WM_CONNMGR_NOTIFICATION",WM_CONNMGR_NOTIFICATION },
#endif
{ "WM_POWER_CHANGE",WM_POWER_CHANGE },
#endif
{ "WM_TILES_LOADED",WM_TILES_LOADED },
{ "WM_REMEMBER_MESSAGE",WM_REMEMBER_MESSAGE },
{ "WM_PORT_STATUS",WM_PORT_STATUS },
{ "WM_PORT_SUB_STATUS",WM_PORT_SUB_STATUS },
{ "WM_PORT_RECEIVED",WM_PORT_RECEIVED },
{ "WM_PORT_XMIT_COUNT",WM_PORT_XMIT_COUNT },
{ "WM_MSG_NOTIFICATION",WM_MSG_NOTIFICATION },
{ "WM_BULL_NOTIFICATION",WM_BULL_NOTIFICATION },
{ "WM_NOTIFY_SIGNAL_STRENGTH",WM_NOTIFY_SIGNAL_STRENGTH },
{ "WM_NOTIFY_OPERATOR_NAME",WM_NOTIFY_OPERATOR_NAME },
{ "WM_NOTIFY_CELL_BROADCAST",WM_NOTIFY_CELL_BROADCAST },
{ "WM_ASYNC_MSG_BOX",WM_ASYNC_MSG_BOX },
{ "WM_FIX_SEND_BUTTON",WM_FIX_SEND_BUTTON },
{ "WM_FIX_CHAT_BUTTONS",WM_FIX_CHAT_BUTTONS },
{ "WM_REFRESH_CHAT",WM_REFRESH_CHAT },
{ "WM_AUTO_ZOOM",WM_AUTO_ZOOM },
{ "WM_CENTER_STATION",WM_CENTER_STATION },
{ "WM_FINISH_STARTUP",WM_FINISH_STARTUP },
{ "WM_ADD_FRIEND",WM_ADD_FRIEND },
{ "WM_REFRESH_CIRCLE",WM_REFRESH_CIRCLE },
{ "WM_SET_CONTROLS",WM_SET_CONTROLS },

{ "WM_USER",0x0400 } };

	for (i=0; i<(sizeof(WindowsMsgs)/sizeof(WindowsMsgs[0])); i++)
	{	if (WindowsMsgs[i].Msg == Msg) return WindowsMsgs[i].Name;
	}
	sprintf(Buffer,"0x%lX",(long)Msg);
	return Buffer;
}

extern HWND hwndLocks;

static char *WindowName(HWND hwnd)
{	char *hwndName = "Unknown";

	if (!hwnd) hwndName = "NULL";
	else if (hwnd == hwndMain) hwndName = "Main";
	else
	{	char *TraceName = GetTraceWindowName(hwnd);
		if (TraceName) hwndName = TraceName;
	}
	return hwndName;
}

typedef struct REMEMBER_MESSAGE_S
{	char *From;
	char *To;
	char *Message;
	MESSAGE_TYPE_V Type;
} REMEMBER_MESSAGE_S;

BOOL QueueRememberMessage(char *From, char *To, char *Buffer, MESSAGE_TYPE_V Type)
{	TraceLogThread("Activity", hwndMain==NULL, "QueueRememberMessage:%s\n", Buffer);
	if (hwndMain)
	{	REMEMBER_MESSAGE_S *rm = (REMEMBER_MESSAGE_S *)malloc(sizeof(*rm));
		rm->From = _strdup(From);
		rm->To = _strdup(To);
		rm->Message = _strdup(Buffer);
		rm->Type = Type;
		PostMessage(hwndMain, WM_REMEMBER_MESSAGE, 0, (LPARAM) rm);
	}
	return TRUE;
}

BOOL QueueInternalMessage(char *Buffer, BOOL FreeIt)
{	TraceLogThread("Activity", hwndMain==NULL, "QueueInternalMessage:%s\n", Buffer);
	QueueRememberMessage(PROGCALL, CALLSIGN, Buffer, MESSAGE_INTERNAL);
	if (FreeIt) free(Buffer);
	return TRUE;
}


#ifdef UNDER_CE
DWORD SendDebugThread(LPVOID pvParam)
#else
DWORD WINAPI SendDebugThread(LPVOID pvParam)
#endif
{	char *Message = (char *)pvParam;

	SetTraceThreadName("SendDebug");
	if (ActiveConfig.Enables.Internet)
	{	char Buffer[256];
		SYSTEMTIME stUTCTime;
		GetSystemTime(&stUTCTime);
		StringCbPrintfA(Buffer, sizeof(Buffer),
						"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld DEBUG:%s:%s",
						(long) stUTCTime.wYear, 
						(long) stUTCTime.wMonth, 
						(long) stUTCTime.wDay, 
						(long) stUTCTime.wHour, 
						(long) stUTCTime.wMinute, 
						(long) stUTCTime.wSecond,
						CALLSIGN, Message);
		size_t Len = strlen(Buffer);
		TraceActivity(NULL, "Sending DEBUG->%s\n", Buffer);
		tcp_send_udp("aprsisce.dnsalias.net", 6369, Len+1, Buffer, 1);
	}
	free(Message);
	return 1;
}
static BOOL QueueToDebug(char *Buffer)
{
	if (!ActiveConfig.Enables.Internet) return FALSE;
	CloseHandle(CreateThread(NULL, 0, SendDebugThread, _strdup(Buffer), 0, NULL));
	return TRUE;
}


BOOL QueueDebugMessage(__int64 Now, char *Buffer)
{
static long cLast = 0;
static __int64 msFirst = 0;

	if (hwndMain && ActiveConfig.Update.Development)	/* Only development debugs */
	{
		if (llMsecSince(msFirst, Now) >= 60000)	/* Reset every minute */
		{	msFirst = 0;
		}
		if (!msFirst)
		{	msFirst = Now; cLast = 0;
		}
		if (cLast++ < 15)	/* Max of 15 in any single minute */
		{static BOOL First = TRUE;
			if (First)
			{static	char Buffer2[256];
				SYSTEMTIME st;
				OSVERSIONINFO osvi = {0};
				osvi.dwOSVersionInfoSize = sizeof(osvi);
				First = FALSE;
				GetSystemTime(&st);
				if (GetVersionEx(&osvi))
					//StringCbPrintfA(Buffer2,sizeof(Buffer2), "%s>DEBUG::%-9s:%02ld:%02ld:%02ld Running %s on Win v%ld.%ld b%ld p%ld",
					//	CALLSIGN, "KJ4ERJ-DB",
					//	(long) st.wHour, (long) st.wMinute, (long) st.wSecond,
					StringCbPrintfA(Buffer2,sizeof(Buffer2), "Running %s on Win v%ld.%ld b%ld p%ld",
						VERSION,
						(long) osvi.dwMajorVersion,
						(long) osvi.dwMinorVersion,
						(long) osvi.dwBuildNumber,
						(long) osvi.dwPlatformId);
				else 
					//StringCbPrintfA(Buffer2,sizeof(Buffer2),"%s>DEBUG::%-9s:%02ld:%02ld:%02ld Running %s",
					//	CALLSIGN, "KJ4ERJ-DB",
					//	(long) st.wHour, (long) st.wMinute, (long) st.wSecond,
					StringCbPrintfA(Buffer2,sizeof(Buffer2),"Running %s",
						VERSION);
				//QueueToTransmit(MESSAGE_PACKET, Buffer2, FALSE, TRUE);
				QueueToDebug(Buffer2);
			}
			//return QueueToTransmit(MESSAGE_PACKET, Buffer, FALSE, TRUE);
			return QueueToDebug(Buffer);
		} else TraceError(NULL, "TOO MANY(%ld), Suppressing %s\n", (long) cLast, Buffer);
	}
	return FALSE;
}

static void MessageTimer(char *Routine, __int64 Start, __int64 *pMax, __int64 *pLast, HWND hwnd, UINT msg, WPARAM wp, LPARAM lp, long msTrigger=MESSAGE_TRIGGER)
{	__int64 Now = llGetMsec();

	if (*pMax > 1000 && llMsecSince(*pLast, Now) >= 60000)	/* Reset every 60 seconds */
	{	//TraceError(hwnd, "Resetting %s Max of %.0lfmsec\n", Routine, (double) *pMax);
		*pMax = 1000;	/* But don't do EVERY one! */
	}

	Start = llMsecSince(Start,Now);
	if (Start > *pMax)
	{	char *hwndName = WindowName(hwnd);

		TraceLog("Timer", Start>100, hwnd, "hwnd%s:%s(%p %s %08lX %08lX) took %.1lfsec (previous %.1lfsec)\n",
					hwndName, Routine,
					hwnd, MsgToText(msg),
					(long) wp, (long) lp,
					(double) Start/1000.0, (double) *pMax/1000.0);

		if (hwndMain && Start > msTrigger && Start < 300000
		//&& !strncmp(CALLSIGN,"KJ4",3)
		&& (msg != WM_PAINT || hwnd != hwndMain)	/* Main Paint gets detailed */
		&& msg != WM_COMMAND		/* Manu popups result from menu options */
		&& msg != WM_MSG_NOTIFICATION	/* Message popups result from notifications */
		&& msg != WM_ASYNC_MSG_BOX	/* This is a message popup */
		&& msg != WM_HOTKEY			/* Manu popups result from menu options */
		&& msg != WM_CLOSE			/* Close takes a while and we don't care */
		&& msg != WM_LBUTTONDBLCLK	/* Left double-click brings up message dialog */
		&& msg != WM_LBUTTONUP		/* A Left button dialog does this */
		&& msg != WM_RBUTTONUP		/* Possibly a RMB popup menu */
		&& msg != WM_CONTEXTMENU	/* Possibly a RMB popup menu */
#ifdef UNDER_CE
		&& msg != WM_LBUTTONDOWN	/* CE does it on Down? */
#else
		&& msg != WM_NCLBUTTONDOWN	/* Frame mouse messages take a long time */
#endif
		)
		{	SYSTEMTIME st;
		static char Buffer[256];
			GetSystemTime(&st);
			sprintf(Buffer,"%s:hwnd%s:%s(%p %s %08lX %08lX) took %.1lfsec",
#ifdef UNDER_CE
					"CE",
#else
					"32",
#endif
					hwndName, Routine,
					hwnd, MsgToText(msg),
					(long) wp, (long) lp,
					(double) Start/1000.0);
#ifdef DEBUG_TIMINGS
			QueueDebugMessage(Now, Buffer);
#endif
		}
		*pMax = Start;
		*pLast = Now;	/* Reset N seconds after last increase */
	}
}

__int64 DebugTimer(char *Routine, char *Text, __int64 Start, __int64 *pMax, __int64 *pLast, HWND hwnd, long msTrigger=DEBUG_TRIGGER)
{	__int64 Now = llGetMsec();

	if (pLast && *pMax > 1000 && llMsecSince(*pLast, Now) >= 60000)	/* Reset every 60 seconds */
	{	//TraceError(hwnd, "Resetting %s Max of %.0lfmsec\n", Routine, (double) *pMax);
		*pMax = 1000;	/* But don't do EVERY one! */
	}

	Start = llMsecSince(Start,Now);
	if (Start > *pMax)
	{	char *hwndName = WindowName(hwnd);

		TraceLog("Timer", Start>100, hwnd, "hwnd%s:%s(%s) took %.1lfsec (previous %.1lfsec)\n",
					hwndName, Routine, Text,
					(double) Start/1000.0, (double) *pMax/1000.0);

		if (hwndMain && Start > msTrigger && Start < 300000
		// && !strncmp(CALLSIGN,"KJ4",3)
		)
		{	SYSTEMTIME st;
		static char Buffer[256];
			GetSystemTime(&st);
			sprintf(Buffer,"%s:hwnd%s:%s(%s) took %.1lfsec",
#ifdef UNDER_CE
					"CE",
#else
					"32",
#endif
					hwndName, Routine, Text,
					(double) Start/1000.0);
#ifdef DEBUG_TIMINGS
			QueueDebugMessage(Now, Buffer);
#endif
		}
		*pMax = Start;
		if (pLast) *pLast = Now;	/* Reset N seconds after last increase */
	}
	return Now;
}

cdecl __int64 cDebugTimer(char *Routine, char *Text, __int64 Start, __int64 *pMax, __int64 *pLast, HWND hwnd, long msTrigger)
{	return DebugTimer(Routine, Text, Start, pMax, pLast, hwnd, msTrigger);
}

void UpdateCallsign(HWND hwnd)
{	TCHAR *szTitle = (TCHAR *)malloc(128);

#ifdef UNDER_CE
	StringCbPrintf(szTitle, sizeof(*szTitle)*128, TEXT("%S"), ActiveConfig.CallSign);
#else
	StringCbPrintf(szTitle, sizeof(*szTitle)*128, TEXT("%S - %S"), PROGNAME, ActiveConfig.CallSign);
#endif
	SetWindowText(hwnd, szTitle);
	free(szTitle);

	TraceLogUpdateCallsign();

	TraceLog("Activity", TRUE, NULL, "Refreshing %ld Stations isMine Status for %s\n", CloseStationCount, CALLSIGN);
	for (unsigned long s=0; s<CloseStationCount; s++)
	{	pCloseStations[s]->isMine = IsSameBaseCallsign(pCloseStations[s]->Station, CALLSIGN);
		if (pCloseStations[s]->Station[0] == 'Q'
		&& pCloseStations[s]->Station[1] == 'R'
		&& pCloseStations[s]->Station[2] == 'U'
		&& !pCloseStations[s]->isMine
		&& IsSameBaseCallsign(&pCloseStations[s]->Station[3], CALLSIGN))
			pCloseStations[s]->isMine = TRUE;
	}
}

#ifdef SUPPORT_RFID
typedef struct RFID_CALL_S
{	unsigned char x;
	char ID[COMMENT_SIZE];
	char Call[STATION_SIZE];
	char Comment[COMMENT_SIZE];
	SYSTEMTIME st;
} RFID_CALL_S;

char RFIDLoaded[256] = {0};
unsigned long RFIDTypeCount = 0;
unsigned long RFIDMoves = 0;
unsigned long RFIDCount = 0;
unsigned long RFIDSize = 0;
RFID_CALL_S *RFIDs = NULL;

void RFIDSaveIDCalls(unsigned char x)
{	FILE *Out;
	char FileName[80];
	unsigned int i, First = TRUE;

	x = toupper(x);
	sprintf(FileName,"RFI%cs.csv", x?x:'D');
	Out = fopen(FileName,"wt");
	for (i=0; i<RFIDCount; i++)
	if (RFIDs[i].x == x)
	{	if (First) fprintf(Out,"ID,CallSign,Referenced,Comment\n");
		First = FALSE;
		fprintf(Out,"%.*s,%.*s,%4ld-%02ld-%02ldT%02ld:%02ld:%02ld,%.*s\n",
				STRING(RFIDs[i].ID), STRING(RFIDs[i].Call),
				(long) RFIDs[i].st.wYear, (long) RFIDs[i].st.wMonth, (long) RFIDs[i].st.wDay,
				(long) RFIDs[i].st.wHour, (long) RFIDs[i].st.wMinute, (long) RFIDs[i].st.wSecond,
				STRING(RFIDs[i].Comment));
	}
	fclose(Out);
}

static int RFIDFromHex(char *Hex, int Len, BOOL *pValid=NULL)
{
static	char HexChar[] = "0123456789ABCDEF";
	int Result = 0;
	int i;

	for (i=0; i<Len; i++)
	{	char *x = strchr(HexChar,toupper(Hex[i]));
		if (!x)
		{	if (pValid) *pValid = FALSE;
			return 0;
		}
		Result = Result*16 + (x-HexChar);
	}
	if (pValid) *pValid = TRUE;
	return Result;
}

static WORD RFIDFromDecimal(char *Digits, int Len, BOOL *pValid=NULL)
{
	WORD Result = 0;
	int i;

	for (i=0; i<Len; i++)
	{	if (!isdigit(Digits[i]&0xff))
		{	if (pValid) *pValid = FALSE;
			return 0;
		}
		Result = Result*10 + (Digits[i]-'0');
	}
	if (pValid) *pValid = TRUE;
	return Result;
}

char *RFIDFillOutID(char x, char *ID)
{
	TraceLog("RFID", TRUE, NULL, "RFID:FillOut(%s) via (%c)\n", ID, x);
	switch (toupper(x))
	{
	case 'D':	/* Original SparkFun RFID Reader, 10 hex digits + 2 hex checksum */
	{	char *Result;
		BOOL Valid;
		int Sum = 0, i;
		if (strlen(ID) != 10) return NULL;
		for (i=0; i<10; i+=2)
			Sum ^= RFIDFromHex(&ID[i],2,&Valid);
		if (!Valid) return NULL;
		TraceLog("RFID", TRUE, NULL, "RFID:Sum(%s) is %ld or 0x%lX or %02lX\n", ID, (long) Sum, (long) Sum, (long) (Sum&0xff));
		Result = (char*)malloc(13);
		StringCbPrintfA(Result, 13, "%s%02lX", ID, (long) Sum);
		return Result;
	}
	}
	TraceLog("RFID", TRUE, NULL, "RFID:No FillOut(%c) for (%s) Assuming Unity\n", x, ID);
	return _strdup(ID);
}

int RFIDValidateID(char x, char *ID)	/* Returns length of validated ID or 0 if bad */
{
	TraceLog("RFID", TRUE, NULL, "RFID:Validate(%s) via (%c)\n", ID, x);
	switch (toupper(x))
	{
	case 'D':	/* Original SparkFun RFID Reader, 10 hex digits + 2 hex checksum */
	{	int Sum = 0, i;
		BOOL Valid;
		if (strlen(ID) < 12) return FALSE;
		for (i=0; i<12; i+=2)
			Sum ^= RFIDFromHex(&ID[i],2,&Valid);
		if (!Valid) return FALSE;
		TraceLog("RFID", TRUE, NULL, "RFID:Sum(%s) is %ld or 0x%lX or %02lX\n", ID, (long) Sum, (long) Sum, (long) (Sum&0xff));
		return (Sum == 0)?12:0;
	}
	}
	TraceLog("RFID", TRUE, NULL, "RFID:No Validator(%c) for (%s) Assuming good\n", x, ID);
	return strlen(ID);
}

void RFIDLoadIDCalls(char x);

unsigned int RFIDSetIDCall(char x, char *ID, char *Call, char *Comment, BOOL SaveIt = TRUE)
{	unsigned int i;
	int lenID;

	x = toupper(x);
	lenID = RFIDValidateID(x, ID);
	if (!lenID) return -1;

	if (!RFIDLoaded[x]) RFIDLoadIDCalls(x);

	for (i=0; i<RFIDCount; i++)
	{	if (RFIDs[i].x == x && !strncmp(RFIDs[i].ID, ID, min(lenID,sizeof(RFIDs[i].ID))))
		{	break;
		}
	}
	if (i >= RFIDCount)
	{	i = RFIDCount++;
		if (RFIDCount > RFIDSize)
		{	unsigned int j;
			RFIDSize += 32;
			RFIDs = (RFID_CALL_S *) realloc(RFIDs, sizeof(*RFIDs)*RFIDSize);
			for (j=i; j<RFIDSize; j++)
				memset(&RFIDs[j], 0, sizeof(RFIDs[j]));
		}
		RFIDs[i].x = x;
		strncpy(RFIDs[i].ID, ID, min(lenID,sizeof(RFIDs[i].ID)));
		TraceLog("RFID", TRUE, NULL, "RFID:New ID(%s)\n", ID);
	}
	if (strncmp(RFIDs[i].Call, Call, sizeof(RFIDs[i].Call)))
	{	TraceLog("RFID", TRUE, NULL, "RFID[%c]:Defining ID(%s) Call(%s)\n", x, ID, Call);
		strncpy(RFIDs[i].Call, Call, sizeof(RFIDs[i].Call));
	} else
	{	TraceLog("RFID", TRUE, NULL, "RFID[%c]:Referencing ID(%s) Call(%s)\n", x, ID, Call);
	}
	if (Comment)
	{	if (strrchr(Comment,'{')) *strrchr(Comment,'{') = '\0';	/* Remove ack flag */
		strncpy(RFIDs[i].Comment, Comment, sizeof(RFIDs[i].Comment));
	}
	if (SaveIt)
	{	GetSystemTime(&RFIDs[i].st);
		RFIDSaveIDCalls(x);
	}
	return i;
}

void RFIDLoadIDCalls(char x)
{	FILE *In;
	char FileName[80];
	char *InBuf;

	x = toupper(x);
	if (RFIDLoaded[x]) return;
	RFIDLoaded[x] = TRUE;
	RFIDTypeCount++;

	sprintf(FileName,"RFI%cs.csv", x?x:'D');

	In = fopen(FileName,"rt");
	if (!In)
	{	TraceLog("RFID", TRUE, NULL, "Failed To Open %s\n", FileName);
		return;	/* No file there yet */
	}

	InBuf = (char*)malloc(1024);
	while (fgets(InBuf, 1024, In))
	{	char *p, *eol, *Commas[20];	/* Hopefully not more than 20! */
		int CommaCount=0;

		eol = InBuf+strlen(InBuf)-1;
		while (eol >= InBuf && (*eol=='\n' || *eol=='\r'))
			*eol-- = '\0';

		TraceLog("RFID", TRUE, NULL, "Loading:%s\n", InBuf);

		Commas[CommaCount++] = InBuf;
		for (p=InBuf; p<eol; p++)
		{	if (*p == ',')
			{	if (CommaCount < ARRAYSIZE(Commas))
					Commas[CommaCount++] = p+1;
				*p = '\0';	/* Null terminate previous string */
			}
		}
		if (CommaCount == 2 || CommaCount == 3 || CommaCount == 4)
		{	int i = RFIDSetIDCall(x, Commas[0], Commas[1], CommaCount==4?Commas[3]:NULL, FALSE);
			if (i != -1 && (CommaCount == 3 || CommaCount == 4))
			{	char *e;
				SYSTEMTIME st = {0};
				st.wYear = (WORD) strtol(Commas[2],&e,10);
				if (*e=='-')
				{	st.wMonth = (WORD) strtol(e+1,&e,10);
					if (*e=='-')
					{	st.wDay = (WORD) strtol(e+1,&e,10);
						if (*e=='T' || *e==' ')
						{	st.wHour = (WORD) strtol(e+1,&e,10);
							if (*e==':')
							{	st.wMinute = (WORD) strtol(e+1,&e,10);
								if (*e==':')
								{	st.wSecond = (WORD) strtol(e+1,&e,10);
									if (!*e || *e==',')
									{	RFIDs[i].st = st;
									}
								}
							}
						}
					}
				}
			}
		} else TraceLog("RFID", TRUE, NULL, "Commas(%ld) != 2, 3, or 4\n", (long) CommaCount);
	}
	fclose(In);
	free(InBuf);
}

char *RFIDGetIDCall(char x, char *ID, char **pComment)
{	unsigned int i;
	char *Calls = (char*)malloc(1);
	*Calls = '\0';

	x = toupper(x);
	if (!RFIDLoaded[x]) RFIDLoadIDCalls(x);

	if (*pComment) *pComment = "";

	for (i=0; i<RFIDCount; i++)
	{	if (RFIDs[i].x == x
		&& !strncmp(RFIDs[i].ID, ID, sizeof(RFIDs[i].ID)))
		{	Calls = (char *) realloc(Calls, strlen(Calls)+RtStrnlen(STRING(RFIDs[i].Call))+2);
			if (*Calls) strcat(Calls," ");
			strncat(Calls, RFIDs[i].Call, sizeof(RFIDs[i].Call));
			if (pComment) *pComment = &RFIDs[i].Comment[0];
		}
	}
	TraceLog("RFID", TRUE, NULL, "RFID:GetIDCall(%s)=%s\n", ID, Calls);
	if (*Calls) return Calls;
	free(Calls);	/* None found */
	return NULL;
}

char *RFIDGetCallIDs(unsigned char x, char *Call)
{	unsigned int i;
	char *IDs = (char*)malloc(1);
	*IDs = '\0';

	x = toupper(x);
	if (!RFIDLoaded[x]) RFIDLoadIDCalls(x);

	for (i=0; i<RFIDCount; i++)
	{	if (RFIDs[i].x == x
		&& !strncmp(RFIDs[i].Call, Call, sizeof(RFIDs[i].Call)))
		{	IDs = (char *) realloc(IDs, strlen(IDs)+RtStrnlen(STRING(RFIDs[i].ID))+2);
			if (*IDs) strcat(IDs," ");
			strncat(IDs, RFIDs[i].ID, sizeof(RFIDs[i].ID));
		}
	}
	TraceLog("RFID", TRUE, NULL, "RFID:GetCallIDs(%s)=%s\n", Call, IDs);
	if (*IDs) return IDs;
	free(IDs);	/* None found */
	return NULL;
}

STATION_INFO_S *RFIDFindReader(char *Call)
{	unsigned int r, rRecent = -1;
	__int64 msRecent;
	int HA = SymbolInt('H', 'A');

TraceLog("RFID", TRUE, NULL,"RFID:FindReader(%s)\n", Call);
	for (r=0; r<CloseStationCount; r++)
	{	if (!strncmp(Call, pCloseStations[r]->Owner, sizeof(pCloseStations[r]->Owner)))
		{	if (pCloseStations[r]->isymbol==HA)
			{	if (rRecent == -1
				|| pCloseStations[r]->Last.msec > msRecent)
				{	rRecent = r;
					msRecent = pCloseStations[r]->Last.msec;
TraceLog("RFID", TRUE, NULL,"RFID:FindReader Maybe[%ld](%s) Since %.0lf\n", (long) r, pCloseStations[r]->Station, (double) msRecent);
				}
			}
else TraceLog("RFID", TRUE, NULL,"RFID:FindReader Not[%ld](%s) Sym 0x%lX != HA[0x%lX]\n",
				(long) r, pCloseStations[r]->Station, (long) pCloseStations[r]->isymbol, (long) HA);
		}
	}
	if (rRecent == -1)
	{	STATION_INFO_S *Stat = FindStationCall(Call);
TraceLog("RFID", TRUE, NULL,"RFID:FindReader(%s) HA Object Not Found Using(%s)\n",
		 Call, Stat?Stat->Station:"*NOTHING*");
		return Stat;
	}
else TraceLog("RFID", TRUE, NULL,"RFID:FindReader(%s) Found[%ld](%s)\n",
				Call, (long) rRecent, pCloseStations[rRecent]->Station);
	return pCloseStations[rRecent];
}
#endif

#define NOTIFY_CLIENT_USAGE
#ifdef NOTIFY_CLIENT_USAGE
#ifdef UNDER_CE
DWORD NotifyUsageThread(LPVOID pvParam)
#else
DWORD WINAPI NotifyUsageThread(LPVOID pvParam)
#endif
{	BOOL *pRunning = (BOOL *)pvParam;

	SetTraceThreadName("NotifyUsage");

	if (ActiveConfig.Enables.Internet)
	{	char Buffer[256];
		SYSTEMTIME stUTCTime;
		GetSystemTime(&stUTCTime);
		int Len = sprintf(Buffer,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld %s@%.5lf,%.5lf (%s %s)",
							(long) stUTCTime.wYear, 
							(long) stUTCTime.wMonth, 
							(long) stUTCTime.wDay, 
							(long) stUTCTime.wHour, 
							(long) stUTCTime.wMinute, 
							(long) stUTCTime.wSecond,
							CALLSIGN,
							(double) BeaconEnabled?LastGoodPosition.dblLatitude:0.0,
							(double) BeaconEnabled?LastGoodPosition.dblLongitude:0.0,
							PROGNAME, VERSION);
		TraceActivity(NULL, "Sending Usage(APRSISCE)->%s\n", Buffer);
		if (tcp_send_udp("aprsisce.dnsalias.net", 6369, Len+1, Buffer, 1))
			NextNotification = llGetMsec() + NOTIFICATION_INTERVAL;
	}
	*pRunning = FALSE;
	return 1;
}
#endif

void CheckNotifyUsage(void)
{
#ifdef NOTIFY_CLIENT_USAGE
static BOOL NotifyRunning = FALSE;

//#ifdef UNDER_CE
	if (ActiveConfig.Enables.Internet && llGetMsec() >= NextNotification && !NotifyRunning)
	{	NotifyRunning = TRUE;
		CloseHandle(CreateThread(NULL, 0, NotifyUsageThread, &NotifyRunning, 0, NULL));
	}
#endif
}

static void PurgeDXList(PORT_PACKET_COUNT_S *pPort = NULL)
{
	if (ActiveConfig.DX.Window)
	{	if (!pPort)
		{	for (unsigned long ppc=0; ppc<PortPacketCount; ppc++)
			if (PortPackets[ppc].DXCount)
				PurgeDXList(&PortPackets[ppc]);
		} else
		{	while (pPort->DXCount
			&& SecondsSince(&pPort->DXList[0].st) > ActiveConfig.DX.Window*60+30)
			{
				TraceLogThread("DX", TRUE,
							"Removing %02ld-%02ld %02ld:%02ld:%02ld %.2lf%s @ %ld %s",
							(long) pPort->DXList[0].st.wMonth,
							(long) pPort->DXList[0].st.wDay,
							(long) pPort->DXList[0].st.wHour,
							(long) pPort->DXList[0].st.wMinute,
							(long) pPort->DXList[0].st.wSecond,
							(double) (pPort->DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
							ActiveConfig.View.Metric.Distance?"km":"mi",
							(long) pPort->DXList[0].Bearing,
							pPort->DXList[0].Station);
				if (--pPort->DXCount)
					memmove(&pPort->DXList[0],
							&pPort->DXList[1],
							sizeof(*pPort->DXList)*pPort->DXCount);
			}
		}
	}
}

static unsigned long GetPortPacketIndex(WPARAM wp, char *Name)
{	unsigned long ppc;
	for (ppc=0; ppc<PortPacketCount; ppc++)
	{	if (PortPackets[ppc].wpPort == wp+1)
			return ppc;
	}

	if (wp >= 0 && wp < ActiveConfig.RFPorts.Count)	/* "REAL" ports come first */
		ppc = wp;
	else ppc = max(PortPacketCount,ActiveConfig.RFPorts.Count);	/* Others come later */

	PortPacketCount = ppc+1;
	if (PortPacketCount > PortPacketSize)
	{	unsigned long OrgSize = PortPacketSize;
		PortPacketSize += 16;
		TraceLogThread("PortPackets", TRUE, "Growing PortPackets from %ld to %ld - Increment\n", OrgSize, PortPacketSize);
		PortPackets = (PORT_PACKET_COUNT_S *) realloc(PortPackets, sizeof(*PortPackets)*PortPacketSize);
		memset(&PortPackets[OrgSize],0,sizeof(*PortPackets)*(PortPacketSize-OrgSize));
	}

	if (PortPackets[ppc].wpPort != wp+1)
	{	if (!Name)	/* Try to patch in the name */
		{	if (wp == APRSISWP) Name = "APRS-IS";
			else if (wp == RFPORT_INTERNAL) Name = "*Internal*";
			else TraceLogThread("PortPackets", TRUE, "Failed to delve NULL name for wp=%ld (Ports 0-%ld)\n", (long) wp, (long) ActiveConfig.RFPorts.Count);
		}
		TraceLogThread("PortPackets", TRUE, "%sInitializing PortPackets[%ld/%ld] for RfPort:%ld - Increment was %ld for %s\n",
				PortPackets[ppc].wpPort?"Re-":"", ppc, PortPacketCount, wp, PortPackets[ppc].wpPort, Name?Name:"*Unknown*");
		memset(&PortPackets[ppc], 0, sizeof(PortPackets[ppc]));
		PortPackets[ppc].wpPort = wp+1;
		PortPackets[ppc].Name = _strdup(Name?Name:"*Unknown*");
	}
	return ppc;
}

static void IncrementXmitPackets(WPARAM wp, long Count, char *Name)
{	PortPackets[GetPortPacketIndex(wp,Name)].XmtPackets[0] += Count;
}

#define USE_PORT_STATUS
#ifdef USE_PORT_STATUS

typedef struct PORT_STATUS_S
{	WPARAM wp;
	char *Name;
	int DisplayFlag;
	BOOL WasOK;
	TCHAR *Status;
	SYSTEMTIME st;
	TCHAR *SubStatus;
} PORT_STATUS_S;
static PORT_STATUS_S *PortStatuses = NULL;
static int PortStatusCount = 0;
static int PortStatusIndex = 0;
static int PortStatusSecond = 0;
static int OKPortCount = 0;

static int PortStatusCompare(const void *One, const void *Two)
{	PORT_STATUS_S *Left = (PORT_STATUS_S *) One;
	PORT_STATUS_S *Right = (PORT_STATUS_S *) Two;
	return strcmp(Left->Name, Right->Name);
}

static void SetPortStatus(HWND hwnd, WPARAM wp, char *Name, char *Status)
{	int p, DisplayFlag = HIWORD(wp);
	int l = strlen(Name)+1+strlen(Status)+1;

	wp = LOWORD(wp);

	for (p=0; p<PortStatusCount; p++)
	{	if (PortStatuses[p].wp == wp)
			break;
	}
	if (p>=PortStatusCount)
	{	p = PortStatusCount++;
		PortStatuses = (PORT_STATUS_S *)realloc(PortStatuses,sizeof(*PortStatuses)*PortStatusCount);
		memset(&PortStatuses[p], 0, sizeof(PortStatuses[p]));
		PortStatuses[p].wp = wp;
		PortStatuses[p].Name = _strdup(Name);
		qsort(PortStatuses, PortStatusCount, sizeof(*PortStatuses), PortStatusCompare);
		for (p=0; p<PortStatusCount; p++)
		{	if (PortStatuses[p].wp == wp)
				break;
		}
		if (p>=PortStatusCount)
		{	TraceError(hwnd, "qSort LOST [%ld] %s %s\n", (long) wp, Name, Status);
			p = 0;
		}
	} else if (PortStatuses[p].WasOK) OKPortCount--;

	if ((PortStatuses[p].WasOK = !_strnicmp(Status, "OK", 2)))
		OKPortCount++;

	GetLocalTime(&PortStatuses[p].st);
	if (PortStatuses[p].Status) free(PortStatuses[p].Status);
	PortStatuses[p].DisplayFlag = DisplayFlag;
	PortStatuses[p].Status = (TCHAR*)malloc(sizeof(TCHAR)*l);
	StringCbPrintf(PortStatuses[p].Status, l*sizeof(TCHAR), TEXT("%S%S%S"),
					Name, *Name?" ":"", Status);

	TraceLog("Activity", DisplayFlag, hwnd, "SetPortStatus: wp[%ld] %s %s\n", (long) wp, Name, Status);

	InvalidatePortStatus(TRUE);

	PortStatusSecond = -1;	/* Force an update */
	PortStatusIndex = p-1;	/* Paint will increment */

	IncrementXmitPackets(wp, 0, Name);	/* Make sure we're counting */
}

static void SetPortSubStatus(HWND hwnd, WPARAM wp, char *Name, char *Status)
{	int p, DisplayFlag = HIWORD(wp);	/* DisplayFlag is not currently used */
	int l = strlen(Status)+1;

	wp = LOWORD(wp);

	for (p=0; p<PortStatusCount; p++)
	{	if (PortStatuses[p].wp == wp)
			break;
	}
	if (p>=PortStatusCount)
	{	p = PortStatusCount++;
		PortStatuses = (PORT_STATUS_S *)realloc(PortStatuses,sizeof(*PortStatuses)*PortStatusCount);
		memset(&PortStatuses[p], 0, sizeof(PortStatuses[p]));
		PortStatuses[p].wp = wp;
		PortStatuses[p].Name = _strdup(Name);
		qsort(PortStatuses, PortStatusCount, sizeof(*PortStatuses), PortStatusCompare);
		for (p=0; p<PortStatusCount; p++)
		{	if (PortStatuses[p].wp == wp)
				break;
		}
		if (p>=PortStatusCount)
		{	TraceError(hwnd, "qSort LOST [%ld] %s %s\n", (long) wp, Name, Status);
			p = 0;
		}
	}

	if (PortStatuses[p].SubStatus) free(PortStatuses[p].SubStatus);
	//PortStatuses[p].DisplayFlag = DisplayFlag;
	PortStatuses[p].SubStatus = (TCHAR*)malloc(sizeof(TCHAR)*l);
	StringCbPrintf(PortStatuses[p].SubStatus, l*sizeof(TCHAR), TEXT("%S"),
					Status);

	TraceLog("Activity", TRUE, hwnd, "SetPortSubStatus: wp[%ld] %s %s\n", (long) wp, Name, Status);
}

static void SaveWindowPosition(TCHAR *Title, WINDOWPOS *pPos, int zoom=0, char *Extra="")
{	int Len = wcslen(Title)+1;
	int TempLen = Len+4*(1+33)+1+strlen(Extra)+1;
	char *TempBuf = (char*)malloc(TempLen);
	StringCbPrintfA(TempBuf, TempLen,
			"%S:%ld@%ld,%ld[%ld,%ld]%s",
			Title,
			zoom,
			pPos->x, pPos->y, pPos->cx, pPos->cy,
			Extra);
	AddOrUpdateColonStringEntry(&ActiveConfig.WindowPositions, TempBuf, NULL);
TraceLogThread("Activity",TRUE,"SaveWindowsPosition:%s\n", TempBuf);
	free(TempBuf);
}

static void SaveWindowPosition(char *Name, WINDOWPOS *pPos, int zoom=0, char *Extra="")
{	size_t Size = sizeof(TCHAR)*(strlen(Name)+1);
	TCHAR *Title = (TCHAR*)malloc(Size);
	StringCbPrintf(Title, Size, TEXT("%S"), Name);
	SaveWindowPosition(Title, pPos, zoom, Extra);
	free(Title);
}

static void SaveWindowPosition(HWND hwnd, int zoom=-1, char *Extra="")
{
#ifndef UNDER_CE
	if (!IsIconic(hwnd) && !IsZoomed(hwnd))
#endif
	{	int Len = GetWindowTextLength(hwnd)+1;
		TCHAR *Title = (TCHAR*)malloc(Len*sizeof(*Title));
		GetWindowText(hwnd, Title, Len);
		RECT rcSize;
		GetWindowRect(hwnd, &rcSize);
		WINDOWPOS Pos;
		Pos.x = rcSize.left;
		Pos.y = rcSize.top;
		Pos.cx = rcSize.right-rcSize.left;
		Pos.cy = rcSize.bottom-rcSize.top;
		SaveWindowPosition(Title, &Pos, zoom, Extra);
		free(Title);
	}
}

/* Note: String is modified by this routine! */
/*		A null is placed after the first colon */
static BOOL ParseWindowPosition(char *String, WINDOWPOS *pPos, int *pz=NULL, char **pExtra=NULL)
{	BOOL Result = FALSE;
	char *c = strchr(String,':');
	if (c)
	{	char *e;
		*c++ = '\0';	/* Null terminate station ID */
		int z = strtol(c,&e,10);	/* And retrieve the zoom factor */
		if (pz) *pz = z;
		if (e && *e=='@')
		{	pPos->x = strtol(e+1,&e,10);
			if (e && *e==',')
			{	pPos->y = strtol(e+1,&e,10);
				if (e && *e=='[')
				{	pPos->cx = strtol(e+1,&e,10);
					if (e && *e==',')
					{	pPos->cy = strtol(e+1,&e,10);
						if (e && *e==']')
						{	if (pExtra) *pExtra = e+1;
							Result = TRUE;
						}
					}
				}
			}
		}
	}
	return Result;
}

static BOOL RecallWindowPosition(char *Name, WINDOWPOS *pPos, int *pz=NULL, char **pExtra=NULL)
{	unsigned long p = LocateColonStringEntry(&ActiveConfig.WindowPositions, Name);
	BOOL Result = FALSE;

	pPos->x = CW_USEDEFAULT;
	pPos->y = CW_USEDEFAULT;
	pPos->cx = CW_USEDEFAULT;
	pPos->cy = CW_USEDEFAULT;

TraceLogThread("Activity",TRUE,"RecallWindowPosition(%s)[%ld]=%s\n",
			   Name, p, (p!=-1)?ActiveConfig.WindowPositions.Entries[p].string:"*NULL*");

	if (p != -1)
	{	char *Extra, *String = _strdup(ActiveConfig.WindowPositions.Entries[p].string);
		Result = ParseWindowPosition(String, pPos, pz, &Extra);
		if (pExtra) *pExtra = _strdup(Extra);
		free(String);
#ifdef OLD_WAY
		char *c = strchr(ActiveConfig.WindowPositions.Entries[p].string,':');
		if (c)
		{	char *e;
			*c++ = '\0';	/* Null terminate station ID */
			int z = strtol(c,&e,10);	/* And retrieve the zoom factor */
			if (e && *e=='@')
			{	pPos->x = strtol(e+1,&e,10);
				if (e && *e==',')
				{	pPos->y = strtol(e+1,&e,10);
					if (e && *e=='[')
					{	pPos->cx = strtol(e+1,&e,10);
						if (e && *e==',')
						{	pPos->cy = strtol(e+1,&e,10);
							if (e && *e==']')
							{	Result = TRUE;
							}
						}
					}
				}
			}
		}
#endif
	}
	return Result;
}

static char *MakeTrackerWindowName(char *Station)
{	size_t Len = 10+1+strlen(Station)+1+1;
	char *Name = (char*)malloc(Len);
	StringCbPrintfA(Name, Len, "MultiTrack(%s)", Station);
	return Name;
}

static BOOL RecallTrackerWindowPosition(char *Station, WINDOWPOS *pPos, int *pz=NULL, char **pExtra=NULL)
{	char *Name = MakeTrackerWindowName(Station);
	BOOL Result = RecallWindowPosition(Name, pPos, pz, pExtra);
	free(Name);
	return Result;
}

static void SaveTrackerWindowRect(HWND hwnd, CLIENT_INFO_S *cInfo)
{
	if (cInfo->CenterStation
	&& !cInfo->CenterStation->isNWS)
	{	RECT *prc = NULL;
		WINDOWPOS Pos;
#ifdef UNDER_CE
		if (!IsIconic(hwnd))
		{	RECT rc;
			GetWindowRect(hwnd, &rc);
			prc = &rc;
#else
		WINDOWPLACEMENT wp;
		GetWindowPlacement(hwnd, &wp);
		if (wp.showCmd == 1)
		{	prc = &wp.rcNormalPosition;
#endif
			char *Name = MakeTrackerWindowName(cInfo->CenterStation->Station);
			char *ViewString = MakeViewString(cInfo, cInfo->viewBits);
	TraceLog("Activity",TRUE,hwnd,"SaveTrackerWindowRect got %s\n", ViewString);
			Pos.x = prc->left; Pos.y = prc->top;
			Pos.cx = prc->right-prc->left;
			Pos.cy = prc->bottom-prc->top;
			SaveWindowPosition(Name, &Pos, cInfo->zoom, ViewString);
			free(ViewString);
			free(Name);
		}
	}
}

void SaveMainWindowRect(HWND hwnd, RECT *prc)
{	WINDOWPOS Pos;
	char *ViewString = MakeViewString(&cInfos[0], cInfos[0].viewBits);
TraceLog("Activity",TRUE,hwnd,"SaveMainWindowRect got %s\n", ViewString);
	Pos.x = prc->left; Pos.y = prc->top;
	Pos.cx = prc->right-prc->left;
	Pos.cy = prc->bottom-prc->top;
	SaveWindowPosition("*MainWindow*", &Pos, cInfos[0].zoom, ViewString);
	ActiveConfig.OrgWindowPlacement.x = Pos.x;
	ActiveConfig.OrgWindowPlacement.y = Pos.y;
	ActiveConfig.OrgWindowPlacement.width = Pos.cx;
	ActiveConfig.OrgWindowPlacement.height = Pos.cy;
	free(ViewString);
#ifdef OLD_WAY
	pConfig->WindowPlacement.x = x;
	pConfig->WindowPlacement.y = y;
	pConfig->WindowPlacement.width = width;
	pConfig->WindowPlacement.height = height;
	//SaveConfiguration(hwnd, pConfig, "WindowPlacement");
#endif
}

static HWND hwndFreq = NULL;
static FILTER_INFO_S FreqMonFilter={0};
static TCHAR g_szFrequencyName[] = TEXT("Frequency Monitor");

void BltSymbolBitmap(HWND hwnd, HDC hdc, HDC hMemDC, int x, int y, int Mult, int Div, int Symbol, int Percentage, COLORREF SysColor, RECT *prc);
LRESULT CALLBACK FrequencyWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
typedef struct FREQ_MON_INFO_S
{	char Station[STATION_SIZE];
	char Owner[STATION_SIZE];
	char Comment[COMMENT_SIZE];
	char Platform[PLATFORM_SIZE];
	int iSymbol;
	COORDINATE_S Coord;
	BOOL isObject;
	FREQUENCY_INFO_S Freq;
} FREQ_MON_INFO_S;

static BOOL MenuActive = FALSE;

static BOOL First = TRUE;
static FREQ_MON_INFO_S DefaultFrequency =
{ "999.999EX",
	PROGCALL,
	"Placeholder Frequency Object",
	TRUE, {0} };

	FREQ_MON_INFO_S *pMon;

	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		pMon = (FREQ_MON_INFO_S *)calloc(1,sizeof(*pMon));
		*pMon = DefaultFrequency;
		if (First)
		{	pMon->Freq.freq = 146.520;
			pMon->Freq.altfreq = 144.390;
			pMon->Freq.offset = (short) ((pMon->Freq.altfreq-pMon->Freq.freq)*1000/10);
			pMon->Freq.Issues = "Sample";
			pMon->Freq.tonetype = 'T';
			pMon->Freq.tone = 100;
			pMon->Freq.range = 99;
			DefaultFrequency = *pMon;
			First = FALSE;
		}
		SetWindowLong(hwnd, GWL_USERDATA, (LONG) pMon);
		if (ActiveConfig.FreqMon.Timer)
			SetTimer(hwnd, 10, ActiveConfig.FreqMon.Timer*1000, NULL);
		return 0;
	}
	case WM_USER:
	{	pMon = (FREQ_MON_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		STATION_INFO_S *pStat = (STATION_INFO_S *)lParam;
		if (!MenuActive
		&& pStat && pStat->Frequency)
		{	strncpy(pMon->Station, pStat->Station, sizeof(pMon->Station));
			strncpy(pMon->Owner, pStat->Owner, sizeof(pMon->Owner));
			if (pStat->pPlatform) strncpy(pMon->Platform, pStat->pPlatform, sizeof(pMon->Platform));
			else memset(pMon->Platform, 0, sizeof(pMon->Platform));
			pMon->isObject = pStat->isObject;
			pMon->Coord = *pStat->pCoord;
			if (pStat->sComment && pStat->pComment)
				StringCbPrintfA(pMon->Comment, sizeof(pMon->Comment),
								"%.*S", pStat->sComment, pStat->pComment);
			else memset(pMon->Comment, 0, sizeof(pMon->Comment));
			strncpy(pMon->Station, pStat->Station, sizeof(pMon->Station));
			pMon->iSymbol = pStat->isymbol;
			pMon->Freq = *pStat->Frequency;
			InvalidateRect(hwnd, NULL, TRUE);
			if (!MenuActive
			&& ActiveConfig.FreqMon.Timer)
				SetTimer(hwnd, 10, ActiveConfig.FreqMon.Timer*1000, NULL);
			DefaultFrequency = *pMon;
		}
		break;
	}
	case WM_LBUTTONDOWN:
#if defined(USING_SHELL) || defined(CE50)
	{	SHRGINFO    shrg = {0};
		shrg.cbSize = sizeof(shrg);
		shrg.hwndClient = hwnd;
		shrg.ptDown.x = LOWORD(lParam);
		shrg.ptDown.y = HIWORD(lParam);
		shrg.dwFlags = SHRG_RETURNCMD /*| SHRG_NOANIMATION*/;
		if (SHRecognizeGesture(&shrg) == GN_CONTEXTMENU)
		{
			return 0;	/* I processed it */
		}
	}
#endif
		break;
	case WM_LBUTTONDBLCLK:
		MessageBox(hwnd, TEXT("This Space Reserved For Future Expansion"), TEXT("Tune Frequency"), MB_OK | MB_ICONINFORMATION);
		return 0;
	case WM_CONTEXTMENU:
	{	pMon = (FREQ_MON_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		POINT pt;
		pt.x = LOWORD(lParam); pt.y = HIWORD(lParam);
//		ClientToScreen(hwnd, &pt);
		HMENU hPopup = CreatePopupMenu();

		MenuActive = TRUE;
		KillTimer(hwnd, 10);

#if MAX_TRACKERS > 1
		AppendMenu(hPopup, MF_STRING, 4, TEXT("MultiTrack"));
		AppendMenu(hPopup, MF_SEPARATOR, NULL, NULL);
#endif
		AppendMenu(hPopup, MF_STRING, 3, TEXT("Auto-Close Timer..."));
		AppendMenu(hPopup, MF_STRING | MF_CHECKED, 5, TEXT("Enabled"));
		AppendMenu(hPopup, MF_STRING, 2, TEXT("Font Size..."));
		AppendMenu(hPopup, MF_STRING, 1, TEXT("Set Filter..."));
	
		switch (TrackPopupMenu(hPopup,
						TPM_CENTERALIGN | TPM_VCENTERALIGN
						| TPM_NONOTIFY | TPM_RETURNCMD,
						pt.x, pt.y, 0, hwnd, NULL))
		{
		case 1:
		{	char *New = StringPromptA(hwnd, "Monitor Filter - CaSe SeNsItIvE", "Enter Filter (blank=all)", sizeof(ActiveConfig.FreqMon.Filter), ActiveConfig.FreqMon.Filter, FALSE, FALSE);
			if (New)
			{	if (CheckOptimizedFilter(New, &FreqMonFilter))
				{	strncpy(ActiveConfig.FreqMon.Filter, SkipWhite(New),
							sizeof(ActiveConfig.FreqMon.Filter));
					SaveConfiguration(hwnd, &ActiveConfig, "FreqMonFilter");
				} else
				{	ShowTraceLog("FilterError");
					MessageBox(hwnd, TEXT("Invalid Filter Specification, Filter Not Saved"), TEXT("Filter Error"), MB_ICONERROR | MB_OK);
				}
				free(New);
			}
			break;
		}
		case 2:
			ActiveConfig.FreqMon.FontSize = NumberPrompt(hwnd, "Freq Size", "5=Default, 0=Off", "Number", "FreqMon.FontSize", ActiveConfig.FreqMon.FontSize);
			break;
		case 3:
			ActiveConfig.FreqMon.Timer = NumberPrompt(hwnd, "Monitor Timer", "Auto-Close Timer (0=forever)", "Seconds", "FreqMon.Timer", ActiveConfig.FreqMon.Timer);
			if (ActiveConfig.FreqMon.Timer
			&& ActiveConfig.FreqMon.Timer < 10)
				ActiveConfig.FreqMon.Timer = 10;
			break;
		case 4:
			RestoreOrCreateTrackerWindow(pMon->Station, pMon->Owner);
			break;
		case 5:
			ActiveConfig.FreqMon.Enabled = FALSE;
			PostMessage(hwnd, WM_CLOSE, 0, 0);
			break;
		}
		DestroyMenu(hPopup);
		MenuActive = FALSE;
		if (ActiveConfig.FreqMon.Timer)
			SetTimer(hwnd, 10, ActiveConfig.FreqMon.Timer*1000, NULL);
		return 0;
	}
	case WM_CHAR:
		switch (wParam)
		{
		case '=':	/* So we don't need to shift */
		case '+': if (++ActiveConfig.FreqMon.FontSize > 7) ActiveConfig.FreqMon.FontSize = 7; break;
		case '-': if (--ActiveConfig.FreqMon.FontSize < 1) ActiveConfig.FreqMon.FontSize = 1; break;
		}
		InvalidateRect(hwnd, NULL, TRUE);
		return 0;

	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_TIMER:
		if (wParam == 10) SendMessage(hwnd, WM_CLOSE, 0, 0);
		break;
	case WM_CLOSE:
		hwndFreq = NULL;
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		pMon = (FREQ_MON_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		return 0;
	case WM_PAINT:
	{
		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);
		RECT rcPaint;
		GetClientRect(hwnd, &rcPaint);
//		Rectangle(ps.hdc, rcPaint.left-2, rcPaint.top-2, rcPaint.right+2, rcPaint.bottom+2);

		pMon = (FREQ_MON_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (pMon && pMon->Freq.freq)
		{	HDC hdc = ps.hdc;
			size_t BuffSize = sizeof(TCHAR)*8192;
			TCHAR *Buffer = (TCHAR*)malloc(BuffSize);
			size_t Remaining = BuffSize;
			TCHAR *Next = Buffer;
			*Next = 0;

			FREQUENCY_INFO_S *pFreq = (FREQUENCY_INFO_S *) &pMon->Freq;

			RECT rcSym;
			HDC hMemDC = CreateCompatibleDC(hdc);
			BltSymbolBitmap(hwnd, hdc, hMemDC, 21/2, 21/2, 1, 1, pMon->iSymbol, 100, COLOR_WINDOW, &rcSym);
			DeleteDC(hMemDC);

			RECT rcStation;
			SetRect(&rcStation, rcSym.right+1, rcSym.top, rcPaint.right, rcPaint.bottom);
			StringCbPrintfEx(Buffer, BuffSize, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("%.*S"), sizeof(pMon->Station), pMon->Station);
			if (pMon->isObject) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" de %.*S"), sizeof(pMon->Owner), pMon->Owner);
			else if (*pMon->Platform)
				 StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" %S"), pMon->Platform);

	if ((LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
	{	double distance, bearing;
		AprsHaversineLatLon(LastGoodPosition.dblLatitude,
							LastGoodPosition.dblLongitude,
							pMon->Coord.lat, pMon->Coord.lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %.*lfkm %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %.*lfmi %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
#ifndef UNDER_CE
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (%ld)"),
						(long) bearing);
#endif
	}

			int tHeight = DrawText(hdc, Buffer, -1, &rcStation, DT_LEFT | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);

			if (pFreq->altfreq)
			{	Next = Buffer; Remaining = BuffSize; *Next = 0;
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%.3lfrx%S"),
								(double) pFreq->altfreq,
								pFreq->altfreq == pFreq->freq?"(BOGUS)":"");
				RECT rc;
				SetRect(&rc, rcStation.right+1, rcStation.top, rcPaint.right, rcPaint.bottom);
				COLORREF prevBkColor = SetBkColor(hdc, RGB(0,255,0));
				int tHeight = DrawText(hdc, Buffer, -1, &rc, DT_RIGHT | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
				SetBkColor(hdc, prevBkColor);
			}
			rcPaint.top += max(tHeight, (rcSym.bottom-rcSym.top));

			{	HFONT hFont = (HFONT) 0, hOld = (HFONT) 0;
				hFont = LoadPaintFont(TEXT("7 Segment"), ActiveConfig.FreqMon.FontSize*g_dwFontSize, FALSE);
				if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
				StringCbPrintf(Buffer, BuffSize, TEXT("%.3lf"), (double) pFreq->freq);
				RECT rcFreq = rcPaint;
				int sHeight = DrawText(hdc, Buffer, -1, &rcFreq, DT_CENTER | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
				rcPaint.top += sHeight;
				if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
			}

			Next = Buffer; Remaining = BuffSize; *Next = 0;
			if (pFreq->tonetype)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									pFreq->tone?TEXT(" %c:%03ld"):TEXT(" %c:None"),
									pFreq->tonetype, (long) pFreq->tone);
			if (pFreq->offset)
				if (abs(pFreq->offset) >= 100)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT(" %S%.2lfMHz"),
								pFreq->offset>0?"+":"",
								(double) pFreq->offset/100.0);
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT(" %S%ldKHz"),
								pFreq->offset>0?"+":"",
								pFreq->offset*10);
			else if (pFreq->standardoffset)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT(" %coffset"),
								pFreq->standardoffset);
			if (pFreq->range)
			{	if (ActiveConfig.View.Metric.Distance)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %ldkm"),
						(long) (pFreq->range*KmPerMile));
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %ldmi"),
						(long) pFreq->range);
			}
			if (*Buffer)
			{	RECT rc = rcPaint;
				int tHeight = DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
			}
			rcPaint.top += tHeight;

			Next = Buffer; Remaining = BuffSize; *Next = 0;
			if (pFreq->Issues)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%S"), pFreq->Issues);
			if (*Buffer)
			{	RECT rc = rcPaint;
				COLORREF prevBkColor = SetBkColor(hdc, RGB(255,255,0));
				int tHeight = DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
				SetBkColor(hdc, prevBkColor);
			}
			rcPaint.top += tHeight;

			Next = Buffer; Remaining = BuffSize; *Next = 0;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%S"), pMon->Comment);
			if (*Buffer)
			{	RECT rc = rcPaint;
				int tHeight = DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
			}
			rcPaint.top += tHeight;

#ifdef FOR_INFO_ONLY
typedef struct FREQUENCY_INFO_S
{	char *Issues;	/* Pointer to parser issue string */
	double freq;
	double altfreq;	/* if second specified (FFF.FFFrx or Object w/FFF.FFFMHz) */
	double range;	/* Largest of NEWS ranges if specified, in miles (kilometer?) */
	short tone;		/* 0=off or not specified */
	short offset;	/* +/- in 10khz units (60=600khz) */
	char tonetype;	/* upper=wide, lower=narrow T/t, C/c, D/d, 1=1750 */
	char standardoffset;	/* +/- if no digits */
} FREQUENCY_INFO_S;
#endif

		free(Buffer);
	}
		EndPaint(hwnd, &ps);
	
		return 0;
	}
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

static void CreateFrequencyWindow(HWND hwndParent)
{static	BOOL First = TRUE;
static int tHeight, tWidth;
static int fHeight, fWidth;

	if (!hwndFreq)
	{	if (First)
		{
#ifndef UNDER_CE
			WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
			Class.lpfnWndProc = FrequencyWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szFrequencyName;
			RegisterClassEx(&Class);
#else			
			WNDCLASS Class = {0};
			Class.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
			Class.lpfnWndProc = FrequencyWndProc;
			Class.hInstance = g_hInstance;
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszClassName = g_szFrequencyName;
			RegisterClass(&Class);
#endif
			First = FALSE;
		}

			RECT rc;
			HDC hdc = GetDC(hwndMain);

			HFONT hOld, hFont = LoadPaintFont(TEXT("7 Segment"), ActiveConfig.FreqMon.FontSize*g_dwFontSize, FALSE);
			if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
			else hOld = (HFONT) 0;
			SetRect(&rc, 0, 0, 999, 999);
			fHeight = DrawText(hdc, TEXT("999.999"), -1, &rc, DT_NOPREFIX | DT_CALCRECT) * 21/20;
			fWidth = rc.right - rc.left + 6;
			if (hOld != (HFONT) 0) SelectObject(hdc, hOld);

			TCHAR Text[] = TEXT("/999.999rx(BOGUS) T999 +9990KHz +offset 9999km *Issues*");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);

		char *szTitle = "Frequency Monitor";

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
#ifndef UNDER_CE
		if (!RecallWindowPosition(szTitle, &Pos))
#endif
		{	Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
		}
		{	RECT rc;
			SetRect(&rc, 0, 0, max(fWidth,tWidth), fHeight+tHeight*4);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}
		if (Pos.cx >= GetSystemMetrics(SM_CXSCREEN))
			Pos.cx = GetSystemMetrics(SM_CXSCREEN)-2;
		if (Pos.cy >= GetSystemMetrics(SM_CYSCREEN))
			Pos.cy = GetSystemMetrics(SM_CYSCREEN)-2;

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		hwndFreq = CreateWindow(g_szFrequencyName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									hwndParent, NULL, g_hInstance, NULL);
		free(tTitle);
//		free(szTitle);
	}
}

#ifndef UNDER_CE
static char *BuildPortStatusString(int p, BOOL MultiLine);
static void AddHourly(char *What, size_t Count, unsigned long *Counts, TCHAR **Next, size_t *Remaining);
LRESULT CALLBACK PortStatusWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{	PORT_PACKET_COUNT_S *pPort;

	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		pPort = (PORT_PACKET_COUNT_S *) cs->lpCreateParams;
		SetWindowLong(hwnd, GWL_USERDATA, (LONG) pPort);
		//TraceLogThread("PortStatus", TRUE, "Creating Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		SetTimer(hwnd, 10, 1000, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	InvalidateRect(hwnd, NULL, FALSE);
		}
		return 0;
	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_PAINT:
	{
		pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);

		size_t Remaining = sizeof(TCHAR)*(8192 + pPort->DXCount*80 + HOURLY_PACKETS*80);
		TCHAR *Buffer = (TCHAR*)malloc(Remaining);
		TCHAR *Next = Buffer;
		*Next = 0;
		int p;

		int Length = GetWindowText(hwnd, Buffer, Remaining);
		Remaining -= Length * sizeof(*Buffer);
		Next += Length;

		for (p=0; p<PortStatusCount; p++)
		if (PortStatuses[p].wp+1 == pPort->wpPort)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%SI:%lu O:%lu"), Length?" - ":"",
							pPort->RcvPackets[0], pPort->XmtPackets[0]);
			if (PortStatuses[p].SubStatus)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("\n%s"), PortStatuses[p].SubStatus);
			}
			AddHourly("Rcv", HOURLY_PACKETS, pPort->RcvPackets, &Next, &Remaining);
			AddHourly("Xmt", HOURLY_PACKETS, pPort->XmtPackets, &Next, &Remaining);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n"));
			break;
		}

#define DOPKT(t,w) \
	AddHourly(#t, HOURLY_PACKETS, w, &Next, &Remaining)
			DOPKT(t/p,pPort->PktPosition);
			DOPKT(t/o,pPort->PktObject);
			DOPKT(t/i,pPort->PktItem);
			DOPKT(t/m,pPort->PktMessage);
			DOPKT(t/q,pPort->PktQuery);
			DOPKT(t/s,pPort->PktStatus);
			DOPKT(t/t,pPort->PktTelemetry);
			DOPKT(t/u,pPort->PktUser);
			DOPKT(t/n,pPort->PktNWS);
			DOPKT(t/w,pPort->PktWeather);
			DOPKT(oth,pPort->PktOther);
#undef DOPKT

		for (p=0; p<pPort->DXCount; p++)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%SList:%02ld-%02ld %02ld:%02ld:%02ld %.2lf%S %s %S"),
							p?"\n":"\n\n",
							(long) pPort->DXList[p].st.wMonth,
							(long) pPort->DXList[p].st.wDay,
							(long) pPort->DXList[p].st.wHour,
							(long) pPort->DXList[p].st.wMinute,
							(long) pPort->DXList[p].st.wSecond,
							(double) (pPort->DXList[p].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
							ActiveConfig.View.Metric.Distance?"km":"mi",
							GetCompassPoint((int)pPort->DXList[p].Bearing),
							pPort->DXList[p].Station);
			if (pPort->DXList[p].Count > 1)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("*%ld"), pPort->DXList[p].Count);
			}
		}

		{	BOOL First = TRUE;
			for (int h=0; h<HOURLY_PACKETS; h++)
			if (pPort->DX[h].Station[0]
			&& pPort->DX[h].Distance)
			{	FILETIME FileTime, LocalFileTime;
				SYSTEMTIME LocalTime;
				SystemTimeToFileTime(&pPort->DX[h].st,&FileTime);
				FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
				FileTimeToSystemTime(&LocalFileTime, &LocalTime);

				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%SHrly:%02ld:%02ld:%02ld DX=%ld*%.*S(%.0lf%S@%ld)"),
							First?"\n\n":"\n",
							(long) LocalTime.wHour,
							(long) LocalTime.wMinute,
							(long) LocalTime.wSecond,
							(long) pPort->DX[h].Count,
							STRING(pPort->DX[h].Station),
							(double) (pPort->DX[h].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
							ActiveConfig.View.Metric.Distance?"km":"mi",
							(long) pPort->DX[h].Bearing);
				First = FALSE;
			}
		}

		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);

		RECT rcWin;
		GetClientRect(hwnd, &rcWin);
        SelectObject(ps.hdc, GetStockObject(WHITE_BRUSH));
		Rectangle(ps.hdc, rcWin.left-2, rcWin.top-2, rcWin.right+2, rcWin.bottom+2);
		InflateRect(&rcWin, -2, -2);
		DrawText(ps.hdc, Buffer, -1, &rcWin, DT_LEFT | DT_TOP | DT_NOPREFIX);
		EndPaint(hwnd, &ps);

		free(Buffer);
		
		return 0;
	}
	case WM_CLOSE:
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);
		//TraceLogThread("PortStatus", TRUE, "Destroyed Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		pPort->hwnd = NULL;
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

static void CreatePortStatusWindow(PORT_PACKET_COUNT_S *pPort)
{static	BOOL First = TRUE;
static int tHeight, tWidth;

	if (!pPort->hwnd)
	{	if (First)
		{	WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW;
			Class.lpfnWndProc = PortStatusWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szPortStatusName;
			RegisterClassEx(&Class);
			First = FALSE;

			RECT rc;
			HDC hdc = GetDC(hwndMain);
			TCHAR Text[] = TEXT("Port() - I:9999 O:9999\nRcv:\nXmt:\n\nt/p\nt/o\nt/i\nt/m\nt/q\nt/s\nt/t\nt/u\nt/n\nt/w: 199k 199k 199k 199k 199k 199k 199k 199k /hr");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);
		}

		char *szTitle = (char *)malloc(sizeof(*szTitle)*128);
		StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Port Status");
		if (pPort->wpPort == APRSISWP+1)
		{	StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Port(APRS-IS)");
		} else for (int p=0; p<PortStatusCount; p++)
		if (PortStatuses[p].wp+1 == pPort->wpPort)
		{	char Text[80];
			StringCbPrintfA(Text, sizeof(Text), "%S", PortStatuses[p].Status);
			for (unsigned long o=0; o<ActiveConfig.RFPorts.Count; o++)
			{	if (strstr(Text, ActiveConfig.RFPorts.Port[o].Name))
				{	StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
								"Port(%s)", ActiveConfig.RFPorts.Port[o].Name);
					break;
				}
			}
		}

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
		if (!RecallWindowPosition(szTitle, &Pos))
		{	RECT rc;
			SetRect(&rc, 0, 0, tWidth, tHeight);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		pPort->hwnd = CreateWindow(g_szPortStatusName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									NULL, NULL, g_hInstance, pPort);
		//TraceLogThread("PortStatus", TRUE, "Created Window[%ld] %p or %S\n", pPort->wpPort, pPort->hwnd, szTitle);
		free(tTitle);
		free(szTitle);
	}
}

HWND hwndStationMemory = NULL;
static char *GetCloseStationStats(void);
LRESULT CALLBACK StationMemoryWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		//pPort = (PORT_PACKET_COUNT_S *) cs->lpCreateParams;
		//SetWindowLong(hwnd, GWL_USERDATA, (LONG) pPort);
		//TraceLogThread("PortStatus", TRUE, "Creating Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		SetTimer(hwnd, 10, 10000, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	InvalidateRect(hwnd, NULL, FALSE);
		}
		return 0;
	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_PAINT:
	{	char *Text = GetCloseStationStats();
		size_t Size = (strlen(Text)+1)*sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR*)malloc(Size);
		StringCbPrintf(Buffer, Size, TEXT("%S"), Text);
		free(Text);

		//pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);

		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);

		RECT rcWin;
		GetClientRect(hwnd, &rcWin);
        SelectObject(ps.hdc, GetStockObject(WHITE_BRUSH));
		Rectangle(ps.hdc, rcWin.left-2, rcWin.top-2, rcWin.right+2, rcWin.bottom+2);
		InflateRect(&rcWin, -2, -2);
		DrawText(ps.hdc, Buffer, -1, &rcWin, DT_LEFT | DT_TOP | DT_NOPREFIX);
		EndPaint(hwnd, &ps);

		free(Buffer);
		
		return 0;
	}
	case WM_CLOSE:
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		//pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);
		//TraceLogThread("PortStatus", TRUE, "Destroyed Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		hwndStationMemory = NULL;
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

static void CreateStationMemoryWindow(void)
{static	BOOL First = TRUE;
static int tHeight, tWidth;
static TCHAR *g_szStationMemoryName = TEXT("StationMemory");

	if (!hwndStationMemory)
	{	if (First)
		{	WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW;
			Class.lpfnWndProc = StationMemoryWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szStationMemoryName;
			RegisterClassEx(&Class);
			First = FALSE;

			RECT rc;
			HDC hdc = GetDC(hwndMain);
			TCHAR Text[] = TEXT("Port() - I:9999 O:9999\nRcv:\nXmt:\n\nt/p\nt/o\nt/i\nt/m\nt/q\nt/s\nt/t\nt/u\nt/n\nt/w: 199k 199k 199k 199k 199k 199k 199k 199k /hr");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);
		}

		char *szTitle = (char *)malloc(sizeof(*szTitle)*128);
		StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Station Memory");

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
		if (!RecallWindowPosition(szTitle, &Pos))
		{	RECT rc;
			SetRect(&rc, 0, 0, tWidth, tHeight);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		hwndStationMemory = CreateWindow(g_szStationMemoryName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									NULL, NULL, g_hInstance, NULL);
		//TraceLogThread("PortStatus", TRUE, "Created Window[%ld] %p or %S\n", pPort->wpPort, pPort->hwnd, szTitle);
		free(tTitle);
		free(szTitle);
	} else if (IsWindow(hwndStationMemory))
	{	ShowWindow(hwndStationMemory, SW_RESTORE);
		SetForegroundWindow(hwndStationMemory);
	}
}

static int CompareRFPacketRates(const void *One, const void *Two)
{	int Left = *(int *)One;
	int Right = *(int *)Two;
	STATION_INFO_S *lStat = pCloseStations[Left];
	STATION_INFO_S *rStat = pCloseStations[Right];
	int lTotal = lStat->Packets[0].RF;
	int rTotal = rStat->Packets[0].RF;

	if (lTotal > rTotal) return -1;
	else if (lTotal < rTotal) return 1;
	else return strcmp(lStat->Station, rStat->Station);
}

static int ComparePacketRates(const void *One, const void *Two)
{	int Left = *(int *)One;
	int Right = *(int *)Two;
	STATION_INFO_S *lStat = pCloseStations[Left];
	STATION_INFO_S *rStat = pCloseStations[Right];
	int lTotal = lStat->Packets[0].IS+lStat->Packets[0].RF-lStat->Packets[0].Dupes;
	int rTotal = rStat->Packets[0].IS+rStat->Packets[0].RF-rStat->Packets[0].Dupes;

	if (lTotal > rTotal) return -1;
	else if (lTotal < rTotal) return 1;
	else return strcmp(lStat->Station, rStat->Station);
}

HWND hwndBusyRFStations = NULL;
HWND hwndBusyFixedStations = NULL;
HWND hwndBusyMobileStations = NULL;
LRESULT CALLBACK BusyRFStationsWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		//pPort = (PORT_PACKET_COUNT_S *) cs->lpCreateParams;
		//SetWindowLong(hwnd, GWL_USERDATA, (LONG) pPort);
		//TraceLogThread("PortStatus", TRUE, "Creating Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		SetTimer(hwnd, 10, 10000, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	InvalidateRect(hwnd, NULL, FALSE);
		}
		return 0;
	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_PAINT:
	{	double DeltaT = (double) SecondsSince(&stHourlyStart[0])*1000;
		double DeltaT2 = stHourlyStart[1].wYear?(double)DeltaSeconds(&stHourlyStart[1],&stHourlyStart[0])*1000.0:0.0;

		size_t Remain = (80*64)*sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR*)malloc(Remain);
		TCHAR *Next = Buffer;
		*Next = TEXT('\0');

		char fdtBuffer[80], fdtBuffer2[80];
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("Packets/Minute extrapolated from %S (%S)\n"),
						FormatDeltaTime((__int64)(DeltaT/1000), fdtBuffer, sizeof(fdtBuffer)),
						FormatDeltaTime((__int64)(DeltaT2/1000), fdtBuffer2, sizeof(fdtBuffer2)));

		if (DeltaT > 1000)
		{	int *Indexes = (int*)calloc(CloseStationCount, sizeof(*Indexes));
			unsigned long s, MyCount = 0;
			for (s=0; s<CloseStationCount; s++)
			if (pCloseStations[s]->HeardOnRF)
				Indexes[MyCount++] = s;
			qsort(Indexes, MyCount, sizeof(*Indexes), CompareRFPacketRates);

			for (s=0; s<min(64,MyCount); s++)
			{	STATION_INFO_S *Stat = pCloseStations[Indexes[s]];
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								TEXT("%.1lf (%.1lf) %.*S %S %.*s\n"),
								(Stat->Packets[0].RF)/DeltaT*60*1000.0,
								DeltaT2?(Stat->Packets[1].RF)/DeltaT2*60*1000.0:0.0,
								STRING(Stat->Station),
								Stat->pPlatform?Stat->pPlatform:"N/A",
								Stat->sComment, Stat->pComment);
			}
		}

		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);

		RECT rcWin;
		GetClientRect(hwnd, &rcWin);
        SelectObject(ps.hdc, GetStockObject(WHITE_BRUSH));
		Rectangle(ps.hdc, rcWin.left-2, rcWin.top-2, rcWin.right+2, rcWin.bottom+2);
		InflateRect(&rcWin, -2, -2);
		DrawText(ps.hdc, Buffer, -1, &rcWin, DT_LEFT | DT_TOP | DT_NOPREFIX);
		EndPaint(hwnd, &ps);

		free(Buffer);
		
		return 0;
	}
	case WM_CLOSE:
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		//pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);
		//TraceLogThread("PortStatus", TRUE, "Destroyed Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		hwndBusyRFStations = NULL;
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

LRESULT CALLBACK BusyFixedStationsWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		//pPort = (PORT_PACKET_COUNT_S *) cs->lpCreateParams;
		//SetWindowLong(hwnd, GWL_USERDATA, (LONG) pPort);
		//TraceLogThread("PortStatus", TRUE, "Creating Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		SetTimer(hwnd, 10, 10000, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	InvalidateRect(hwnd, NULL, FALSE);
		}
		return 0;
	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_PAINT:
	{	double DeltaT = (double) SecondsSince(&stHourlyStart[0])*1000;
		double DeltaT2 = stHourlyStart[1].wYear?(double)DeltaSeconds(&stHourlyStart[1],&stHourlyStart[0])*1000.0:0.0;

		size_t Remain = (80*64)*sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR*)malloc(Remain);
		TCHAR *Next = Buffer;
		*Next = TEXT('\0');

		char fdtBuffer[80], fdtBuffer2[80];
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("Packets/Minute extrapolated from %S (%S)\n"),
						FormatDeltaTime((__int64)(DeltaT/1000), fdtBuffer, sizeof(fdtBuffer)),
						FormatDeltaTime((__int64)(DeltaT2/1000), fdtBuffer2, sizeof(fdtBuffer2)));

		if (DeltaT > 1000)
		{	int *Indexes = (int*)calloc(CloseStationCount, sizeof(*Indexes));
			unsigned long s, MyCount = 0;
			for (s=0; s<CloseStationCount; s++)
			if (!pCloseStations[s]->TrackCount)
				Indexes[MyCount++] = s;
			qsort(Indexes, MyCount, sizeof(*Indexes), ComparePacketRates);

			for (s=0; s<min(64,MyCount); s++)
			{	STATION_INFO_S *Stat = pCloseStations[Indexes[s]];
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								TEXT("%.1lf (%.1lf) %.*S %S %.*s\n"),
								(Stat->Packets[0].IS+Stat->Packets[0].RF-Stat->Packets[0].Dupes)/DeltaT*60*1000.0,
								DeltaT2?(Stat->Packets[1].IS+Stat->Packets[1].RF-Stat->Packets[1].Dupes)/DeltaT2*60*1000.0:0.0,
								STRING(Stat->Station),
								Stat->pPlatform?Stat->pPlatform:"N/A",
								Stat->sComment, Stat->pComment);
			}
		}

		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);

		RECT rcWin;
		GetClientRect(hwnd, &rcWin);
        SelectObject(ps.hdc, GetStockObject(WHITE_BRUSH));
		Rectangle(ps.hdc, rcWin.left-2, rcWin.top-2, rcWin.right+2, rcWin.bottom+2);
		InflateRect(&rcWin, -2, -2);
		DrawText(ps.hdc, Buffer, -1, &rcWin, DT_LEFT | DT_TOP | DT_NOPREFIX);
		EndPaint(hwnd, &ps);

		free(Buffer);
		
		return 0;
	}
	case WM_CLOSE:
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		//pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);
		//TraceLogThread("PortStatus", TRUE, "Destroyed Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		hwndBusyFixedStations = NULL;
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

LRESULT CALLBACK BusyMobileStationsWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		//pPort = (PORT_PACKET_COUNT_S *) cs->lpCreateParams;
		//SetWindowLong(hwnd, GWL_USERDATA, (LONG) pPort);
		//TraceLogThread("PortStatus", TRUE, "Creating Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		SetTimer(hwnd, 10, 10000, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	InvalidateRect(hwnd, NULL, FALSE);
		}
		return 0;
	case WM_MOVE:
	case WM_SIZE:
		SaveWindowPosition(hwnd);
		break;
	case WM_PAINT:
	{	double DeltaT = (double) SecondsSince(&stHourlyStart[0])*1000;
		double DeltaT2 = stHourlyStart[1].wYear?(double)DeltaSeconds(&stHourlyStart[1],&stHourlyStart[0])*1000:0.0;

		size_t Remain = (80*64)*sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR*)malloc(Remain);
		TCHAR *Next = Buffer;
		*Next = TEXT('\0');

		char fdtBuffer[80], fdtBuffer2[80];
		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
						TEXT("Packets/Minute extrapolated from %S (%S)\n"),
						FormatDeltaTime((__int64)(DeltaT/1000), fdtBuffer, sizeof(fdtBuffer)),
						FormatDeltaTime((__int64)(DeltaT2/1000), fdtBuffer2, sizeof(fdtBuffer2)));

		if (DeltaT > 1000)
		{	int *Indexes = (int*)calloc(CloseStationCount, sizeof(*Indexes));
			unsigned long s, MyCount = 0;
			for (s=0; s<CloseStationCount; s++)
			if (pCloseStations[s]->TrackCount)
				Indexes[MyCount++] = s;
			qsort(Indexes, MyCount, sizeof(*Indexes), ComparePacketRates);

			for (s=0; s<min(64,MyCount); s++)
			{	STATION_INFO_S *Stat = pCloseStations[Indexes[s]];
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								TEXT("%.1lf (%.1lf) %.*S %S %.*s\n"),
								(Stat->Packets[0].IS+pCloseStations[Indexes[s]]->Packets[0].RF-pCloseStations[Indexes[s]]->Packets[0].Dupes)/DeltaT*60*1000.0,
								DeltaT2?(Stat->Packets[1].IS+pCloseStations[Indexes[s]]->Packets[1].RF-pCloseStations[Indexes[s]]->Packets[1].Dupes)/DeltaT2*60*1000.0:0.0,
								STRING(Stat->Station),
								Stat->pPlatform?Stat->pPlatform:"N/A",
								Stat->sComment, Stat->pComment);
			}
		}

		PAINTSTRUCT ps;
		BeginPaint(hwnd, &ps);

		RECT rcWin;
		GetClientRect(hwnd, &rcWin);
        SelectObject(ps.hdc, GetStockObject(WHITE_BRUSH));
		Rectangle(ps.hdc, rcWin.left-2, rcWin.top-2, rcWin.right+2, rcWin.bottom+2);
		InflateRect(&rcWin, -2, -2);
		DrawText(ps.hdc, Buffer, -1, &rcWin, DT_LEFT | DT_TOP | DT_NOPREFIX);
		EndPaint(hwnd, &ps);

		free(Buffer);
		
		return 0;
	}
	case WM_CLOSE:
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		//pPort = (PORT_PACKET_COUNT_S *) GetWindowLong(hwnd, GWL_USERDATA);
		//TraceLogThread("PortStatus", TRUE, "Destroyed Window[%ld] %p\n", pPort->wpPort, pPort->hwnd);
		hwndBusyMobileStations = NULL;
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

static void CreateBusyStationsWindow(void)
{static	BOOL First = TRUE;
static int tHeight, tWidth;
static TCHAR *g_szBusyRFStationsName = TEXT("BusyRFStations");
static TCHAR *g_szBusyFixedStationsName = TEXT("BusyFixedStations");
static TCHAR *g_szBusyMobileStationsName = TEXT("BusyMobileStations");


	if (!hwndBusyRFStations)
	{	if (First)
		{	WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW;
			Class.lpfnWndProc = BusyRFStationsWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szBusyRFStationsName;
			RegisterClassEx(&Class);

			RECT rc;
			HDC hdc = GetDC(hwndMain);
			TCHAR Text[] = TEXT("Port() - I:9999 O:9999\nRcv:\nXmt:\n\nt/p\nt/o\nt/i\nt/m\nt/q\nt/s\nt/t\nt/u\nt/n\nt/w: 199k 199k 199k 199k 199k 199k 199k 199k /hr");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);
		}

		char *szTitle = (char *)malloc(sizeof(*szTitle)*128);
		StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Busy on RF");

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
		if (!RecallWindowPosition(szTitle, &Pos))
		{	RECT rc;
			SetRect(&rc, 0, 0, tWidth, tHeight);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		hwndBusyRFStations = CreateWindow(g_szBusyRFStationsName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									NULL, NULL, g_hInstance, NULL);
		free(tTitle);
		free(szTitle);
	} else if (IsWindow(hwndBusyRFStations))
	{	ShowWindow(hwndBusyRFStations, SW_RESTORE);
		SetForegroundWindow(hwndBusyRFStations);
	}


	if (!hwndBusyFixedStations)
	{	if (First)
		{	WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW;
			Class.lpfnWndProc = BusyFixedStationsWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szBusyFixedStationsName;
			RegisterClassEx(&Class);

			RECT rc;
			HDC hdc = GetDC(hwndMain);
			TCHAR Text[] = TEXT("Port() - I:9999 O:9999\nRcv:\nXmt:\n\nt/p\nt/o\nt/i\nt/m\nt/q\nt/s\nt/t\nt/u\nt/n\nt/w: 199k 199k 199k 199k 199k 199k 199k 199k /hr");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);
		}

		char *szTitle = (char *)malloc(sizeof(*szTitle)*128);
		StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Busy Fixed");

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
		if (!RecallWindowPosition(szTitle, &Pos))
		{	RECT rc;
			SetRect(&rc, 0, 0, tWidth, tHeight);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		hwndBusyFixedStations = CreateWindow(g_szBusyFixedStationsName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									NULL, NULL, g_hInstance, NULL);
		free(tTitle);
		free(szTitle);
	} else if (IsWindow(hwndBusyFixedStations))
	{	ShowWindow(hwndBusyFixedStations, SW_RESTORE);
		SetForegroundWindow(hwndBusyFixedStations);
	}

	if (!hwndBusyMobileStations)
	{	if (First)
		{	WNDCLASSEX Class = {0};
			Class.cbSize = sizeof(Class);
			Class.style = CS_HREDRAW | CS_VREDRAW;
			Class.lpfnWndProc = BusyMobileStationsWndProc;
			Class.hInstance = g_hInstance;
			Class.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!Class.hIcon) Class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			Class.hCursor = LoadCursor(NULL, IDC_ARROW);
			Class.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			Class.lpszMenuName = NULL;
			Class.lpszClassName = g_szBusyMobileStationsName;
			RegisterClassEx(&Class);
			First = FALSE;

			RECT rc;
			HDC hdc = GetDC(hwndMain);
			TCHAR Text[] = TEXT("Port() - I:9999 O:9999\nRcv:\nXmt:\n\nt/p\nt/o\nt/i\nt/m\nt/q\nt/s\nt/t\nt/u\nt/n\nt/w: 199k 199k 199k 199k 199k 199k 199k 199k /hr");
			tHeight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			tWidth = rc.right-rc.left;
			tHeight = rc.bottom-rc.top;
			ReleaseDC(hwndMain, hdc);
		}

		char *szTitle = (char *)malloc(sizeof(*szTitle)*128);
		StringCbPrintfA(szTitle, sizeof(*szTitle)*128,
						"Busy Mobiles");

		UINT wsStatus = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;
		WINDOWPOS Pos;
		if (!RecallWindowPosition(szTitle, &Pos))
		{	RECT rc;
			SetRect(&rc, 0, 0, tWidth, tHeight);
			AdjustWindowRectEx(&rc, wsStatus&~WS_OVERLAPPED, FALSE, GetWindowLong(hwndMain,GWL_EXSTYLE));
			Pos.x = CW_USEDEFAULT;
			Pos.y = CW_USEDEFAULT;
			Pos.cx = rc.right-rc.left;
			Pos.cy = rc.bottom-rc.top;
		}

		size_t tLen = (strlen(szTitle)+1)*sizeof(TCHAR);
		TCHAR *tTitle = (TCHAR *)malloc(tLen);
		StringCbPrintf(tTitle, tLen, TEXT("%S"), szTitle);
		hwndBusyMobileStations = CreateWindow(g_szBusyMobileStationsName, tTitle, wsStatus,
									Pos.x, Pos.y, Pos.cx, Pos.cy,
									NULL, NULL, g_hInstance, NULL);
		//TraceLogThread("PortStatus", TRUE, "Created Window[%ld] %p or %S\n", pPort->wpPort, pPort->hwnd, szTitle);
		free(tTitle);
		free(szTitle);
	} else if (IsWindow(hwndBusyMobileStations))
	{	ShowWindow(hwndBusyMobileStations, SW_RESTORE);
		SetForegroundWindow(hwndBusyMobileStations);
	}
}
#endif

static char *BuildPortStatusString(int p, BOOL MultiLine)
{	size_t Remaining = wcslen(PortStatuses[p].Status)+256+64*HOURLY_PACKETS;
	char *Result = (char*)malloc(Remaining);
	char *Next = Result;

#ifdef UNDER_CE
	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld %02ld:%02ld %S",
					(long) PortStatuses[p].st.wDay, 
					(long) PortStatuses[p].st.wHour, 
					(long) PortStatuses[p].st.wMinute, 
					PortStatuses[p].Status);
#else
	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld-%02ld %02ld:%02ld:%02ld %S",
					(long) PortStatuses[p].st.wMonth, 
					(long) PortStatuses[p].st.wDay, 
					(long) PortStatuses[p].st.wHour, 
					(long) PortStatuses[p].st.wMinute, 
					(long) PortStatuses[p].st.wSecond,
					PortStatuses[p].Status);
#endif
#ifdef SUPPORT_HOURLY_PACKET_COUNT
	unsigned long ppc = GetPortPacketIndex(PortStatuses[p].wp, PortStatuses[p].Name);
	//for (ppc=0; ppc<PortPacketCount; ppc++)
	{	//if (PortStatuses[p].wp+1 == PortPackets[ppc].wpPort)
		{
			if (MultiLine)
			{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" - I:%ld O:%ld",
							(long) PortPackets[ppc].RcvPackets[0],
							(long) PortPackets[ppc].XmtPackets[0]);
				if (PortStatuses[p].SubStatus)
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"\n%S", PortStatuses[p].SubStatus);
			}
			int h;
			BOOL DidOne = FALSE;
			char *LastGood = Next;
			size_t LastRemain = Remaining;
			for (h=0; h<HOURLY_PACKETS; h++)
			{	double Display, Divisor = 1;
				int Digits=0;
				char *Suffix="";
				int Value = PortPackets[ppc].RcvPackets[h];

				if (h == 0)
				{	SYSTEMTIME stNow;
					GetSystemTime(&stNow);
					if (stNow.wMinute)
					{	Value *= 60;
						Value /= stNow.wMinute;
					}
				}

				if (Value > 1000*1000*1000)
				{	Divisor = 1000.0*1000.0*1000; Suffix = "b";
				} else if (Value > 1000*1000)
				{	Divisor = 1000.0*1000.0; Suffix = "m";
				} else if (Value > 10*1000)
				{	Divisor = 1000.0; Suffix = "k";
				} else { Divisor = 1.0; Suffix = ""; }
				Display = (double) Value/Divisor;
				if (Divisor > 1)
				{	if (Display >= 100) { Digits=0; }
					else if (Display >= 10) { Digits=1; }
					else { Digits=2; }
				} else { Digits=0; }
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%s%.*lf%s", h?" ":(MultiLine?"\n/hr ":" "), (int) Digits, (double) Display, Suffix);
				if (Display)
				{	LastGood = Next; LastRemain = Remaining; DidOne = TRUE;
				}
			}
			if (!MultiLine && DidOne)
			{	StringCbPrintfExA(LastGood, LastRemain, &LastGood, &LastRemain, STRSAFE_IGNORE_NULLS, " /hr");
			}
			*LastGood = '\0';	/* Eliminate trailing 0s */

			if (MultiLine)
			{	for (h=0; h<HOURLY_PACKETS; h++)
				if (PortPackets[ppc].DX[h].Station[0]
				&& PortPackets[ppc].DX[h].Distance)
				{	FILETIME FileTime, LocalFileTime;
					SYSTEMTIME LocalTime;
					SystemTimeToFileTime(&PortPackets[ppc].DX[h].st,&FileTime);
					FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
					FileTimeToSystemTime(&LocalFileTime, &LocalTime);

					StringCbPrintfExA(LastGood, LastRemain, &LastGood, &LastRemain, STRSAFE_IGNORE_NULLS,
								"\n       %02ld:%02ld:%02ld DX=%ld*%.*s(%.0lf%s@%ld)",
								(long) LocalTime.wHour,
								(long) LocalTime.wMinute,
								(long) LocalTime.wSecond,
								(long) PortPackets[ppc].DX[h].Count,
								STRING(PortPackets[ppc].DX[h].Station),
								(double) (PortPackets[ppc].DX[h].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
								ActiveConfig.View.Metric.Distance?"km":"mi",
								(long) PortPackets[ppc].DX[h].Bearing);
				}
			} else if (PortPackets[ppc].DXCount)
			{	StringCbPrintfExA(LastGood, LastRemain, &LastGood, &LastRemain, STRSAFE_IGNORE_NULLS,
								" DX=%ld*%.*s(%.0lf%s@%ld)",
								(long) PortPackets[ppc].DXList[0].Count,
								STRING(PortPackets[ppc].DXList[0].Station),
								(double) (PortPackets[ppc].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
								ActiveConfig.View.Metric.Distance?"km":"mi",
								(long) PortPackets[ppc].DXList[0].Bearing);
			}
			*LastGood = '\0';	/* Eliminate trailing 0s */
		}
	}
#endif
	return Result;
}
#endif

void SoundGps(HWND hwnd, BOOL newState)
{
#ifdef OPTIONS
	0xFFFFFFFF SystemDefault
    MB_ICONASTERISK SystemAsterisk
    MB_ICONEXCLAMATION SystemExclamation
    MB_ICONHAND SystemHand
    MB_ICONQUESTION SystemQuestion
    MB_OK SystemDefault
#endif
	if (newState != HadGPSFix)
	{	TraceActivity(hwnd, "GPS %s\n", newState?"LOST->Acquired":"Acquired->LOST");
		//if (ActiveConfig.Enables.Sound) MessageBeep(newState?MB_ICONHAND:MB_OK);
		if (ActiveConfig.Enables.Sound) MessageBeep(newState?MB_OK:MB_ICONWARNING);
		HadGPSFix = newState;
		GPSTransitionTransmit = TRUE;
	}
	if (HadGPSFix) CheckNotifyUsage();
}


void SoundConn(BOOL newState)
{
#ifdef OPTIONS
	0xFFFFFFFF SystemDefault
    MB_ICONASTERISK SystemAsterisk
    MB_ICONEXCLAMATION SystemExclamation
    MB_ICONHAND SystemHand
    MB_ICONQUESTION SystemQuestion
    MB_OK SystemDefault
#endif
	//if (ActiveConfig.Enables.Sound) MessageBeep(newState?MB_ICONHAND:MB_OK);
	if (ActiveConfig.Enables.Sound) MessageBeep(newState?MB_OK:MB_ICONWARNING);
}

#ifdef OLD_WAY
void EnableLogging(HWND hwnd, BOOL Enabled)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (LoggingEnabled != Enabled)
	{	if (LoggingEnabled) TraceActivity(hwnd, "File Logging Disabled\n");
		LoggingEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_LOGGING_TOGGLE, (LoggingEnabled?MF_CHECKED:MF_UNCHECKED));
		if (LoggingEnabled) TraceActivity(hwnd, "File Logging Enabled\n");
		if (ActiveConfig.Enables.Debug != LoggingEnabled)
		{	ActiveConfig.Enables.Debug = LoggingEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:Logging");
		}
	}
}
#endif

static PORT_CONFIG_INFO_S APRSISPort = {0};
static char *APRSIS_Actual = NULL;	/* From SubStatus */
static __int64 APRSIS_MSec = 0;	/* Time of SubStatus */
#define APRSISStart(p)		\
{	APRSISPort.IsEnabled = TRUE;	\
	strncpy(APRSISPort.Device, p, sizeof(APRSISPort.Device)); \
	strncpy(APRSISPort.Name, "APRS-IS", sizeof(APRSISPort.Name)); \
	strncpy(APRSISPort.Protocol, "APRSIS", sizeof(APRSISPort.Protocol)); \
	APRSISPort.QuietTime = ActiveConfig.QuietTime; \
	IncrementXmitPackets(APRSISWP, 0, APRSISPort.Name); \
	PortStart(&APRSISPort, hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, APRSISWP); \
}
#define APRSISStop() PortStop(&APRSISPort,APRSISWP)

void EnableAPRS(HWND hwnd, BOOL Enabled)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (APRSEnabled != Enabled)
	{	APRSEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_APRS_TOGGLE, (APRSEnabled?MF_CHECKED:MF_UNCHECKED));
		InvalidateRect(hwnd, NULL, FALSE);
		if (APRSEnabled && ActiveConfig.Enables.Internet)
		{	APRSISStart(ActiveConfig.APRSIS.Port);
		} else if (APRSISStop() && *APRSISPort.Name)
			PostMessage(hwnd, WM_PORT_STATUS, MAKELONG(APRSISWP,1), (LPARAM) _strdup("Disabled"));

		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.APRSIS != APRSEnabled)
		{
#ifdef THIS_NEVER_GOES_OUT
			if (!APRSEnabled && LastIGateTransmitted)	/* Did we send any out?  If so, attempt a "DISABLED" */
			{	char Buffer[128];
				if (SUCCEEDED(StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s:<IGATE,DISABLED\n",
								CALLSIGN, DESTID, *PATH?",":"", PATH)))
				{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
					QueueToTransmit(CAPABILITY_PACKET, Buffer, FALSE, ActiveConfig.Enables.APRSIS);
					Sleep(500);	/* give it a chance to get transmitted at least */
				} else TraceError(hwnd, "IGATE Format Failed!\n");
			}
#endif
			ActiveConfig.Enables.APRSIS = APRSEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:APRS");
		}
		FixIGateEnabled();
	}
#ifdef SUPPORT_APRSTRACE
	if (!APRSEnabled)
	{	if (!APRSTraceFile)
			APRSTraceFile = fopen(GetAPRSTraceFile(hwnd),"a+t");
	} else if (APRSTraceFile)
	{	fclose(APRSTraceFile);
		APRSTraceFile = NULL;
	}
#endif
}

static void TriggerTelemetry(HWND hwnd);

void EnableTelemetry(HWND hwnd, BOOL Enabled)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (TelemetryEnabled != Enabled)
	{	TelemetryEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_TELEMETRY_TOGGLE, (TelemetryEnabled?MF_CHECKED:MF_UNCHECKED));
		if (TelemetryEnabled)
		{	TriggerTelemetry(hwnd);
			if (!ActiveConfig.Enables.Telemetry)	/* If we're enabling fromd disable, trigger a definition */
				memset(&ActiveConfig.Telemetry.Defined,0,sizeof(ActiveConfig.Telemetry.Defined));
		}
		if (ActiveConfig.Enables.Telemetry != TelemetryEnabled)
		{	ActiveConfig.Enables.Telemetry = TelemetryEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:Telemetry");
		}
	}
}

static PORT_CONFIG_INFO_S GPSPort = {0};
#define GPSWP 5678
#define GPSStart(p)		\
{	GPSPort.IsEnabled = TRUE; \
	strncpy(GPSPort.Name, "NMEA", sizeof(GPSPort.Name)); \
	strncpy(GPSPort.Device, p, sizeof(GPSPort.Device)); \
	strncpy(GPSPort.Protocol, "NMEA", sizeof(GPSPort.Protocol)); \
	GPSPort.QuietTime = 10; \
	IncrementXmitPackets(GPSWP, 0, GPSPort.Name); \
	PortStart(&GPSPort, hwnd, WM_PORT_STATUS, 0, 0, WM_PORT_XMIT_COUNT, GPSWP); \
}
#define GPSStop() PortStop(&GPSPort,GPSWP)

BOOL HasNMEAPort(void)
{
	if (ActiveConfig.GPSPort[0]) return TRUE;
	for (unsigned int i=0; i<ActiveConfig.RFPorts.Count; i++)
	{	if (ActiveConfig.RFPorts.Port[i].ProvidesNMEA)
			return TRUE;
	}
	return FALSE;
}

void EnableGPS(HWND hwnd, BOOL Enabled, BOOL First)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

#ifndef UNDER_CE
	if (!HasNMEAPort()) Enabled = FALSE;
	EnableMenuItem(cInfo->hMenu, ID_GPS_TOGGLE, (HasNMEAPort()?MF_ENABLED:MF_GRAYED));
#endif

	if (GPSEnabled != Enabled || First)
	{	GPSEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_GPS_TOGGLE, (GPSEnabled?MF_CHECKED:MF_UNCHECKED));
		// EnableMenuItem(cInfo->hMenu, ID_TRANSMIT, (GPSEnabled?MF_ENABLED:MF_GRAYED));
		if (ActiveConfig.GPSPort[0])
		{	TraceError(hwnd, "%sabling NMEA GPS\n", Enabled?"En":"Dis");
			if (GPSEnabled)
			{	if (!GPSRunning) GPSStart(ActiveConfig.GPSPort);
			} else if (GPSRunning && GPSStop() && *GPSPort.Name)
				PostMessage(hwnd, WM_PORT_STATUS, MAKELONG(GPSWP,1), (LPARAM) _strdup("Disabled"));
			GPSRunning = GPSEnabled;
		}
#ifdef USING_GPSAPI
		else
		{
			TraceError(hwnd, "%sabling GPSapi\n", Enabled?"En":"Dis");
			if (GPSEnabled)
			{	hGPS = GPSOpenDevice(NULL, NULL, NULL, 0);
				if (!hGPS)
				{	MessageBox(hwnd,TEXT("GPSOpenDevice Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);
					GPSEnabled = FALSE;
				}
			
				gpsDevice.dwVersion = GPS_VERSION_1;
				gpsDevice.dwSize = sizeof(gpsDevice);
				if (GPSGetDeviceState(&gpsDevice) == ERROR_SUCCESS)
				{	FILETIME localFileTime;
					FileTimeToLocalFileTime(&gpsDevice.ftLastDataReceived, &localFileTime);
					SYSTEMTIME st;
					FileTimeToSystemTime(&localFileTime, &st);
					TraceActivityBegin(hwndMain, "GPSdev2 dwServiceState: 0x%lX dwDeviceState: 0x%lX\n",
								(long) gpsDevice.dwServiceState, (long) gpsDevice.dwDeviceState);
					TraceActivity(hwndMain, "GPSdev2 LastDataReceived: %04ld-%02ld-%02ldT%02ld:%02ld:%02ld ",
									(long) st.wYear, (long) st.wMonth, (long) st.wDay, 
									(long) st.wHour, (long) st.wMinute, (long) st.wSecond);
					TraceActivityEnd(hwndMain, "GPSdev2 DriverPrefix: %S MultiplexPrefix: %S FriendlyName: %S\n",
								gpsDevice.szGPSDriverPrefix, gpsDevice.szGPSMultiplexPrefix, gpsDevice.szGPSFriendlyName);
				} else
				{	TraceError(hwndMain, "GPSGetDeviceState Failed With %ld\n", (long) GetLastError());
				}
			} else if (hGPS)
			{	GPSCloseDevice(hGPS);
				hGPS = NULL;
				GPSStop();	/* Just in case we were running NMEA */
			}
		}
#endif
		if (ActiveConfig.Enables.AutoSaveGPX && !ActiveConfig.Enables.GPS
		&& MyStation && MyStation->TrackCount)
			SaveTrackToGPX(hwnd, MyStation);
		TriggerTelemetry(hwnd);
		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.GPS != GPSEnabled)
		{	ActiveConfig.Enables.GPS = GPSEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:GPS");
		}
		ShuffleScreenElements(hwnd);	/* Just for good measure */
	}
	if (GPSEnabled && BeaconSuspended)
	{	if (ActiveConfig.Beacon.AfterTransmit)	/* Put the screen back */
		{	cInfo->LastCenterPosition.dblLatitude = OriginalScreen.lat;
			cInfo->LastCenterPosition.dblLongitude = OriginalScreen.lon;
			cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
			cInfo->zoom = OriginalScreen.zoom;
			cInfo->CenterTracking = FALSE;	/* No longer tracking ME */
			TransmitFilter();
			InvalidateStationPoints(cInfo->Index,"SetCenter",TRUE);
			InvalidateCenter(hwnd, TRUE);
			cInfo->msLastSigChange = llGetMsec();
		}
		BeaconSuspended = FALSE;
		if (hwndFirstRun) DestroyWindow(hwndFirstRun);
	}
}

void EnableCSV(HWND hwnd, BOOL Enabled, BOOL First)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (CSVEnabled != Enabled || First)
	{	CSVEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_CSV_TOGGLE, (CSVEnabled?MF_CHECKED:MF_UNCHECKED));

		if (ActiveConfig.Enables.CSVFile != CSVEnabled)
		{	ActiveConfig.Enables.CSVFile = CSVEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:CSVFile");
		}
	}
	if (CSVEnabled)
	{	if (!CSVTrackFile)
		{	if (!CSVTrackFileName)
				CSVTrackFileName = GetTrackFileName(hwnd);
			CSVTrackFile = fopen(CSVTrackFileName,"a+t");
		}
	} else if (CSVTrackFile)
	{	fclose(CSVTrackFile);
		CSVTrackFile = NULL;
		CSVTrackFileName = NULL;	/* Force a new name next time */
	}
}

#ifdef OBSOLETE
void EnableAGW(HWND hwnd, BOOL Enabled, BOOL First)
{
	if (!ActiveConfig.AGWPort[0]) Enabled = FALSE;
	EnableMenuItem(cInfo->hMenu, ID_AGW_TOGGLE, (ActiveConfig.AGWPort[0]?MF_ENABLED:MF_GRAYED));

	if (AGWEnabled != Enabled || First)
	{	AGWEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_AGW_TOGGLE, (AGWEnabled?MF_CHECKED:MF_UNCHECKED));
		if (AGWEnabled)
			AGWStart(hwnd, WM_PORT_RECEIVED, ActiveConfig.AGWPort);
		else AGWStop();
		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.AGW != AGWEnabled)
		{	ActiveConfig.Enables.AGW = AGWEnabled;
			SaveConfiguration(hwnd, &ActiveConfig);
		}
	}
}
#endif

#ifdef OBSOLETE
void EnableKISS(HWND hwnd, BOOL Enabled, BOOL First)
{
	if (!ActiveConfig.KISSPort[0]) Enabled = FALSE;
	EnableMenuItem(cInfo->hMenu, ID_KISS_TOGGLE, (ActiveConfig.KISSPort[0]?MF_ENABLED:MF_GRAYED));

	if (KISSEnabled != Enabled || First)
	{	KISSEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_KISS_TOGGLE, (KISSEnabled?MF_CHECKED:MF_UNCHECKED));
		if (KISSEnabled)
			KISSStart(hwnd, WM_PORT_RECEIVED, ActiveConfig.KISSPort);
		else KISSStop();
		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.KISS != KISSEnabled)
		{	ActiveConfig.Enables.KISS = KISSEnabled;
			SaveConfiguration(hwnd, &ActiveConfig);
		}
	}
}
#endif

#ifdef OBSOLETE
void EnableTEXT(HWND hwnd, BOOL Enabled, BOOL First)
{
	if (!ActiveConfig.TEXTPort[0]) Enabled = FALSE;
	EnableMenuItem(cInfo->hMenu, ID_TEXT_TOGGLE, (ActiveConfig.TEXTPort[0]?MF_ENABLED:MF_GRAYED));

	if (TEXTEnabled != Enabled || First)
	{	TEXTEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_TEXT_TOGGLE, (TEXTEnabled?MF_CHECKED:MF_UNCHECKED));
		if (TEXTEnabled)
			TEXTStart(hwnd, WM_PORT_RECEIVED, ActiveConfig.TEXTPort);
		else TEXTStop();
		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.TEXT != TEXTEnabled)
		{	ActiveConfig.Enables.TEXT = TEXTEnabled;
			SaveConfiguration(hwnd, &ActiveConfig);
		}
	}
}
#endif

void EnableOSMFetch(HWND hwnd, BOOL Enabled, BOOL First)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (OSMFetchEnabled != Enabled || First)
	{	if (Enabled)
		{
			if (VerifyOSMPath(hwnd, &ActiveConfig.OSM, FALSE, NULL))
			{	OSMSetTileServerInfo(hwnd, WM_TILES_LOADED, &ActiveConfig.OSM,
									ActiveConfig.OSMMinMBFree);
				OSMSetPurgeEnable(!ActiveConfig.OSMPurgeDisabled);
			} else Enabled = FALSE;
		}
		OSMFetchEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_OSM_TOGGLE, (OSMFetchEnabled?MF_CHECKED:MF_UNCHECKED));
		OSMSetFetchEnable(OSMFetchEnabled && ActiveConfig.Enables.Internet);
		if (OSMFetchEnabled && ActiveConfig.Enables.Internet)
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (cInfo)
			{	if (cInfo->ts) OSMFreeTileSet(cInfo->ts); cInfo->ts = NULL;
				PostMessage(hwnd, WM_TILES_LOADED, -1, 0);
			}
		}
		InvalidateRect(hwnd, NULL, FALSE);
		if (ActiveConfig.Enables.OSMFetch != OSMFetchEnabled)
		{	ActiveConfig.Enables.OSMFetch = OSMFetchEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:OSM:Fetch");
		}
	}
}

void EnableBeaconing(HWND hwnd, BOOL Enabled)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (BeaconEnabled != Enabled)
	{	BeaconEnabled = Enabled;
		CheckMenuItem (cInfo->hMenu, ID_BEACON_TOGGLE, (BeaconEnabled?MF_CHECKED:MF_UNCHECKED));
		EnableMenuItem(cInfo->hMenu, ID_TRANSMIT, (BeaconEnabled?MF_ENABLED:MF_GRAYED));
		if (BeaconEnabled)
		{	ForceTransmit = TRUE;
		}
		if (ActiveConfig.Enables.Beacons != BeaconEnabled)
		{	ActiveConfig.Enables.Beacons = BeaconEnabled;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:Beacons");
		}
	}
}

static char *Check4Version(void)
{	int BufLen, URLen = strlen(PROGNAME)*3+8;
	char *Buf, *URL = (char*)malloc(URLen);
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;

	StringCbPrintfA(URL, URLen, "/%s/%s.%s", PROGNAME, PROGNAME, ActiveConfig.Update.Development?"development":"release");
	Buf = httpGetBuffer(NULL, "aprsisce.dnsalias.net", 80, URL, &BufLen, CALLSIGN);
	free(URL);
	if (Buf)
	{	int i=0;
		if (isdigit(Buf[i]&0xff) && isdigit(Buf[i+1]&0xff) && isdigit(Buf[i+2]&0xff) && isdigit(Buf[i+3]&0xff)
		&& Buf[i+4] == '/' && isdigit(Buf[i+5]&0xff) && isdigit(Buf[i+6]&0xff)
		&& Buf[i+7] == '/' && isdigit(Buf[i+8]) && isdigit(Buf[i+9]&0xff)
		&& Buf[i+10] == ' ' && isdigit(Buf[i+11]&0xff) && isdigit(Buf[i+12]&0xff)
		&& Buf[i+13] == ':' && isdigit(Buf[i+14]&0xff) && isdigit(Buf[i+15]&0xff))
		{	TraceLogThread("Version", TRUE, "Check4Version:New(%s) Me(%s)\n", Buf, Timestamp);
DebugTimer("Check4Version","GotVersion",Start,&msMax,&msLast,NULL);
			return Buf;	/* And return it! */
		} else TraceLogThread("Version", TRUE, "Check4Version(%s) Isn't a Timestamp\n", Buf);
	} else TraceLogThread("Version", TRUE, "Check4Version:New Version Check Failed!\n");
	free(Buf);
DebugTimer("Check4Version","Failed",Start,&msMax,&msLast,NULL);
	return NULL;
}

static BOOL GetNewEXE(HWND hwnd, char *NewVers)
{	char *OrgVers = NewVers;
	int BufLen, URLen = strlen(PROGNAME)*3+80;
	char *p, *Buffer, *URL = (char*)malloc(URLen);
	unsigned long ExpectedCRC;
	BOOL Result = FALSE;
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;

	if (!ActiveConfig.Enables.Internet) return FALSE;

//	if (APRSEnabled) APRSISStop();	/* Take the burden off the network */
//Start = DebugTimer("GetNewEXE","Stop APRS-IS",Start,&msMax,&msLast,hwnd);

	NewVers = _strdup(NewVers);
	for (p=NewVers; *p; )
	{	if (!isdigit(*p&0xff)) memmove(p, p+1, strlen(p));
		else p++;
	}
/*
	1,345,536 aprsis32.exe.201003050438
        8 aprsis32.exe.201003050438.crc
       16 aprsis32.exe.201003050438.ver
*/

	StringCbPrintfA(URL, URLen, "/%s/%s.exe.%s.crc", PROGNAME, PROGNAME, NewVers);
	Buffer = httpGetBuffer(hwnd, "aprsisce.dnsalias.net", 80, URL, &BufLen, CALLSIGN);
	if (Buffer)
	{	char *e, x;
		ExpectedCRC = strtoul(Buffer,&e,16); x = *e;
		TraceLog("Version", TRUE, hwnd, "CRC(%s) = 0x%lX\n", Buffer, (long) ExpectedCRC);
		if (!x)	/* Conversion was ok */
		{	unsigned long CRC = ~ExpectedCRC;	/* Make sure it's worng */
			char *Error = NULL;
			free(Buffer);
			StringCbPrintfA(URL, URLen, "/%s/%s.exe.%s", PROGNAME, PROGNAME, NewVers);
//#ifndef UNDER_CE	/* Win32 tries the cached route (the .EXE is bigger)
			Buffer = httpGetBuffer(hwnd, "aprsisce.dnsalias.net.nyud.net", 80, URL, &BufLen, CALLSIGN, TRUE, &Error);
			if (Buffer)
			{	CRC = CRC32((unsigned char *)Buffer, BufLen);
				TraceLog("Version", TRUE, hwnd, "Coral Got %ld Bytes of %s.exe, %s CRC=0x%lX Expected 0x%lX\n",
							(long) BufLen, PROGNAME,
							CRC==ExpectedCRC?"OK":"BAD", (long) CRC, (long) ExpectedCRC);
				if (CRC != ExpectedCRC)
				{static	char Temp[80];
					if (BufLen >= 6
					&& isprint(Buffer[0]&0xff)
					&& isprint(Buffer[1]&0xff)
					&& isprint(Buffer[2]&0xff)
					&& isprint(Buffer[3]&0xff)
					&& isprint(Buffer[4]&0xff)
					&& isprint(Buffer[5]&0xff))
						StringCbPrintfA(Temp, sizeof(Temp),
									"BadCRC(%ld:%.6s)",
									(long) BufLen, Buffer);
					else StringCbPrintfA(Temp, sizeof(Temp),
									"Invalid CRC(%ldb)",
									(long) BufLen);
					free(Buffer);
					Buffer = NULL;
					Error = Temp;
				}
			}

			if (Buffer)
			{	static char dBuffer[256];
				StringCbPrintfA(dBuffer,sizeof(dBuffer), "CoralCDN Delivered %ldb for %s",
								(long) BufLen, OrgVers);
				QueueDebugMessage(llGetMsec(), dBuffer);
			}

			if (!Buffer)	/* If that doesn't work, fall into direct get */
			{static char dBuffer[256];
				StringCbPrintfA(dBuffer,sizeof(dBuffer), "CoralCDN (Cache) Fetch Failed(%s), Retrying Direct",
								Error?Error:"NULL");
				QueueDebugMessage(llGetMsec(), dBuffer);
				//if (MessageBox(hwnd, TEXT("Coral CDN (Cache) Fetch Failed, Retry Direct?"), TEXT("GetNewEXE"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				TraceLog("Version", TRUE, hwnd, "Coral CDN (Cache) Fetch Failed, Retrying Direct.");
				{	Error = NULL;
					Buffer = httpGetBuffer(hwnd, "aprsisce.dnsalias.net", 80, URL, &BufLen, CALLSIGN, TRUE, &Error);
					if (Buffer)
					{	CRC = CRC32((unsigned char *)Buffer, BufLen);
						TraceLog("Version", TRUE, hwnd, "Direct Got %ld Bytes of %s.exe, %s CRC=0x%lX Expected 0x%lX\n",
								(long) BufLen, PROGNAME,
								CRC==ExpectedCRC?"OK":"BAD", (long) CRC, (long) ExpectedCRC);
						if (CRC != ExpectedCRC)
						{	free(Buffer);
							Buffer = NULL;
							Error = "Invalid CRC";
						}
					}
				}
			}
//#endif
			if (Buffer)
			{
				if (CRC == ExpectedCRC)
				{	if (OriginalPath[0]	/* Already got one during load */
					|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
					{	size_t Size = sizeof(TCHAR)*(wcslen(OriginalPath)+80);
						TCHAR *uNewFile = (TCHAR*)malloc(Size);
						char *Vers = _strdup(Timestamp);
						for (p=Vers; *p; )
						{	if (!isdigit(*p&0xff)) memmove(p, p+1, strlen(p));
							else p++;
						}

						TraceLog("Version", TRUE, hwnd, "GetModuleFileName(%S)\n", OriginalPath);

						StringCbPrintf(uNewFile,Size,TEXT("%s.%S"), OriginalPath, Vers);

						TraceLog("Version", TRUE, hwnd,"uNewFile=%S\n", uNewFile);
#ifdef UNDER_CE
						if (!DeleteFile(uNewFile))
							TraceLog("Version", TRUE, hwndMain, "Delete(%S) Failed with %ld!\n", uNewFile, (long) GetLastError());
						if (!MoveFile(OriginalPath,uNewFile))
							TraceLog("Version", TRUE, hwndMain, "Move(%S) to %S Failed with %ld!\n", OriginalPath, uNewFile, (long) GetLastError());
#else
						if (!MoveFileEx(OriginalPath,uNewFile,MOVEFILE_REPLACE_EXISTING))
						{	TraceLog("Version", TRUE, hwnd, "Move %S to %S Failed with %ld\n", OriginalPath, uNewFile, GetLastError());
						} else TraceLog("Version", TRUE, hwnd, "Move %S to %S Succeeded!\n", OriginalPath, uNewFile);
#endif
						free(uNewFile);

						{	char *OutName = (char*)malloc(MAX_PATH);
							StringCbPrintfA(OutName, MAX_PATH, "%S", OriginalPath);
							FILE *Out = fopen(OutName,"wb");
							if (Out)
							{	if (fwrite(Buffer, 1, BufLen, Out) == (size_t) BufLen)
								{	Result = TRUE;
								} else TraceLog("Version", TRUE, hwnd, "Failed To write %ld Bytes to %s\n", (long) BufLen, OutName);
								fclose(Out);
							} else TraceLog("Version", TRUE, hwnd, "Failed To Create %s\n", OutName);
							free(OutName);
						}
					} else TraceLog("Version", TRUE, hwnd, "GetModuleFileName Failed!\n");
				} else TraceLog("Version", TRUE, hwnd, "Expected CRC 0x%lX Got 0x%lX\n", (long) ExpectedCRC, (long) CRC);
			} else
			{static char dBuffer[256];
				StringCbPrintfA(dBuffer,sizeof(dBuffer), "DIRECT Fetch Failed(%s)",
								Error?Error:"NULL");
				QueueDebugMessage(llGetMsec(), dBuffer);
				TraceLog("Version", TRUE, hwnd, "Failed To Get %s\n", URL);
			}
		} else TraceLog("Version", TRUE, hwnd, "Failed To Convert CRC(%s)\n", Buffer);
		free(Buffer);
	} else TraceLog("Version", TRUE, hwnd, "Failed To Get %s\n", URL);
	free(URL);
Start = DebugTimer("GetNewEXE",Result?"Success":"Failed",Start,&msMax,&msLast,hwnd);

//	if (APRSEnabled) APRSISStart(ActiveConfig.APRSIS.Port);
//Start = DebugTimer("GetNewEXE","Start APRS-IS",Start,&msMax,&msLast,hwnd);

	return Result;
}

static BOOL Check4NewVersion(HWND hwnd)
{	char *NewVersion = Check4Version();
	BOOL Result = FALSE;

	if (NewVersion)
	{	if (strcmp(Timestamp,NewVersion) != 0)
		{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
#ifdef TRAKVIEW
			TCHAR Title[] = TEXT("TrakView32 Version");
			StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("TrakView32 Client\nBuilt: %S\n\n%S Version Available!\nBuilt: %S\n\nDownload it?"), VERSION, strcmp(Timestamp,NewVersion)<0?"New":"RetroGrade", NewVersion);
#else
			TCHAR Title[] = TEXT("APRSISCE/32 Version");
			StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("APRS-IS Client by KJ4ERJ\nBuilt: %S\n\n%S Version Available!\nBuilt: %S\n\nDownload it?"), VERSION, strcmp(Timestamp,NewVersion)<0?"New":"RetroGrade", NewVersion);
#endif
			if (MessageBox(hwnd, Buffer, Title, MB_YESNO | MB_ICONQUESTION) == IDYES)
				{		Result = GetNewEXE(hwnd, NewVersion);
					if (!Result)
						MessageBox(hwnd, TEXT("Download Failed"), Title, MB_OK | MB_ICONERROR);
			}
			free(Buffer);
		}
		free(NewVersion);
	}
	return Result;
}

/*static void myMessageCallback(void *userarg, char *from, char *message); */

static unsigned __int64 Check4UpdateElapsed;

#ifdef UNDER_CE
DWORD Check4UpdateThread(LPVOID pvParam)
#else
DWORD WINAPI Check4UpdateThread(LPVOID pvParam)
#endif
{	char *NewVersion;

	SetTraceThreadName("Check4UpdateThread");

	NewVersion = Check4Version();

	if (NewVersion)
	{	TraceLogThread("Version", TRUE, "Check4UpdateThread:New(%s) Running(%s) LastSeen(%s)\n",
					NewVersion, Timestamp, ActiveConfig.Update.LastSeen);
		GetSystemTime(&ActiveConfig.Update.LastCheck);
		if (strcmp(Timestamp,NewVersion) < 0)	/* NEW version available! */
		{	if (strcmp(ActiveConfig.Update.LastSeen,NewVersion))	/* Something new is out there! */
			{	char *Buffer = (char *) malloc(256);
				TraceLogThread("Version", TRUE, "Check4UpdateThread:New(%s) Running(%s) LastSeen(%s), INFORMING!\n",
							NewVersion, Timestamp, ActiveConfig.Update.LastSeen);
				StringCbPrintfA(Buffer, 256, "%s Version %s Available, Please Check About",
								ActiveConfig.Update.Development?"DEVELOPMENT":"NEW", NewVersion);
				QueueInternalMessage(Buffer, TRUE);
				GetSystemTime(&ActiveConfig.Update.LastReminder);
			} else
			{	FILETIME ftNow, ftCheck;
				unsigned __int64 ullNow, Check4ReminderElapsed;

#ifdef UNDER_CE
				GetCurrentFT(&ftNow);
#else
				GetSystemTimeAsFileTime(&ftNow);
#endif
				ullNow = ((unsigned __int64) ftNow.dwHighDateTime)<<32 | ftNow.dwLowDateTime;

				SystemTimeToFileTime(&ActiveConfig.Update.LastReminder, &ftCheck);

				Check4ReminderElapsed = ((unsigned __int64) ftCheck.dwHighDateTime)<<32 | ftCheck.dwLowDateTime;
				Check4ReminderElapsed = ullNow - Check4ReminderElapsed;	/* Delta time before now */
				Check4ReminderElapsed /= 10;	/* 1000 nanosec = microsec */
				Check4ReminderElapsed /= 1000;	/* 1000 microsec = millisec */
				Check4ReminderElapsed /= 1000;	/* 1000 millisec = seconds */

				if (Check4ReminderElapsed >= ((unsigned __int64)ActiveConfig.Update.ReminderInterval)*24L*60L*60L)
				{	char *Buffer = (char *) malloc(256);
					TraceLogThread("Version", TRUE, "Check4UpdateThread:New(%s) Running(%s) LastSeen(%s), REMINDING!\n",
								NewVersion, Timestamp, ActiveConfig.Update.LastSeen);
					StringCbPrintfA(Buffer, 256, "Version %s Still Available, Please Check About", NewVersion);
					QueueInternalMessage(Buffer, TRUE);
					GetSystemTime(&ActiveConfig.Update.LastReminder);
				} else
				{	TraceLogThread("Version", TRUE, "Check4UpdateThread:Elapsed %.0lf Not time For Reminder %.0lf\n",
								(double) (__int64)Check4ReminderElapsed, (double) (__int64) ((unsigned __int64)ActiveConfig.Update.ReminderInterval)*24L*60L*60L);
				}
			}
		} else TraceLogThread("Version", TRUE, "Check4UpdateThread:Running(%s) Current Version(%s), no update available\n",
							Timestamp, NewVersion);
		strncpy(ActiveConfig.Update.LastSeen, NewVersion, sizeof(ActiveConfig.Update.LastSeen));
		free(NewVersion);
	} else TraceLogThread("Version", TRUE, "Check4UpdateThread:Failed To Get NewVersion, Not remembering\n");
	return 0;
}

static __int64 LastUpdateCheck = 0;
static void Check4Updates(HWND hwnd)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	__int64 msNow = llGetMsec();

	if (!ActiveConfig.Enables.Internet) return;	/* Don't even think about it */
	if (!ActiveConfig.Update.AutoCheck) return;	/* Not doing it */

	if (!LastUpdateCheck) LastUpdateCheck = msNow - 60*60*1000 + 5*60*1000;	/* Trigger in 5 minutes */

	if (llMsecSince(LastUpdateCheck, msNow) >= 60*60*1000)	/* every 60 minutes, see if it's time */
	{	SYSTEMTIME stNow;
		FILETIME ftNow, ftCheck;
		unsigned __int64 ullNow;

		LastUpdateCheck = msNow;	/* Remember this one, we're checking! */

		GetSystemTime(&stNow);

#ifdef UNDER_CE
		GetCurrentFT(&ftNow);
#else
		GetSystemTimeAsFileTime(&ftNow);
#endif
		ullNow = ((unsigned __int64) ftNow.dwHighDateTime)<<32 | ftNow.dwLowDateTime;

		SystemTimeToFileTime(&ActiveConfig.Update.LastCheck, &ftCheck);

		Check4UpdateElapsed = ((unsigned __int64) ftCheck.dwHighDateTime)<<32 | ftCheck.dwLowDateTime;
		Check4UpdateElapsed = ullNow - Check4UpdateElapsed;	/* Delta time before now */
		Check4UpdateElapsed /= 10;	/* 1000 nanosec = microsec */
		Check4UpdateElapsed /= 1000;	/* 1000 microsec = millisec */
		Check4UpdateElapsed /= 1000;	/* 1000 millisec = seconds */

#ifdef VERBOSE
		TraceLog("Version", TRUE, hwnd, "Check4Updates:LastCheck(%04ld-%02ld-%02ldT%02ld:%02ld:%02ld) Now(%04ld-%02ld-%02ldT%02ld:%02ld:%02ld) Delta=%.0lf seconds\n",
			(long) ActiveConfig.Update.LastCheck.wYear, 
			(long) ActiveConfig.Update.LastCheck.wMonth, 
			(long) ActiveConfig.Update.LastCheck.wDay, 
			(long) ActiveConfig.Update.LastCheck.wHour, 
			(long) ActiveConfig.Update.LastCheck.wMinute, 
			(long) ActiveConfig.Update.LastCheck.wSecond, 
			(long) stNow.wYear, 
			(long) stNow.wMonth, 
			(long) stNow.wDay, 
			(long) stNow.wHour, 
			(long) stNow.wMinute, 
			(long) stNow.wSecond, 
			(double) Elapsed);
#endif

		if (Check4UpdateElapsed >= ((unsigned __int64)ActiveConfig.Update.CheckInterval)*60L*60L*(ActiveConfig.Update.Development?(IsSameBaseCallsign(CALLSIGN,"KJ4ERJ")?1:12):24))
		{	TraceLog("Version", TRUE, hwnd, "Check4Updates:Starting Check4UpdateThread\n");
			CloseHandle(CreateThread(NULL, 0, Check4UpdateThread, (LPVOID) hwnd, 0, NULL));
		}
#ifdef VERBOSE
		else TraceLog("Version", TRUE, hwnd, "Check4Updates:LastCheck(%04ld-%02ld-%02ldT%02ld:%02ld:%02ld) Now(%04ld-%02ld-%02ldT%02ld:%02ld:%02ld) Delta=%.0lf  < %.0lf\n",
			(long) ActiveConfig.Update.LastCheck.wYear, 
			(long) ActiveConfig.Update.LastCheck.wMonth, 
			(long) ActiveConfig.Update.LastCheck.wDay, 
			(long) ActiveConfig.Update.LastCheck.wHour, 
			(long) ActiveConfig.Update.LastCheck.wMinute, 
			(long) ActiveConfig.Update.LastCheck.wSecond, 
			(long) stNow.wYear, 
			(long) stNow.wMonth, 
			(long) stNow.wDay, 
			(long) stNow.wHour, 
			(long) stNow.wMinute, 
			(long) stNow.wSecond, 
			(double) Check4UpdateElapsed,
			(double) ActiveConfig.Update.CheckInterval*24.0*60.0*60.0);
#endif
	}
}

static void AutoZoomMultiLine(HWND hwnd, BOOL ShowAll = FALSE);

static TCHAR *GetNWSIssued(STATION_INFO_S *Station, int *pday, int *phour, int *pminute)
{	*pday = *phour = *pminute = 0;
	if (!Station->isNWS || !Station->sComment) return NULL;
	TCHAR *c = wcsrchr(Station->pComment,TEXT('{'));
	if (!c) return NULL;	/*	See if it has an NWS comment */
static TCHAR Key[] = TEXT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
/* The first three characters are the "issue time" compressed by assigning 0-9 as themselves, A-Z as 10 thru 35, a-x as 36-59, where it is DHM (Day of the Month-Hour in 24 hour format and Minute). Up to 16 this reads as hexadecimal so {A8B** was issued on the 10th at 08:11 Z. */
	int l = wcslen(c);
	if (l>1) *pday = wcschr(Key, c[1]) - Key;
	if (l>2) *phour = wcschr(Key, c[2]) - Key;
	if (l>3) *pminute = wcschr(Key, c[3]) - Key;
	while (c > Station->pComment && *c==TEXT(' ')) c--;
	return c;
}

/*	Returns TRUE if the station was updated */
static BOOL FixNWSIssueKill(STATION_INFO_S *Station, SYSTEMTIME *pstWhen, BOOL First=FALSE)
{//	SYSTEMTIME myNow;
	BOOL Updated = FALSE;

/*	Self-protection */
	if (!Station->isNWS || !Station->sComment) return FALSE;

/*	If caller hasn't provided, get our own */
//	if (!pstNow)
//	{	pstNow = &myNow;
//		GetSystemTime(pstNow);
//	}

	if (First)
	{	int day, hour, minute;
		if (GetNWSIssued(Station, &day, &hour, &minute))
		{	NWS_TIMES_S *pTime = Station->pNWSTimes;

			if (!Station->pNWSTimes)
				pTime = Station->pNWSTimes = (NWS_TIMES_S *)calloc(1,sizeof(*Station->pNWSTimes));

			pTime->stIssued = *pstWhen;
			pTime->stIssued.wDay = day;
			pTime->stIssued.wHour = hour;
			pTime->stIssued.wMinute = minute;
			pTime->stIssued.wSecond = pTime->stIssued.wMilliseconds = 0;
			if (pstWhen->wDay+14 < pTime->stIssued.wDay)	/* Last month? */
			{	if (!--pTime->stIssued.wMonth)
				{	pTime->stIssued.wMonth = 12;
					pTime->stIssued.wYear--;
				}
			} else if ((int)(pstWhen->wDay-14) > pTime->stIssued.wDay)	/* Next month? */
			{	if (++pTime->stIssued.wMonth > 12)
				{	pTime->stIssued.wMonth = 1;
					pTime->stIssued.wYear++;
				}
			}

			pTime->stExpires = *pstWhen;
			pTime->stExpires.wDay = Station->Time.day;
			pTime->stExpires.wHour = Station->Time.hour;
			pTime->stExpires.wMinute = Station->Time.minute;
			pTime->stExpires.wSecond = pTime->stExpires.wMilliseconds = 0;
			if (pstWhen->wDay+14 < pTime->stExpires.wDay)	/* Last month? */
			{	if (!--pTime->stExpires.wMonth)
				{	pTime->stExpires.wMonth = 12;
					pTime->stExpires.wYear--;
				}
			} else if (pstWhen->wDay-14 > pTime->stExpires.wDay)	/* Next month? */
			{	if (++pTime->stExpires.wMonth > 12)
				{	pTime->stExpires.wMonth = 1;
					pTime->stExpires.wYear++;
				}
			}

			char Temp[80];
			TraceLogThread("NWS-Debug", FALSE, "NWS(%s) %s %4ld-%02ld-%02ld %02ld:%02ld:%02ld %s %4ld-%02ld-%02ld %02ld:%02ld:%02ld, Valid %s from %02ld%02ld%02ld %.*S\n",
						Station->Station,
						DeltaSeconds(&pTime->stIssued, pstWhen)>=0?(Station->isNWSIssued?"ISSUED":"Issued"):"Forecast",
						pTime->stIssued.wYear, 
						pTime->stIssued.wMonth, 
						pTime->stIssued.wDay, 
						pTime->stIssued.wHour, 
						pTime->stIssued.wMinute, 
						pTime->stIssued.wSecond, 
						DeltaSeconds(&Station->pNWSTimes->stExpires, pstWhen) >= 0?"EXPIRED":"Expires",
						pTime->stExpires.wYear, 
						pTime->stExpires.wMonth, 
						pTime->stExpires.wDay, 
						pTime->stExpires.wHour, 
						pTime->stExpires.wMinute, 
						pTime->stExpires.wSecond, 
						FormatDeltaTime(DeltaSeconds(&pTime->stIssued,&pTime->stExpires),
										Temp, sizeof(Temp)),
						Station->Time.day, Station->Time.hour, Station->Time.minute,
						(int) Station->sComment, Station->pComment);
		}
	}

	if (!Station->pNWSTimes) return FALSE;	/* No time to work from */

	if (!Station->isNWSIssued)
	{	if (Station->isNWSIssued = (DeltaSeconds(&Station->pNWSTimes->stIssued, pstWhen) >= 0))
		{	Updated = TRUE;
			NWS_TIMES_S *pTime = Station->pNWSTimes;
			char Temp[80];
			TraceLogThread("NWS-Debug", FALSE, "ISSUED NWS(%s) Issued %4ld-%02ld-%02ld %02ld:%02ld:%02ld Expires %4ld-%02ld-%02ld %02ld:%02ld:%02ld, Valid %s from %02ld%02ld%02ld %.*S\n",
						Station->Station,
						pTime->stIssued.wYear, 
						pTime->stIssued.wMonth, 
						pTime->stIssued.wDay, 
						pTime->stIssued.wHour, 
						pTime->stIssued.wMinute, 
						pTime->stIssued.wSecond, 
						pTime->stExpires.wYear, 
						pTime->stExpires.wMonth, 
						pTime->stExpires.wDay, 
						pTime->stExpires.wHour, 
						pTime->stExpires.wMinute, 
						pTime->stExpires.wSecond, 
						FormatDeltaTime(DeltaSeconds(&pTime->stIssued,&pTime->stExpires),
										Temp, sizeof(Temp)),
						Station->Time.day, Station->Time.hour, Station->Time.minute,
						(int) Station->sComment, Station->pComment);
		}

#ifdef OLD_WAY
		int iDay, iHour, iMinute;
		if (GetNWSIssued(Station, &iDay, &iHour, &iMinute))
		{	if ((iDay == pstWhen->wDay
				&& 	(iHour < pstWhen->wHour
				|| (iHour == pstWhen->wHour 
					&& iMinute <= pstWhen->wMinute)))
			|| (iDay < pstWhen->wDay && pstWhen->wDay-iDay <= 3)	/* A few days ago, but not next month */
			|| (iDay >= 27 && pstWhen->wDay <=3))	/* Last Month wrap */
			{	Station->isNWSIssued = TRUE;
				Updated = TRUE;
				TraceLogThread("NWS-Debug", FALSE, "%s(%.*S) ISSUED (%0ld %02ld:%02ld)\n", 
									Station->Station, Station->sComment, Station->pComment,
									iDay, iHour, iMinute);
			} else
			{	if (First) TraceLogThread("NWS-Debug", FALSE, "%s(%.*S) Not Yet Issued (%0ld %02ld:%02ld)\n", 
									Station->Station, Station->sComment, Station->pComment,
									iDay, iHour, iMinute);
				 Station->lastMsec = llGetMsec();	/* Allow it to draw */
			}
		} else TraceLogThread("NWS-Debug", FALSE, "%s(%.*S) Has Invalid Sequence!\n", 
									Station->Station, Station->sComment, Station->pComment);
#endif
	}

	if (!Station->isKilled)
	{	if (Station->isKilled = (DeltaSeconds(&Station->pNWSTimes->stExpires, pstWhen) >= 0))
		{	Station->lastMsec = 1;	/* Force expiration */
			Updated = TRUE;	/* Get the circles repainted */
			NWS_TIMES_S *pTime = Station->pNWSTimes;
			char Temp[80];
			TraceLogThread("NWS-Debug", FALSE, "EXPIRED NWS(%s) Issued %4ld-%02ld-%02ld %02ld:%02ld:%02ld Expires %4ld-%02ld-%02ld %02ld:%02ld:%02ld, Valid %s from %02ld%02ld%02ld %.*S\n",
						Station->Station,
						pTime->stIssued.wYear, 
						pTime->stIssued.wMonth, 
						pTime->stIssued.wDay, 
						pTime->stIssued.wHour, 
						pTime->stIssued.wMinute, 
						pTime->stIssued.wSecond, 
						pTime->stExpires.wYear, 
						pTime->stExpires.wMonth, 
						pTime->stExpires.wDay, 
						pTime->stExpires.wHour, 
						pTime->stExpires.wMinute, 
						pTime->stExpires.wSecond, 
						FormatDeltaTime(DeltaSeconds(&pTime->stIssued,&pTime->stExpires),
										Temp, sizeof(Temp)),
						Station->Time.day, Station->Time.hour, Station->Time.minute,
						(int) Station->sComment, Station->pComment);
		}
	}
#ifdef OLD_WAY
	&& Station->isNWS		/* Only expire NWS objects */
	&& Station->Time.day)	/* See also auto-popup logic */
	{	if ((Station->Time.day == pstWhen->wDay
		&& 	(Station->Time.hour < pstWhen->wHour
			|| (Station->Time.hour == pstWhen->wHour 
				&& Station->Time.minute <= pstWhen->wMinute)))
		|| (Station->Time.day < pstWhen->wDay && pstWhen->wDay-Station->Time.day <= 3)	/* A few days ago, but not next month */
		|| (Station->Time.day >= 27 && pstWhen->wDay <=3))	/* Month wrap */
		{
#ifdef DEBUG_EXPIRES
					SYSTEMTIME stRcvd = Station->st;
					int day=0, hour=0, minute=0;
					GetNWSIssued(Station, &day, &hour, &minute);
					TraceLogThread("NWS-Debug", TRUE, "%s(%s) Rcvd:%02ld %02ld:%02ld (local) Issued:%02ld %02ld:%02ldz Expires:%02ld %02ld:%02ld%c %S\n",
									Station->Station, Station->Owner,
									(long) stRcvd.wDay,
									(long) stRcvd.wHour,
									(long) stRcvd.wMinute,
									(long) day, 
									(long) hour, 
									(long) minute,
									(long) Station->Time.day, 
									(long) Station->Time.hour, 
									(long) Station->Time.minute, 
									Station->Time.type,
									Station->Comment);
#endif
			Station->lastMsec = 1;	/* Force expiration */
			Station->isKilled = TRUE;	/* Marks as killed station */
			Updated = TRUE;	/* Get the circles repainted */
		} else Station->lastMsec = llGetMsec();
	}
#endif
	return Updated;
}

static void FormatNWSTitle(STATION_INFO_S *Station, TCHAR *Buffer, size_t BufSize, char *Suffix=NULL)
{	TCHAR *Next = Buffer;
	size_t Remaining = BufSize;

	if (strcmp(Station->Owner, CALLSIGN))
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%.3S-"), Station->Owner);

	size_t cLen = Station->sComment;
	if (Station->sComment)	/* Got a comment? */
	{	TCHAR *s = wcschr(Station->pComment, TEXT('}'));
		if (s)
		{	TCHAR *e = wcschr(s+1,TEXT('{'));
			if (e)
			{	while (s > Station->pComment && s[-1]==TEXT(' ')) s--;
				cLen = s-Station->pComment;
			}
		} else
		{	TCHAR *e = wcschr(Station->pComment,TEXT('{'));
			if (e)
			{	while (e > Station->pComment && e[-1]==TEXT(' ')) e--;
				cLen = e-Station->pComment;
			}
		}
	}
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
				TEXT("%.*s"), cLen, Station->pComment);

	if (Station->Time.day || Station->Time.hour
	|| Station->Time.minute || Station->Time.second)
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT(" (%02ld %02ld:%02ld%1S)"),
					(long) Station->Time.day, 
					(long) Station->Time.hour, 
					(long) Station->Time.minute, 
					&Station->Time.type);
	}
	if (Suffix && *Suffix)
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("%S"), Suffix);
	}
}

static void SetCenterLatLon(HWND hwnd, double lat, double lon, BOOL CenterRanging = FALSE)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	cInfo->CenterTracking = FALSE;	/* No longer locked on center */
	cInfo->CenterRanging = cInfo->Index?CenterRanging:TRUE;	/* Range the center */
	cInfo->LastCenterPosition.dblLatitude = lat;
	cInfo->LastCenterPosition.dblLongitude = lon;
	cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */

	TransmitFilter();
	InvalidateStationPoints(cInfo->Index,"SetCenter",TRUE);
	InvalidateCenter(hwnd, TRUE);
	cInfo->msLastSigChange = llGetMsec();
}

static void SetCenterTracking(HWND hwnd, STATION_INFO_S *Station, BOOL AutoZoom)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (!Station) return;	/* Skip it if no station specified */
	if (!cInfo->Index)
		ActiveConfig.Tracking.Center = FALSE;	/* Cancel any active watcher */
	cInfo->Awaiting = FALSE;
	Station->isCenter = TRUE;
	if (cInfo->Driving)
	{	cInfo->Driving = FALSE;
		KillTimer(hwnd, DRIVE_TIMER);
		TraceLog("Driver", TRUE, hwnd, "SetCenterTracking:No Longer Driving, Centered on %s\n", Station->Station);
	}
	cInfo->CenterTracking = TRUE;	/* Tracking a station now */
	cInfo->CenterStation = Station;
	strncpy(cInfo->CenterID, cInfo->CenterStation->Station, sizeof(cInfo->CenterID));

#ifndef UNDER_CE
	cInfo->FlashingAcked = FALSE;
	if (Station->MicEIndex)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
		if (Action->Enabled)
		if (Action->FlashOnCenter)
		if (ActiveConfig.Enables.MicENotification
		|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
//		if (!CheckIgnoreString(hwnd, &Action->Ignores, Station->Station, TRUE))
		{	FLASHWINFO fw = {0};
			fw.cbSize = sizeof(fw);
			fw.hwnd = hwnd;
			fw.dwFlags = FLASHW_ALL | FLASHW_TIMER;
			FlashWindowEx(&fw);
			cInfo->Flashing = TRUE;
			cInfo->Locked = TRUE;
		}
	} else if (cInfo->Flashing)
	{	FLASHWINFO fw = {0};
		fw.cbSize = sizeof(fw);
		fw.hwnd = hwnd;
		fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
		FlashWindowEx(&fw);
		cInfo->Flashing = FALSE;
	}
#endif

	if (Station != MyStation)	/* Got anyone but me? */
	{	cInfo->LastCenterPosition.dblLatitude = Station->pCoord->lat;
		cInfo->LastCenterPosition.dblLongitude = Station->pCoord->lon;
		cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
	} else cInfo->LastCenterPosition = LastGoodPosition;	/* Otherwise, it's ME */

	if (cInfo->Index)	/* Not the main window */
	{	TCHAR Buffer[80];
		SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM) MakeSymbolIcon(hwnd, GetStationSymbol(Station)));
		SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM) MakeSymbolIcon(hwnd, GetStationSymbol(Station)));

		if (Station->isNWS && Station->sComment)
			FormatNWSTitle(Station, Buffer, sizeof(Buffer));
		else if (HasNickLabelNonBlank(Station))
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Follow(%.*S)"), STRING(Station->Nickname->Label));
		else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Follow(%.*S)"), STRING(Station->Station));
		SetWindowText(hwnd, Buffer);
	}

	TransmitFilter();
	InvalidateStationPoints(cInfo->Index,"SetCenterTracking",TRUE);
	InvalidateCenter(hwnd, FALSE);
	InvalidateCircle(hwnd, TRUE, TRUE);
	if (AutoZoom) AutoZoomMultiLine(hwnd);
	cInfo->msLastSigChange = llGetMsec();
}

BOOL SetOrientation(HWND hwnd, unsigned long Orientation)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	BOOL Result = FALSE;

//TraceLog("Orientation", TRUE, hwnd, "Set Orientation(%ld) cInfo(%ld) Active(%ld)\n", Orientation, cInfo->Orientation, ActiveConfig.Orientation);

	if (cInfo->Orientation != Orientation)
	{	cInfo->Orientation = Orientation;
		ShuffleScreenElements(hwnd);
		Result = TRUE;
	}
	if (cInfo->Index==0 && ActiveConfig.Orientation != Orientation)
	{	ActiveConfig.Orientation = Orientation;
		SaveConfiguration(hwnd, &ActiveConfig, "SetOrientation");
	}
	CheckMenuItem(cInfo->hMenu, ID_VIEW_LANDSCAPE, (Orientation==0)?MF_CHECKED:MF_UNCHECKED);
	CheckMenuItem(cInfo->hMenu, ID_VIEW_PORTRAIT, (Orientation==1)?MF_CHECKED:MF_UNCHECKED);
	CheckMenuItem(cInfo->hMenu, ID_VIEW_AUTOMATIC, (Orientation==2)?MF_CHECKED:MF_UNCHECKED);
	cInfo->msLastSigChange = llGetMsec();
	return Result;
}

static BOOL IsPreferredView(HWND hwnd, CLIENT_INFO_S *cInfo, BOOL IfSet=FALSE)
{
	if (!ActiveConfig.Preferred.Latitude	/* If we don't have one configured */
	&& !ActiveConfig.Preferred.Longitude
	&& !ActiveConfig.Preferred.Zoom)
		return !IfSet;						/* Pretend it is the current view */

	return (cInfo->LastCenterPosition.dblLatitude == ActiveConfig.Preferred.Latitude)
	&& (cInfo->LastCenterPosition.dblLongitude == ActiveConfig.Preferred.Longitude)
	&& (cInfo->zoom == (int) ActiveConfig.Preferred.Zoom)
	// && (cInfo->Scale == ActiveConfig.Preferred.Scale)
	&& (cInfo->Orientation == ActiveConfig.Preferred.Orientation)
	&& !cInfo->CenterTracking;
}

static void SavePreferredView(HWND hwnd, CLIENT_INFO_S *cInfo)
{
	if (cInfo->Index) return;	/* Don't save for trackers (yet) */
	ActiveConfig.Preferred.Latitude = cInfo->LastCenterPosition.dblLatitude;
	ActiveConfig.Preferred.Longitude = cInfo->LastCenterPosition.dblLongitude;
	ActiveConfig.Preferred.Zoom = cInfo->zoom;
	ActiveConfig.Preferred.Scale = cInfo->Scale;
	ActiveConfig.Preferred.Orientation = cInfo->Orientation;
	SaveConfiguration(hwnd, &ActiveConfig, "SavePreferred");
}

static BOOL RestorePreferredView(HWND hwnd, CLIENT_INFO_S *cInfo)
{
	if ((ActiveConfig.Preferred.Latitude
	|| ActiveConfig.Preferred.Longitude
	|| ActiveConfig.Preferred.Zoom)
	&& (ActiveConfig.Preferred.Latitude != cInfo->LastCenterPosition.dblLatitude
	|| ActiveConfig.Preferred.Longitude != cInfo->LastCenterPosition.dblLongitude
	|| (int) ActiveConfig.Preferred.Zoom != cInfo->zoom))
	{	cInfo->LastCenterPosition.dblLatitude = ActiveConfig.Preferred.Latitude;
		cInfo->LastCenterPosition.dblLongitude = ActiveConfig.Preferred.Longitude;
		cInfo->zoom = ActiveConfig.Preferred.Zoom;
		cInfo->Scale = ActiveConfig.Preferred.Scale;
		cInfo->CenterTracking = FALSE;		/* We dragged to here */
		InvalidateStationPoints(cInfo->Index,"RestorePreferredView",TRUE);
		if (!SetOrientation(hwnd, ActiveConfig.Preferred.Orientation))
			InvalidateRect(hwnd, NULL, TRUE);
//TraceError(hwnd, "LastCenterPosition:RestorePreferredView:%.6lf x %.6lf %s\n", (double) LastCenterPosition.dblLatitude, (double) LastCenterPosition.dblLongitude, (LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))==(GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)?"valid":"INVALID");
		cInfo->msLastSigChange = llGetMsec();
		TransmitFilter();
		return TRUE;
	}
	return FALSE;
}

BOOL TransmitString(char *Buffer)
{
	if (!APRSEnabled) return TRUE;	/* Lie about transmitting it! */
	if (!ActiveConfig.Enables.Internet) return TRUE;	/* ditto */

	if (!PortTransmit(&APRSISPort, APRSISWP, Buffer))
	{	SoundConn(FALSE);
		InvalidatePortStatus(TRUE);
	} else
	{	IncrementXmitPackets(APRSISWP, 1, APRSISPort.Name);
		//TraceLogThread("APRS-IS", FALSE, "APRS-IS:Sent %s\n", Buffer);
		PacketsXmit++;
	}
	return APRSEnabled;
}

void SendTransmitQueue(void)
{	while (TransmitCount)
	{	if (TransmitString(TransmitQueue[0]))
		{	if (--TransmitCount)
				memmove(&TransmitQueue[0], &TransmitQueue[1], sizeof(TransmitQueue[0])*TransmitCount);
		}
	}
}

static BOOL QueueToTransmit(PACKET_TYPE_V PacketType, char *Buffer, BOOL RFOnly, BOOL ISOnly, BOOL NoQueue)	/* FALSE, FALSE, TRUE default in Prototype above */
{	BOOL Success = TRUE;

	TraceLogThread("Transmit", FALSE, "Transmit%s(%s) %s\n",
			NoQueue?"":"OrQueue",
			(RFOnly&&ISOnly)?"BothOnly":(RFOnly?"RF":(ISOnly?"IS":"IS+RF")),
			Buffer);

	if (!NoQueue)
	{	TraceLogThread("Transmit", TRUE, "NOT Queueing %s\n", Buffer);
		NoQueue = TRUE;
	}

	if (ActiveConfig.Enables.RFPorts
	&& !ActiveConfig.Enables.RFReceiveOnly)
	{	unsigned long p;
		for (p=0; p<ActiveConfig.RFPorts.Count; p++)
		{	PORT_CONFIG_INFO_S *Port = &ActiveConfig.RFPorts.Port[p];
			BOOL Enabled = RFPortRunnable(Port) && Port->XmitEnabled;
			if (ISOnly && !Port->NotRF) Enabled = FALSE;
			if (Enabled)
			{	if (Port->RfBaud!=-1)	/* -1 (server ports) get everything */
				switch (PacketType)
				{
				case CAPABILITY_PACKET:
					if (Port->NotRF)	/* CAPABILITY over -IS always on */
						break;
				case BEACON_PACKET:		/* Otherwise, track beacon enable */
				case STATUS_PACKET:
					Enabled = Port->BeaconingEnabled;
					break;

				case DX_PACKET:
					Enabled = Port->DXEnabled;
					break;

				case MESSAGE_PACKET:
				case MESSAGE_ACK_PACKET:
					Enabled = Port->MessagesEnabled;
					break;

				case BULLETIN_PACKET:
				case OBJECT_PACKET:
					Enabled = Port->BulletinObjectEnabled;
					Enabled = TRUE;
					break;

				case TELEMETRY_PACKET:
					Enabled = Port->TelemetryEnabled;
					break;

				case DIGIPEAT_PACKET:	/* Some protocols don't support Used (*) Path components */
					if (Port->NoUsedPath)
					{	TraceLogThread("Digi", TRUE, "%s:DigiPeating Not Supported on %s Protocol Ports\n", Port->Name, Port->Protocol);
						TraceLogThread(Port->Name, TRUE, "DigiPeating Not Supported on %s Protocol Ports\n", Port->Protocol);
						Enabled = FALSE;
					}
					break;

				case IS2RF_IGATE_PACKET:
					Enabled = Port->IStoRFEnabled;
					break;

				default:
					TraceLogThread("Transmit", TRUE, "Unsupported PacketType(%ld) Assuming enabled for %s Sending %s\n", (long) PacketType, Port->Name, Buffer);
				}
				if (Enabled)
				{	if (!PortTransmit(Port, p, Buffer))
					{	TraceLogThread("Transmit", TRUE, "%s(%s) FAILED to Queue %s\n",
								Port->Name, Port->Protocol, Buffer);
						Success = FALSE;
					} else IncrementXmitPackets(p, 1, Port->Name);
				} else
				{	TraceLogThread("Transmit", TRUE, "%s(%s) NOT Queueing %s\n",
								Port->Name, Port->Protocol, Buffer);
				}
			}
		}
	}

	if (!RFOnly)
	{	BOOL Enabled = ActiveConfig.Enables.APRSIS
		&& ActiveConfig.APRSIS.XmitEnabled;
		if (Enabled)
		switch (PacketType)
		{
		case CAPABILITY_PACKET:
			break;	/* CAPABILITY over -IS always on */
		case BEACON_PACKET:
		case STATUS_PACKET:
			Enabled = ActiveConfig.APRSIS.BeaconingEnabled;
			break;
		case DX_PACKET:
			Enabled = FALSE;	// DX packets are RF Only
			break;

		case MESSAGE_PACKET:
		case MESSAGE_ACK_PACKET:
			Enabled = ActiveConfig.APRSIS.MessagesEnabled;
			break;

		case BULLETIN_PACKET:
		case OBJECT_PACKET:
			Enabled = ActiveConfig.APRSIS.BulletinObjectEnabled;
			Enabled = TRUE;
			break;

		case TELEMETRY_PACKET:
			Enabled = ActiveConfig.APRSIS.TelemetryEnabled;
			break;

		case DIGIPEAT_PACKET:
			Enabled = FALSE;
			break;

		case IS2RF_IGATE_PACKET:
			Enabled = FALSE;
			break;

		default:
			TraceLogThread("Transmit", TRUE, "Unsupported PacketType(%ld) Assuming enabled for %s\n", (long) PacketType, Buffer);
		}
		if (Enabled)
		{
			if (NoQueue)
			{	if (!TransmitString(Buffer))
				{	int len = strlen(Buffer);
					TraceLogThread("Transmit", TRUE, "Failed To Transmit %.*s\n", Buffer[len-1]=='\n'?len-1:len, Buffer);
					Success = FALSE;
				}
			} else
			{	if (TransmitCount
				|| !TransmitString(Buffer))
				{	int len = strlen(Buffer);
					if (TransmitCount < 30)	/* Protect against runaway queues */
					{	int t = TransmitCount++;
						if (t >= TransmitSize)
						{	t = TransmitSize++;
							TransmitQueue = (char **) realloc(TransmitQueue, sizeof(*TransmitQueue)*TransmitSize);
						}
						TransmitQueue[t] = _strdup(Buffer);
						TraceLogThread("Transmit", TRUE, "APRS-IS:Queued %.*s\n", Buffer[len-1]=='\n'?len-1:len, Buffer);
					} else TraceLogThread("Transmit", TRUE, "APRS-IS:QUEUE TOO FULL(%ld) Dropping %.*s\n", (long) TransmitCount, Buffer[len-1]=='\n'?len-1:len, Buffer);
				}
			}
		}
	}
	return Success;
}


#ifdef USING_SHELL
//Add a node to the linked list(MFC Linked List)
SHNOTIFICATIONDATA* CreateAndAddNotification()
{
    SHNOTIFICATIONDATA* pshndTemp =(SHNOTIFICATIONDATA*)LocalAlloc(LMEM_MOVEABLE, sizeof(SHNOTIFICATIONDATA));

    if (pshndTemp)
    {   ZeroMemory(pshndTemp, sizeof(SHNOTIFICATIONDATA));
    }
    return pshndTemp;    
}

void FillSHND(HWND hwnd,
    SHNOTIFICATIONDATA* pshnd,
	SYSTEMTIME *st,
	char *From, char *Text
    )
{	int sTitle = strlen(From)+20+1;
	int sText = strlen(Text)+1;
	TCHAR *tTitle, *tText;
static BOOL First = TRUE;
static HMODULE hGWES = NULL;
static UINT g_iIDCounter = 10000;

	tTitle = (TCHAR *) LocalAlloc(LMEM_FIXED, sizeof(*tTitle)*sTitle);
	tText = (TCHAR *) LocalAlloc(LMEM_FIXED, sizeof(*tText)*sText);
	StringCbPrintf(tTitle, sizeof(*tTitle)*sTitle, TEXT("%S %04ld-%02ld-%02ld %02ld:%02ld"),
					From, (long) st->wYear, (long) st->wMonth, (long) st->wDay,
					(long) st->wHour, (long) st->wMinute, (long) st->wSecond);
	StringCbPrintf(tText, sizeof(*tText)*sText, TEXT("%S"), Text);

//#define IDS_DEFAULTHTMLMESSAGE    TEXT("<html><body><form method=\"POST\" action=><p>This is an <font color=\"#0000FF\"><b>HTML</b></font> notification stored in a  <font color=\"#FF0000\"><i>string</i></font> table!</p><p align=right></p></body></html>");
//#define IDS_DEFAULTTITLE        TEXT("APRS Message")

	pshnd->dwID = g_iIDCounter;
    pshnd->clsid = myGUID;
    pshnd->hwndSink = hwnd;
    pshnd->pszHTML = tText;
    pshnd->cbStruct = sizeof(SHNOTIFICATIONDATA);
    pshnd->pszTitle = tTitle;
	if (First)
	{	First = FALSE;
		hGWES = LoadLibraryEx( TEXT("gwes.exe"), NULL, LOAD_LIBRARY_AS_DATAFILE );
	}
	if (hGWES)
	{	pshnd->hicon = LoadIcon( hGWES, MAKEINTRESOURCE(MB_ICONINFORMATION));
	}
#ifdef FOR_INFO_ONLY
	pshnd->hicon = LoadIcon(g_hInstance, IDI_INFORMATION);

HMODULE hGWES = LoadLibraryEx( L"gwes.exe", NULL, LOAD_LIBRARY_AS_DATAFILE );
HICON hIcon = LoadIcon( hGWES, MAKEINTRESOURCE(MB_ICONQUESTION) );


IDI_APPLICATION
MAKEINTRESOURCE(32512)
Default application icon.

IDI_ASTERISK
MAKEINTRESOURCE(32516)
Asterisk icon. Same as IDI_INFORMATION.

IDI_ERROR
MAKEINTRESOURCE(32513)
Hand-shaped icon.

IDI_EXCLAMATION
MAKEINTRESOURCE(32515)
Exclamation point icon. Same as IDI_WARNING.

IDI_HAND
MAKEINTRESOURCE(32513)
Hand-shaped icon. Same as IDI_ERROR.

IDI_INFORMATION
MAKEINTRESOURCE(32516)
Asterisk icon.

IDI_QUESTION
MAKEINTRESOURCE(32514)
Question mark icon.

IDI_SHIELD
MAKEINTRESOURCE(32518)
Security Shield icon.

IDI_WARNING
MAKEINTRESOURCE(32515)
Exclamation point icon.

IDI_WINLOGO
MAKEINTRESOURCE(32517)
Default application icon.
#endif
#ifdef FUTURE
			pshnd->hicon = LoadIcon(g_hInst,
				MAKEINTRESOURCE(IDI_MESSAGE));
#endif
	pshnd->npPriority = SHNP_INFORM;
	pshnd->csDuration = 20;
    pshnd->grfFlags = SHNF_HASMENU | SHNF_SPINNERS;
	if (!ActiveConfig.Enables.Sound) pshnd->grfFlags |= SHNF_SILENT;
    pshnd->skm.hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_NOTIFY));
    pshnd->skm.cskc = 2;
    pshnd->skm.prgskc = (SOFTKEYCMD *)LocalAlloc(LMEM_FIXED, pshnd->skm.cskc * sizeof(SOFTKEYCMD));
    pshnd->skm.prgskc[0].wpCmd = ID_MENU_REPLY;
    pshnd->skm.prgskc[0].grfFlags = NOTIF_SOFTKEY_FLAGS_DISMISS;
    pshnd->skm.prgskc[1].wpCmd = ID_MENU_DISMISS;
    pshnd->skm.prgskc[1].grfFlags = NOTIF_SOFTKEY_FLAGS_DISMISS;

    g_iIDCounter++;
}

void DestroySHND(
    SHNOTIFICATIONDATA* pshnd
    )
{
    if (pshnd->pszHTML) LocalFree((HLOCAL) pshnd->pszHTML);
    if (pshnd->pszTitle) LocalFree((HLOCAL) pshnd->pszTitle);
    if (pshnd->hicon) DestroyIcon(pshnd->hicon);
    if (pshnd->skm.cskc && pshnd->skm.prgskc)
        LocalFree(pshnd->skm.prgskc);
    LocalFree(pshnd);
}

// remove a node with the specified dwID
BOOL RemoveMessageNotification(
	CLIENT_INFO_S *Info, int i
    )
{	BOOL bFound = FALSE;
	if (Messages[i].pNotification)
	{	bFound = TRUE;
		SHNotificationRemove(&myGUID, Messages[i].pNotification->dwID);
		DestroySHND(Messages[i].pNotification);
		Messages[i].pNotification = NULL;
	}
    return bFound;    
}

BOOL RemoveNotification(
	DWORD dwID
    )
{	int i;
    BOOL bFound = FALSE;
	for (i=0; i<MessageCount; i++)
	{	if (Messages[i].pNotification
		&& Messages[i].pNotification->dwID == dwID)
		{	bFound = TRUE;
			SHNotificationRemove(&myGUID, dwID);
			DestroySHND(Messages[i].pNotification);
			Messages[i].pNotification = NULL;
		}
	}
	for (i=0; i<BulletinCount; i++)
	{	if (Bulletins[i].pNotification
		&& Bulletins[i].pNotification->dwID == dwID)
		{	bFound = TRUE;
			SHNotificationRemove(&myGUID, dwID);
			DestroySHND(Bulletins[i].pNotification);
			Bulletins[i].pNotification = NULL;
		}
	}
    return bFound;    
}

void RemoveBulletinNotifications(CLIENT_INFO_S *Info)
{
	int i;
	for (i=0; i<BulletinCount; i++)
	if (Bulletins[i].pNotification)
	{	LRESULT Error = SHNotificationRemove(&myGUID, Bulletins[i].pNotification->dwID);
		if (Error != ERROR_SUCCESS)
			TraceLogThread("Bulletins", TRUE, "Failed To Remove Bulletin %ld\n",
							Bulletins[i].pNotification->dwID);
		DestroySHND(Bulletins[i].pNotification);
		Bulletins[i].pNotification = NULL;
	}
}

// function removed all nodes in the list
// called when the programme exits
void RemoveNotificationAll(	CLIENT_INFO_S *Info)
{
	int i;
	for (i=0; i<MessageCount; i++)
	if (Messages[i].pNotification)
	{	DestroySHND(Messages[i].pNotification);
		Messages[i].pNotification = NULL;
	}
	for (i=0; i<BulletinCount; i++)
	if (Bulletins[i].pNotification)
	{	DestroySHND(Bulletins[i].pNotification);
		Bulletins[i].pNotification = NULL;
	}
	SHNotificationRemove(&myGUID, 0);
}
#endif




#ifndef UNDER_CE
typedef	BOOL (WINAPI * MINIDUMP_WRITE_DUMP)(
	IN HANDLE			hProcess,
	IN DWORD			ProcessId,
	IN HANDLE			hFile,
	IN MINIDUMP_TYPE	DumpType,
	IN CONST PMINIDUMP_EXCEPTION_INFORMATION	ExceptionParam, OPTIONAL
	IN PMINIDUMP_USER_STREAM_INFORMATION		UserStreamParam, OPTIONAL
	IN PMINIDUMP_CALLBACK_INFORMATION			CallbackParam OPTIONAL
	);

HMODULE	hDbgHelp;
MINIDUMP_WRITE_DUMP	MiniDumpWriteDump_;

// Tool Help functions.
typedef	HANDLE (WINAPI * CREATE_TOOL_HELP32_SNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);
typedef	BOOL (WINAPI * MODULE32_FIRST)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
typedef	BOOL (WINAPI * MODULE32_NEST)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

HMODULE	hKernel32;
CREATE_TOOL_HELP32_SNAPSHOT	CreateToolhelp32Snapshot_;
MODULE32_FIRST	Module32First_;
MODULE32_NEST	Module32Next_;

#define	DUMP_SIZE_MAX	32000	//max size of our dump
#define	CALL_TRACE_MAX	((DUMP_SIZE_MAX - 2000) / (MAX_PATH + 40))	//max number of traced calls
#define	NL				TEXT("\r\n")	//new line

//****************************************************************************************
BOOL WINAPI Get_Module_By_Ret_Addr(PBYTE Ret_Addr, PTCHAR Module_Name, PBYTE & Module_Addr)
//****************************************************************************************
// Find module by Ret_Addr (address in the module).
// Return Module_Name (full path) and Module_Addr (start address).
// Return TRUE if found.
{
	MODULEENTRY32	M = {sizeof(M)};
	HANDLE	hSnapshot;

	Module_Name[0] = 0;
	
	if (CreateToolhelp32Snapshot_)
	{
		hSnapshot = CreateToolhelp32Snapshot_(TH32CS_SNAPMODULE, 0);
		
		if ((hSnapshot != INVALID_HANDLE_VALUE) &&
			Module32First_(hSnapshot, &M))
		{
			do
			{
				if (DWORD(Ret_Addr - M.modBaseAddr) < M.modBaseSize)
				{
					lstrcpyn(Module_Name, M.szExePath, MAX_PATH);
					Module_Addr = M.modBaseAddr;
					break;
				}
			} while (Module32Next_(hSnapshot, &M));
		}

		CloseHandle(hSnapshot);
	}

	return !!Module_Name[0];
} //Get_Module_By_Ret_Addr

//******************************************************************
int WINAPI Get_Call_Stack(PEXCEPTION_POINTERS pException, PTCHAR Str)
//******************************************************************
// Fill Str with call stack info.
// pException can be either GetExceptionInformation() or NULL.
// If pException = NULL - get current call stack.
{
	TCHAR	Module_Name[MAX_PATH];
	PBYTE	Module_Addr = 0;
	PBYTE	Module_Addr_1;
	int		Str_Len;
	
#pragma warning(disable: 4200)	//nonstandard extension used : zero-sized array in struct/union
	typedef struct STACK
	{
		STACK *	Ebp;
		PBYTE	Ret_Addr;
		DWORD	Param[0];
	} STACK, * PSTACK;

	STACK	Stack = {0, 0};
	PSTACK	Ebp;

	if (pException)		//fake frame for exception address
	{
		Stack.Ebp = (PSTACK)pException->ContextRecord->Ebp;
		Stack.Ret_Addr = (PBYTE)pException->ExceptionRecord->ExceptionAddress;
		Ebp = &Stack;
	}
	else
	{
		Ebp = (PSTACK)&pException - 1;	//frame addr of Get_Call_Stack()

		// Skip frame of Get_Call_Stack().
		if (!IsBadReadPtr(Ebp, sizeof(PSTACK)))
			Ebp = Ebp->Ebp;		//caller ebp
	}

	Str[0] = 0;
	Str_Len = 0;

	// Trace CALL_TRACE_MAX calls maximum - not to exceed DUMP_SIZE_MAX.
	// Break trace on wrong stack frame.
	for (int Ret_Addr_I = 0;
		(Ret_Addr_I < CALL_TRACE_MAX) && !IsBadReadPtr(Ebp, sizeof(PSTACK)) && !IsBadCodePtr(FARPROC(Ebp->Ret_Addr));
		Ret_Addr_I++, Ebp = Ebp->Ebp)
	{
		// If module with Ebp->Ret_Addr found.
		if (Get_Module_By_Ret_Addr(Ebp->Ret_Addr, Module_Name, Module_Addr_1))
		{
			if (Module_Addr_1 != Module_Addr)	//new module
			{
				// Save module's address and full path.
				Module_Addr = Module_Addr_1;
				Str_Len += wsprintf(Str + Str_Len, NL TEXT("%08X  %s"), Module_Addr, Module_Name);
			}

			// Save call offset.
			Str_Len += wsprintf(Str + Str_Len,
				NL TEXT("  +%08X"), Ebp->Ret_Addr - Module_Addr);

			// Save 5 params of the call. We don't know the real number of params.
			if (pException && !Ret_Addr_I)	//fake frame for exception address
				Str_Len += wsprintf(Str + Str_Len, TEXT("  Exception Offset"));
			else if (!IsBadReadPtr(Ebp, sizeof(PSTACK) + 5 * sizeof(DWORD)))
			{
				Str_Len += wsprintf(Str + Str_Len, TEXT("  (%X, %X, %X, %X, %X)"),
					Ebp->Param[0], Ebp->Param[1], Ebp->Param[2], Ebp->Param[3], Ebp->Param[4]);
			}
		}
		else
			Str_Len += wsprintf(Str + Str_Len, NL TEXT("%08X"), Ebp->Ret_Addr);
	}

	return Str_Len;
} //Get_Call_Stack

//***********************************
int WINAPI Get_Version_Str(PTCHAR Str)
//***********************************
// Fill Str with Windows version.
{
	OSVERSIONINFOEX	V = {sizeof(OSVERSIONINFOEX)};	//EX for NT 5.0 and later

	if (!GetVersionEx((POSVERSIONINFO)&V))
	{
		ZeroMemory(&V, sizeof(V));
		V.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		GetVersionEx((POSVERSIONINFO)&V);
	}

	if (V.dwPlatformId != VER_PLATFORM_WIN32_NT)
		V.dwBuildNumber = LOWORD(V.dwBuildNumber);	//for 9x HIWORD(dwBuildNumber) = 0x04xx

	return wsprintf(Str,
		NL TEXT("Windows:  %d.%d.%d, SP %d.%d, Product Type %d"),	//SP - service pack, Product Type - VER_NT_WORKSTATION,...
		V.dwMajorVersion, V.dwMinorVersion, V.dwBuildNumber, V.wServicePackMajor, V.wServicePackMinor, V.wProductType);
} //Get_Version_Str

//*************************************************************
PTCHAR WINAPI Get_Exception_Info(PEXCEPTION_POINTERS pException)
//*************************************************************
// Allocate Str[DUMP_SIZE_MAX] and return Str with dump, if !pException - just return call stack in Str.
{
	PTCHAR		Str;
	int			Str_Len;
	int			i;
	TCHAR		Module_Name[MAX_PATH];
	PBYTE		Module_Addr;
	HANDLE		hFile;
	FILETIME	Last_Write_Time;
	FILETIME	Local_File_Time;
	SYSTEMTIME	T;
	
	Str = new TCHAR[DUMP_SIZE_MAX];

	if (!Str)
		return NULL;

	Str_Len = 0;
	Str_Len += Get_Version_Str(Str + Str_Len);

	Str_Len += wsprintf(Str + Str_Len, NL TEXT("Process:  "));
	GetModuleFileName(NULL, Str + Str_Len, MAX_PATH);
	Str_Len = lstrlen(Str);

	// If exception occurred.
	if (pException)
	{
		EXCEPTION_RECORD &	E = *pException->ExceptionRecord;
		CONTEXT &			C = *pException->ContextRecord;

		// If module with E.ExceptionAddress found - save its path and date.
		if (Get_Module_By_Ret_Addr((PBYTE)E.ExceptionAddress, Module_Name, Module_Addr))
		{
			Str_Len += wsprintf(Str + Str_Len,
				NL TEXT("Module:  %s"), Module_Name);

			if ((hFile = CreateFile(Module_Name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
			{
				if (GetFileTime(hFile, NULL, NULL, &Last_Write_Time))
				{
					FileTimeToLocalFileTime(&Last_Write_Time, &Local_File_Time);
					FileTimeToSystemTime(&Local_File_Time, &T);

					Str_Len += wsprintf(Str + Str_Len,
						NL TEXT("Date Modified:  %02d/%02d/%d"),
						T.wMonth, T.wDay, T.wYear);
				}
				CloseHandle(hFile);
			}
		}
		else
		{
			Str_Len += wsprintf(Str + Str_Len,
				NL TEXT("Exception Addr:  %08X"), E.ExceptionAddress);
		}
		
		Str_Len += wsprintf(Str + Str_Len,
			NL TEXT("Exception Code:  %08X"), E.ExceptionCode);
		
		if (E.ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
		{
			// Access violation type - Write/Read.
			Str_Len += wsprintf(Str + Str_Len,
				NL TEXT("%s Address:  %08X"),
				(E.ExceptionInformation[0]) ? TEXT("Write") : TEXT("Read"), E.ExceptionInformation[1]);
		}

		// Save instruction that caused exception.
		Str_Len += wsprintf(Str + Str_Len, NL TEXT("Instruction: "));
		for (i = 0; i < 16; i++)
			Str_Len += wsprintf(Str + Str_Len, TEXT(" %02X"), PBYTE(E.ExceptionAddress)[i]);

		// Save registers at exception.
		Str_Len += wsprintf(Str + Str_Len, NL TEXT("Registers:"));
		Str_Len += wsprintf(Str + Str_Len, NL TEXT("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X"), C.Eax, C.Ebx, C.Ecx, C.Edx);
		Str_Len += wsprintf(Str + Str_Len, NL TEXT("ESI: %08X  EDI: %08X  ESP: %08X  EBP: %08X"), C.Esi, C.Edi, C.Esp, C.Ebp);
		Str_Len += wsprintf(Str + Str_Len, NL TEXT("EIP: %08X  EFlags: %08X"), C.Eip, C.EFlags);
	} //if (pException)
	
	// Save call stack info.
	Str_Len += wsprintf(Str + Str_Len, NL TEXT("Call Stack:"));
	Get_Call_Stack(pException, Str + Str_Len);

	if (Str[0] == NL[0])
		lstrcpy(Str, Str + sizeof(NL) - 1);

	return Str;
} //Get_Exception_Info

static char gCurrentPacket[1024];	// Buffer for inclusion in crash dump

//*************************************************************************************
void WINAPI Create_Dump(PEXCEPTION_POINTERS pException, BOOL File_Flag, BOOL Show_Flag)
//*************************************************************************************
// Create dump. 
// pException can be either GetExceptionInformation() or NULL.
// If File_Flag = TRUE - write dump files (.dmz and .dmp) with the name of the current process.
// If Show_Flag = TRUE - show message with Get_Exception_Info() dump.
{
	HANDLE	hDump_File;
	PTCHAR	Str;
	SYSTEMTIME stNow;
static TCHAR	Dump_Path[MAX_PATH+sizeof(CALLSIGN)+32] = {0};
	DWORD	Bytes;

	Str = Get_Exception_Info(pException);

	if (Show_Flag && Str)
		MessageBox(NULL, Str, TEXT("MiniDump"), MB_ICONHAND | MB_OK);

	if (File_Flag)
	{	char Vers[32];

		strncpy(Vers, Timestamp, sizeof(Vers));
		for (char*p=Vers; *p; )
		{	if (!isdigit(*p&0xff)) memmove(p, p+1, strlen(p));
			else p++;
		}

		GetModuleFileName(NULL, Dump_Path+lstrlen(Dump_Path), sizeof(Dump_Path)-lstrlen(Dump_Path));	//path of current process
		GetSystemTime(&stNow);
		StringCbPrintf(Dump_Path+lstrlen(Dump_Path)-4, MAX_PATH-lstrlen(Dump_Path), TEXT("-%S-%S-%04d%02d%02d-%02d%02d%02d.exe"),
						Vers, CALLSIGN, 
						stNow.wYear, stNow.wMonth, stNow.wDay,
						stNow.wHour, stNow.wMinute, stNow.wSecond);

		if (Str)
		{
			lstrcpy(Dump_Path + lstrlen(Dump_Path) - 3, TEXT("dmz"));

			hDump_File = CreateFile(Dump_Path,
				GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

			WriteFile(hDump_File, Str, sizeof(*Str)*(lstrlen(Str) + 1), &Bytes, NULL);

			CloseHandle(hDump_File);
		}

		// If MiniDumpWriteDump() of DbgHelp.dll available.
		if (MiniDumpWriteDump_)
		{
			MINIDUMP_EXCEPTION_INFORMATION	M;

			M.ThreadId = GetCurrentThreadId();
			M.ExceptionPointers = pException;
			M.ClientPointers = 0;

			MINIDUMP_USER_STREAM MUS[1];
			MUS[0].Type = CommentStreamA;
			MUS[0].BufferSize = sizeof(gCurrentPacket);
			MUS[0].Buffer = gCurrentPacket;

			MINIDUMP_USER_STREAM_INFORMATION MU;
			MU.UserStreamCount = 1;
			MU.UserStreamArray = MUS;

			lstrcpy(Dump_Path + lstrlen(Dump_Path) - 3, TEXT("dmp"));

			hDump_File = CreateFile(Dump_Path,
				GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

			MiniDumpWriteDump_(GetCurrentProcess(), GetCurrentProcessId(), hDump_File,
				(MINIDUMP_TYPE) ((int)MiniDumpNormal | (int)MiniDumpWithIndirectlyReferencedMemory),
				(pException) ? &M : NULL, &MU, NULL);

			CloseHandle(hDump_File);
		}
	} //if (File_Flag)

	delete Str;

	RestartProgram = TRUE;

} //Create_Dump

#endif	/* UNDER_CE */







#ifdef UNDER_CE
LPWSTR g_lpCmdLine;
#else
LPSTR g_lpCmdLine;
#endif

#ifdef UNDER_CE
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
#else
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
#endif
{
	MSG    msg = {0};

#ifndef UNDER_CE
	// Try to get MiniDumpWriteDump() address.
	hDbgHelp = LoadLibrary(TEXT("DBGHELP.DLL"));
	MiniDumpWriteDump_ = (MINIDUMP_WRITE_DUMP)GetProcAddress(hDbgHelp, "MiniDumpWriteDump");
//	d("hDbgHelp=%X, MiniDumpWriteDump_=%X", hDbgHelp, MiniDumpWriteDump_);

	// Try to get Tool Help library functions.
	hKernel32 = GetModuleHandle(TEXT("KERNEL32"));
	CreateToolhelp32Snapshot_ = (CREATE_TOOL_HELP32_SNAPSHOT)GetProcAddress(hKernel32, "CreateToolhelp32Snapshot");
	Module32First_ = (MODULE32_FIRST)GetProcAddress(hKernel32, "Module32First");
	Module32Next_ = (MODULE32_NEST)GetProcAddress(hKernel32, "Module32Next");

	__try
	{
#endif	/* UNDER_CE */

	HANDLE hEvent = NULL;
    TCHAR *szTitle = (TCHAR*)malloc(sizeof(*szTitle)*128);

	// Save the instance handle so we can access it later
    g_hInstance = hInstance;
	g_lpCmdLine = lpCmdLine;

	SetTraceThreadName("WinMain");

	FirstRun = TRUE;	/* Suppress popup and debug defaults */

	char *CallSign = GetXmlCallsign(NULL);	/* See how long this takes */
	if (CallSign) TraceLog("Config", TRUE, NULL, "Found CallSign(%s)\n", CallSign);
	else TraceLog("Config", TRUE, NULL, "No CallSign Found In Config\n");

	if (CallSign && *CallSign)	/* Have a callsign already? */
#ifdef UNDER_CE
		StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S"), CallSign);
#else
		StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S - %S"), PROGNAME, CallSign);
#endif
	else StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S"), PROGNAME);
	FirstRun = FALSE;	/* Go back to normal */
	
	hEvent = FindPrevInstance(szTitle);
	if (hEvent == NULL)
	{
		// We found another instance
		return -1;
	}

	ClearTraceFile(NULL);
	ActiveConfigLoaded = LoadOrDefaultConfiguration(NULL, &ActiveConfig, FALSE, FALSE);	/* Must still be necessary, go figure! */
#ifdef USING_POWER
    // size of a POWER_BROADCAST message
    DWORD cbPowerMsgSize = sizeof POWER_BROADCAST + (MAX_PATH * sizeof TCHAR);

    // Initialize our MSGQUEUEOPTIONS structure
    MSGQUEUEOPTIONS mqo;
    mqo.dwSize = sizeof(MSGQUEUEOPTIONS); 
    mqo.dwFlags = MSGQUEUE_NOPRECOMMIT;
    mqo.dwMaxMessages = 4;
    mqo.cbMaxMessage = cbPowerMsgSize;
    mqo.bReadAccess = TRUE;
                                         
    // Create a message queue to receive power notifications
    HANDLE hPowerMsgQ = CreateMsgQueue(NULL, &mqo);
    if (NULL == hPowerMsgQ) 
    {
        RETAILMSG(1, (L"CreateMsgQueue failed: %x\n", GetLastError()));
        goto Error;
    }

    // Request power notifications 
    HANDLE hPowerNotifications = RequestPowerNotifications(hPowerMsgQ,
                                                           PBT_TRANSITION | 
                                                           PBT_RESUME | 
                                                           PBT_POWERINFOCHANGE);
    if (NULL == hPowerNotifications) 
    {
        RETAILMSG(1, (L"RequestPowerNotifications failed: %x\n", GetLastError()));
        goto Error;
    }
#endif

	// Create our main application window
    hwndMain = CreateMainWindow(nShowCmd, szTitle, 0);
    if (hwndMain == NULL)
    {
        // Failed to initialize
		CloseHandle(hEvent);
		hEvent = NULL;
        return GetLastError();
	}
/*
	And get the virgin birth accomplished
*/
	if (FirstRun
	|| (ActiveConfig.Beacon.AfterTransmit && !ActiveConfig.Enables.GPS))
	{	RECT rcMine = rcCircle(0);
		RECT rc = rcMine;
		TCHAR *Text = TEXT("Drag and Zoom to Home, then Click Transmit\nSee http://APRSISCE.wikidot.com");
		if (!FirstRun && ActiveConfig.Beacon.AfterTransmit)
		{	BeaconSuspended = TRUE;
#ifdef UNDER_CE	/* Don't ask me why I couldn't line it up! */
			Text = TEXT("Beaconing Suspended\r\nConfirm Center and Transmit\r\n ");
#else
			Text = TEXT("Beaconing Suspended\r\nConfirm Center and Transmit");
#endif
			if (cInfos[0].zoom < MIN_SETTABLE_ZOOM) cInfos[0].zoom = MIN_SETTABLE_ZOOM;

			if (IsValidLatLon(ActiveConfig.Latitude, ActiveConfig.Longitude))
			{	if (!MyStation) DefineME(hwndMain);
//				MyStation->lat = ActiveConfig.Latitude;
//				MyStation->lon = ActiveConfig.Longitude;
				MyStation->pCoord = GetCoordIndex(ActiveConfig.Latitude, ActiveConfig.Longitude, "MyStation", MyStation->Station, MyStation->pCoord);
			}

			PostMessage(hwndMain, WM_COMMAND, ID_SCREEN_TRACK_ME, 0);
		}
		HDC hdc = GetDC(hwndMain);
		int theight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
		int twidth = rc.right-rc.left;
		int cwidth = rcMine.right-rcMine.left;
		ReleaseDC(hwndMain, hdc);
		hwndFirstRun = CreateWindow(TEXT("static"),
					Text,
					WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
					| SS_CENTER | SS_NOPREFIX,
					rcMine.left+(cwidth-twidth)/2, rcMine.bottom-theight,
					rcMine.left+twidth, rcMine.bottom,
					hwndMain, (HMENU) 1,
					g_hInstance, NULL);
	}

//	SpinMessages(hwndMain);
	if (!CheckOptimizedFilter(ActiveConfig.FreqMon.Filter, &FreqMonFilter))
	{	TraceError(hwndMain, "Invalid FreqMonFilter(%s)\n", ActiveConfig.FreqMon.Filter);
	}
	if (!CheckOptimizedFilter(ActiveConfig.Scroller.Filter, &ScrollerFilter))
	{	ShowTraceLog("FilterError", FALSE);
		TraceError(hwndMain, "Invalid ScrollerFilter(%s)\n", ActiveConfig.Scroller.Filter);
	}
	GPSEnabled = ActiveConfig.Enables.GPS;	/* For screen layout */

#ifdef MOVED_TO_FINISH
	EnableAPRS(hwndMain, ActiveConfig.Enables.APRSIS);
	if (!FirstRun)
	{	//SpinMessages(hwndMain);
		if (ActiveConfig.Enables.RFPorts)
		{	unsigned long p;
			TraceLog("Activity", TRUE, hwndMain, "Loaded %ld RFPorts\n", (long) ActiveConfig.RFPorts.Count);
			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			{	PORT_CONFIG_INFO_S *pPort = &ActiveConfig.RFPorts.Port[p];
				TraceLog("Activity", TRUE, hwndMain, "RFPort[%ld] %s(%s) %ld via %s\n",
						(long) p,
						pPort->Name, 
						pPort->Protocol, 
						(long) pPort->RfBaud, 
						pPort->Device);
				if (RFPortRunnable(pPort))
				{	if (!PortStart(pPort, hwndMain, WM_PORT_STATUS, 0, WM_PORT_RECEIVED, p))
					{
	#ifdef USE_PORT_STATUS
						SetPortStatus(hwndMain, p, pPort->Name, "Failed");
	#endif

						TraceLog("Activity", TRUE, hwndMain, "Failed To Start RFPort[%ld] %s(%s) %ld via %s\n",
						(long) p,
						pPort->Name, 
						pPort->Protocol, 
						(long) pPort->RfBaud, 
						pPort->Device);
					}
					FixIGateEnabled();
				}
	#ifdef USE_PORT_STATUS
				else if (*pPort->Device)
					SetPortStatus(hwndMain, MAKELONG(p,1), pPort->Name, "Disabled");
	#endif
			}
		}
	}
#endif

	if (IsRectEmpty(&rcCircle(0)))
	{	TraceLog("Activity", TRUE, hwndMain, "Final Startup Shuffle?\n");
		ShuffleScreenElements(hwndMain);
	}

//	RestoreSavedPosits(hwndMain);

	// Finally Make the window visible and paint
	InvalidateRect(hwndMain, NULL, TRUE);
	ShowWindow(hwndMain, nShowCmd);
	UpdateWindow(hwndMain);
#ifdef UNDER_CE	/* Just in case RestoreSavedPosits called PeekMessage() */
	SetForegroundWindow((HWND)((UINT_PTR)hwndMain | 0x01));
//#else
//	SetForegroundWindow(hwndMain);
#endif

	if (!PostMessage(hwndMain, WM_FINISH_STARTUP, 0, 0))
		TraceError(hwndMain, "PostMessage(FINISH_STARTUP) Failed, Error=%ld\n", GetLastError());

#ifdef GPS_EVENTS
	// Create a named event
	HANDLE hNewLocData=NULL, hDeviceChange=NULL;
	hNewLocData = CreateEvent(NULL, TRUE, TRUE, NULL);
	hDeviceChange = CreateEvent(NULL, TRUE, TRUE, NULL);

	hGPS2 = GPSOpenDevice(hNewLocData, hDeviceChange, NULL, 0);
	if (!hGPS2)
		MessageBox(hwndMain,TEXT("GPSOpenDevice Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);
#endif

	hExitProgram = CreateEvent(NULL, TRUE, FALSE, NULL);

#ifdef GPS_EVENTS
	HANDLE rgHandles[3] = {0};
    rgHandles[0] = hPowerMsgQ;
    rgHandles[1] = hNewLocData;
    rgHandles[2] = hDeviceChange;
#elif defined(USING_POWER)
	HANDLE rgHandles[2] = {0};
	rgHandles[0] = hExitProgram;
    rgHandles[1] = hPowerMsgQ;
#else
	HANDLE rgHandles[1] = {0};
	rgHandles[0] = hExitProgram;
#endif

	if (GetModuleFileName(NULL, OriginalPath, MAX_PATH))
		TraceLog("Version", TRUE, hwndMain,"winMain:Running %s(%s) from %S\n", PROGNAME, Timestamp, OriginalPath);
	else TraceLog("Version", TRUE, hwndMain,"winMain:Running %s(%s) GetModuleFileName returned %ld\n", PROGNAME, Timestamp, (long) GetLastError());

#ifdef NOT_YET
	try
	{
#endif
	for (;;)	/* infinite loop until a WM_QUIT breaks us out */
	{
	// Wait for a power notification or for the app to exit
    DWORD WakeReason = MsgWaitForMultipleObjectsEx(ARRAYSIZE(rgHandles), rgHandles, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);
	if (!IsWindow(hwndMain))
	{	TraceError(hwndMain, "hwndMain no longer a window\n");
		break;	/* Window was destroyed! */
	}
	if (WakeReason == WAIT_OBJECT_0)
	{	TraceActivity(hwndMain,"Got ExitProgram event\n");
		break;
#ifdef USING_POWER
	} else if (WakeReason == WAIT_OBJECT_0 + 1)	/* NewLocData */
    {   DWORD cbRead;
        DWORD dwFlags;
        POWER_BROADCAST *ppb = (POWER_BROADCAST*) new BYTE[cbPowerMsgSize];
            
        // loop through in case there is more than 1 msg 
        while(ReadMsgQueue(hPowerMsgQ, ppb, cbPowerMsgSize, &cbRead, 
                           0, &dwFlags))
        {
            switch (ppb->Message)
            {
                case PBT_TRANSITION:
                    TraceActivityBegin(hwndMain, "Power Notification Message: PBT_TRANSITION\n");
                    TraceActivity(hwndMain, "Flags: %lx", ppb->Flags);
                    TraceActivityEnd(hwndMain, "Length: %d", ppb->Length);
                    if (ppb->Length)
                    {
                        TraceActivity(hwndMain, "SystemPowerState: %.*S\n", ppb->Length, ppb->SystemPowerState);
                    }
                    break;

                case PBT_RESUME:
                    TraceActivity(hwndMain, "Power Notification Message: PBT_RESUME\n");
                    break;

                case PBT_POWERINFOCHANGE:
                {
                    TraceActivity(hwndMain, "Power Notification Message: PBT_POWERINFOCHANGE\n");

                    // PBT_POWERINFOCHANGE message embeds a 
                    // POWER_BROADCAST_POWER_INFO structure into the 
                    // SystemPowerState field
                    PPOWER_BROADCAST_POWER_INFO ppbpi =
                        (PPOWER_BROADCAST_POWER_INFO) ppb->SystemPowerState;
                    if (ppbpi) 
                    {	pbpi = *ppbpi;	/* Remember for window painting */
                        TraceActivityBegin(hwndMain, "Length: %d\n", ppb->Length);
                        TraceActivity(hwndMain, "BatteryLifeTime = %d\n",ppbpi->dwBatteryLifeTime);
                        TraceActivity(hwndMain, "BatterFullLifeTime = %d\n",
                                     ppbpi->dwBatteryFullLifeTime);
                        TraceActivity(hwndMain, "BackupBatteryLifeTime = %d\n",
                                     ppbpi->dwBackupBatteryLifeTime);
                        TraceActivity(hwndMain, "BackupBatteryFullLifeTime = %d\n",
                                     ppbpi->dwBackupBatteryFullLifeTime);
                        TraceActivity(hwndMain, "ACLineStatus = %d\n",ppbpi->bACLineStatus);
                        TraceActivity(hwndMain, "BatteryFlag = %d\n",ppbpi->bBatteryFlag);
                        TraceActivity(hwndMain, "BatteryLifePercent = %d\n",
                                     ppbpi->bBatteryLifePercent);
                        TraceActivity(hwndMain, "BackupBatteryFlag = %d\n",
                                     ppbpi->bBackupBatteryFlag);
                        TraceActivityEnd(hwndMain, "BackupBatteryLifePercent = %d\n",
                                     ppbpi->bBackupBatteryLifePercent);
						if (ppbpi->bBatteryLifePercent != BATTERY_PERCENTAGE_UNKNOWN)
							PostMessage(hwndMain, WM_POWER_CHANGE, ppbpi->bBatteryLifePercent, ppbpi->bACLineStatus<<8 | ppbpi->bBatteryFlag);
                    }
                    break;
                }

                default:
                    break;
            }

//            UpdatePowerState();
        }

        delete[] ppb;
#endif
#ifdef GPS_EVENTS
	} else if (WakeReason == WAIT_OBJECT_0 + 1)	/* NewLocData */
	{	GPS_POSITION newPosition;
		ResetEvent(hNewLocData);
		newPosition.dwVersion = GPS_VERSION_1;
		newPosition.dwSize = sizeof(newPosition);
		if (GPSGetPosition(hGPS, &newPosition, 10000, 0) == ERROR_SUCCESS)
		{	TraceActivityBegin(hwndMain, "GPS Valid: 0x%lX Flags: 0x%lX\n",
							(long) newPosition.dwValidFields, (long) newPosition.dwFlags);
			TraceActivity(hwndMain, "GPS stUTCTime: %04ld-%02ld-%02ldT%02ld:%02ld:%02ld ",
							(long) newPosition.stUTCTime.wYear, (long) newPosition.stUTCTime.wMonth, (long) newPosition.stUTCTime.wDay, 
							(long) newPosition.stUTCTime.wHour, (long) newPosition.stUTCTime.wMinute, (long) newPosition.stUTCTime.wSecond);
			TraceActivity(hwndMain, "GPS Lat: %.5lf Lon: %.5lf Speed: %.2lf Heading: %.2lf Variation: %.5lf\n",
							(double) newPosition.dblLatitude, (double) newPosition.dblLongitude,
							(double) newPosition.flSpeed, (double) newPosition.flHeading,
							(double) newPosition.dblMagneticVariation);
			TraceActivity(hwndMain, "GPS WRTSeaLevel: %.2lf WRTEllipsoid: %.3lf\n",
							(double) newPosition.flAltitudeWRTSeaLevel, (double) newPosition.flAltitudeWRTEllipsoid);
			TraceActivity(hwndMain, "GPS FixQual: 0x%lX FixType: 0x%lX Selection: 0x%lX\n",
							(long) newPosition.FixQuality, (long) newPosition.FixType, (long) newPosition.SelectionType);
			TraceActivity(hwndMain, "GPS PDOP: %.2lf HDOP: %.3lf VDOP: %.3lf\n",
							(double) newPosition.flPositionDilutionOfPrecision,
							(double) newPosition.flHorizontalDilutionOfPrecision,
							(double) newPosition.flVerticalDilutionOfPrecision);
			TraceActivityEnd(hwndMain, "GPS SatCount: %ld SatInView: %ld\n",
							(long) newPosition.dwSatelliteCount, (long) newPosition.dwSatellitesInView);
		} else
		{	TraceError(hwndMain, "GPSGetPosition Failed With %ld\n", (long) GetLastError());
		}
	} else if (WakeReason == WAIT_OBJECT_0 + 2)	/* DeviceChange */
	{	ResetEvent(hDeviceChange);
		gpsDevice.dwVersion = GPS_VERSION_1;
		gpsDevice.dwSize = sizeof(gpsDevice);
		if (GPSGetDeviceState(&gpsDevice) == ERROR_SUCCESS)
		{	FILETIME localFileTime;
			FileTimeToLocalFileTime(&gpsDevice.ftLastDataReceived, &localFileTime);
			SYSTEMTIME st;
			FileTimeToSystemTime(&localFileTime, &st);
			TraceActivityBegin(hwndMain, "GPSdev3 dwServiceState: 0x%lX dwDeviceState: 0x%lX\n",
						(long) gpsDevice.dwServiceState, (long) gpsDevice.dwDeviceState);
			TraceActivity(hwndMain, "GPSdev3 LastDataReceived: %04ld-%02ld-%02ldT%02ld:%02ld:%02ld ",
							(long) st.wYear, (long) st.wMonth, (long) st.wDay, 
							(long) st.wHour, (long) st.wMinute, (long) st.wSecond);
			TraceActivityEnd(hwndMain, "GPSdev3 DriverPrefix: %S MultiplexPrefix: %S FriendlyName: %S\n",
						gpsDevice.szGPSDriverPrefix, gpsDevice.szGPSMultiplexPrefix, gpsDevice.szGPSFriendlyName);
		} else
		{	TraceError(hwndMain, "GPSGetDeviceState Failed With %ld\n", (long) GetLastError());
		}
#endif
	} else if (WakeReason == WAIT_OBJECT_0 + ARRAYSIZE(rgHandles))
	{
	    // Run the message loop (note that GetMessage() returns -1 for error)
		if (GetMessage(&msg, NULL, 0, 0) > 0)
		{	__int64 Start = llGetMsec();
		static __int64 msMax = 0, msLast = 0;
//TraceActivity(hwndMain, "hwnd: %lX msg: %lX wp: %lX lp: %lX\n", (long) msg.hwnd, (long) msg.message, (long) msg.wParam, (long) msg.lParam);

			if (!gModelessDialog || !IsDialogMessage(gModelessDialog, &msg))
			{	TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
			if (msg.hwnd != hwndMain)	/* MainWindowProc does these */
				MessageTimer("DispatchMessage", Start, &msMax, &msLast,
							msg.hwnd, msg.message, msg.wParam, msg.lParam);
		} else
		{	TraceActivity(hwndMain,"WM_QUIT!\n");
			break;	/* WM_QUIT must have been posted! */
		}
	} else TraceError(hwndMain, "UnHandled Wake Reason %ld (0x%lX)\n", (long) WakeReason, (long) WakeReason);

	}
#ifdef NOT_YET
	} catch ( Exception^ ex ) 
    {
         Console::WriteLine( "\nMessage ---\n{0}", ex->Message );
         Console::WriteLine( "\nHelpLink ---\n{0}", ex->HelpLink );
         Console::WriteLine( "\nSource ---\n{0}", ex->Source );
         Console::WriteLine( "\nStackTrace ---\n{0}", ex->StackTrace );
         Console::WriteLine( "\nTargetSite ---\n{0}", ex->TargetSite->ToString() );
    }
#endif

	TraceActivity(hwndMain,"Exited Processing Loop!\n");

	// Clean up
	FreePaintImage();
	FreePaintFont();

    // This is the value we passed to PostQuitMessage()
	CloseHandle(hEvent); hEvent = NULL;
	CloseHandle(hExitProgram);

#ifdef SUPPORT_APRSTRACE
	if (APRSTraceFile) fclose(APRSTraceFile);
	APRSTraceFile = NULL;
#endif
	if (CSVTrackFile) fclose(CSVTrackFile);
	CSVTrackFile = NULL;

#ifdef USING_GPSAPI
	if (hGPS) GPSCloseDevice(hGPS);
#endif

#ifdef USING_POWER
Error:
    if (hPowerNotifications)
        StopPowerNotifications(hPowerNotifications);

    if (hPowerMsgQ)
        CloseMsgQueue(hPowerMsgQ);
#endif

	free(szTitle);

	TraceActivity(hwndMain,"WinMain Returning\n");

	if (hEvent) CloseHandle(hEvent);	/* So we don't get discovered on restart */


#ifndef UNDER_CE
	}
	__except (Create_Dump(GetExceptionInformation(), 1, 1), EXCEPTION_EXECUTE_HANDLER)
	{	RestartProgram = TRUE;
	}
	FreeLibrary(hDbgHelp);
#endif

	if (RestartProgram)
	{	if (OriginalPath[0]
		|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
		{	STARTUPINFO StartupInfo = {0};
			PROCESS_INFORMATION ProcessInfo = {0};

			StartupInfo.cb = sizeof(StartupInfo);
			StartupInfo.lpTitle = NULL;
			//StartupInfo.wShowWindow = SW_SHOW;
			//StartupInfo.dwFlags = STARTF_FORCEONFEEDBACK;
			if (CreateProcess(OriginalPath,TEXT(""),NULL,NULL,FALSE,
					CREATE_NEW_CONSOLE /*| CREATE_NEW_PROCESS_GROUP*/,
					NULL, NULL, &StartupInfo, &ProcessInfo))
			{	CloseHandle(ProcessInfo.hThread);
			}
		}
	}



	return msg.wParam;
}

HANDLE FindPrevInstance(TCHAR *szTitle)
{
	HANDLE hEvent;
	HWND   hwnd;
	UINT   cTries = 0;

	// Create a named event
	hEvent = CreateEvent(NULL, TRUE, FALSE, g_szClassName);
	if (hEvent != NULL)
	{
		// If the event already existed, that means there's another copy of our app
		// already running
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			TraceError(NULL, "Found Existing %S Event, Looking for %S\n", g_szClassName, szTitle);
			do
			{
				// Just in case the other window needs to finish initialization
				Sleep(cTries ? 250 : 0);

				// Try to find the other application window
				hwnd = FindWindow(g_szClassName, szTitle);
				if (hwnd != NULL)
				{
					TraceError(NULL, "Found %S(%S) Window at %p\n", g_szClassName, szTitle, hwnd);
					if (!SetForegroundWindow((HWND)((UINT_PTR)hwnd | 0x01))
					&& !SetForegroundWindow(hwnd))
					{	TraceError(NULL, "SetForegoundWindow %S(%S) %p FAILED!\n", g_szClassName, szTitle, hwnd);
						if (!SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE))
							TraceError(NULL, "SetWindowPos %S(%S) %p also FAILED!\n", g_szClassName, szTitle, hwnd);
						else TraceError(NULL, "SetWindowPos %S(%S) %p Worked.\n", g_szClassName, szTitle, hwnd);
					} else TraceError(NULL, "SetForegoundWindow %S(%S) %p Worked.\n", g_szClassName, szTitle, hwnd);
					ShowWindow(hwnd, SW_SHOW);
					CloseHandle(hEvent);
					return NULL;
				}
			}
			while (++cTries < 2);  // only try twice
			TraceError(NULL, "%S(%S) Window Never Found\n", g_szClassName, szTitle);

			// If we didn't find the window, the other application was probably
			// shutting down, so we'll just continue
		}
	}

	// Done
	return hEvent;
}

HWND CreateMainWindow(int nShowCmd, TCHAR *szTitle, LPARAM Index)
{
    HWND     hwnd;
static ATOM     atm = 0;

	if (!atm)
	{
    WNDCLASS wc;
// Set up the window class description
    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = MainWindowProc;
    wc.hInstance = g_hInstance;
//    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = g_szClassName;

#ifndef UNDER_CE
//	if (LoadIconMetric(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON), LIM_SMALL, &wc.hIcon) != S_OK)
	wc.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
	if (!wc.hIcon)
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);              // predefined app. icon 
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);                    // predefined arrow 
	wc.lpszMenuName = MAKEINTRESOURCE(IDM_MAIN_W32);
#endif

	// We want to redraw the window contents anytime we get resized. That way
	// we'll respond appropriately when the user switches between portrait and
	// landscape. If we had any child windows or controls, we'd need to
	// reposition or resize them when we get a WM_SIZE message.
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;

    // Register the window class
    atm = RegisterClass(&wc);
    if (atm == 0)
    {	printf("RegisterClass Failed!  Error=%ld\n", (long) GetLastError());
        // Failed!!
        return NULL;
    }
	}

    // Create a window using the class we just registered. Note that the
	// initial size and position don't matter, because we're going to make it
	// fullscreen when we get WM_CREATE, before it's ever displayed.
	char *Extra=NULL;
	WINDOWPOS Pos;
	Pos.x = Pos.y = Pos.cx = Pos.cy = CW_USEDEFAULT;
	BOOL RecalledPos = RecallWindowPosition("*MainWindow*", &Pos, NULL, &Extra);	/* Get Extra Set */
#ifdef UNDER_CE
#ifdef USING_SHELL
	hwndMain = hwnd = CreateWindow((LPCTSTR)atm, szTitle,
						/* WS_OVERLAPPED | WS_SYSMENU */
						WS_NONAVDONEBUTTON,
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
						NULL, NULL, g_hInstance, NULL);
#else
	hwndMain = hwnd = CreateWindow((LPCTSTR)atm, szTitle,
						WS_OVERLAPPED | WS_SYSMENU,
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
						NULL, NULL, g_hInstance, NULL);
#endif
#else
	if (RecalledPos)
	{	RECT rc;
		SetRect(&rc, Pos.x, Pos.y, Pos.x+Pos.cx, Pos.y+Pos.cy);
		TraceError(NULL, "Saved WindowPosition %ld x %ld @ %ld %ld\n",
					Pos.cx, Pos.cy, Pos.x, Pos.y);
		ClipOrCenterRectToMonitor(&rc, MONITOR_CLIP | MONITOR_WORKAREA);
		Pos.x = rc.left; Pos.y = rc.top;
		OffsetRect(&rc, -rc.left, -rc.top);
		Pos.cx = rc.right; Pos.cy = rc.bottom;
		TraceError(NULL, "Modified WindowPosition %ld x %ld @ %ld %ld\n",
					Pos.cx, Pos.cy, Pos.x, Pos.y);
	} else if (ActiveConfig.OrgWindowPlacement.width
	&& ActiveConfig.OrgWindowPlacement.height)
	{	RECT rc;
		rc.left = ActiveConfig.OrgWindowPlacement.x;
		rc.top = ActiveConfig.OrgWindowPlacement.y;
		rc.right = rc.left + ActiveConfig.OrgWindowPlacement.width;
		rc.bottom = rc.top + ActiveConfig.OrgWindowPlacement.height;
		TraceError(NULL, "Saved WindowPlacement %ld x %ld @ %ld %ld\n",
					ActiveConfig.OrgWindowPlacement.width,
					ActiveConfig.OrgWindowPlacement.height,
					ActiveConfig.OrgWindowPlacement.x,
					ActiveConfig.OrgWindowPlacement.y);
		ClipOrCenterRectToMonitor(&rc, MONITOR_CLIP | MONITOR_WORKAREA);
		Pos.x = rc.left; Pos.y = rc.top;
		OffsetRect(&rc, -rc.left, -rc.top);
		Pos.cx = rc.right; Pos.cy = rc.bottom;
		TraceError(NULL, "Modified WindowPlacement %ld x %ld @ %ld %ld\n",
					Pos.cx, Pos.cy, Pos.x, Pos.y);
	}

	hwndMain = hwnd = CreateWindow((LPCTSTR)atm, szTitle, WS_OVERLAPPED | WS_SYSMENU | WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
        Pos.x, Pos.y, Pos.cx, Pos.cy,
		NULL, NULL, g_hInstance, NULL);

#endif
	if (hwnd == NULL)
    {  	printf("CreateMainWindow Failed!  Error=%ld\n", (long) GetLastError());
        // Failed!!
        return NULL;
    }

	FinishMainWindowStartup(hwnd, Extra);

	EnableOSMFetch(hwnd, ActiveConfig.Enables.OSMFetch, TRUE);

#ifndef UNDER_CE
	if (ActiveConfig.Enables.DebugStartup && !FirstRun) PostMessage(hwnd, WM_COMMAND, ID_LOG_ALL, 0);
#endif

/*	Get the original symbol remembered as an option */
	if (RememberSymbolChoice(hwnd, &ActiveConfig, &ActiveConfig.Symbol))
		SaveConfiguration(hwnd, &ActiveConfig, "SymbolChoice");

	cInfos[0].Running = TRUE;
	cInfos[0].CenterRanging = TRUE;
//	cInfos[0].Destination.lat = 26+20.1945/60.0;
//	cInfos[0].Destination.lon = -(81+26.2313/60.0);

	return hwnd;
}

static int GetFreeTrackerCount(STATION_INFO_S *Station=NULL, BOOL *pActive=NULL)
{	int Available = 0;

	if (pActive) *pActive = FALSE;
	for (int tr=1; tr<MAX_TRACKERS; tr++)
		if (!cInfos[tr].Active) Available++;
		else if (Station && pActive
		&& cInfos[tr].CenterStation
		&& cInfos[tr].CenterStation == Station)
			*pActive = TRUE;
	return Available;
}

static int GetFreeRangerCount(void)
{
	int trCount=1;	/* One for the main window */
	for (int tr=1; tr<MAX_TRACKERS; tr++)
		if (cInfos[tr].Active && cInfos[tr].CenterRanging)
			trCount++;
	return max(0,MAX_RANGERS-trCount);
}

#ifdef OBSOLETE
static int CompareTrackerNames(const char *s1, const char *s2)
{	const char *p, *q;

	for (p=s1, q=s2; *p && *p!=':' && *q && *q!=':'; p++, q++)
	{	if (*p > *q)
			return -1;	/* s1 is greater */
		else if (*p < *q)
			return 1;	/* s2 is greater */
	}
	if (!*p || *p==':')
	{	if (!*q || *q==':')
			return 0;	/* End of both, they matched */
		else return 1;	/* s2 is longer */
	} else return -1;	/* s1 is longer */
}

static unsigned long LocateTrackerEntry(TIMED_STRING_LIST_S *pList, const char *string)
{	unsigned long i;

	for (i=0; i<pList->Count; i++)
	{	if (!CompareTrackerNames(string, pList->Entries[i].string))
			return i;	/* Found it */
	}
	return -1;
}
#endif

BOOL CloseTrackers(HWND hwnd, BOOL Quiet)
{
#if MAX_TRACKERS <= 1
	return TRUE;
#else
	{	STRING_LIST_S *pList = &ActiveConfig.AutoTrackers;
		STRING_LIST_S *aList = &ActiveConfig.AlwaysTrackers;
		size_t ActiveCount=0;
		pList->Count = 0;
/*
	First purge out any AlwaysTrackers that got closed
*/
		for (size_t p=0; p<aList->Count; p++)
		{	int tr;
			for (tr=1; tr<MAX_TRACKERS; tr++)
			if (cInfos[tr].Active
			&& !CompareColonStrings(cInfos[tr].CenterID, aList->Entries[p].string))
				break;
			if (tr >= MAX_TRACKERS)
			{	RemoveSimpleStringEntry(aList, p--);
			}
		}
/*
	Now build up a question list of what to ask about
*/
		for (int tr=1; tr<MAX_TRACKERS; tr++)	/* Don't count ME[0]! */
		{	if (cInfos[tr].Active
			&& cInfos[tr].CenterStation != MyStation
			&& (!cInfos[tr].CenterStation
				|| !cInfos[tr].CenterStation->isNWS)
			&& (!cInfos[tr].CenterStation
				|| !cInfos[tr].CenterStation->Nickname
				|| (!cInfos[tr].CenterStation->Nickname->MultiTrackNew
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackActive
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackAlways)))
			{	unsigned long p = LocateColonStringEntry(aList, cInfos[tr].CenterID);
				if (p == -1)	/* New one! */
				{	ActiveCount++;
				} else	/* It's always, remember the current stats */
				{	char *ViewString = MakeViewString(&cInfos[tr], cInfos[tr].viewBits);
					size_t Len = sizeof(cInfos[tr].CenterID)+6*(1+33)+1+strlen(ViewString)+1;
					char *TempBuf = (char*)malloc(Len);
					StringCbPrintfA(TempBuf, Len,
							"%s:%ld@%ld,%ld[%ld,%ld]%s",
							cInfos[tr].CenterID, cInfos[tr].zoom,
							cInfos[tr].rcSize.left, cInfos[tr].rcSize.top,
							cInfos[tr].rcSize.right-cInfos[tr].rcSize.left,
							cInfos[tr].rcSize.bottom-cInfos[tr].rcSize.top,
							ViewString);
					UpdateTimedStringEntryAt(aList, p, TempBuf);
					free(TempBuf);
					free(ViewString);
				}
#ifdef OBSOLETE
				{	NICKNAME_INFO_S *MyNick = GetOrCreateNickname(&ActiveConfig, cInfos[tr].CenterID, NULL, FALSE, FALSE);
					if (MyNick) MyNick->MultiTrackZoom = cInfos[tr].zoom;
				}
#endif
			}
		}

		if (ActiveCount)
		{	int SaveThem = IDYES;
			size_t Remaining = sizeof(TCHAR) * (ActiveCount*32 + 80);
			TCHAR *Buffer = (TCHAR *)malloc(Remaining);
			TCHAR *Next = Buffer;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("Save Active MultiTracks:\n\n"));
			for (int tr=1; tr<MAX_TRACKERS; tr++)	/* Don't count ME[0]! */
			{	if (cInfos[tr].Active
				&& cInfos[tr].CenterStation != MyStation
				&& (!cInfos[tr].CenterStation
					|| !cInfos[tr].CenterStation->isNWS)
				&& (!cInfos[tr].CenterStation
					|| !cInfos[tr].CenterStation->Nickname
					|| (!cInfos[tr].CenterStation->Nickname->MultiTrackNew
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackActive
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackAlways)))
				{	unsigned long p = LocateColonStringEntry(aList, cInfos[tr].CenterID);
					if (p == -1)	/* New one? */
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("%.*S "), STRING(cInfos[tr].CenterID));
				}
			}
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n\nFor Auto-Restart?"));

			BUTTONS_S *Buttons = CreateButtons(-1);
			AddButton(Buttons, "Yes", IDYES);
			AddButton(Buttons, "Always", IDRETRY);
			AddButton(Buttons, "Show Me", IDABORT);
			AddButton(Buttons, "No", IDNO);
			if (Quiet) SaveThem = IDYES;
			else SaveThem = LwdMessageBox2(hwnd, Buffer, TEXT("WM_CLOSE"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons);
			free(Buffer);

			if (SaveThem == IDABORT)	/* Show the MultiTracks */
			{	for (int tr=1; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active
				&& (!cInfos[tr].CenterStation
					|| !cInfos[tr].CenterStation->isNWS))
				{	ShowWindow(hwndTracker[tr], SW_RESTORE);
					SetForegroundWindow(hwndTracker[tr]);
				}
				return FALSE;	/* Let's not close just yet */
			} else if (SaveThem == IDRETRY)	/* Upgrade to Always */
			{	EmptySimpleStringList(aList);
				for (int tr=1; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active
				&& (!cInfos[tr].CenterStation
					|| !cInfos[tr].CenterStation->isNWS)
				&& (!cInfos[tr].CenterStation
					|| !cInfos[tr].CenterStation->Nickname
					|| (!cInfos[tr].CenterStation->Nickname->MultiTrackNew
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackActive
					&& !cInfos[tr].CenterStation->Nickname->MultiTrackAlways)))
				{	char *ViewString = MakeViewString(&cInfos[tr], cInfos[tr].viewBits);
					size_t Len = sizeof(cInfos[tr].CenterID)+6*(1+33)+1+strlen(ViewString)+1;
					char *TempBuf = (char*)malloc(Len);
					StringCbPrintfA(TempBuf, Len,
							"%s:%ld@%ld,%ld[%ld,%ld]%s",
							cInfos[tr].CenterID, cInfos[tr].zoom,
							cInfos[tr].rcSize.left, cInfos[tr].rcSize.top,
							cInfos[tr].rcSize.right-cInfos[tr].rcSize.left,
							cInfos[tr].rcSize.bottom-cInfos[tr].rcSize.top,
							ViewString);
					AddSimpleStringEntry(aList, TempBuf);
					free(TempBuf);
					free(ViewString);
				}
#ifdef OLD_WAY
				{	char TempBuf[sizeof(cInfos[tr].CenterID)+6*(1+33)+1];
					StringCbPrintfA(TempBuf, sizeof(TempBuf),
							"%s:%ld@%ld,%ld[%ld,%ld]%ld",
							cInfos[tr].CenterID, cInfos[tr].zoom,
							cInfos[tr].rcSize.left, cInfos[tr].rcSize.top,
							cInfos[tr].rcSize.right-cInfos[tr].rcSize.left,
							cInfos[tr].rcSize.bottom-cInfos[tr].rcSize.top,
							cInfos[tr].viewBits);
					AddSimpleStringEntry(aList, TempBuf);
				}
#endif
				EmptySimpleStringList(pList);	/* Not saving as pList */
				TraceError(hwnd, "WM_CLOSE Saved %ld Always MultiTracks\n", aList->Count);
			} else if (SaveThem == IDYES)
			{	EmptySimpleStringList(pList);
				for (int tr=1; tr<MAX_TRACKERS; tr++)	/* Don't count ME[0]! */
				{	if (cInfos[tr].Active
					&& (!cInfos[tr].CenterStation
						|| !cInfos[tr].CenterStation->isNWS)
					&& (!cInfos[tr].CenterStation
						|| !cInfos[tr].CenterStation->Nickname
						|| (!cInfos[tr].CenterStation->Nickname->MultiTrackNew
							&& !cInfos[tr].CenterStation->Nickname->MultiTrackActive
							&& !cInfos[tr].CenterStation->Nickname->MultiTrackAlways)))
					{	char *ViewString = MakeViewString(&cInfos[tr], cInfos[tr].viewBits);
						size_t Len = sizeof(cInfos[tr].CenterID)+6*(1+33)+1+strlen(ViewString)+1;
						char *TempBuf = (char*)malloc(Len);
						StringCbPrintfA(TempBuf, Len,
								"%s:%ld@%ld,%ld[%ld,%ld]%s",
								cInfos[tr].CenterID, cInfos[tr].zoom,
								cInfos[tr].rcSize.left, cInfos[tr].rcSize.top,
								cInfos[tr].rcSize.right-cInfos[tr].rcSize.left,
								cInfos[tr].rcSize.bottom-cInfos[tr].rcSize.top,
								ViewString);
						if (LocateColonStringEntry(aList, TempBuf) == -1)	/* New one? */
							AddSimpleStringEntry(pList, TempBuf);
						free(TempBuf);
						free(ViewString);
					}
#ifdef OLD_WAY
					{	char TempBuf[sizeof(cInfos[tr].CenterID)+6*(1+33)+1];
						StringCbPrintfA(TempBuf, sizeof(TempBuf),
								"%s:%ld@%ld,%ld[%ld,%ld]%ld",
								cInfos[tr].CenterID, cInfos[tr].zoom,
								cInfos[tr].rcSize.left, cInfos[tr].rcSize.top,
								cInfos[tr].rcSize.right-cInfos[tr].rcSize.left,
								cInfos[tr].rcSize.bottom-cInfos[tr].rcSize.top,
								cInfos[tr].viewBits);
						if (LocateColonStringEntry(aList, TempBuf) == -1)	/* New one? */
							AddSimpleStringEntry(pList, TempBuf);
					}
#endif
				}
				TraceError(hwnd, "WM_CLOSE Saved %ld Active MultiTracks\n", pList->Count);
			} else EmptySimpleStringList(pList);
		}
	}
#endif
	return TRUE;
}

HWND RestoreTracker(char *string)
{	char *Station = _strdup(string);
	int z = -1;
	RECT rcPlace = { CW_USEDEFAULT, CW_USEDEFAULT,
					CW_USEDEFAULT, CW_USEDEFAULT };
	WINDOWPOS Pos;
	char *Extra = NULL;
	if (ParseWindowPosition(Station, &Pos, &z, &Extra))
	{	RECT rc;
		SetRect(&rc, Pos.x, Pos.y, Pos.x+Pos.cx, Pos.y+Pos.cy);
		ClipOrCenterRectToMonitor(&rc,
					MONITOR_CLIP | MONITOR_WORKAREA);
		SetRect(&rcPlace, rc.left, rc.top,
					rc.right-rc.left,
					rc.bottom-rc.top);
	}
#ifdef OLD_WAY
		char *e;
		*c++ = '\0';	/* Null terminate station ID */
		z = strtol(c,&e,10);	/* And retrieve the zoom factor */
		if (e && *e=='@')
		{	RECT rc;
			rc.left = strtol(e+1,&e,10);
			if (e && *e==',')
			{	rc.top = strtol(e+1,&e,10);
				if (e && *e=='[')
				{	rc.right = rc.left + strtol(e+1,&e,10);
					if (e && *e==',')
					{	rc.bottom = rc.top + strtol(e+1,&e,10);
						if (e && *e==']')
						{	ClipOrCenterRectToMonitor(&rc,
										MONITOR_CLIP | MONITOR_WORKAREA);
							SetRect(&rcPlace, rc.left, rc.top,
										rc.right-rc.left,
										rc.bottom-rc.top);
							if (strtol(e+1,&e,10) == 0)
								v = 0;	/* View NONE */
						}
					}
				}
			}
		}
	}
#endif
	HWND hwnd = CreateTrackerWindow(Station,NULL,-1,Extra,z,&rcPlace);
	free(Station);
	return hwnd;
}

static BOOL SuppressAwaitingAPRSP = FALSE;	/* Suppresses ?APRSP on Tracker recalls */

void RestoreTrackers(void)
{
#if MAX_TRACKERS > 1
	SuppressAwaitingAPRSP = TRUE;
	STRING_LIST_S *pList = &ActiveConfig.AlwaysTrackers;
	unsigned int i;
	for (i=0; i<pList->Count; i++)
	{	RestoreTracker(pList->Entries[i].string);
	}
	pList = &ActiveConfig.AutoTrackers;
	for (i=0; i<pList->Count; i++)
	{	RestoreTracker(pList->Entries[i].string);
	}
	for (i=0; i<ActiveConfig.Nicknames.Count; i++)
	{	NICKNAME_INFO_S *pNick = &ActiveConfig.Nicknames.Nick[i];
		if (pNick->MultiTrackAlways && !strchr(pNick->Station,'*'))
			CreateTrackerWindow(pNick->Station);
	}
	SuppressAwaitingAPRSP = FALSE;
#endif
}

/*	rcPlace.right/.bottom = width/height */
HWND CreateTrackerWindow(char *StationID, char *OwnerID, int fromIndex, char *ViewString, int zoom, RECT *rcPlace)
{
#if MAX_TRACKERS <= 1
	return NULL;
#else
	int tr;
    HWND     hwnd;
	RECT	rcMine;
static ATOM     atm2 = 0;

{	WINDOWPOS Pos;
	char *Extra;
	int z;
	if (RecallTrackerWindowPosition(StationID, &Pos, &z, &Extra))
	{	if (!rcPlace
		|| (rcPlace->left == CW_USEDEFAULT && rcPlace->right == CW_USEDEFAULT
			&& rcPlace->top == CW_USEDEFAULT && rcPlace->bottom == CW_USEDEFAULT))
		{	RECT rc;
			rcPlace = &rcMine;
			SetRect(&rc, Pos.x, Pos.y, Pos.x+Pos.cx, Pos.y+Pos.cy);
			ClipOrCenterRectToMonitor(&rc,
						MONITOR_CLIP | MONITOR_WORKAREA);
			SetRect(rcPlace, rc.left, rc.top,
						rc.right-rc.left,
						rc.bottom-rc.top);
		}
		if (zoom == -1) zoom = z;
		if (!ViewString) ViewString = Extra;
	}
}

	if (!ViewString) ViewString = ActiveConfig.MultiTrack.ViewNone?"0":"All";

TraceError(hwndMain, "CreateTrackerWindow(%s)\n", StationID);
	if (!atm2)
	{
		WNDCLASS wc;
	// Set up the window class description
		ZeroMemory(&wc, sizeof(wc));
		wc.lpfnWndProc = TrackerWindowProc;
		wc.hInstance = g_hInstance;
//		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszClassName = g_szTrackerName;

#ifndef UNDER_CE
	//	if (LoadIconMetric(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON), LIM_SMALL, &wc.hIcon) != S_OK)
		wc.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
		if (!wc.hIcon)
		wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);              // predefined app. icon 
		wc.hCursor = LoadCursor(NULL, IDC_ARROW);                    // predefined arrow 
		wc.lpszMenuName = MAKEINTRESOURCE(IDM_TRACKER);
#endif

		// We want to redraw the window contents anytime we get resized. That way
		// we'll respond appropriately when the user switches between portrait and
		// landscape. If we had any child windows or controls, we'd need to
		// reposition or resize them when we get a WM_SIZE message.
		wc.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;

#ifdef TRACE_MESSAGES
TraceLogThread("MultiTrack",TRUE,"RegisterClass(%S)\n", g_szTrackerName);
#endif
		// Register the window class
		atm2 = RegisterClass(&wc);
		if (atm2 == 0)
		{	TraceError(hwndMain, "RegisterClass(%S) Failed! Error=%ld\n", wc.lpszClassName, (long) GetLastError());
			// Failed!!
			return NULL;
		}
	}
#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"FindStationCall(%s %s) pCloseStations->%p[%ld]\n", StationID?StationID:"*NULL*", OwnerID?OwnerID:"*NULL*", pCloseStations, (long) CloseStationCount);
#endif

	STATION_INFO_S *Station = FindStationCall(StationID, OwnerID, OwnerID==NULL);
	if (!Station)
	{	unsigned int s;
		char *tOwner = OwnerID?OwnerID:StationID;
		for (s=0; s<CloseStationCount; s++)
		{	if (!_stricmp(StationID, pCloseStations[s]->Station)
			&& !_stricmp(tOwner, pCloseStations[s]->Owner))
				break;
		}
		if (s < CloseStationCount) Station = pCloseStations[s];
	}

#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"Check %ld Trackers\n", (long) MAX_TRACKERS);
#endif
	{	HWND hwndTemp = GetMultiTrackWindow(StationID, Station, fromIndex);
		if (hwndTemp)
		{	ShowWindow(hwndTemp, SW_RESTORE);
			SetForegroundWindow(hwndTemp);
			return hwndTemp;
		}
	}
/*
	First we need to find an available slot
*/
#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"Find Available Tracker Slot\n");
#endif
	for (tr=1; tr<MAX_TRACKERS; tr++)
	{	if (!cInfos[tr].Active)
		if (!hwndTracker[tr] || !IsWindow(hwndTracker[tr]))
		{	break;
		}
	}
	if (tr >= MAX_TRACKERS)
	{	if (strcmp(ViewString,"0"))
		{	char *Buffer = (char*)malloc(256);
			StringCbPrintfA(Buffer, 256, "Too Many MultiTrackers Active, Not Tracking %s", StationID);
			QueueInternalMessage(Buffer, TRUE);
		}
		return NULL;	/* No room */
	}

	memset(&cInfos[tr], 0, sizeof(cInfos[tr]));
	cInfos[tr].Index = tr;

	TCHAR szTitle[80];

	if (Station)
	{
#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"New Tracker[%ld] is %s %s\n", (long) tr, Station->Station, Station->Owner);
#endif
		if (Station->isNWS && Station->sComment)
			FormatNWSTitle(Station, szTitle, sizeof(szTitle));
		else if (HasNickLabelNonBlank(Station))
			StringCbPrintf(szTitle, sizeof(szTitle), TEXT("Follow%S)"), Station->Nickname->Label);
		else StringCbPrintf(szTitle, sizeof(szTitle), TEXT("Follow(%S)"), Station->Station);
		Station->isCenter = TRUE;
		cInfos[tr].CenterTracking = TRUE;
		cInfos[tr].CenterStation = Station;
		strncpy(cInfos[tr].CenterID, cInfos[tr].CenterStation->Station, sizeof(cInfos[tr].CenterID));
		cInfos[tr].LastCenterPosition.dblLatitude = Station->pCoord->lat;
		cInfos[tr].LastCenterPosition.dblLongitude = Station->pCoord->lon;
		cInfos[tr].LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
	} else	/* Station not found, wait for it */
	{
#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"New Tracker[%ld] Awaiting %s ME(%p) hwndMain(%p)\n", (long) tr, StationID, MyStation, hwndMain);
#endif
		StringCbPrintf(szTitle, sizeof(szTitle), TEXT("Await(%S)"), StationID);
		cInfos[tr].Awaiting = TRUE;
		strncpy(cInfos[tr].CenterID, StationID, sizeof(cInfos[tr].CenterID));

		if (!MyStation) DefineME(hwndMain);
		cInfos[tr].LastCenterPosition.dblLatitude = MyStation->pCoord->lat;
		cInfos[tr].LastCenterPosition.dblLongitude = MyStation->pCoord->lon;
		cInfos[tr].LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
	}

	if (fromIndex >= 0 && fromIndex < MAX_TRACKERS)
	{	cInfos[tr].Paths = cInfos[fromIndex].Paths;
	} else
	{	cInfos[tr].Paths = cInfos[0].Paths;
	}

#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"InvalidateStationPoints[%ld]\n", (long) tr);
#endif
	InvalidateStationPoints(tr,"CreateTrackerWindow",TRUE);

    // Create a window using the class we just registered. Note that the
	// initial size and position don't matter, because we're going to make it
	// fullscreen when we get WM_CREATE, before it's ever displayed.

	/* Probe configuration to see if we have a saved WindowPlacement */
#ifdef FUTURE
//	if (!ActiveConfig.WindowPlacement.x
//	|| !ActiveConfig.WindowPlacement.y
//	|| !ActiveConfig.WindowPlacement.width
//	|| !ActiveConfig.WindowPlacement.height)
	{	ActiveConfig.WindowPlacement.x = ActiveConfig.WindowPlacement.y = CW_USEDEFAULT;
//		ActiveConfig.WindowPlacement.width = 640;
//		ActiveConfig.WindowPlacement.height = 480;
		ActiveConfig.WindowPlacement.width = CW_USEDEFAULT;
		ActiveConfig.WindowPlacement.height = CW_USEDEFAULT;
	}
#ifdef FUTURE
	else
	{	RECT rc;
		rc.left = ActiveConfig.WindowPlacement.x;
		rc.top = ActiveConfig.WindowPlacement.y;
		rc.right = rc.left + ActiveConfig.WindowPlacement.width;
		rc.bottom = rc.top + ActiveConfig.WindowPlacement.height;
		TraceError(NULL, "Saved WindowPlacement %ld x %ld @ %ld %ld\n",
					ActiveConfig.WindowPlacement.width,
					ActiveConfig.WindowPlacement.height,
					ActiveConfig.WindowPlacement.x,
					ActiveConfig.WindowPlacement.y);
		ClipOrCenterRectToMonitor(&rc, MONITOR_CLIP | MONITOR_WORKAREA);
		ActiveConfig.WindowPlacement.x = rc.left;
		ActiveConfig.WindowPlacement.y = rc.top;
		OffsetRect(&rc, -rc.left, -rc.top);
		ActiveConfig.WindowPlacement.width = rc.right;
		ActiveConfig.WindowPlacement.height = rc.bottom;
		TraceError(NULL, "Modified WindowPlacement %ld x %ld @ %ld %ld\n",
					ActiveConfig.WindowPlacement.width,
					ActiveConfig.WindowPlacement.height,
					ActiveConfig.WindowPlacement.x,
					ActiveConfig.WindowPlacement.y);
	}
#endif
#else
	struct
	{	long x, y, w, h;
	} WindowPlacement = { CW_USEDEFAULT, CW_USEDEFAULT,
						ActiveConfig.MultiTrack.width,
						ActiveConfig.MultiTrack.height };
//TraceLogThread("MultiTrack", TRUE, "%ld x %ld vs %ld x %ld\n",
//		 ActiveConfig.MultiTrack.width, ActiveConfig.MultiTrack.height,
//		 ActiveConfig.WindowPlacement.width, ActiveConfig.WindowPlacement.height);

	if (!WindowPlacement.w)
		WindowPlacement.w = ActiveConfig.OrgWindowPlacement.width;
	if (!WindowPlacement.h)
		WindowPlacement.h = ActiveConfig.OrgWindowPlacement.height;
	if (!WindowPlacement.w)
		WindowPlacement.w = CW_USEDEFAULT;
	if (!WindowPlacement.h)
		WindowPlacement.h = CW_USEDEFAULT;
	if (rcPlace)
	{
	if (rcPlace->left != CW_USEDEFAULT) WindowPlacement.x = rcPlace->left;
	if (rcPlace->top != CW_USEDEFAULT) WindowPlacement.y = rcPlace->top;
	if (rcPlace->right != CW_USEDEFAULT) WindowPlacement.w = rcPlace->right;
	if (rcPlace->bottom != CW_USEDEFAULT) WindowPlacement.h = rcPlace->bottom;
	}
#endif

#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"'Creating[%ld] %ld x %ld\n", (long) tr, WindowPlacement.width, WindowPlacement.height);
#endif


#ifdef UNDER_CE
#ifdef USING_SHELL
	hwnd = CreateWindow((LPCTSTR)atm2, szTitle,
						/* WS_OVERLAPPED | WS_SYSMENU */
						WS_NONAVDONEBUTTON,
        WindowPlacement.x, WindowPlacement.y,
		WindowPlacement.w, WindowPlacement.h,
						NULL, NULL, g_hInstance, (LPVOID) tr);
#else
	{	RECT rc;
		GetWindowRect(hwndMain, &rc);
		WindowPlacement.h = (rc.bottom-rc.top)/2;
		WindowPlacement.w = (rc.right-rc.left)/2;
		
		hwnd = CreateWindow((LPCTSTR)atm2, szTitle,
							WS_NONAVDONEBUTTON | WS_OVERLAPPED | /* WS_BORDER | */WS_DLGFRAME | WS_SYSMENU | /*WS_THICKFRAME | */WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
	        WindowPlacement.x, WindowPlacement.y,
			WindowPlacement.w, WindowPlacement.h,
							NULL, NULL, g_hInstance, (LPVOID) tr);
		if (hwnd)
		{
#ifdef TRACE_MESSAGES
	TraceLogThread("MultiTrack",TRUE,"Create Command Bar\n");
#endif
			HWND hwndCB = CommandBar_Create(g_hInstance, hwnd, 0xBEEF);
			if (!CommandBar_InsertMenubar(hwndCB, g_hInstance, IDM_TRACKER, 0))
				TraceError(hwndMain, "InsertMenubar(%p) Failed with %ld\n", hwndCB, GetLastError());
			// CommandBar_AddAdornments (hwndCB, 0, 0); /*WM_HELP | CMDBAR_OK*/
		}
	}
#endif
#else
	hwnd = CreateWindow((LPCTSTR)atm2, szTitle, WS_OVERLAPPED | WS_SYSMENU | WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
        /* CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, */
        WindowPlacement.x, WindowPlacement.y,
		WindowPlacement.w, WindowPlacement.h,
		NULL, NULL, g_hInstance, (LPVOID) tr);
	if (hwnd)
	{	SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM) MakeSymbolIcon(hwnd, GetStationSymbol(MyStation)));
		SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM) MakeSymbolIcon(hwnd, GetStationSymbol(MyStation)));
//		CreateNotifyIcon(hwnd, szTitle, 1, WM_MSG_NOTIFICATION);
	}
#endif

//#ifdef TRACE_MESSAGES
//TraceLogThread("MultiTrack",TRUE, "CreateTrackerWindow(%s)=%p %ld,%ld %ldx%ld\n", StationID, hwnd, (long) WindowPlacement.x, (long) WindowPlacement.y, (long) WindowPlacement.width, (long) WindowPlacement.height);
//#else
//TraceLogThread("MultiTrace", TRUE, "CreateTrackerWindow(%s)=%p %ld,%ld %ldx%ld\n", StationID, hwnd, (long) WindowPlacement.x, (long) WindowPlacement.y, (long) WindowPlacement.w, (long) WindowPlacement.h);
//#endif

	if (hwnd == NULL)
    {	TraceError(hwndMain, "CreateTrackerWindow[%ld] Failed, Error=%ld\n", (long) tr, (long) GetLastError());
        // Failed!!
        return NULL;
    }

	hwndTracker[tr] = hwnd;
	cInfos[tr].Running = TRUE;
	cInfos[tr].viewBits = MakeViewBits(&cInfos[tr], ViewString);
	if (zoom != -1) cInfos[tr].zoom = zoom;
	TrackersActive++;

	if (Station)
	{	SetCenterTracking(hwnd, Station);
	} else
	{	TransmitFilter();
		if (cInfos[tr].Awaiting && !SuppressAwaitingAPRSP)
		{	SendAPRSMessage(cInfos[tr].CenterID, 0, TEXT("?APRSP"), FALSE, FALSE, FALSE, TRUE);
		}
	}

	// Make the window visible and paint before returning
//	CenterWindow(hwnd);
	InvalidateRect(hwnd, NULL, TRUE);
	ShowWindow(hwnd, SW_SHOW);
	UpdateWindow(hwnd);

	PostMessage(hwnd, WM_AUTO_ZOOM, 0, 0);

	return hwnd;
#endif
}

HWND RestoreOrCreateTrackerWindow(char *Station, char *Owner, int fromIndex)
{
	unsigned long i = LocateColonStringEntry(&ActiveConfig.AlwaysTrackers, Station);
	if (i != -1)
		return RestoreTracker(ActiveConfig.AlwaysTrackers.Entries[i].string);
	else
	{	i = LocateColonStringEntry(&ActiveConfig.AutoTrackers, Station);
		if (i != -1)
			return RestoreTracker(ActiveConfig.AutoTrackers.Entries[i].string);
		else
			return CreateTrackerWindow(Station,Owner,fromIndex);
	}
}

static void GetStationCounts(unsigned long *pDirect, unsigned long *pLocal, unsigned long *pRF)
{	unsigned long DirectStationCount = 0, LocalStationCount = 0, RFStationCount = 0;
	unsigned int s;

	for (s=1; s<CloseStationCount; s++)
	{	if (pCloseStations[s]->HeardOnRF)
		{	RFStationCount++;
			if (pCloseStations[s]->HeardOnRF <= LOCAL_MAX_HOPS+1)
				LocalStationCount++;
			if (pCloseStations[s]->HeardOnRF == 1)
				DirectStationCount++;
		}
	}
	*pDirect = DirectStationCount;
	*pLocal = LocalStationCount;
	*pRF = RFStationCount;
}

static void SetupStationTrackColor(STATION_INFO_S *Station)
{	unsigned long i, c=0, l=-1;
	COLORREF Color = RGB(0,0,0);
static unsigned long NextIndex = 0;

	if (Station->TrackColorLocked) return;

	for (i=0; i<ActiveConfig.TrackColors.Count; i++)
	{	if (ActiveConfig.TrackColors.Entries[i].value)	/* Active? */
		{	c++;
			l = i;
		}
	}
	if (c==1)
	{	Color = GetColorRGB(&ActiveConfig, ActiveConfig.TrackColors.Entries[l].string, "Station:TrackColor");
//TraceLogThread("Colors", FALSE, "SetupStationTrackColor:Assigning [%ld/%ld/%ld] or %s to %s\n",
//			   (long) 0, (long) c, (long) NextIndex,
//			   ActiveConfig.TrackColors.Entries[l].string, Station->Station);
	} else if (c)
	{	int u = NextIndex++ % c;	/* Mod index with available options */
		int o = u;
		for (i=0; i<ActiveConfig.TrackColors.Count; i++)
		{	if (ActiveConfig.TrackColors.Entries[i].value)	/* Active? */
			{	if (!u--)
				{	Color = GetColorRGB(&ActiveConfig, ActiveConfig.TrackColors.Entries[i].string, "Station:TrackColor");
//TraceLogThread("Colors", FALSE, "SetupStationTrackColor:Assigning [%ld/%ld/%ld] or %s to %s\n",
//			   (long) o, (long) c, (long) NextIndex,
//			   ActiveConfig.TrackColors.Entries[i].string, Station->Station);
					break;
				}
			}
		}
		if (i>=ActiveConfig.TrackColors.Count)
TraceLogThread("Colors", TRUE, "SetupStationTrackColor:[%ld/%ld/%ld] FAILED for %s\n",
			   (long) o, (long) c, (long) NextIndex, Station->Station);
	} else
	{	Color = ActiveConfig.Screen.Track.Other.RGB;
//TraceLogThread("Colors", FALSE, "SetupStationTrackColor:No Rotation Enabled of %ld, Assiging Other's %s to %s\n",
//			   (long) ActiveConfig.TrackColors.Count,
//			   ActiveConfig.Screen.Track.Other.Color, Station->Station);
	}
	Station->TrackColor = Color;
}

static void UpdateShriekStatus(STATION_INFO_S *Station, char *Comment)
{	if (strchr(Comment,'!'))	/* Must have one ! to do this work */
	{	char *s = strchr(Comment, '}');		/* Don't want to process inside }MultiLine{xxxxx */
		char *e = s?strrchr(s,'{'):NULL;
		if (e)	/* Have the }MultiLine{ delimiters, shorten the parseable comment */
		{	if (s > Comment)	/* Make sure more than MultiLine */
			{	size_t Len = s-Comment;
				char *Temp = (char*)malloc(Len+1);
				strncpy(Temp, Comment, Len);
				Temp[Len] = '\0';
				Station->ShriekMask |= GetStringShriekMask(Temp, Station, Comment);
				free(Temp);
			}
		} else Station->ShriekMask |= GetStringShriekMask(Comment, Station, Comment);
	}
}

static void SetupStationNickname(STATION_INFO_S *Station)
{	NICKNAME_INFO_S *MyNick = GetOrCreateNickname(&ActiveConfig, Station->Station, NULL, FALSE, FALSE);
	//long eTactical = FALSE;

	if (!MyNick)	/* Maybe there's a wildcard available? */
	{	unsigned int p;
		for (p=0; p<ActiveConfig.Nicknames.Count; p++)
		{	char *l, *r;
			for (l=ActiveConfig.Nicknames.Nick[p].Station, r=Station->Station; *l && *r; l++, r++)
			{	if (toupper(*l&0xff) != toupper(*r&0xff)) break;
			}
			if (*l == '*'
			&& (l[1]=='*' || !*r || *r=='-'))
			{	NICKNAME_INFO_S *Copyable = (NICKNAME_INFO_S*)malloc(sizeof(*Copyable));
				*Copyable = ActiveConfig.Nicknames.Nick[p];
				MyNick = GetOrCreateNickname(&ActiveConfig, Station->Station, "", TRUE, FALSE);
				if (MyNick)
				{	char *Message = (char*)malloc(80);
					StringCbPrintfA(Message, 80, "Cloned Nickname From %s To %s", Copyable->Station, MyNick->Station);
					QueueInternalMessage(Message, TRUE);
					strncpy(Copyable->DefinedBy, Copyable->Station, sizeof(Copyable->DefinedBy));
					strncpy(Copyable->Station, MyNick->Station, sizeof(Copyable->Station));
					*MyNick = *Copyable;
					MyNick->OverrideLabel = FALSE;
				}
				free(Copyable);
			}
		}
	}

	if (!MyNick && !Station->Nickname) return;	/* Quick out */

	Station->ShriekMask = 0;	/* Let the next real packet reload it */
	if (!MyNick)
	{	free(Station->Nickname);
		Station->Nickname = NULL;
	} else 
	{	GetSystemTime(&MyNick->LastSeen);
		if (!Station->Nickname) Station->Nickname = (NICKNAME_INFO_S *)malloc(sizeof(*Station->Nickname));
		if (!MyNick->OverrideSymbol)
		{	char Overlay = (Station->isymbol>>8);
			char Symbol = Station->isymbol&0xff;
			if (Station->isymbol&0xff0000)
				Overlay = (Station->isymbol>>16)&0xff;
			else Overlay = Overlay?'\\':'/';
			MyNick->Symbol.Table = Overlay;
			MyNick->Symbol.Symbol = Symbol;
		}
		*Station->Nickname = *MyNick;
		if (Station->Nickname->OverrideColor)
		{	Station->Nickname->RGB = GetColorRGB(&ActiveConfig, Station->Nickname->Color, "NickName");
		}

		UpdateShriekStatus(Station, Station->Nickname->Comment);
		if (Station->Nickname->Enabled)
		{	if (Station->Nickname->OverrideLabel)
				UpdateShriekStatus(Station, Station->Nickname->Label);
		}				

#ifdef OBSOLETE
	} else if (MyTactical && eTactical)
	{	if (!Station->Nickname) Station->Nickname = (NICKNAME_INFO_S *)calloc(1, sizeof(*Station->Nickname));
		strncpy(Station->Nickname->Station, Station->Station,
				sizeof(Station->Nickname->Station));
		Station->Nickname->Enabled = TRUE;
		Station->Nickname->OverrideLabel = TRUE;
		strncpy(Station->Nickname->Label, MyTactical, sizeof(Station->Nickname->Label)-1);
		if (strlen(MyTactical) >= sizeof(Station->Nickname->Label))
		{	Station->Nickname->OverrideComment = TRUE;
			strncpy(Station->Nickname->Comment, MyTactical, sizeof(Station->Nickname->Comment)-1);
		}
#endif
	}
//	if (MyTactical) free(MyTactical);
	if (!HasNickComment(Station) && Station->pLastPositPacket)
	{	char *TempPkt = _strdup(Station->pLastPositPacket);
		APRS_PARSED_INFO_S APRS;
		if (parse_full_aprs(TempPkt,&APRS))
			UpdateShriekStatus(Station, APRS.CleanComment);
		free(TempPkt);
	}
}

static void FixNickname(char *StationID)
{	STATION_INFO_S *Station = FindStationCall(StationID);
	if (Station) SetupStationNickname(Station);
	else if (strchr(StationID,'*'))	/* Wildcard?  take care of it */
	{	int count = ClearClonedNicknames(NULL, &ActiveConfig, StationID);
		if (count)
		{	char *Buffer = (char*) malloc(80);
			StringCbPrintfA(Buffer, 80, "Cleared %ld Nicknames Cloned From %s", count, StationID);
			QueueInternalMessage(Buffer, TRUE);
		}
	}
}

static void FixNicknames(char *AtLeast=NULL)
{	BOOL DoAll = AtLeast && strchr(AtLeast,'*');	/* Wildcards require total re-scan */
	if (AtLeast) FixNickname(AtLeast);
	for (unsigned long p=0; p<CloseStationCount; p++)
	{	if (DoAll
		|| pCloseStations[p]->Nickname
		|| (AtLeast && !_stricmp(pCloseStations[p]->Station,AtLeast)))
			SetupStationNickname(pCloseStations[p]);
	}
}

static void ParseAndDefineTacticals(HWND hwnd, char *srcCall, char *Message, SYSTEMTIME *st)
{	int SaveThem = IDYES;

	if (!Message) return;

	Message = _strdup(Message);
	if (strrchr(Message,'{'))
	{	*strrchr(Message,'{') = '\0';	/* Null out sequence */
	}

	if (LocateSimpleStringEntry(&ActiveConfig.TacticalNevers, srcCall)!=-1)
	{	TraceLog("Tactical", TRUE, hwnd, "ParseAndDefineTacticals:Ignoring %s's TACTICAL %s\n", srcCall, Message);
		SaveThem = IDIGNORE;
	} else
	{	if (_stricmp(srcCall, CALLSIGN)
		&& LocateSimpleStringEntry(&ActiveConfig.TacticalSources, srcCall)==-1)
		{	BUTTONS_S *Buttons = CreateButtons(-1);
			size_t BufSize = sizeof(TCHAR)*(strlen(Message)+256);
			TCHAR *Buffer = (TCHAR*)malloc(BufSize);
			StringCbPrintf(Buffer, BufSize, TEXT("Trust TACTICAL Assignments From %S\n\n%S\n\n(%04ld-%02ld-%02ld %02ld:%02ld:%02ld)"),
							srcCall, Message,
							st->wYear, st->wMonth, st->wDay,
							st->wHour, st->wMinute, st->wSecond);
			AddButton(Buttons, "Yes", IDYES);
			AddButton(Buttons, "Always", IDRETRY);
			AddButton(Buttons, "Never", IDIGNORE);
			AddButton(Buttons, "No", IDNO);
			SaveThem = LwdMessageBox2(hwnd, Buffer, TEXT("TACTICAL"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons);
			free(Buffer);
		}
		switch (SaveThem)
		{
		case IDIGNORE:
			TraceLog("Tactical", TRUE, hwnd, "ParseAndDefineTacticals:Permanently Ignoring %s's TACTICAL %s\n", srcCall, Message);
			AddSimpleStringEntry(&ActiveConfig.TacticalNevers, srcCall);
			break;
		case IDRETRY:	/* Remember the sender as trusted */
			TraceLog("Tactical", TRUE, hwnd, "ParseAndDefineTacticals:Always Accepting %s's TACTICAL %s\n", srcCall, Message);
			AddSimpleStringEntry(&ActiveConfig.TacticalSources, srcCall);
		case IDYES:		/* And define the tacticals */
		{	TraceLog("Tactical", TRUE, hwnd, "ParseAndDefineTacticals:Accepting %s's TACTICAL %s\n", srcCall, Message);
			if (!strchr(Message, '='))	/* Defining my own? */
			{	RememberTacticalNickname(hwnd, &ActiveConfig, srcCall, Message, srcCall);
				FixNickname(srcCall);
			} else
			{	char *Copy = _strdup(Message);
				char *start = Copy;
				while (start && *start)
				{	char *end = strchr(start,';');		/* Multi-part */
					if (!end) end = strchr(start,'\0');	/* or last one */
					char *equal = strchr(start,'=');
					if (equal && equal < end)	/* Need an equal BEFORE semi */
					{	char safe = *end;
						*end = '\0';	/* Null out end */
						*equal++ = '\0';	/* Null out call */
						RtStrnTrim(-1,start);
						RtStrnTrim(-1,equal);
						if (*start)
						{	RememberTacticalNickname(hwnd, &ActiveConfig, start, equal, srcCall);
							FixNickname(start);
						} else TraceError(hwnd, "Blank Call in %s TACTICAL(%s) from %s\n", srcCall, Message);
						*end = safe;
					} else TraceError(hwnd, "Missing Equal In %s TACTICAL(%s)\n", srcCall, Message);
					start = *end?end+1:end;
				}
				free(Copy);
			}
			FixNicknames();
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		}
	}
	}
	free(Message);
}

extern "C"
{
void GetOverlayCounts(OVERLAY_CONFIG_INFO_S *pOver, int *pPoints, int *pRoutes, int *pTracks);
void *CreateOverlayObject(OVERLAY_CONFIG_INFO_S *pOver, char *ID, char Type, double Lat, double Lon, long Alt, int isymbol, char *Comment);
void SetOverlayObjectStatus(OVERLAY_CONFIG_INFO_S *pOver, char *ID, char *Status);
void MoveOverlayObject(void *ObjHandle, double Lat, double Lon, long Alt, BOOL ClearFirst);
}

static OVERLAY_INFO_S *GetOverlayInfo(OVERLAY_CONFIG_INFO_S *pOver, BOOL AllowCreate = TRUE)
{	return &pOver->Runtime;
}

static OVERLAY_OBJECT_INFO_S *GetOverlayObject(OVERLAY_CONFIG_INFO_S *pOver, char *ID, BOOL AllowCreate = TRUE)
{	OVERLAY_INFO_S *Overlay = GetOverlayInfo(pOver, AllowCreate);
	int o;

	if (!Overlay) return NULL;

	for (o=0; o<Overlay->ObjectCount; o++)
	{	if (!strcmp(Overlay->Objects[o].ID, ID))
			return &Overlay->Objects[o];
	}
	if (!AllowCreate) return NULL;

	o = Overlay->ObjectCount++;
	if (Overlay->ObjectCount > Overlay->ObjectSize)
	{	Overlay->ObjectSize += 1;
		Overlay->Objects = (OVERLAY_OBJECT_INFO_S*)realloc(Overlay->Objects, sizeof(*Overlay->Objects)*Overlay->ObjectSize);
		memset(&Overlay->Objects[o], 0, sizeof(*Overlay->Objects)*(Overlay->ObjectSize-o));
	}
	Overlay->Objects[o].ID = _strdup(ID);
	return &Overlay->Objects[o];
}

void GetOverlayCounts(OVERLAY_CONFIG_INFO_S *pOver, int *pPoints, int *pRoutes, int *pTracks)
{	OVERLAY_INFO_S *Overlay = GetOverlayInfo(pOver, FALSE);
	if (Overlay)
	{	if (pPoints) *pPoints = Overlay->PointCount;
		if (pRoutes) *pRoutes = Overlay->RouteCount;
		if (pTracks) *pTracks = Overlay->TrackCount;
	}
}

void *CreateOverlayObject(OVERLAY_CONFIG_INFO_S *pOver, char *ID, char Type, double Lat, double Lon, long Alt, int isymbol, char *Comment)
{	OVERLAY_OBJECT_INFO_S *Obj = GetOverlayObject(pOver, ID, FALSE);
	if (!Obj)	/* new one */
	{	OVERLAY_INFO_S *Overlay = GetOverlayInfo(pOver, TRUE);
		Obj = GetOverlayObject(pOver, ID, TRUE);
		if (!Obj) return Obj;
		if (Overlay)
		switch (Type)
		{
		case 'P': Overlay->PointCount++; break;
		case 'R': Overlay->RouteCount++; break;
		case 'T': Overlay->TrackCount++; break;
		}
	}

	Obj->Type = Type;
	Obj->isymbol = isymbol;
	UTF8Save(&Obj->sComment, &Obj->pComment, Comment HERE);
	Obj->pCoord = GetCoordIndex(Lat, Lon, "OverlayObj", Obj->ID, Obj->pCoord);
	Obj->alt = Alt;

//	TraceLogThread("Overlays", TRUE, "Created:%s(%s) at %.4lf %.4lf\n", FileName, ID, Lat, Lon);
	return Obj;
}

void SetOverlayObjectStatus(OVERLAY_CONFIG_INFO_S *pOver, char *ID, char *Status)
{	OVERLAY_OBJECT_INFO_S *Obj = GetOverlayObject(pOver, ID, FALSE);

	if (!Obj) return;

	UTF8Save(&Obj->sStatusReport, &Obj->pStatusReport, Status HERE);
}

void MoveOverlayObject(void *ObjHandle, double Lat, double Lon, long Alt, BOOL ClearFirst)
{	OVERLAY_OBJECT_INFO_S *Obj = (OVERLAY_OBJECT_INFO_S *) ObjHandle;
	int t;

	if (!Obj) return;

//	TraceLogThread("Overlays", TRUE, "Move:%s to %.4lf %.4lf\n", Obj->ID, Lat, Lon);
	if (ClearFirst && Obj->TrackCount)
	{	for (t=0; t<Obj->TrackCount; t++)
			DeReferenceCoord("MoveOverlay", Obj->ID, Obj->Tracks[t].pCoord);
		Obj->TrackCount = 0;
		Obj->TrackSize = 0;
		if (Obj->Tracks)
		{	free(Obj->Tracks);
			Obj->Tracks = NULL;
		}
	}

	if (!Obj->TrackCount)	/* First one? */
	{	Obj->TrackColor = RGB(0,0,128);	/* Dark blue hard-coded for now */
	}

	t = Obj->TrackCount++;
	if (Obj->TrackCount > Obj->TrackSize)
	{	Obj->TrackSize += 1;
		Obj->Tracks = (TRACK_INFO_S *)realloc(Obj->Tracks, sizeof(*Obj->Tracks)*Obj->TrackSize);
		memset(&Obj->Tracks[t], 0, sizeof(*Obj->Tracks)*(Obj->TrackSize-t));
	}
	Obj->Tracks[t].pCoord = GetCoordIndex(Lat, Lon, "MoveOverlay", Obj->ID, Obj->Tracks[t].pCoord);
	Obj->Tracks[t].alt = Alt;
}

static int CmpCharChar(const void *one, const void *two)
{	char **Left = (char **) one;
	char **Right = (char **) two;
	return strcmp(*Left,*Right);
}

#ifdef USING_CHAT

#define COLOR_MESSAGE_ADOPTED RGB(0,0,255)
#define COLOR_MESSAGE_SOURCE_DONE RGB(0,192,0)	/* Sent and ack'd */
#define COLOR_MESSAGE_SOURCE_ACK RGB(0xFF,0x8C,0x00)	/* Sent, pending ack */
#define COLOR_MESSAGE_SOURCE_QUEUED RGB(0xFF,0xD7,0x00)	/* Blocked by previous */
#define COLOR_MESSAGE_SOURCE_STALLED RGB(0xDB,0x70,0x93)	/* Exhausted first set */
#define COLOR_MESSAGE_SOURCE_EXHAUSTED RGB(0xC7,0x15,0x85)	/* Exhausted all retries */
#define COLOR_MESSAGE_SOURCE_CANCELLED RGB(0x94,0x00,0xD3)	/* Cancelled by user (or ONE-SHOT) */
#define COLOR_MESSAGE_REPLY RGB(255,0,0)
#define COLOR_MESSAGE_INTRO RGB(192,192,64)
#ifdef FOR_REFERENCE
{ "darkorange", RGB(0xFF,0x8C,0x00) },
{ "orange", RGB(0xFF,0xA5,0x00) },
{ "orangered", RGB(0xFF,0x45,0x00) },
{ "gold", RGB(0xFF,0xD7,0x00) },
{ "goldenrod", RGB(0xDA,0xA5,0x20) },
{ "blueviolet", RGB(0x8A,0x2B,0xE2) },
{ "darkviolet", RGB(0x94,0x00,0xD3) },
{ "mediumvioletred", RGB(0xC7,0x15,0x85) },
{ "palevioletred", RGB(0xDB,0x70,0x93) },
{ "violet", RGB(0xEE,0x82,0xEE) },
#endif

typedef struct CHAT_MESSAGE_S
{	SYSTEMTIME stFirst, stLast;
	long Dupes;
	char *Text;
	MESSAGE_TYPE_V Type;
	long Index;
	BOOL Response;
	COLORREF Color;
	UINT LineIndex;	/* Where inserted in text box */
} CHAT_MESSAGE_S;

typedef struct CHAT_INFO_S
{	char From[STATION_SIZE];
	char To[STATION_SIZE];
	BOOL FromToChanged;
	HWND hwndChat;
	HWND hwndLog;
	HWND hwndAck;
	HWND hwndPort;
	HWND hwndSend;
	HWND hwndEntry;
	HWND hwndCB;
	int MenuOffset;
	BOOL isActive;
	BOOL isFlashing;

	int textHeight;
	int textWidth;
	int leadInWidth;

#ifdef USING_SHELL
	SHACTIVATEINFO sha;
#endif
	struct
	{	int ID;
		HWND hwnd;
		TCHAR *Label;
	} Buttons[4];
	int ButtonCount;
	int ButtonHeight;
	int ButtonMargin;
	int ButtonDefault;

	long MessageLoaded;
	long MessageCount;
	long MessageSize;
	CHAT_MESSAGE_S *Messages;
} CHAT_INFO_S;

unsigned long ChatCount=0;
CHAT_INFO_S **Chats = NULL;
//CHAT_INFO_S *RunningChat = NULL;
char LastChatStation[STATION_SIZE] = {0};	/* Last station sent to */

void FreeChat(CHAT_INFO_S *Chat, BOOL MessagesOnly=FALSE)
{//	if (Chat == RunningChat) return;
	if (!MessagesOnly)
	for (unsigned int c=0; c<ChatCount; c++)
	{	if (Chats[c] == Chat)
			Chats[c] = NULL;
	}
	for (int m=0; m<Chat->MessageCount; m++)
		free(Chat->Messages[m].Text);
	if (MessagesOnly)
		Chat->MessageLoaded = Chat->MessageCount = 0;
	else
	{	free(Chat->Messages);
		free(Chat);
	}
}

CHAT_INFO_S *FindChat(char *From, char *To, BOOL *pReply=NULL, MESSAGE_TYPE_V Type=MESSAGE_UNSPECIFIED)
{
	unsigned int c;

	//if (Type == MESSAGE_RUNNING) return RunningChat;

	for (c=0; c<ChatCount; c++)
	if (Chats[c] /*&& Chats[c]->hwndChat*/)
	{	if (!_strnicmp(Chats[c]->From, From, sizeof(Chats[c]->From))
			&& !_strnicmp(Chats[c]->To, To, sizeof(Chats[c]->To)))
		{	BOOL Changed = strncmp(Chats[c]->From, From, sizeof(Chats[c]->From))
					|| strncmp(Chats[c]->To, To, sizeof(Chats[c]->To));
			if (Changed)
			{	strncpy(Chats[c]->From, From, sizeof(Chats[c]->From));
				strncpy(Chats[c]->To, To, sizeof(Chats[c]->To));
				Chats[c]->FromToChanged = TRUE;
				if (Chats[c]->hwndChat)
					PostMessage(Chats[c]->hwndChat, WM_FIX_SEND_BUTTON, 0, 0);
			}
			if (pReply) *pReply = FALSE;
			return Chats[c];
		} else if (!_strnicmp(Chats[c]->From, To, sizeof(Chats[c]->From))
			&& !_strnicmp(Chats[c]->To, From, sizeof(Chats[c]->To)))
		{	BOOL Changed = strncmp(Chats[c]->From, To, sizeof(Chats[c]->From))
					|| strncmp(Chats[c]->To, From, sizeof(Chats[c]->To));
			if (Changed)
			{	strncpy(Chats[c]->From, To, sizeof(Chats[c]->From));
				strncpy(Chats[c]->To, From, sizeof(Chats[c]->To));
				Chats[c]->FromToChanged = TRUE;
				if (Chats[c]->hwndChat)
					PostMessage(Chats[c]->hwndChat, WM_FIX_SEND_BUTTON, 0, 0);
			}
			if (pReply) *pReply = TRUE;
			return Chats[c];
		}
	}
	return NULL;
}

static BOOL AddToChat(CHAT_INFO_S *Chat, BOOL Reply, MESSAGE_TYPE_V type, char *message, SYSTEMTIME *pst=NULL, COLORREF Color = RGB(0,0,0), BOOL ForceNew=FALSE)
{	int m;
	SYSTEMTIME stNow;
	if (!pst)
	{	GetLocalTime(&stNow);
		pst = &stNow;
	}

	if (!Chat) return FALSE;

	TraceLog("Chat", TRUE, NULL, "AddToChat(%s<->%s):Reply:%ld Type:%ld Color:0x%06lX %s(%ld)<%s>\n", Chat->From, Chat->To, Reply, type, Color, ForceNew?"FORCENEW ":"", strlen(message), message);

	int len, cmplen=strlen(message);
	char *ack = strrchr(message,'{');
	if (ack && strlen(ack) <= 6)
	{	len = ack-message-1;
		if (strlen(ack) >= 5 && ack[3] == '}')
		{	if (ack[4])
			{	cmplen--;	/* Don't match on Reply-Ack */
				if (ack[5])
					cmplen--;	/* Don't match on Reply-Ack */
			}
		}
	} else len = cmplen;	/* Compare entire message */

	if (ForceNew)
		m = -1;
	else for (m=Chat->MessageCount-1; m>=0; m--)
	{	if (Chat->Messages[m].Response == Reply
		&& Chat->Messages[m].Type == type
		&& (Chat->Messages[m].Color == Color
			|| (Color == COLOR_MESSAGE_SOURCE_DONE
				&& (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_ACK
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_QUEUED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_STALLED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_CANCELLED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_EXHAUSTED))
			|| (Color == COLOR_MESSAGE_SOURCE_ACK
				&& (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_QUEUED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_STALLED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_EXHAUSTED))
			|| (Color == COLOR_MESSAGE_SOURCE_STALLED
				&& (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_ACK))
			|| (Color == COLOR_MESSAGE_SOURCE_EXHAUSTED
				&& (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_ACK))
			|| (Color == COLOR_MESSAGE_SOURCE_CANCELLED
				&& (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_ACK
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_QUEUED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_STALLED
					|| Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_EXHAUSTED))
			|| (Chat->Messages[m].Color == COLOR_MESSAGE_SOURCE_ACK
				&& Color == COLOR_MESSAGE_SOURCE_DONE))
		&& Chat->Messages[m].stFirst.wYear == pst->wYear
		&& Chat->Messages[m].stFirst.wMonth == pst->wMonth
		&& Chat->Messages[m].stFirst.wDay == pst->wDay)
		if (!strncmp(Chat->Messages[m].Text, message, cmplen)	/* Needs ack included */
		&& (len != cmplen || DeltaSeconds(&Chat->Messages[m].stFirst, pst) <= DUPLICATE_DETECT_SECONDS))	/* Ackless new enough? */
		{	break;
		} else
		{	if (!strncmp(Chat->Messages[m].Text, message, len))
				TraceLog("Chat", TRUE, NULL, "AddToChat:Message[%ld] LOST ACK! (%ld)<%s> -> (%ld)<%s>\n", m, strlen(message),message, strlen(Chat->Messages[m].Text),Chat->Messages[m].Text);
			if (Chat->Messages[m].Response == Reply
			&& Chat->Messages[m].Type == type
			&& Chat->Messages[m].stFirst.wYear == pst->wYear
			&& Chat->Messages[m].stFirst.wMonth == pst->wMonth
			&& Chat->Messages[m].stFirst.wDay == pst->wDay
			&& !strncmp(Chat->Messages[m].Text, message, cmplen)	/* Needs ack included */
			&& (len != cmplen || DeltaSeconds(&Chat->Messages[m].stFirst, pst) <= DUPLICATE_DETECT_SECONDS))	/* Ackless new enough? */
			{	TraceLog("Chat", TRUE, NULL, "AddToChat:Message[%ld] Color 0x%06lX Not Changing To 0x%06lX ", m, (long) Chat->Messages[m].Color, Color);
			}
		}
		if (!ack)	/* Ackless only merges below ack'd messages */
		{	char *hadAck = strrchr(Chat->Messages[m].Text,'{');
			if (hadAck && strlen(hadAck) <= 6)
			{	
TraceLog("Chat", TRUE, NULL, "AddToChat:Not Merging Ackless(%s) Before Ack'd[%ld/%ld](%s)\n", message, (long) m, (long) Chat->MessageCount, Chat->Messages[m].Text);
				m = -1;	/* Didn't find it */
				break;
			} else if (DeltaSeconds(&Chat->Messages[m].stFirst, pst) >DUPLICATE_DETECT_SECONDS)	/* too long ago? */
			{
TraceLog("Chat", TRUE, NULL, "AddToChat:Ackless(%s) Too Old (%ld>%ld sec) to Merge before [%ld/%ld](%s)\n", message, (long) DeltaSeconds(&Chat->Messages[m].stFirst, pst), (long) DUPLICATE_DETECT_SECONDS, (long) m, (long) Chat->MessageCount, Chat->Messages[m].Text);
				m = -1;	/* Didn't find it */
				break;
			}
		}
	}
	if (m < 0)
	{	m = Chat->MessageCount++;
		if (Chat->MessageCount > Chat->MessageSize)
		{	Chat->MessageSize += 16;
			Chat->Messages = (CHAT_MESSAGE_S *)realloc(Chat->Messages, sizeof(*Chat->Messages)*Chat->MessageSize);
		}
		memset(&Chat->Messages[m],0,sizeof(Chat->Messages[m]));
		Chat->Messages[m].stFirst = Chat->Messages[m].stLast = *pst;
		Chat->Messages[m].Type = type;
		Chat->Messages[m].Response = Reply;
		Chat->Messages[m].Dupes = 0;
		Chat->Messages[m].Text = _strdup(message);
		Chat->Messages[m].Color = Color;
TraceLog("Chat", FALSE, NULL, "%s->%s New[%ld] %s\n", Chat->From, Chat->To, (long) m, Chat->Messages[m].Text);
	} else
	{	Chat->Messages[m].stLast = *pst;
		if (Chat->Messages[m].Color == Color)	/* Not the ack yet! */
			Chat->Messages[m].Dupes++;
		else Chat->Messages[m].Color = Color;	/* Ack just changes color, doesn't count */
		if (m < Chat->MessageLoaded) Chat->MessageLoaded = m;
TraceLog("Chat", FALSE, NULL, "%s->%s Repeat[%ld]*%ld %s\n", Chat->From, Chat->To, (long) m, Chat->Messages[m].Dupes, Chat->Messages[m].Text);
	}
TraceLog("Chat", FALSE, NULL, "AddLineIndex[%ld/%ld] is %ld\n", m, Chat->MessageCount, Chat->Messages[m].LineIndex);
	SendMessage(Chat->hwndChat, WM_REFRESH_CHAT, 0, 0);
#ifdef UNDER_CE
	TraceLog("Chat", FALSE, NULL, "AddToChat 0x%lX %s %s\n", Chat->hwndChat, IsWindowVisible(Chat->hwndChat)?"visible":"NOT Visible", Chat->isActive?"Active":"INActive");
	return Chat->isActive;
	return Chat->hwndChat != NULL && IsWindowVisible(Chat->hwndChat);
#else
	return Chat->isActive;
#endif
}

static void RemoveMessage(int i);

typedef struct DUPE_DETECT_S
{	int m;
	int Index;
	BOOL First;
	int Duplicates;
	SYSTEMTIME stLast;
} DUPE_DETECT_S;

static int MessageDupeCompare(const void *One, const void *Two)
{	DUPE_DETECT_S *Left = (DUPE_DETECT_S *) One;
	DUPE_DETECT_S *Right = (DUPE_DETECT_S *) Two;

	if (Left->Index < Right->Index) return -1;
	else if (Left->Index > Right->Index) return 1;
	else return 0;
}

static BOOL PopulateChat(CHAT_INFO_S *Chat, BOOL PurgeOnly = FALSE)
{	BOOL Removed = FALSE;
TraceLog("Chat", FALSE, NULL, "PopulateChat[%ld] Starting\n", MessageCount);

	int m, Count=0;

	for (m=0; m<MessageCount; m++)
	{	if ((!_stricmp(Chat->From, Messages[m].From)
		&& !_stricmp(Chat->To, Messages[m].To))
		|| (!_stricmp(Chat->To, Messages[m].From)
		&& !_stricmp(Chat->From, Messages[m].To)))
		{	Count++;
		}
	}

	DUPE_DETECT_S *Dupes = (DUPE_DETECT_S *) calloc(Count, sizeof(*Dupes));

	Count = 0;
	for (m=0; m<MessageCount; m++)
	{	if ((!_stricmp(Chat->From, Messages[m].From)
		&& !_stricmp(Chat->To, Messages[m].To))
		|| (!_stricmp(Chat->To, Messages[m].From)
		&& !_stricmp(Chat->From, Messages[m].To)))
		{	BOOL First = TRUE;
			Dupes[Count].m = m;
			Dupes[Count].Index = Messages[m].Index;
			Dupes[Count].First = TRUE;
			for (int d=0; d<Count; d++)
			{	int m1 = Dupes[d].m;
				if (!strcmp(Messages[m1].Text, Messages[m].Text))
				{	if ((!_stricmp(Messages[m1].From, Messages[m].From)
					&& !_stricmp(Messages[m1].To, Messages[m].To)))
					{	Dupes[d].Duplicates++;
						Dupes[d].stLast = Messages[m].stLocal;
						Dupes[Count].First = FALSE;
						break;
					}
				}
			}
			Count++;	/* Count the new entry */
		}
	}
	if (Count > 1)
		qsort(Dupes, Count, sizeof(*Dupes), MessageDupeCompare);

	for (int d=0; d<Count; d++)
	{	int m = Dupes[d].m;
		int Index = Dupes[d].Index;

		if (m >= MessageCount || Messages[m].Index != Index)
		{
TraceLog("Messages", TRUE, NULL, "Messages MOVED!  Locating Index %ld\n", Index);
			for (m=0; m<MessageCount; m++)
				if (Messages[m].Index == Index)
					break;
			if (m >= MessageCount || Messages[m].Index != Index)
			{	
TraceLog("Messages", TRUE, NULL, "Messages MOVED!  Failed To Find Index %ld\n", Index);
				continue;	/* Next Dupe */
			}
		}

		if (!_strnicmp(Chat->From, Messages[m].From, sizeof(Chat->From))
		&& !_strnicmp(Chat->To, Messages[m].To, sizeof(Chat->To)))
		{	if (!PurgeOnly && !Messages[m].AddedToChat)
			{	AddToChat(Chat, FALSE, Messages[m].Type,
							Messages[m].Text, &Messages[m].stLocal,
							COLOR_MESSAGE_REPLY);
				Messages[m].AddedToChat = TRUE;
			}
			RemoveMessage(m); m--;	/* Repeat this entry */
			Removed = TRUE;
		} else if (!_strnicmp(Chat->From, Messages[m].To, sizeof(Chat->From))
		&& !_strnicmp(Chat->To, Messages[m].From, sizeof(Chat->To)))
		{	if (!PurgeOnly && !Messages[m].AddedToChat)
			{	AddToChat(Chat, TRUE, Messages[m].Type,
							Messages[m].Text, &Messages[m].stLocal,
							COLOR_MESSAGE_SOURCE_DONE);
				Messages[m].AddedToChat = TRUE;
			}
			RemoveMessage(m); m--;	/* Repeat this entry */
			Removed = TRUE;
		}
	}
	if (Removed) InvalidateMessage(TRUE);
TraceLog("Chat", FALSE, NULL, "PopulateChat[%ld] Complete\n", MessageCount);
	return Removed;
}

CHAT_INFO_S *DisplayChat(char *From, char *To);

TCHAR uMsgLeadIn[] = TEXT("01:02:03> ");
TCHAR uMaxMsgLine[] = TEXT("This APRS message line is equal to the specs limit of 67 characters");

LRESULT CALLBACK ChatWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{	CHAT_INFO_S *Chat;
static BOOL UseRichEdit = FALSE;
static TCHAR *sLogClassName = NULL;

#ifdef VERBOSE_CHAT
if (iMsg != WM_SETCURSOR
&& iMsg != WM_GETICON
&& iMsg != WM_TIMER)
	TraceLog("Chat", FALSE, hwnd, "%p %s %08lX %08lX", hwnd, MsgToText(iMsg),(long) wParam, (long) lParam);
#endif

#ifndef IDE_LOG
#define IDE_LOG 12345
#endif
	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		Chat = (CHAT_INFO_S *) cs->lpCreateParams;
		SetWindowLong(hwnd, GWL_USERDATA, (LONG) Chat);
#ifdef USING_SHELL
		memset(&Chat->sha,0,sizeof(Chat->sha));
		Chat->sha.cbSize = sizeof(Chat->sha);
#endif

		RECT rcFixed, rcText, rcLeadIn;
		GetWindowRect(hwndMain, &rcFixed);
		GetNearestMonitor(&rcFixed, MONITOR_WORKAREA);
		rcText = rcFixed;
		SetFixedTextRect(hwndMain, &rcText, uMaxMsgLine, 0, 0);
	    OffsetRect(&rcText, -rcText.left, -rcText.top);	/* Width/Height */
		rcLeadIn = rcFixed;
		SetFixedTextRect(hwndMain, &rcLeadIn, uMsgLeadIn, 0, 0);
	    OffsetRect(&rcLeadIn, -rcLeadIn.left, -rcLeadIn.top);	/* Width/Height */
		TraceLog("Chat", TRUE, hwndMain, "Text %ld x %ld LeadIn %ld x %ld\n", rcText.right, rcText.bottom, rcLeadIn.right, rcLeadIn.bottom);

		Chat->textWidth = rcText.right;
		Chat->textHeight = rcText.bottom;
		Chat->leadInWidth = rcLeadIn.right;

		if (!sLogClassName)
		{
#ifndef UNDER_CE
			if (LoadLibrary(TEXT("Riched20.dll")))
			{	TraceLog("Chat", TRUE, NULL, "RichEd20.dll Loaded!\n");
				sLogClassName = RICHEDIT_CLASS;
				UseRichEdit = TRUE;
			} else
#endif
				sLogClassName = TEXT("edit");
		}

#if defined(USING_SHELL) || defined(CE50)
#ifdef CE50
	{	Chat->hwndCB = CommandBar_Create(g_hInstance, hwnd, 0xBEEA);
		if (Chat->hwndCB)
		{	if (!CommandBar_InsertMenubar(Chat->hwndCB, g_hInstance, IDM_CHAT, 0))
				TraceLogThread("Activity", TRUE, "InsertMenubar(%p) Failed with %ld\n", Chat->hwndCB, (long) GetLastError());
			else
			{	Chat->MenuOffset = CommandBar_Height(Chat->hwndCB);
				TraceLogThread("Chat", TRUE, "Chat MenuOffset=%ld\n", Chat->MenuOffset);
			}
			// CommandBar_AddAdornments (Chat->hwndCB, 0, 0); /*WM_HELP | CMDBAR_OK*/
		} else TraceLogThread("Activity", TRUE, "CommandBar_Create Failed with %ld\n", (long) GetLastError());
	}
#else
	SHMENUBARINFO shmbi;

	// Create our softkey bar
	ZeroMemory(&shmbi, sizeof(shmbi));
	shmbi.cbSize = sizeof(shmbi);
	shmbi.hwndParent = hwnd;
	shmbi.dwFlags = SHCMBF_HMENU;
	shmbi.nToolBarId = IDM_CHAT;
	shmbi.hInstRes = g_hInstance;
	if (!SHCreateMenuBar(&shmbi))
	{
#ifdef DONT_DO_THIS
		// Failed!!
		return FALSE;
	} else
	{	//g_hwndMb          = shmbi.hwndMB;
		TBBUTTONINFO tbbi = {0};
		tbbi.cbSize       = sizeof(tbbi);
		tbbi.dwMask       = TBIF_LPARAM | TBIF_BYINDEX;
		SendMessage(shmbi.hwndMB, TB_GETBUTTONINFO, 1, (LPARAM)&tbbi);
		cInfo->hMenu           = (HMENU)tbbi.lParam;
#endif
	}
#endif

	// Windows Mobile applications should always display their main window
	// full-screen. We're going to let the OS do this for us by calling
	// SHInitDialog, even though technically this window isn't a dialog window.
	SHINITDLGINFO shidi;
	shidi.dwMask = SHIDIM_FLAGS;
	shidi.hDlg = hwnd;	/* SHIDIF_SIZEDLG */
	shidi.dwFlags = SHIDIF_SIZEDLGFULLSCREEN | SHIDIF_SIPDOWN;
	if (!SHInitDialog(&shidi))
	{
	}

	SHDoneButton(hwnd, SHDB_HIDE);	/* SHDB_SHOW, SHDB_HIDE, SHDB_SHOWCANCEL */
#endif

#ifdef UNDER_CE
		Chat->hwndLog = CreateWindow(sLogClassName, NULL,
									WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_BORDER | WS_CLIPSIBLINGS |
									ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_AUTOVSCROLL | ES_READONLY,
									0, 0, 0, 0, hwnd, (HMENU) IDE_LOG, g_hInstance, NULL);	/* Display portion */
#else
		Chat->hwndLog = CreateWindow(sLogClassName, NULL,
									WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER | WS_CLIPSIBLINGS |
									ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_READONLY,
									0, 0, 0, 0, hwnd, (HMENU) IDE_LOG, g_hInstance, NULL);	/* Display portion */
#endif
#ifndef UNDER_CE
		if (UseRichEdit)
		{	SendMessage(Chat->hwndLog, EM_SETBKGNDCOLOR, 0, GetSysColor(COLOR_BTNFACE));
			SendMessage(Chat->hwndLog, EM_AUTOURLDETECT, TRUE, 0);
			LPARAM evMask = SendMessage(Chat->hwndLog, EM_GETEVENTMASK, 0, 0);
			evMask |= ENM_LINK | ENM_KEYEVENTS;
			SendMessage(Chat->hwndLog, EM_SETEVENTMASK, 0, evMask);
TraceLog("Chat", TRUE, hwnd, "SetEventMask to 0x%lX (Link=0x%lX)\n", evMask, ENM_LINK);
		}
#endif

		SendMessage(Chat->hwndLog, EM_LIMITTEXT, 65535, 0);
		SendMessage(Chat->hwndLog, WM_SETFONT, (WPARAM)GetFixedFont(), 0);
#ifdef FOR_INFO
COMBOBOX        IDL_TO_CALL,25,6,48,66,CBS_DROPDOWN | CBS_AUTOHSCROLL | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    EDITTEXT        IDE_TEXT,25,22,123,38,ES_MULTILINE | ES_AUTOVSCROLL
    DEFPUSHBUTTON   "Send",IDB_SEND,7,62,50,14,BS_NOTIFY
    PUSHBUTTON      "Cancel",IDB_CANCEL,99,62,50,14,BS_NOTIFY
    LTEXT           "  To:",IDC_STATIC,6,9,16,8
    LTEXT           "Text:",IDC_STATIC,5,24,18,8
	CONTROL         "Ack",IDC_ACK,"Button",BS_AUTOCHECKBOX | BS_NOTIFY | WS_GROUP
#endif
		if (!_strnicmp(Chat->To, CALLSIGN, sizeof(Chat->To))
		|| !_strnicmp(Chat->From, CALLSIGN, sizeof(Chat->From)))
		{	Chat->hwndEntry = CreateWindow(sLogClassName/*TEXT("edit")*/, NULL,
									WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP |
									ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_AUTOVSCROLL,
									0, 0, 0, 0, hwnd, (HMENU) IDE_TEXT, g_hInstance, NULL);	/* Entry space */
		SendMessage(Chat->hwndEntry, WM_SETFONT, (WPARAM)GetFixedFont(), 0);
		SendMessage(Chat->hwndEntry, EM_LIMITTEXT, (DEFAULT_WRAP_WIDTH-1)*5+1+2, 0);
		SendMessage(Chat->hwndEntry, EM_SETSEL, 0, -1);
		SendMessage(Chat->hwndEntry, EM_FMTLINES, 0, 0);	/* No soft breaks */

#ifndef UNDER_CE
		{	RECT rc;
			SetRect(&rc, 0, 0, 32767, 32767);
			SetMessageBoxTextRect(hwnd, &rc, TEXT("Send RF"), 0, 0);	
			OffsetRect(&rc, -rc.left, -rc.top);
			Chat->hwndSend = CreateWindow(TEXT("button"), TEXT("Send"),
							WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
							| BS_PUSHBUTTON,
							0, 0, (long) (rc.right*1.5), (long) (rc.bottom*1.5),
							hwnd, (HMENU) IDB_SEND, cs->hInstance, NULL);
		}
		{	RECT rc;
			SetRect(&rc, 0, 0, 32767, 32767);
			SetMessageBoxTextRect(hwnd, &rc, TEXT("Ack"), 0, 0);	
			OffsetRect(&rc, -rc.left, -rc.top);
			Chat->hwndAck = CreateWindow(TEXT("button"), TEXT("Ack"),
							WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
							| BS_AUTOCHECKBOX,
							0, 0, (long) (rc.right*3), (long) (rc.bottom*1.5),
							hwnd, (HMENU) IDC_ACK, cs->hInstance, NULL);
			SendMessage(Chat->hwndAck, BM_SETCHECK, BST_CHECKED, 0);
		}

		{	RECT rc;
			SetRect(&rc, 0, 0, 32767, 32767);
			SetMessageBoxTextRect(hwnd, &rc, TEXT("RF-Only"), 0, 0);	
			OffsetRect(&rc, -rc.left, -rc.top);
			Chat->hwndPort = CreateWindow(TEXT("button"), TEXT("Best"),
							WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
							| BS_AUTO3STATE,
							0, 0, (long) (rc.right*2), (long) (rc.bottom*1.5),
							hwnd, (HMENU) IDC_COMMPORT, cs->hInstance, NULL);
			SendMessage(Chat->hwndPort, BM_SETCHECK, BST_INDETERMINATE, 0);
			SendMessage(hwnd, WM_FIX_SEND_BUTTON, 0, 0);
		}

		if (UseRichEdit)
		{	SendMessage(Chat->hwndEntry, EM_AUTOURLDETECT, TRUE, 0);
			LPARAM evMask = SendMessage(Chat->hwndEntry, EM_GETEVENTMASK, 0, 0);
			evMask |= ENM_CHANGE /*| ENM_LINK | ENM_KEYEVENTS*/;
			SendMessage(Chat->hwndEntry, EM_SETEVENTMASK, 0, evMask);
TraceLog("Chat", TRUE, hwnd, "SetEventMask to 0x%lX (Link=0x%lX)\n", evMask, ENM_LINK);
		}
#endif

		} else
		{	int bWidth = 0;
			Chat->ButtonHeight = 0;
			Chat->ButtonCount = 2;
			Chat->ButtonDefault = -1;

			Chat->Buttons[0].ID = WM_USER;
			Chat->Buttons[0].Label = (TCHAR*) malloc(sizeof(TCHAR)*sizeof(Chat->From));
			StringCbPrintf(Chat->Buttons[0].Label, sizeof(TCHAR)*sizeof(Chat->From), TEXT("%S"), Chat->From);

			Chat->Buttons[1].ID = WM_USER+1;
			Chat->Buttons[1].Label = (TCHAR*) malloc(sizeof(TCHAR)*sizeof(Chat->To));
			StringCbPrintf(Chat->Buttons[1].Label, sizeof(TCHAR)*sizeof(Chat->To), TEXT("%S"), Chat->To);

#ifndef UNDER_CE
			HMENU hMenu = GetMenu(hwnd);
			if (hMenu)
			{	for (int i=0; i<Chat->ButtonCount; i++)
				{	AppendMenu(hMenu, MF_STRING, Chat->Buttons[i].ID, Chat->Buttons[i].Label);
				}
				DrawMenuBar(hwnd);
				Chat->ButtonCount = 0;
			}
#endif

//			Chat->Buttons[1].ID = IDB_CANCEL;
//			Chat->Buttons[1].Label = (TCHAR*) malloc(sizeof(TCHAR)*sizeof(Chat->To));
//			StringCbPrintf(Chat->Buttons[1].Label, sizeof(TCHAR)*sizeof(Chat->To), TEXT("%S"), "Close");
//			Chat->ButtonDefault = 1;	/* Default to Close */

			if (Chat->ButtonCount)
			{	int b;
				for (b=0; b<Chat->ButtonCount; b++)
				{	RECT rc;
					SetRect(&rc, 0, 0, 32767, 32767);
					SetMessageBoxTextRect(hwnd, &rc, Chat->Buttons[b].Label, 0,	0);	
					OffsetRect(&rc, -rc.left, -rc.top);
					if (rc.right > bWidth) bWidth = rc.right;
					if (rc.bottom > Chat->ButtonHeight) Chat->ButtonHeight = rc.bottom;
				}

				bWidth = (int)(bWidth*2);
				Chat->ButtonMargin = (int)(Chat->ButtonHeight*0.6)/2;
				Chat->ButtonHeight = (int)(Chat->ButtonHeight*1.6);
				for (b=0; b<Chat->ButtonCount; b++)
				{
					Chat->Buttons[b].hwnd = CreateWindow(TEXT("button"), Chat->Buttons[b].Label,
							WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
							| (b==Chat->ButtonDefault?BS_DEFPUSHBUTTON:BS_PUSHBUTTON),
							0, 0, bWidth, Chat->ButtonHeight,
							hwnd, (HMENU) Chat->Buttons[b].ID, cs->hInstance, NULL);
TraceLog("Chat", FALSE, hwnd, "But[%ld] is %S %ld x %ld (Height %ld Margin %ld)\n",
		 b, Chat->Buttons[b].Label, bWidth, Chat->ButtonHeight,
		 Chat->ButtonHeight, Chat->ButtonMargin);
				}
			}
		}

		SendMessage(Chat->hwndLog, EM_LIMITTEXT, 2000, 0L);

		{	TCHAR *Buffer = (TCHAR *) malloc(512);
			SYSTEMTIME stFirst;
			GetLocalTime(&stFirst);
			StringCbPrintf(Buffer, 512, TEXT("%02ld:%02ld:%02ld  New Chat Between %S and %S on %04ld-%02ld-%02ld\r\n"),
							(long) stFirst.wHour, 
							(long) stFirst.wMinute, 
							(long) stFirst.wSecond,
							Chat->From, Chat->To,
							(long) stFirst.wYear, 
							(long) stFirst.wMonth, 
							(long) stFirst.wDay);
			SetWindowText(Chat->hwndLog,Buffer);
			//SendMessage(Chat->hwndLog, EM_REPLACESEL, FALSE, (LPARAM) Buff);
			free(Buffer);
		}

		PostMessage(hwnd, WM_REFRESH_CHAT, 0, 0);	/* Populate the window */
		SetTimer(hwnd, 10, 500, NULL);
		return 0;
	}
	case WM_TIMER:
		if (wParam == 10)	/* Update timer */
		{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (Chat->isFlashing
			|| Chat->MessageLoaded < Chat->MessageCount)
			{	PostMessage(hwnd, WM_REFRESH_CHAT, 0, 0);	/* Populate the window */
			}
		}
		return 0;
#ifdef USING_SHELL
	case WM_SETTINGCHANGE:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		SHHandleWMSettingChange(hwnd, wParam, lParam, &Chat->sha);
		return 0;
	}
	case WM_ACTIVATE:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		SHHandleWMActivate(hwnd, wParam, lParam, &Chat->sha, 0);
		return 0;
	}
#endif

	case WM_FIX_SEND_BUTTON:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Chat->FromToChanged)
		{
			TCHAR *szTitle = (TCHAR *)malloc(sizeof(*szTitle)*128);
#ifdef UNDER_CE
			if (!strcmp(Chat->From,CALLSIGN))
			{	StringCbPrintf(szTitle, sizeof(*szTitle)*128,
							TEXT("%S"), Chat->To);
			} else if (!strcmp(Chat->To,CALLSIGN))
			{	StringCbPrintf(szTitle, sizeof(*szTitle)*128,
							TEXT("%S"), Chat->From);
			} else 
#endif
	/* Note that title is also built in DisplayChat */
				StringCbPrintf(szTitle, sizeof(*szTitle)*128,
							TEXT("%S <-> %S"), Chat->From, Chat->To);
			SetWindowText(hwnd, szTitle);
			free(szTitle);
		}
#ifndef UNDER_CE
		if (Chat->hwndPort)
		{	unsigned int p;
			BOOL ISMsg = ActiveConfig.Enables.Internet
			&& ActiveConfig.Enables.APRSIS
			&& ActiveConfig.APRSIS.XmitEnabled
			&& ActiveConfig.APRSIS.MessagesEnabled;
			BOOL RFMsg = FALSE;

			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			{	if (RFPortRunnable(&ActiveConfig.RFPorts.Port[p])
				&& ActiveConfig.RFPorts.Port[p].XmitEnabled
				&& ActiveConfig.RFPorts.Port[p].MessagesEnabled
				&& !ActiveConfig.Enables.RFReceiveOnly)
				{	RFMsg = TRUE;
					break;
				}
			}

			TraceLog("Chat", TRUE, hwnd, "Checking/Fixing Send Button IS:%s RF:%s\n",
					ISMsg?"Enabled":"Disabled", RFMsg?"Enabled":"Disabled");

			if (RFMsg && ISMsg)	// Can do either!
			{	EnableWindow(Chat->hwndPort, TRUE);
				EnableWindow(Chat->hwndSend, TRUE);
				int TriState = SendMessage(Chat->hwndPort, BM_GETCHECK, 0, 0);
				BOOL ISOnly = TriState==BST_UNCHECKED;
				BOOL RFOnly = TriState==BST_CHECKED;
TraceLog("Chat", TRUE, hwnd, "Send %s %s %s\n", ISOnly?"IS-Only":"", RFOnly?"RF-Only":"", ISOnly||RFOnly?"":"BOTH");
				if (RFOnly)
				{	SetWindowText(Chat->hwndPort, TEXT("RF Only"));
					SetWindowText(Chat->hwndSend, TEXT("Send RF"));	
				} else if (ISOnly)
				{	SetWindowText(Chat->hwndPort, TEXT("RF Only"));
					SetWindowText(Chat->hwndSend, TEXT("Send IS"));	
				} else
				{	SetWindowText(Chat->hwndPort,TEXT("Best"));
					SetWindowText(Chat->hwndSend, TEXT("Send"));
				}
			} else if (RFMsg)	// Can only do RF
			{	SetWindowText(Chat->hwndPort, TEXT("RF Only"));
				SetWindowText(Chat->hwndSend, TEXT("Send RF"));	
				SendMessage(Chat->hwndPort, BM_SETCHECK, BST_CHECKED, 0);	// RF-only
				EnableWindow(Chat->hwndPort, FALSE);
				EnableWindow(Chat->hwndSend, TRUE);
			} else if (ISMsg)	// Can only do IS
			{	SetWindowText(Chat->hwndPort, TEXT("RF Only"));
				SetWindowText(Chat->hwndSend, TEXT("Send IS"));
				SendMessage(Chat->hwndPort, BM_SETCHECK, BST_UNCHECKED, 0);	// IS-only
				EnableWindow(Chat->hwndPort, FALSE);
				EnableWindow(Chat->hwndSend, TRUE);
			} else				// Cannot do messaging!
			{	SendMessage(Chat->hwndPort, BM_SETCHECK, BST_INDETERMINATE, 0);	// Best?
				SetWindowText(Chat->hwndPort,TEXT("None"));
				SetWindowText(Chat->hwndSend, TEXT("NoPort"));
				EnableWindow(Chat->hwndPort, FALSE);
				EnableWindow(Chat->hwndSend, FALSE);
			}

		}
#endif
		return 0;
	}

	case WM_SETFOCUS:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Chat->hwndEntry) SetFocus(Chat->hwndEntry);
		if (!PopulateChat(Chat, TRUE))	/* Empty all of my messages */
			PostMessage(hwnd, WM_REFRESH_CHAT, 0, 0);	/* Populate the window */
		Chat->isActive = TRUE;
TraceLog("Chat", FALSE, NULL, "WM_SETFOCUS Active\n");
		SendMessage(hwnd, WM_FIX_SEND_BUTTON, 0, 0);
		return 0;
	}
	case WM_KILLFOCUS:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		Chat->isActive = FALSE;
TraceLog("Chat", FALSE, NULL, "WM_KILLFOCUS InActive\n");
		SendMessage(Chat->hwndLog, EM_SETSEL, -1, 0);	/* Deselect */
		return 0;
	}
	case WM_FIX_CHAT_BUTTONS:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Chat && Chat->ButtonCount)
		{	int b, lm, rm, gap;
			RECT rcBut, rcWin;

			GetWindowRect(Chat->Buttons[0].hwnd,&rcBut);
			OffsetRect(&rcBut, -rcBut.left, -rcBut.top);

			GetClientRect(hwnd,&rcWin);
TraceLog("Chat", FALSE, hwnd, "Window %ld %ld -> %ld %ld\n",
		 rcWin.left, rcWin.top, rcWin.right, rcWin.bottom);
			OffsetRect(&rcWin, -rcWin.left, -rcWin.top);
TraceLog("Chat", FALSE, hwnd, "Window Size %ld x %ld\n",
		 rcWin.right, rcWin.bottom);

			gap = (rcWin.right-rcBut.right*Chat->ButtonCount) / (Chat->ButtonCount+1);
			lm = rm = gap;

			for (b=0; b<Chat->ButtonCount; b++)
			{	HWND hwndButton = Chat->Buttons[b].hwnd;

TraceLog("Chat", FALSE, hwnd, "But[%ld](%p) is %S at %ld %ld\n",
		 b, Chat->Buttons[b].hwnd, Chat->Buttons[b].Label, 
		(b%Chat->ButtonCount)*(gap+rcBut.right)+lm,
		(rcWin.bottom-(b/Chat->ButtonCount+1)*rcBut.bottom)-Chat->ButtonMargin);

#ifdef AT_BOTTOM
				SetWindowPos(hwndButton, HWND_TOP,
						(b%Chat->ButtonCount)*(gap+rcBut.right)+lm,
						(rcWin.bottom-(b/Chat->ButtonCount+1)*rcBut.bottom)-Chat->ButtonMargin,
						0, 0, SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
#endif

TraceLog("Chat", FALSE, hwnd, "But[%ld](%p) is %S at %ld %ld (Margin %ld)\n",
		 b, Chat->Buttons[b].hwnd, Chat->Buttons[b].Label, 
		 rcWin.right / (b+2), rcWin.bottom / (b+2),
		 Chat->ButtonMargin);

#ifdef AT_BOTTOM
			SetWindowPos(hwndButton, HWND_TOP,
//						rcWin.right / (b+2),
						(b%Chat->ButtonCount)*(gap+rcBut.right)+lm,
//						rcWin.bottom / (b+2),
						(rcWin.bottom-(b/Chat->ButtonCount+1)*rcBut.bottom)-Chat->ButtonMargin,
						0, 0, SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
#else
				SetWindowPos(hwndButton, HWND_TOP,
						(b%Chat->ButtonCount)*(gap+rcBut.right)+lm,
						rcWin.top - Chat->ButtonMargin,
						0, 0, SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);
#endif
			}
		}
		break;
	}
	case WM_SIZE:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

if (Chat) TraceLogThread("Chat", TRUE, "WM_SIZE:%ld - %ld\n", HIWORD(lParam), Chat->MenuOffset);

		MarkActivity();

		if (!Chat->hwndEntry)
		{	MoveWindow(Chat->hwndLog, 0, Chat->MenuOffset, LOWORD(lParam), HIWORD(lParam)-Chat->MenuOffset, TRUE);
		}
#ifdef UNDER_CE
		else
		{	int Height = (HIWORD(lParam)-Chat->MenuOffset)*3/4;
			if (!MoveWindow(Chat->hwndLog, 0, Chat->MenuOffset, LOWORD(lParam), Height, TRUE))
				TraceLogThread("Chat", TRUE, "Failed to Move(hwndLog)\n");
			if (!MoveWindow(Chat->hwndEntry, 0, Height+Chat->MenuOffset, LOWORD(lParam), HIWORD(lParam)-Chat->MenuOffset-Height, TRUE))
				TraceLogThread("Chat", TRUE, "Failed to Move(hwndEntry)\n");
		}
#else
		else
		{	int tHeight = Chat->textHeight*5+Chat->textHeight/2;
			int tWidth = Chat->textWidth;
			int lWidth = Chat->leadInWidth;

			if (lWidth > LOWORD(lParam)/2) lWidth = LOWORD(lParam)/2;
			tWidth = LOWORD(lParam) - lWidth;

			if (tHeight > HIWORD(lParam)/2) tHeight = HIWORD(lParam)/2;
			MoveWindow(Chat->hwndLog, 0, 0, LOWORD(lParam), HIWORD(lParam)-tHeight, TRUE);
			MoveWindow(Chat->hwndEntry, lWidth, HIWORD(lParam)-tHeight, tWidth, tHeight, TRUE);
			if (Chat->hwndSend)
			{	RECT rcBut;
				GetWindowRect(Chat->hwndSend, &rcBut);
				OffsetRect(&rcBut, -rcBut.left, -rcBut.top);
				MoveWindow(Chat->hwndSend, (lWidth-rcBut.right)/2, HIWORD(lParam)-rcBut.bottom-Chat->textHeight/2, rcBut.right, rcBut.bottom, TRUE);
			}
			if (Chat->hwndAck)
			{	RECT rcBut;
				GetWindowRect(Chat->hwndAck, &rcBut);
				OffsetRect(&rcBut, -rcBut.left, -rcBut.top);
				MoveWindow(Chat->hwndAck, g_dwFontSize/2 /*(lWidth-rcBut.right)/2*/, HIWORD(lParam)-tHeight+Chat->textHeight/2, rcBut.right, rcBut.bottom, TRUE);
			}
			if (Chat->hwndPort)
			{	RECT rcBut;
				GetWindowRect(Chat->hwndPort, &rcBut);
				OffsetRect(&rcBut, -rcBut.left, -rcBut.top);
				MoveWindow(Chat->hwndPort, g_dwFontSize/2 /* (lWidth-rcBut.right)/2*/, HIWORD(lParam)-tHeight+(tHeight-rcBut.bottom)/2, rcBut.right, rcBut.bottom, TRUE);
			}
		}
#endif
		SetWindowPos(Chat->hwndLog, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		SendMessage(hwnd, WM_FIX_CHAT_BUTTONS, 0, 0);
		return 0;
	}

	case WM_REFRESH_CHAT:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

		if (Chat->hwndEntry	/* Not a Monitor chat */
		&& IsWindowEnabled(Chat->hwndEntry)
		&& strncmp(Chat->From, CALLSIGN, sizeof(Chat->From))	/* Not FROM me */
		&& strncmp(Chat->To, CALLSIGN, sizeof(Chat->To)))		/* Not TO me */
		{	TraceLog("Chat", TRUE, hwnd, "Callsign(%s) Changed, Neither %s Nor %s\n",
					CALLSIGN, Chat->From, Chat->To);
			EnableWindow(Chat->hwndEntry, FALSE);
			EnableWindow(Chat->hwndSend, FALSE);
			AddToChat(Chat, FALSE, MESSAGE_INTERNAL, "CallSign Changed, Chat DISABLED!");
		}

		if (Chat->MessageLoaded >= Chat->MessageCount)	/* Nothing to do */
		{
#ifndef UNDER_CE
			if (Chat->isFlashing)
			{	FLASHWINFO fw = {0};
				fw.cbSize = sizeof(fw);
				fw.hwnd = hwnd;
				fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
				FlashWindowEx(&fw);
				Chat->isFlashing = FALSE;
			}
#endif
		} else if (IsWindowVisible(hwnd))
		{	unsigned long Start, End;
			SendMessage(Chat->hwndLog, EM_GETSEL, (WPARAM) &Start, (LPARAM) &End);
			if (Start != End		/* Don't disrupt a user selection */
			|| IsIconic(hwnd))		/* or flash my icon */
			{
#ifndef UNDER_CE
				if (!Chat->isFlashing)
				{	FLASHWINFO fw = {0};
					fw.cbSize = sizeof(fw);
					fw.hwnd = hwnd;
					fw.dwFlags = FLASHW_ALL | FLASHW_TIMER;
					FlashWindowEx(&fw);
					Chat->isFlashing = TRUE;
				}
#endif
			} else
			{	unsigned long Len = GetWindowTextLength(Chat->hwndLog);

				unsigned long CurrentSize = (unsigned long) SendMessage(Chat->hwndLog, EM_GETLIMITTEXT, 0, 0);
				unsigned long Required = 80;
				size_t Original, Remaining;
				TCHAR *Buff, *Next;
				int i;

				SendMessage(Chat->hwndLog, WM_SETREDRAW, FALSE, 0);

			TraceLog("Chat", FALSE, hwnd, "LineIndex[%ld/%ld] is %ld\n", Chat->MessageLoaded, Chat->MessageCount, Chat->Messages[Chat->MessageLoaded].LineIndex);
				if (Chat->Messages[Chat->MessageLoaded].LineIndex)	/* Already loaded? */
				{
					TraceLog("Chat", FALSE, hwnd, "Overwrite1[%ld/%ld] at %ld->%ld\n", Chat->MessageLoaded, Chat->MessageCount, Chat->Messages[Chat->MessageLoaded].LineIndex-1, Len);
					SendMessage(Chat->hwndLog, EM_SETSEL, Chat->Messages[Chat->MessageLoaded].LineIndex-1, Len);
					SendMessage(Chat->hwndLog, EM_REPLACESEL, FALSE, (LPARAM) TEXT(""));
					TraceLog("Chat", FALSE, hwnd, "Overwrite2[%ld/%ld] at %ld->%ld\n", Chat->MessageLoaded, Chat->MessageCount, Chat->Messages[Chat->MessageLoaded].LineIndex-1, Len);
				} else
				{	SendMessage(Chat->hwndLog, EM_SETSEL, Len, Len);	/* At end */
					TraceLog("Chat", FALSE, hwnd, "Insert[%ld/%ld] at %ld->%ld\n", Chat->MessageLoaded, Chat->MessageCount, Len, Len);
				}

				for (i=Chat->MessageLoaded; i<Chat->MessageCount; i++)
					Required += strlen(Chat->Messages[i].Text)+32;
				if (Required >= CurrentSize)
				{	SendMessage(Chat->hwndLog, EM_LIMITTEXT, CurrentSize+Required+80+CurrentSize/4, 0);
				}

				Original = Remaining = sizeof(TCHAR)*max(256,min(Required,16*1024));	/* no more than 16K at a time */
				Buff = Next = (TCHAR *)malloc(Remaining);
				*Buff = *TEXT("");	/* Just in case there's nothing to add */

				BOOL WasReply;
				MESSAGE_TYPE_V typeLast = (MESSAGE_TYPE_V) -1;
				SYSTEMTIME stLast = {0};

				if (Chat->MessageLoaded)
				{	i = Chat->MessageLoaded-1;
					WasReply = Chat->Messages[i].Response;
					typeLast = Chat->Messages[i].Type;
					stLast = Chat->Messages[i].stFirst;
				} else WasReply = !Chat->Messages[0].Response;

				for (i=Chat->MessageLoaded; i<Chat->MessageCount; i++)
				{
					if (i) StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS, TEXT("\r\n"));
					if (!Chat->Messages[i].Response)
					{
						if (i
						&& (Chat->Messages[i].stFirst.wDay != stLast.wDay
						|| Chat->Messages[i].stFirst.wMonth != stLast.wMonth
						|| Chat->Messages[i].stFirst.wYear != stLast.wYear))
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("New Date  %04ld-%02ld-%02ld\r\n"),
											Chat->Messages[i].stFirst.wYear,
											Chat->Messages[i].stFirst.wMonth,
											Chat->Messages[i].stFirst.wDay);
						}

						if (WasReply
						|| Chat->Messages[i].Type != typeLast
						|| Chat->Messages[i].stFirst.wSecond != stLast.wSecond
						|| Chat->Messages[i].stFirst.wMinute != stLast.wMinute
						|| Chat->Messages[i].stFirst.wHour != stLast.wHour)
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("%02ld:%02ld:%02ld> "),
								(long) Chat->Messages[i].stFirst.wHour, 
								(long) Chat->Messages[i].stFirst.wMinute, 
								(long) Chat->Messages[i].stFirst.wSecond);
#ifndef UNDER_CE
						else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("        > "));
#endif
					} else
					{	if (!WasReply
						|| Chat->Messages[i].Type != typeLast
						|| Chat->Messages[i].stFirst.wSecond != stLast.wSecond
						|| Chat->Messages[i].stFirst.wMinute != stLast.wMinute
						|| Chat->Messages[i].stFirst.wHour != stLast.wHour)
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("%02ld:%02ld:%02ld< "),
								(long) Chat->Messages[i].stFirst.wHour, 
								(long) Chat->Messages[i].stFirst.wMinute, 
								(long) Chat->Messages[i].stFirst.wSecond);
#ifndef UNDER_CE
					else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("        < "));
#endif
					}
					WasReply = Chat->Messages[i].Response;
					stLast = Chat->Messages[i].stFirst;
					typeLast = Chat->Messages[i].Type;

					char *ack = strrchr(Chat->Messages[i].Text, '{');	/* Does it have an ack tag? */
					if (!ack || strlen(ack) > 6) ack = strchr(Chat->Messages[i].Text, '\0');
					StringCbPrintExUTF8(Next, Remaining, &Next, &Remaining, ack-Chat->Messages[i].Text, Chat->Messages[i].Text, NULL);

					__int64 First2Last = DeltaSeconds(&Chat->Messages[i].stFirst, &Chat->Messages[i].stLast);

					if (Chat->Messages[i].Dupes || First2Last > 30)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT(" (*%ld-%02ld:%02ld:%02ld)"),
										(long) Chat->Messages[i].Dupes+1,
										(long) Chat->Messages[i].stLast.wHour,
										(long) Chat->Messages[i].stLast.wMinute,
										(long) Chat->Messages[i].stLast.wSecond);
					}

					SendMessage(Chat->hwndLog, EM_GETSEL, (WPARAM) &Start, (LPARAM) &End);
					Chat->Messages[i].LineIndex = Start+1;
	TraceLog("Chat", FALSE, hwnd, "Inserted[%ld/%ld] at %ld (%ld)\n", i, Chat->MessageCount, Start, Chat->Messages[i].LineIndex-1);

#ifndef UNDER_CE
					if (UseRichEdit)
					{	CHARFORMAT cf = {0};
						cf.cbSize = sizeof(cf);
						cf.crTextColor = Chat->Messages[i].Color;
						cf.dwMask = CFM_COLOR;
						SendMessage(Chat->hwndLog, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM) &cf);
					}
#endif

TraceLog("Chat", TRUE, hwnd, "Insert[%ld/%ld] at %ld (%ld) %ld/%ld Remaining (%S)\n",
			i, Chat->MessageCount, Start, Chat->Messages[i].LineIndex-1, (long) Remaining, Original, Buff);

					SendMessage(Chat->hwndLog, EM_REPLACESEL, FALSE, (LPARAM) Buff);
					Remaining = Original;
					Next = Buff;
				}

				Chat->MessageLoaded = Chat->MessageCount;
				SendMessage(Chat->hwndLog, WM_SETREDRAW, TRUE, 0);
				RedrawWindow(Chat->hwndLog, NULL, NULL,
							RDW_ERASE | RDW_FRAME
							| RDW_INVALIDATE | RDW_ALLCHILDREN);
				Start = SendMessage(Chat->hwndLog, EM_LINEINDEX, -1, 0);
				SendMessage(Chat->hwndLog, EM_SETSEL, Start, Start);
				SendMessage(Chat->hwndLog, EM_SCROLLCARET, 0, 0);

				if (Buff) free(Buff);
			}
		}
	}
	break;
	case WM_CHAR:
	{	Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		switch (wParam)
		{
		case '\n':
		case '\r':
			if (Chat)
			{	if (Chat->ButtonDefault < Chat->ButtonCount)
				SendMessage(hwnd, WM_COMMAND, Chat->Buttons[Chat->ButtonDefault].ID, 0);
			}
			break;
		case 27:	return SendMessage(hwnd, WM_COMMAND, IDB_CANCEL, 0);/* Escape */
		}
		break;
	}
#ifndef UNDER_CE
	case WM_NOTIFY:
	{	NMHDR *nm = (NMHDR*)lParam;

#ifdef VERBOSE_CHAT
	TraceLog("Chat", TRUE, hwnd, "WM_NOTIFY: hwnd:%lX ID:%ld Code:0x%lX\n",
		 nm->hwndFrom, nm->idFrom, nm->code);
#endif

		Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Chat)
		switch (nm->idFrom)
		{
		case IDE_LOG:
		{	switch (nm->code)
			{
			case EN_MSGFILTER:
			{	MSGFILTER *msgFilter = (MSGFILTER*)lParam;
				TraceLog("Chat", TRUE, hwnd, "EN_MSGFILTER[%ld](%s) Received\n", msgFilter->msg, MsgToText(msgFilter->msg));
#ifdef FOR_INFO_ONLY
typedef struct _msgfilter {
  NMHDR  nmhdr;
  UINT   msg;
  WPARAM wParam;
  LPARAM lParam;
} MSGFILTER;
#endif
				return 0;	/* Control should process it */
			}
			case EN_LINK:
			{	ENLINK *enLink = (ENLINK*) lParam;
//				TraceLog("Chat", TRUE, hwnd, "EN_LINK[%ld] Received\n", enLink->msg);
				if (enLink->msg == WM_RBUTTONUP
				|| enLink->msg == WM_LBUTTONUP)
				{	TCHAR *URL;
					unsigned long Start, End;

		MarkActivity();

					SendMessage(Chat->hwndLog, EM_GETSEL, (WPARAM) &Start, (LPARAM) &End);
					SendMessage(Chat->hwndLog, EM_EXSETSEL, 0, (LPARAM) &enLink->chrg);

					URL = (TCHAR*)malloc((enLink->chrg.cpMax-enLink->chrg.cpMin+3)*sizeof(*URL));

					if (SendMessage(Chat->hwndLog, EM_GETSELTEXT, 0, (LPARAM) URL))
					{	if (enLink->msg == WM_LBUTTONUP
						&& (int)ShellExecute(NULL, TEXT("open"), URL, NULL, NULL, SW_SHOWNORMAL) > 32)
						{	TraceLog("Chat", TRUE, hwnd, "Successfully Executed %S\n", URL);
						} else SendMessage(Chat->hwndLog, WM_COPY, 0, 0);
					} else SendMessage(Chat->hwndLog, WM_COPY, 0, 0);
					free(URL);

					SendMessage(Chat->hwndLog, EM_SETSEL, Start, End);
				}
#ifdef FOR_INFO_ONLY
typedef struct {
  NMHDR     nmhdr;
  UINT      msg;
  WPARAM    wParam;
  LPARAM    lParam;
  CHARRANGE chrg;
} ENLINK;
    * WM_LBUTTONDBLCLK
    * WM_LBUTTONDOWN
    * WM_LBUTTONUP
    * WM_MOUSEMOVE
    * WM_RBUTTONDBLCLK
    * WM_RBUTTONDOWN
    * WM_RBUTTONUP
    * WM_SETCURSOR
#endif
return 0;
			}
			}
		}
		}
		break;
	}
#endif
	case WM_COMMAND:

#ifdef VERBOSE_CHAT
		TraceLog("Chat", FALSE, hwnd, "00000000 WM_COMMAND: ID:%ld Code:0x%lX hwnd:%08lX", LOWORD(wParam), HIWORD(wParam), (long) lParam);
#endif

		if (MakeFocusControlVisible(hwnd, wParam, lParam)) break;
#ifdef VERBOSE_CHAT
		TraceLog("Chat", FALSE, hwnd, "00000000 WM_COMMAND2: ID:%ld Code:0x%lX hwnd:%08lX", LOWORD(wParam), HIWORD(wParam), (long) lParam);
#endif
		Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Chat)
		switch (LOWORD(wParam))	/* Handle menu options here */
		{
		case IDE_LOG:
		if (lParam)
		{	switch (HIWORD(wParam))
			{
			case EN_UPDATE:	/* Flag needs Save */
				return 0;
			case EN_ERRSPACE:
			case EN_MAXTEXT:
//				MessageBox(hwnd, TEXT("Growing Edit Control"), TEXT("EN_MAXTEXT/ERRSPACE"), MB_OK);
				SendMessage(Chat->hwndLog, EM_SETLIMITTEXT, SendMessage(Chat->hwndLog, EM_GETLIMITTEXT, 0, 0)+32000, 0);
				return 0;
			case EN_SETFOCUS:
				PopulateChat(Chat, TRUE);	/* Empty all of my messages */
				Chat->isActive = TRUE;
TraceLog("Chat", FALSE, NULL, "Log EN_SETFOCUS Active\n");
				SendMessage(hwnd, WM_FIX_SEND_BUTTON, 0, 0);
				return 0;
			case EN_KILLFOCUS:
				Chat->isActive = FALSE;
TraceLog("Chat", FALSE, NULL, "Log EN_KILLFOCUS InActive\n");
				SendMessage(Chat->hwndLog, EM_SETSEL, -1, 0);	/* Deselect */
				return 0;
			}
		}
		break;

		case IDE_TEXT:
		{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*80);
			switch (HIWORD(wParam))
			{
			case EN_CHANGE:
			{	int TextLen = GetWindowTextLength(Chat->hwndEntry)+1;
				TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*(TextLen+1));
				BOOL Xmit = FALSE, Changed = FALSE;
				unsigned long Start, End;

		MarkActivity();

				SendMessage(Chat->hwndEntry, EM_GETSEL, (WPARAM) &Start, (LPARAM) &End);
				GetWindowText(Chat->hwndEntry, Text, TextLen);
				for (int c=0; c<TextLen; c++)
				{	if (Text[c] == *TEXT("\n")
					|| Text[c] == *TEXT("\r"))
					{	memmove(&Text[c], &Text[c+1], sizeof(*Text)*(--TextLen-c));
						c--;	/* Recheck the new character */
						Changed = TRUE;
						Xmit = TRUE;
					} else if (Text[c] == TEXT('|')
					|| Text[c] == TEXT('~')
					|| Text[c] == TEXT('{'))
					{	memmove(&Text[c], &Text[c+1], sizeof(*Text)*(--TextLen-c));
						c--;	/* Recheck the new character */
						Changed = TRUE;
					}
				}
				if (TextLen > (DEFAULT_WRAP_WIDTH-1)*5+1)
				{	Text[(DEFAULT_WRAP_WIDTH-1)*5+1] = *TEXT("");
					Changed = TRUE;
				}
				if (Changed)
				{	SetWindowText(Chat->hwndEntry, Text);
					SendMessage(Chat->hwndEntry, EM_SETSEL, Start, End);
					SendMessage(Chat->hwndEntry, EM_SCROLLCARET, 0, 0);
				}

				if (Xmit) SendMessage(hwnd, WM_COMMAND, IDB_SEND, 0);

				free(Text);
				//EntryChanged = GetDlgItemText(hwnd, IDE_TEXT, Text, 80) > 0;
				break;
			}
			case EN_SETFOCUS:
TraceLog("Chat", FALSE, NULL, "Entry EN_SETFOCUS Populating %ld Messages\n", MessageCount);
				PopulateChat(Chat, TRUE);	/* Empty all of my messages */
				Chat->isActive = TRUE;
TraceLog("Chat", FALSE, NULL, "Entry EN_SETFOCUS Active %ld Messages\n", MessageCount);
				SendMessage(hwnd, WM_FIX_SEND_BUTTON, 0, 0);
				return 0;
			case EN_KILLFOCUS:
				Chat->isActive = FALSE;
TraceLog("Chat", FALSE, NULL, "Entry EN_KILLFOCUS InActive %ld Messages\n", MessageCount);
				SendMessage(Chat->hwndLog, EM_SETSEL, -1, 0);	/* Deselect */
				return 0;
			}
			free(Text);
			return TRUE;
		}
		case IDC_ACK:
		{	switch (HIWORD(wParam))
			{
			case BN_CLICKED:
			{	SetFocus(Chat->hwndEntry);
			}
			}
			return TRUE;
		}
		case IDC_COMMPORT:
		{	switch (HIWORD(wParam))
			{
			case BN_CLICKED:
			{	SendMessage(hwnd, WM_FIX_SEND_BUTTON, 0, 0);
				SetFocus(Chat->hwndEntry);
			}
			}
			return TRUE;
		}
		case WM_USER:
		{	CHAT_INFO_S *newChat = FindChat(CALLSIGN, Chat->From);
			if (!newChat)
			{	newChat = DisplayChat(CALLSIGN, Chat->From);
				if (newChat)
				for (int m=0; m<Chat->MessageCount; m++)
				if (!Chat->Messages[m].Response
				&& Chat->Messages[m].Type != MESSAGE_UNSPECIFIED)
				{	AddToChat(newChat, TRUE, Chat->Messages[m].Type,
								Chat->Messages[m].Text,
								&Chat->Messages[m].stLast,
								COLOR_MESSAGE_ADOPTED);
				}
			} else DisplayChat(CALLSIGN, Chat->From);
			return TRUE;
			//return SendMessage(hwnd, WM_CLOSE, 0, 0);
		}
		case WM_USER+1:
		{	CHAT_INFO_S *newChat = FindChat(CALLSIGN, Chat->To);
			if (!newChat)
			{	newChat = DisplayChat(CALLSIGN, Chat->To);
				if (newChat)
				for (int m=0; m<Chat->MessageCount; m++)
				if (Chat->Messages[m].Response
				&& Chat->Messages[m].Type != MESSAGE_UNSPECIFIED)
				{	AddToChat(newChat, TRUE, Chat->Messages[m].Type,
								Chat->Messages[m].Text,
								&Chat->Messages[m].stLast,
								COLOR_MESSAGE_ADOPTED);
				}
			} else DisplayChat(CALLSIGN, Chat->To);
			return TRUE;
			//return SendMessage(hwnd, WM_CLOSE, 0, 0);
		}
		case IDB_CANCEL:

		MarkActivity();

			return SendMessage(hwnd, WM_CLOSE, 0, 0);
		case IDB_SEND:
		{	HWND hwndEntry = Chat->hwndEntry;
			BOOL Ack = !Chat->hwndAck
				|| SendMessage(Chat->hwndAck, BM_GETCHECK, 0, 0) == BST_CHECKED;
			int TriState = Chat->hwndPort?SendMessage(Chat->hwndPort, BM_GETCHECK, 0, 0):BST_INDETERMINATE;
			BOOL ISOnly = TriState==BST_UNCHECKED;
			BOOL RFOnly = TriState==BST_CHECKED;

		MarkActivity();

			int TextLen = GetWindowTextLength(hwndEntry);
			//if (EntryChanged)
			if (TextLen)
			{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*(TextLen+1));
				if (GetDlgItemText(hwnd, IDE_TEXT, Text, TextLen+1))
				{	char *To = !_strnicmp(Chat->To, CALLSIGN, sizeof(Chat->To))?Chat->From:Chat->To;
					strncpy(LastChatStation, To, sizeof(LastChatStation));
					//ZeroSSID(Chat->To);
					//RememberMessageCall(hdlg, &ActiveConfig, Chat->To);
					if (*Text==TEXT('?')) Ack = FALSE;	/* Never ack leading ? */
					if (!SendAPRSMessage(/*hwndMain,*/ To, 0, Text, Ack, RFOnly, ISOnly))
						MessageBox(hwnd, TEXT("SendAPRSMessage Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
					if (*Text==TEXT('?')) Ack = TRUE;	/* But clear query below */
				}
//				else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDE_TEXT"), MB_OK | MB_ICONERROR);
				free(Text);
			}
//			else MessageBox(hdlg, TEXT("TextLen is ZERO"), TEXT("TextLen"), MB_OK | MB_ICONERROR);
//			else MessageBox(hdlg, TEXT("No Change In Message Text"), TEXT("EntryChanged"), MB_OK | MB_ICONERROR);
			if (Ack) SetWindowText(hwndEntry,TEXT(""));
			else SendMessage(Chat->hwndEntry, EM_SETSEL, 0, -1);
			SetFocus(Chat->hwndEntry);
			return TRUE;
		}
		case ID_LOG_HIDE:	/* Close comes here on Win32 */
			Chat->isActive = FALSE;
TraceLog("Chat", FALSE, NULL, "HIDE InActive\n");
			ShowWindow(Chat->hwndChat, SW_HIDE);
			return TRUE;
		case ID_LOG_CLEAR:
			FreeChat(Chat,TRUE);
			SetWindowText(Chat->hwndLog, TEXT(""));
			return 0;
		case ID_LOG_COPY:
		{	int Len = GetWindowTextLength(Chat->hwndLog);
			if (Len > 0)
			{	unsigned long Start, End;
				SendMessage(Chat->hwndLog, EM_GETSEL, (WPARAM) &Start, (LPARAM) &End);
				if (Start == End)
					SendMessage(Chat->hwndLog, EM_SETSEL, 0, -1);
				SendMessage(Chat->hwndLog, WM_COPY, 0, 0);
				SendMessage(Chat->hwndLog, EM_SETSEL, -1, 0);	/* Deselect */
				//Start = SendMessage(Chat->hwndLog, EM_LINEINDEX, -1, 0);
				//SendMessage(Chat->hwndLog, EM_SETSEL, End, End);
				//SendMessage(Chat->hwndLog, EM_SCROLLCARET, 0, 0);
			}
			return 0;
		}
#if MAX_TRACKERS > 1
		case IDB_MULTITRACK:
			if (strncmp(Chat->From, CALLSIGN, sizeof(Chat->From)))
				CreateTrackerWindow(Chat->From,NULL);
			if (strncmp(Chat->To, CALLSIGN, sizeof(Chat->To)))
				CreateTrackerWindow(Chat->To,NULL);
			return 0;
#endif
		default: ;
		}
		break;

	case WM_CLOSE:
		Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
#ifndef UNDER_CE
		if (Chat->MessageCount)
			return SendMessage(hwnd, WM_COMMAND, ID_LOG_HIDE, 0);
#endif
		Chat->isActive = FALSE;
TraceLog("Chat", FALSE, NULL, "CLOSE InActive\n");
		Chat->hwndChat = NULL;
		DestroyWindow(Chat->hwndLog);
		DestroyWindow(Chat->hwndEntry);
		DestroyWindow(hwnd);
		return 0;
	case WM_DESTROY:
		Chat = (CHAT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
TraceLog("Chat", FALSE, NULL, "Destroy Chat(%p) %s<->%s\n", Chat, Chat->From, Chat->To);
		FreeChat(Chat);
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

CHAT_INFO_S *DisplayChat(char *From, char *To)
{static	BOOL First = TRUE;

	CHAT_INFO_S *Chat = FindChat(From, To);

	if (!Chat)
	{	if (First)
#ifndef UNDER_CE
		{	WNDCLASSEX chatClass = {0};
			chatClass.cbSize = sizeof(chatClass);
			chatClass.style = CS_HREDRAW | CS_VREDRAW;
			chatClass.lpfnWndProc = ChatWndProc;
			chatClass.hInstance = g_hInstance;
//			if (LoadIconMetric(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON), LIM_SMALL, &bullClass.hIcon) != S_OK)
			chatClass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!chatClass.hIcon)
			chatClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			chatClass.hCursor = LoadCursor(NULL, IDC_ARROW);
			chatClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
			chatClass.lpszMenuName = MAKEINTRESOURCE(IDM_CHAT_W32);
			chatClass.lpszClassName = g_szChatName;
			RegisterClassEx(&chatClass);
			First = FALSE;
		}
#else
		{	WNDCLASS chatClass = {0};
			chatClass.style = CS_HREDRAW | CS_VREDRAW;
			chatClass.lpfnWndProc = ChatWndProc;
			chatClass.hInstance = g_hInstance;
#ifndef UNDER_CE
			chatClass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!chatClass.hIcon)
			chatClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			chatClass.hCursor = LoadCursor(NULL, IDC_ARROW);
			chatClass.lpszMenuName = MAKEINTRESOURCE(IDM_LOG_W32);
#endif
			chatClass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			chatClass.lpszClassName = g_szChatName;
			RegisterClass(&chatClass);
			First = FALSE;
		}
#endif

		if (!IsAX25Safe((unsigned char *) CALLSIGN))	/* If I'm not AX.25, check for FTM-350s */
		{	STATION_INFO_S *pStat = NULL;
			if (!_stricmp(From, CALLSIGN)) pStat = FindStationCall(To);
			if (!_stricmp(To, CALLSIGN)) pStat = FindStationCall(From);
			if (pStat)	/* found one? */
			if (pStat->tPlatform == PLATFORM_YAESU_VX8R
			|| pStat->tPlatform == PLATFORM_YAESU_VX8G
			|| pStat->tPlatform == PLATFORM_YAESU_FT1D	// Not sure if this needs the constraint!
			|| pStat->tPlatform == PLATFORM_YAESU_FTM350
			|| pStat->tPlatform == PLATFORM_YAESU_FTM400DR)	// Not sure if this one needs the constraint!
			if (MessageBox(hwndMain, TEXT("Yaesu Radios Don't Support Non-AX.25 Messaging.\n\nContinue Anyway?"), TEXT("Yaesu AX.25"), MB_ICONQUESTION | MB_YESNO) != IDYES)
				return NULL;
		}

		unsigned int c;
		for (c=0; c<ChatCount; c++)
			if (!Chats[c])
				break;
		if (c >= ChatCount)
		{	c = ChatCount;
			ChatCount += 8;
			Chats = (CHAT_INFO_S **)realloc(Chats,sizeof(*Chats)*ChatCount);
			memset(&Chats[c], 0, sizeof(Chats[c])*(ChatCount-c));
		}
		Chat = Chats[c] = (CHAT_INFO_S*)calloc(1,sizeof(*Chat));
		strncpy(Chat->From, From, sizeof(Chat->From));
		strncpy(Chat->To, To, sizeof(Chat->To));

		PopulateChat(Chat);	/* This might wipe From and To */

		TCHAR *szTitle = (TCHAR *)malloc(sizeof(*szTitle)*128);
#ifdef UNDER_CE
		if (!strcmp(Chat->From,CALLSIGN))
		{	StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S"), Chat->To);
		} else if (!strcmp(Chat->To,CALLSIGN))
		{	StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S"), Chat->From);
		} else 
#endif
/* Note that title is also built in WM_FIX_SEND_BUTTON */
			StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("%S <-> %S"), Chat->From, Chat->To);

#if defined(UNDER_CE) && !defined(CE50)
		UINT wsChat = /* WS_EX_CAPTIONOKBTN*/ /*WS_OVERLAPPED |*/ WS_SYSMENU;
#else
		UINT wsChat = WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
					WS_OVERLAPPED | WS_SYSMENU;
#endif

		RECT rcFixed, rcText, rcLead;
//		SystemParametersInfo(SPI_GETWORKAREA, sizeof(rcFixed), &rcFixed, 0);
		GetWindowRect(hwndMain, &rcFixed);
		TraceLog("Chat", FALSE, hwndMain, "hwndMain %ld %ld -> %ld %ld\n",
				rcFixed.left, rcFixed.top,
				rcFixed.right, rcFixed.bottom);
		GetNearestMonitor(&rcFixed, MONITOR_WORKAREA);
		TraceLog("Chat", FALSE, hwndMain, "Monitor Work %ld %ld -> %ld %ld\n",
				rcFixed.left, rcFixed.top,
				rcFixed.right, rcFixed.bottom);

		rcText = rcFixed;
		SetFixedTextRect(hwndMain, &rcText, uMaxMsgLine, 0, 0);
	    OffsetRect(&rcText, -rcText.left, -rcText.top);	/* Width/Height */
		TraceLog("Chat", FALSE, hwndMain, "Text %ld x %ld\n", rcText.right, rcText.bottom);
		rcLead = rcFixed;
		SetFixedTextRect(hwndMain, &rcLead, uMsgLeadIn, 0, 0);
	    OffsetRect(&rcLead, -rcLead.left, -rcLead.top);	/* Width/Height */
		TraceLog("Chat", FALSE, hwndMain, "Lead %ld x %ld\n", rcLead.right, rcLead.bottom);

		rcFixed = rcText;
		rcFixed.right += rcFixed.right/ARRAYSIZE(uMaxMsgLine);	/* margin */
		rcFixed.right += rcLead.right;	/* Add lead-in */

		rcFixed.right += GetSystemMetrics(SM_CXVSCROLL);	/* Room for scroll */
		rcFixed.bottom *= 5*4;	/* 5 rows is 25% of height */
		TraceLog("Chat", FALSE, hwndMain, "Scroll %ld x %ld\n", rcFixed.right, rcFixed.bottom);

		AdjustWindowRectEx(&rcFixed, wsChat, TRUE, 0);
		OffsetRect(&rcFixed, -rcFixed.left, -rcFixed.top);
		TraceLog("Chat", FALSE, hwndMain, "Frame %ld x %ld\n", rcFixed.right, rcFixed.bottom);

#ifdef UNDER_CE
		Chat->hwndChat = CreateWindow(g_szChatName, szTitle, wsChat,
									CW_USEDEFAULT, CW_USEDEFAULT,
									CW_USEDEFAULT, CW_USEDEFAULT,
									NULL, NULL, g_hInstance, Chat);
#else
		Chat->hwndChat = CreateWindow(g_szChatName, szTitle, wsChat,
									CW_USEDEFAULT, CW_USEDEFAULT,
									rcFixed.right, rcFixed.bottom,
									NULL, NULL, g_hInstance, Chat);
#endif
		TraceLog("Messages", TRUE, NULL, "New Chat(%s<>%s) hwnd(%p) Error(%ld)\n",
				Chat->From, Chat->To, Chat->hwndChat, GetLastError());
		free(szTitle);

		CenterWindow(Chat->hwndChat, hwndMain);
		ShowWindow(Chat->hwndChat, SW_SHOW);
	} else
	{	PopulateChat(Chat);	/* This might wipe From and To */
		ShowWindow(Chat->hwndChat, SW_RESTORE);
	}
/*
	Set the icon to whatever's current
*/
	{	STATION_INFO_S *Stat = FindStationCall(Chat->From);
		if (Stat==MyStation) Stat = FindStationCall(Chat->To);	/* Looking for not ME */
		if (Stat)
		{	HICON hIcon = MakeSymbolIcon(hwndMain, GetStationSymbol(Stat));
			if (hIcon)
			{	SendMessage(Chat->hwndChat, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
				SendMessage(Chat->hwndChat, WM_SETICON, ICON_SMALL, (LPARAM) hIcon);
			}
		}
	}

	SetForegroundWindow(Chat->hwndChat);
	UpdateWindow(Chat->hwndChat);
	return Chat;
}
#endif	/* USING_CHAT */

static STATION_INFO_S *AprsLogInternalPacket(char *Why, HWND hwnd, char *Packet, BOOL FreeIt=FALSE, BOOL *ForcePost=FALSE);

static void RetryPendingMessage(int m)
{	BOOL ISOnly = PendingMsgs[m].ISOnly;
	STATION_INFO_S *Stat = FindStationCall(PendingMsgs[m].aTo);

	if (Stat)
	{	if (Stat->ReplyAck[0])
		{	char *ack = strchr(PendingMsgs[m].Message, '{');
			if (ack)
			{	ack[3] = '}';
				ack[4] = Stat->ReplyAck[0];
				ack[5] = Stat->ReplyAck[1];
				ack[6] = '\0';
//				TraceLog("Messages", TRUE, hwnd, "MSG:Updated (%.*s) ReplyAck(%s)\n", STRING(Stat->Station), ack);
			}
		}
		if (!PendingMsgs[m].RFOnly  && !PendingMsgs[m].ISOnly)
		if (APRSEnabled && ActiveConfig.Enables.APRSIS	/* APRS-IS enabled? */
		&& ActiveConfig.APRSIS.MessagesEnabled	/* Messaging over APRS-IS? */
		&& ActiveConfig.Enables.Internet	/* Internet enabled? */
		&& !PendingMsgs[m].Retriggered)	/* Retriggered go out everywhere */
		{	ISOnly = (Stat && !Stat->HeardOnRF);	/* Not on RF? */
		}
	}

	if (strcmp(PendingMsgs[m].aTo, CALLSIGN))
	{	BOOL RFOnly = PendingMsgs[m].RFOnly;
		__int64 msNow = llGetMsec();
		BOOL SkipIt = FALSE;
		if (!RFOnly	/* IS allowed? */
		&& PendingMsgs[m].msLastIS	/* Did an IS already? */
		&& (msNow-PendingMsgs[m].msLastIS) <= 30000L)	/* too soon? */
		{	if (ISOnly)	/* Only going -IS? */
			{	SkipIt = TRUE;	/* Yep, then skip this one */
				TraceLogThread("Transmit", FALSE, "Transmit(IS) Too Soon (%ld), skipping %s",
							(long) (msNow-PendingMsgs[m].msLastIS),
							PendingMsgs[m].Message);
			} else
			{	RFOnly = TRUE;	/* Force it to RF only this time */
				TraceLogThread("Transmit", FALSE, "Transmit(IS) Too Soon (%ld), RF-ing %s",
							(long) (msNow-PendingMsgs[m].msLastIS),
							PendingMsgs[m].Message);
			}
		}
		if (RFOnly && ISOnly)
			TraceError(NULL, "Messages[%ld] From(%s) To(%s) BOTH RF and -IS! - %s\n",
						(long) m, PendingMsgs[m].aFrom, PendingMsgs[m].aTo,
						PendingMsgs[m].Message);
		if (!SkipIt)
		{	QueueToTransmit(MESSAGE_PACKET, PendingMsgs[m].Message, RFOnly, ISOnly);
			if (!RFOnly) PendingMsgs[m].msLastIS = msNow;	/* Went out -IS */
		}
	} else AprsLogInternalPacket("Talk2Self", hwndMain, PendingMsgs[m].Message);

	COLORREF Color = PendingMsgs[m].MsgAckID[0] ? COLOR_MESSAGE_SOURCE_ACK : COLOR_MESSAGE_SOURCE_DONE;

	if (++PendingMsgs[m].Retries < MAX_MSG_RETRIES)
		PendingMsgs[m].msNextSend = NEXT_MSG_SEND(PendingMsgs[m].Retries);
	else if (PendingMsgs[m].OneShot)
	{	STATION_INFO_S *Stat = FindStationCall(PendingMsgs[m].aTo);
		size_t BufLen = sizeof(char)*(sizeof(PendingMsgs[m].MessageBody)+256);
		char *Buffer = (char*)malloc(BufLen);
		StringCbPrintfA(Buffer, BufLen, "OneShot Retries Exhausted - %s->%s(%s) %s",
						PendingMsgs[m].aFrom, PendingMsgs[m].aTo,
						Stat&&Stat->pPlatform?Stat->pPlatform:"*Unknown*",
						PendingMsgs[m].MessageBody);
		QueueRememberMessage(PendingMsgs[m].aFrom, PendingMsgs[m].aTo, Buffer, MESSAGE_ME);
		free(Buffer);
		//RemovePendingMessage(m, "OneShot");	// Deferred until after chat is updated!
		Color = COLOR_MESSAGE_SOURCE_CANCELLED;
	} else if (!PendingMsgs[m].Retriggered)
	{	STATION_INFO_S *Stat = FindStationCall(PendingMsgs[m].MsgAckFrom);
		if (Stat)
		{	Stat->MessagePending = TRUE;	/* Flag this one for retry restart */
			TraceLogThread("Messages", TRUE, "Flagging(%.*s) For Message Retry restart\n", STRING(Stat->Station));
		}
		Color = COLOR_MESSAGE_SOURCE_STALLED;
	} else
	{	TraceLogThread("Messages", TRUE, "Message(%.*s) Exhausted Retries TWICE!\n", STRING(PendingMsgs[m].MsgAckFrom));
		Color = COLOR_MESSAGE_SOURCE_EXHAUSTED;
	}
#ifdef USING_CHAT
	if (!PendingMsgs[m].SuppressChat)
	{	BOOL Reply = FALSE;
		CHAT_INFO_S *Chat = FindChat(CALLSIGN, PendingMsgs[m].aTo, &Reply);
		if (Chat)
		{	AddToChat(Chat, Reply, MESSAGE_ME, PendingMsgs[m].MessageBody, NULL, Color);
		}
	}
#endif
	if (Color == COLOR_MESSAGE_SOURCE_CANCELLED) RemovePendingMessage(m, "OneShot");
}

static void RetriggerPendingMessage(int m, char *Why, BOOL Retrigger)
{
	PendingMsgs[m].Retriggered = Retrigger;	/* Only do this ONCE! */
	PendingMsgs[m].Retries = -1;	/* Restart the retries (it will increment on retransmission) */
	PendingMsgs[m].msNextSend = llGetMsec();	/* And it's already timed out */
	TraceLogThread("Messages", TRUE, "%s Message For(%s) by %s\n",
			Retrigger?"Retriggered":"Sending",
			PendingMsgs[m].aTo, Why);
	RetryPendingMessage(m);
}

static void RemovePendingMessage(int m, char *Reason)
{	int m1;

	if (--PendingMsgCount)
	{
		for (m1=m+1; m1<=PendingMsgCount; m1++)
		if (PendingMsgs[m1].Subordinated
		&& !strcmp(PendingMsgs[m].aTo, PendingMsgs[m1].aTo))
		{	PendingMsgs[m1].Subordinated = FALSE;
			RetriggerPendingMessage(m1,Reason,FALSE);	/* Start transmitting */
			break;	/* Only 1! */
		}
		if (PendingMsgCount > m)
		{	memmove(&PendingMsgs[m], &PendingMsgs[m+1], sizeof(*PendingMsgs)*(PendingMsgCount-m));
		}
	}
}



static BOOL CheckAndHandlePendingAck(char *from, char *message, char *ackID)
{	int m;
	BOOL Found = FALSE;

	for (m=0; m<PendingMsgCount; m++)
	{	if (ackID[0] == PendingMsgs[m].MsgAckID[0]	/* Only 2 chars */
		&& ackID[1] == PendingMsgs[m].MsgAckID[1])	/* For my Reply-Ack */
		{	if (!_stricmp(from, PendingMsgs[m].MsgAckFrom))
			{	if (ActiveConfig.Enables.Sound) MessageBeep(MB_ICONINFORMATION);
				BOOL Rejected = !strncmp(message, "rej", 3);
#ifdef USING_CHAT
				if (!PendingMsgs[m].SuppressChat)
				{	BOOL Reply = FALSE;
					CHAT_INFO_S *Chat = FindChat(PendingMsgs[m].aFrom, from, &Reply);
					if (Chat)
					{	AddToChat(Chat, Reply, MESSAGE_ME, PendingMsgs[m].MessageBody, NULL, //&PendingMsgs[m].stQueued,
									Rejected
									? (PendingMsgs[m].OneShot
										? COLOR_MESSAGE_SOURCE_CANCELLED : COLOR_MESSAGE_SOURCE_EXHAUSTED)
									: COLOR_MESSAGE_SOURCE_DONE);
					}
				}
#endif
				if (Rejected)
				{	char *Buffer = (char*)malloc(sizeof(*Buffer)*256);
					StringCbPrintfA(Buffer, sizeof(*Buffer)*256, "%s Rejected %s For %s (%s)",
						from, message, PendingMsgs[m].MsgAckFrom, PendingMsgs[m].MsgAckID);
					QueueInternalMessage(Buffer, TRUE);
					if (PendingMsgs[m].OneShot)
						RemovePendingMessage(m, "rej");
					else
					{	PendingMsgs[m].Retries = MAX_MSG_RETRIES;
						PendingMsgs[m].Retriggered = TRUE;	/* Don't do this one again */
					}
				} else RemovePendingMessage(m, message);
#ifdef REDUNDANT_CODE
				if (--PendingMsgCount)	/* Any left? */
				{	int m1;
					for (m1=m+1; m1<=PendingMsgCount; m1++)
					if (PendingMsgs[m1].Subordinated
					&& !_stricmp(PendingMsgs[m].aTo, PendingMsgs[m1].aTo))
					{	PendingMsgs[m1].Subordinated = FALSE;
						RetriggerPendingMessage(m1,message,FALSE);	/* Start transmitting */
						break;	/* only release one */
					}
					if (PendingMsgCount!=m)
					{	memmove(&PendingMsgs[m], &PendingMsgs[m+1], sizeof(*PendingMsgs)*(PendingMsgCount-m));
					}
				}
#endif
				Found = TRUE;
			} else
			{	TraceLogThread("Messages", TRUE, "%s May Have Pirated %s For %s (%s)",
							from, message, PendingMsgs[m].MsgAckFrom, PendingMsgs[m].MsgAckID);
			}
		}
	}
	if (!Found)
	{
#ifdef SHOW_ORPHAN_ACKS
		TCHAR *Buffer = (TCHAR*)malloc(sizeof(*Buffer)*256);
		StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Unexpected (Redundant?) %S From %S"),
						message, from);
		MessageBox(Info->hwnd, Buffer, TEXT("myMessageCallback"), MB_OK | MB_ICONINFORMATION);
		free(Buffer);
#endif
		TraceLogThread("Messages", TRUE, "Unexpected (Redundant?) %s From %s (%.2s)", message, from, ackID);
	} else if (!PendingMsgCount)
	{	InvalidateMessage(TRUE);
	}
	return Found;
}

char *IsAckRequested(char *message)
{	char *ack = SpaceCompress(-1,strrchr(message, '{'));	/* Do we need to ack it? */
	return (ack && strlen(ack) <= 6) ? ack : NULL;
}

void SendAckIfRequested(char *from, char *to, char *ack, char *message)
{	if (ack && *ack)
	{	int acklen = strlen(ack);
		STATION_INFO_S *Stat = FindStationCall(from);
		/* -IS only if I'm enabled, connected, and the station isn't on RF */
		BOOL ISOnly = APRSEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet && (Stat&&!Stat->HeardOnRF);
		char Buffer[80];
		int len = sprintf(Buffer,"%s>%s%s%s::%-9s:ack%s", to, DESTID, *PATH?",":"", PATH, from, ack+1);

		if (Stat && acklen>=4 && ack[3] == '}')	/* Remember the ReplyAck if any */
		{	Stat->ReplyAck[0] = ack[1];
			Stat->ReplyAck[1] = ack[2];
			if (acklen == 6)
			{
TraceLogThread("Messages", TRUE, "Scanning For My ReplyAck[%s] from %s\n", ack, from);
				CheckAndHandlePendingAck(from, "ack", &ack[4]);
			}
		}

		TraceLogThread("Messages", FALSE, "%s", Buffer);

		QueueToTransmit(MESSAGE_ACK_PACKET, Buffer, FALSE, ISOnly);
		if (!ISOnly) QueueToTransmit(MESSAGE_ACK_PACKET, Buffer, TRUE);	/* RF-Only a second copy */
	
		ack = IsAckRequested(message);
		if (ack) *ack = '\0';	/* Null terminate message early */
	}
}

static int MessageCompare(const void *One, const void *Two)
{	MESSAGE_INFO_S *Left = (MESSAGE_INFO_S *) One;
	MESSAGE_INFO_S *Right = (MESSAGE_INFO_S *) Two;

	if (Left->Type < Right->Type) return -1;
	else if (Left->Type > Right->Type) return 1;
	else if (Left->Index < Right->Index) return -1;
	else if (Left->Index > Right->Index) return 1;
	else return 0;
}

static int RememberMessage(char *from, char *to, char *message, MESSAGE_TYPE_V type, char *NWSObject=NULL)
{	char *e;
	int i;
static	long MsgIndex = 0;

	if (type == MESSAGE_ME
	&& *message=='?'
	&& ActiveConfig.Messaging.HideQueries) return -1;	/* Hide these */

	if (!strncmp(message, "ack", 3)
	|| !strncmp(message, "rej", 3)) return -1;	/* Never remember these! */

	i = MessageCount++;
TraceLog("Chat", FALSE, NULL, "Remember Message %ld/%ld\n", i, MessageCount);

	if (MessageCount >= MessageSize)
	{	MessageSize += 4;
		if (MessageSize < MessageCount) MessageSize = MessageCount+4;
		Messages = (MESSAGE_INFO_S *) realloc(Messages,sizeof(*Messages)*MessageSize);
	}
	memset(&Messages[i], 0, sizeof(Messages[i]));

	GetLocalTime(&Messages[i].stLocal);

	if (!strcmp(from,"KJ4ERJ")
	&& ((e=strstr(message," @ ")) || (e=strstr(message," Running "))))
	{/* KJ4ERJ>APZAPM,qAS,KJ4ERJ-LT::KJ4ERJ-12:KJ4ERJ-12 @ 27.9964 -80.6591 */
		Messages[i].From = strncpy((char*)calloc(sizeof(char),e-message+1),message,e-message);
		message = e+1;	/* Skip over the Running and rely on From */
		if (IsSameBaseCallsign(CALLSIGN,"KJ4ERJ")) type = MESSAGE_RUNNING;
	} else
	{	Messages[i].From = strcpy((char*)malloc(strlen(from)+1),from);
	}
	Messages[i].To = strcpy((char*)malloc(strlen(to)+1),to);
	Messages[i].Text = strcpy((char*)malloc(strlen(message)+1),message);
	Messages[i].NWSObject = NWSObject?_strdup(NWSObject):NWSObject;
	Messages[i].Type = type;
	Messages[i].Index = ++MsgIndex;	/* For arrival-based ordering */

	TraceLogThread("Messages", TRUE, "Priority %ld %s>%s:%s\n",
			Messages[i].Type, Messages[i].From, Messages[i].To, Messages[i].Text);
//	TraceLogThread("Remember", TRUE, "Priority %ld %s>%s %s\n",
//			Messages[i].Type, Messages[i].From, Messages[i].To, Messages[i].Text);

//	char *ack = strrchr(Messages[i].Text, '{');	/* Does it have an ack tag? */
//	if (ack && strlen(ack) <= 6) *ack = '\0';	/* Null terminate message early */

	BOOL Notify = FALSE;

	if (type == MESSAGE_ME || type == MESSAGE_COMPANION)	/* Only notify on my -SSID */
	{	Notify = *Messages[i].Text=='?'
					? (!ActiveConfig.Messaging.HideQueries
						&& ActiveConfig.Messaging.NotifyOnQuery)
					: ActiveConfig.Messaging.NotifyOnNewMessage;
	} else if (type == MESSAGE_NWS)
	{	Notify = ActiveConfig.NWS.Notify
				&& (strlen(from) != 6
					|| GetNWSProduct(&ActiveConfig, from+3, from, "MSG")->ActionEnabled);
	}

#ifdef USING_CHAT
	BOOL Reply = FALSE;
	CHAT_INFO_S *Chat;

//	if (type == MESSAGE_RUNNING)
//	{	if (!RunningChat) RunningChat = FindChat("KJ4ERJ", "RUNNING");
//		Chat = RunningChat;
//	} else
		Chat = FindChat(from, to, &Reply);
	if (Chat)
	{	COLORREF Color;
		MESSAGE_TYPE_V Type = type;
		if (!strcmp(to,CALLSIGN))
		{	Color = COLOR_MESSAGE_REPLY;
			Type = MESSAGE_ME;
		} else if (!strcmp(from,CALLSIGN))
		{	Color = COLOR_MESSAGE_SOURCE_DONE;
			Type = MESSAGE_ME;
		} else Color = Reply?COLOR_MESSAGE_SOURCE_DONE:COLOR_MESSAGE_REPLY;
		if (AddToChat(Chat, Reply, Type, message, NULL, Color)
		&& type != MESSAGE_RUNNING)	/* Need to keep RUNNING to suppress auto-answer */
		{	RemoveMessage(i);	/* Don't even keep this one */
			Notify = FALSE;
			i = -1;
		} else
		{	Messages[i].AddedToChat = TRUE;
		}
	}
#endif

	if (Notify && i >= 0 && i < MessageCount)
	{	for (int j=0; j<MessageCount; j++)
		if (j != i)
		if (Messages[i].Type == Messages[j].Type
		&& !strcmp(Messages[i].From, Messages[j].From)
		&& !strcmp(Messages[i].Text, Messages[j].Text))
		{	Notify = FALSE;
			TraceLogThread("Messages", TRUE, "Suppressing Notification(%s->%s) %ld == %ld\n",
						Messages[i].From, Messages[i].Text,
						(long) i, (long) j);
			break;
		}
	}

	if (Notify && i >= 0 && i < MessageCount)
#ifdef USING_SHELL
	{	Messages[i].pNotification = CreateAndAddNotification();
		FillSHND(hwndMain,Messages[i].pNotification,&Messages[i].stLocal,Messages[i].From,Messages[i].Text);
		SHNotificationAdd(Messages[i].pNotification);
	}
#elif !defined(UNDER_CE)
	{	PopupNotifyIcon(hwndMain, Messages[i].From, Messages[i].Text, 1);
		if (ActiveConfig.Enables.Sound) MessageBeep(MB_ICONINFORMATION);
	}
#endif

	if (MessageCount > 1)
	{	if (i > 0 && Messages[i].Type < Messages[i-1].Type)
		{	qsort(Messages, MessageCount, sizeof(*Messages), MessageCompare);
			for (i=0; i<MessageCount; i++)
			{	if (Messages[i].Index == MsgIndex) break;
			}
			if (i >= MessageCount) i = -1;	/* Didn't find it?  Confused, but recoverable */
		}
	}
	InvalidateMessage(TRUE);
TraceLog("Chat", FALSE, NULL, "Remember Message[%ld] %ld Left\n", (long) i, (long) MessageCount);
	return i;
}

static void RemoveMessage(int i)
{
TraceLog("Chat", FALSE, NULL, "Remove Message %ld/%ld\n", i, MessageCount);
	if (i < MessageCount)
	{	free(Messages[i].Text);
		free(Messages[i].To);
		free(Messages[i].From);
		if (Messages[i].NWSObject) free(Messages[i].NWSObject);
#ifdef USING_SHELL
		if (Messages[i].pNotification)
			RemoveNotification(Messages[i].pNotification->dwID);
		// else TraceError(NULL, "NULL Notification Index[%ld/%ld]\n", (long) i, (long) MessageCount);
#endif

		if (--MessageCount > 0)
		{	if (MessageCount!=i)
				memmove(&Messages[i], &Messages[i+1], sizeof(Messages[0])*(MessageCount-i));
		} else
		{	free(Messages);
			Messages = NULL;
			MessageCount = MessageSize = 0;
		}
	}
TraceLog("Chat", FALSE, NULL, "Remove Message %ld Left\n", MessageCount);
}

int RememberMessage2(char *from, char *to, TCHAR *message, MESSAGE_TYPE_V type)
{	size_t msglen = wcslen(message)+1;
	size_t aMsgLen = msglen*2+2;
	char *aMsg = (char*)malloc(aMsgLen);
	WideCharToMultiByte(CP_UTF8, 0, message, msglen,
						aMsg, aMsgLen, NULL, NULL);
	int Result = RememberMessage(from, to, aMsg, type);
	free(aMsg);
	return Result;
}

static BOOL SendAutoReply(HWND hwnd, char *to)
{	TIMED_STRING_LIST_S *pList = &ActiveConfig.Messaging.AutoAnswer.Stations;
	unsigned long i = LocateTimedStringEntry(pList, to);

	if (i>=pList->Count
	|| (ActiveConfig.Messaging.AutoAnswer.Interval != LONG_MAX
		&& IsSystemTimeout(&pList->Entries[i].time, ActiveConfig.Messaging.AutoAnswer.Interval*60)))
	{	int Size = (sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)+1) * sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR *) malloc(Size);
		StringCbPrintf(Buffer, Size, TEXT("AA:%.*S"), STRING(ActiveConfig.Messaging.AutoAnswer.Reply));
		SendAPRSMessage(/*hwnd,*/ to, 3, Buffer, FALSE);
		RememberAutoAnswerStation(hwnd, &ActiveConfig, to);
		SaveConfiguration(hwnd, &ActiveConfig, "AutoAnswerStation", 300);
		{	size_t Size2 = 3+sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)+1;
			char *Buf2 = (char *)malloc(Size2);
			StringCbPrintfA(Buf2, Size2, "AA:%.*s", STRING(ActiveConfig.Messaging.AutoAnswer.Reply));
			RememberMessage(CALLSIGN, to, Buf2, MESSAGE_ME);
			free(Buf2);
		}
		free(Buffer);
		return TRUE;
	} else
	{	TraceLog("AutoAnswer", FALSE, hwnd, "Not Yet Time(%.1lf/%ld) for Auto-Answer to %s\n", SecondsSince(&pList->Entries[i].time)/60.0, (long) ActiveConfig.Messaging.AutoAnswer.Interval, to);
		return FALSE;
	}
}

static int SameButDash(char *l, char *r)
{
	while (*l && *r)
	{	if (*l != *r)
		{	if ((*l !='-' && *l != '_')
			|| (*r !='-' && *r != '_'))
				break;	/* Don't match */
		}
		l++; r++;	/* Moving on */
	}
	return !(*l || *r);	/* Stopped early */
}

static int SameSequence(char *l, char *r)
{	l = strrchr(l,'{');
	r = strrchr(r,'{');
	return r && l && !strncmp(l,r,5);	/* {ssssL is 5 match */
}

static void DisplayMessage(HWND hwnd, CLIENT_INFO_S *cInfo, int i)
{
	if (Messages[i].Type == MESSAGE_TACTICAL)
	{	ParseAndDefineTacticals(hwnd, Messages[i].From, Messages[i].Text, &Messages[i].stLocal);
		RemoveMessage(i);
		for (int m=0; m<MessageCount; m++)
		if (Messages[m].Type == MESSAGE_TACTICAL)	/* Deal with all new Nevers or Sources */
		{	if (LocateSimpleStringEntry(&ActiveConfig.TacticalNevers, Messages[m].From)!=-1
			|| LocateSimpleStringEntry(&ActiveConfig.TacticalSources, Messages[m].From)!=-1)
			{	ParseAndDefineTacticals(hwnd, Messages[m].From, Messages[m].Text, &Messages[m].stLocal);
				RemoveMessage(m); m--;	/* Redo this one */
			}
		}
		return;
	}

#ifdef USING_CHAT
	{	CHAT_INFO_S *newChat = FindChat(Messages[i].From, Messages[i].To);
		if (newChat)
		{	DisplayChat(Messages[i].From, Messages[i].To);
			return;
		}
	}
#endif

	size_t Remaining=0;
	int m, Count=0;

	for (m=0; m<MessageCount; m++)
	{	if ((!_stricmp(Messages[i].From, Messages[m].From)
		&& (!_stricmp(Messages[i].To, Messages[m].To)
		|| (Messages[i].Type == MESSAGE_NWS
			&& Messages[m].Type == MESSAGE_NWS
			&& SameButDash(Messages[i].To, Messages[m].To))))
		|| (!_stricmp(Messages[i].To, Messages[m].From)
		&& !_stricmp(Messages[i].From, Messages[m].To)))
		{	Count++;
			Remaining += strlen(Messages[m].Text);
		}
	}
#ifdef ALLOW_SINGLE_LINE
	if (Count < 2)	/* The original single message dialog */
	{
		Remaining = sizeof(TCHAR)*256;
		TCHAR *Buffer=(TCHAR*)malloc(Remaining);
		TCHAR *Title=(TCHAR*)malloc(sizeof(*Title)*32);
		TCHAR *Next = Buffer;

	#ifdef UNDER_CE
		RemoveMessageNotification(cInfo, i);
	#endif

		char *ack = strrchr(Messages[i].Text, '{');	/* Does it have an ack tag? */
		if (!ack || strlen(ack) > 6) ack = strchr(Messages[i].Text, '\0');

		StringCbPrintExUTF8(Next, Remaining, &Next, &Remaining,
							ack-Messages[i].Text, Messages[i].Text, NULL);
		StringCbPrintf(Title, sizeof(*Title)*32, TEXT("%S %04ld-%02ld-%02ld %02ld:%02ld:%02ld"),
						Messages[i].From,
						(long) Messages[i].st.wYear, 
						(long) Messages[i].st.wMonth, 
						(long) Messages[i].st.wDay, 
						(long) Messages[i].st.wHour, 
						(long) Messages[i].st.wMinute, 
						(long) Messages[i].st.wSecond);

		HICON hIcon = NULL;
		{	int s = FindStationCall(Messages[i].From);
			if (s != -1)
				hIcon = MakeSymbolIcon(hwnd, CloseStations[s].symbol);
		}

		BUTTONS_S *Buttons = CreateButtons(-1);
		if (_stricmp(Messages[i].From, PROGCALL))
		{
			if (_stricmp(Messages[i].To, CALLSIGN))
			{	AddButton(Buttons, Messages[i].From, 1);
#ifdef USING_CHAT
				AddButton(Buttons, "Monitor", 4);
#endif
				AddButton(Buttons, Messages[i].To, 2);
			} else AddButton(Buttons, Messages[i].From, 3);
		}

		int Index = Messages[i].Index;

		int Answer = LwdMessageBox2(hwnd, Buffer, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons, hIcon);

		if (Answer == 1)
		{
	#ifdef USING_CHAT
			CHAT_INFO_S *newChat = FindChat(CALLSIGN, Messages[i].From);
			if (!newChat)
			{	newChat = DisplayChat(CALLSIGN, Messages[i].From);
				if (i < MessageCount && Messages[i].Index == Index)
					AddToChat(newChat, TRUE, Messages[i].Type,
							Messages[i].Text,
							&Messages[i].st, COLOR_MESSAGE_ADOPTED);
			} else DisplayChat(CALLSIGN, Messages[i].From);
	#else
			if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].From) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
	#endif
		} else if (Answer == 2)
		{
	#ifdef USING_CHAT
			CHAT_INFO_S *newChat = FindChat(CALLSIGN, Messages[i].To);
			if (!newChat)
			{	newChat = DisplayChat(CALLSIGN, Messages[i].To);
				if (i < MessageCount && Messages[i].Index == Index)
					AddToChat(newChat, TRUE, Messages[i].Type,
							Messages[i].Text,
							&Messages[i].st, COLOR_MESSAGE_ADOPTED);
			} else DisplayChat(CALLSIGN, Messages[i].To);
	#else
			if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].To) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
	#endif
		} else if (Answer == 3)
		{
	#ifdef USING_CHAT
			CHAT_INFO_S *newChat = FindChat(Messages[i].From, CALLSIGN);
			if (!newChat)
			{	newChat = DisplayChat(Messages[i].From, CALLSIGN);
				if (i < MessageCount && Messages[i].Index == Index)
					AddToChat(newChat, TRUE, Messages[i].Type,
							Messages[i].Text,
							&Messages[i].st, COLOR_MESSAGE_ADOPTED);
			} else DisplayChat(Messages[i].From, CALLSIGN);
	#else
			if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].To) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
	#endif
	#ifdef USING_CHAT
		} else if (Answer == 4)
		{	DisplayChat(Messages[i].From, Messages[i].To);
	#endif
		}
		if (i < MessageCount && Messages[i].Index == Index)
			RemoveMessage(i);
		InvalidateMessage(cInfo->hwnd, TRUE);
		free(Buffer); free(Title);

	} else	/* The new multi-message dialog or Chat */
#endif	/* SINGLE_LINE */
	{
		DUPE_DETECT_S *Dupes = (DUPE_DETECT_S *) calloc(Count, sizeof(*Dupes));

		Remaining += Count*(32+12) + 256;	/* +12 for NWS object */
		Remaining *= sizeof(TCHAR);
		TCHAR *Buffer=(TCHAR*)malloc(Remaining), *Title=(TCHAR*)malloc(sizeof(*Title)*(32+12));	/* +12 for NWS object */
		TCHAR *Next = Buffer;

		Count = 0;
		for (m=0; m<MessageCount; m++)
		{	if ((!_stricmp(Messages[i].From, Messages[m].From)
			&& (!_stricmp(Messages[i].To, Messages[m].To)
			|| (Messages[i].Type == MESSAGE_NWS
				&& Messages[m].Type == MESSAGE_NWS
				&& SameButDash(Messages[i].To, Messages[m].To))))
			|| (!_stricmp(Messages[i].To, Messages[m].From)
			&& !_stricmp(Messages[i].From, Messages[m].To)))
			if (Messages[i].Type != MESSAGE_NWS
			|| SameSequence(Messages[i].Text, Messages[m].Text))
			{	BOOL First = TRUE;
				Dupes[Count].m = m;
				Dupes[Count].Index = Messages[m].Index;
				Dupes[Count].First = TRUE;
				for (int d=0; d<Count; d++)
				{	int m1 = Dupes[d].m;
					if (!strcmp(Messages[m1].Text, Messages[m].Text))
					{	if ((!_stricmp(Messages[m1].From, Messages[m].From)
						&& (!_stricmp(Messages[m1].To, Messages[m].To)
						|| (Messages[m1].Type == MESSAGE_NWS
							&& Messages[m].Type == MESSAGE_NWS
							&& SameButDash(Messages[m1].To, Messages[m].To)))))
						{	Dupes[d].Duplicates++;
							Dupes[d].stLast = Messages[m].stLocal;
							Dupes[Count].First = FALSE;
							break;
						}
					}
				}
				Count++;	/* Count the new entry */
			}
		}
		if (Count > 1)
			qsort(Dupes, Count, sizeof(*Dupes), MessageDupeCompare);

		for (int d=0; d<Count; d++)
		{	if (Dupes[d].First)
			{	m = Dupes[d].m;
	#ifdef USING_SHELL
				RemoveMessageNotification(cInfo, m);
	#endif
				if (!_stricmp(Messages[i].From, Messages[m].From)
				&& (!_stricmp(Messages[i].To, Messages[m].To)
				|| (Messages[i].Type == MESSAGE_NWS
					&& Messages[m].Type == MESSAGE_NWS
					&& SameButDash(Messages[i].To, Messages[m].To))))
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S%02ld-%02ld %02ld:%02ld:%02ld "),
							d?"\n":"",
							(long) Messages[m].stLocal.wMonth, 
							(long) Messages[m].stLocal.wDay, 
							(long) Messages[m].stLocal.wHour, 
							(long) Messages[m].stLocal.wMinute, 
							(long) Messages[m].stLocal.wSecond);
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%SReply %02ld:%02ld:%02ld "),
						d?"\n":"",
						(long) Messages[m].stLocal.wHour, 
						(long) Messages[m].stLocal.wMinute, 
						(long) Messages[m].stLocal.wSecond);

				char *ack = strrchr(Messages[m].Text, '{');	/* Does it have an ack tag? */
				if (!ack || strlen(ack) > 6) ack = strchr(Messages[m].Text, '\0');

				StringCbPrintExUTF8(Next, Remaining, &Next, &Remaining, ack-Messages[m].Text, Messages[m].Text, NULL);

#ifdef SHOW_NWS_OBJECTS_IN_TEXT
				if (Messages[m].NWSObject)
				{	char *Seq = strrchr(Messages[m].Text, '{');
					if (Seq)		/* Found a sequence */
					{	TCHAR *mySeq = (TCHAR*) malloc((strlen(Seq)+1)*sizeof(TCHAR));
						StringCbPrintf(mySeq, (strlen(Seq)+1)*sizeof(TCHAR), TEXT("%S"), Seq);
						for (unsigned long s=1; s<CloseStationCount; s++)
						if (pCloseStations[s]->isNWS && pCloseStations[s]->sComment
						&& !strcmp(pCloseStations[s]->Owner, Messages[i].From))
						{	TCHAR *tSeq = wcschr(pCloseStations[s]->pComment, TEXT('{'));
							if (tSeq && !wcsncmp(mySeq, tSeq, 6))
							{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT(" %S%S"), pCloseStations[s]->Station,
									(strlen(pCloseStations[s]->Station) == 9
										&& islower(pCloseStations[s]->Station[6]&0xff))?"":"*");
							}
						}
						free(mySeq);
					}
				}
#endif

				if (Dupes[d].Duplicates)
				{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT(" (*%ld-%02ld:%02ld:%02ld)"),
									(long) Dupes[d].Duplicates+1,
									(long) Dupes[d].stLast.wHour,
									(long) Dupes[d].stLast.wMinute,
									(long) Dupes[d].stLast.wSecond);
				}
			}
		}

#ifdef OLD_WAY
		if (strcmp(Messages[i].From, PROGCALL))
		{	if (!_stricmp(Messages[i].To, CALLSIGN))
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n\nReply?"));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n\nReply For %S?"), Messages[i].To);
		}
#endif
		StringCbPrintf(Title, sizeof(*Title)*32, TEXT("%S -> %S"),
						Messages[i].From,
						Messages[i].To);
#ifdef DEBUG_NWS_OBJECT_IDS
		if (Messages[i].NWSObject)
			StringCbPrintf(wcschr(Title, TEXT('\0')), sizeof(*Title)*32, TEXT(" (%S)"),
				Messages[i].NWSObject);
#endif

		HICON hIcon = NULL;
		{	STATION_INFO_S *Stat = FindStationCall(Messages[i].From);
			if (Stat)
				hIcon = MakeSymbolIcon(hwnd, GetStationSymbol(Stat));
		}

		BUTTONS_S *Buttons = CreateButtons(-1);

		if (Messages[i].NWSObject)
		{	STATION_INFO_S *Station = FindStationCall(Messages[i].NWSObject, Messages[i].From);
			if (Station && !Station->isKilled)
			{	size_t ButLen = 80+strlen(Messages[i].NWSObject);
				char *Button = (char*)malloc(ButLen);
				StringCbPrintfA(Button, ButLen,"Show %s", Messages[i].NWSObject);
				AddButton(Buttons, Button, 5);
				free(Button);
			}
		} else if (_stricmp(Messages[i].From, PROGCALL))
		{
			if (_stricmp(Messages[i].To, CALLSIGN))
			{	if (Messages[i].Type != MESSAGE_NWS)
					AddButton(Buttons, Messages[i].From, 1);
#ifdef USING_CHAT
				AddButton(Buttons, "Monitor", 4);
#endif
				if (Messages[i].Type != MESSAGE_NWS)
					AddButton(Buttons, Messages[i].To, 2);
			} else AddButton(Buttons, Messages[i].From, 3, TRUE);
		}

		int Index = Messages[i].Index;

		int Answer = LwdMessageBox2(hwnd, Buffer, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons, hIcon);

		if (i >= MessageCount || Messages[i].Index != Index)
		{
TraceLog("Messages", TRUE, hwnd, "Messages MOVED!  Locating Index %ld\n", Index);
			for (i=0; i<MessageCount; i++)
				if (Messages[i].Index == Index)
					break;
		}

		if (i >= MessageCount || Messages[i].Index != Index)
		{	TraceLog("Messages", TRUE, hwnd, "Failed To Locate Index %ld\n", Index);
			MessageBox(hwnd, TEXT("Lost Message Context, Please Try Again..."), Title, MB_ICONERROR | MB_OK);
		} else
		{
			if (Answer == 1)
			{
		#ifdef USING_CHAT
				if (i < MessageCount)
				{	CHAT_INFO_S *newChat = FindChat(CALLSIGN, Messages[i].From);
					if (!newChat)
					{	newChat = DisplayChat(CALLSIGN, Messages[i].From);
						if (newChat)
						if (i < MessageCount && Messages[i].Index == Index
						&& !Messages[i].AddedToChat)
						{	AddToChat(newChat, TRUE, Messages[i].Type,
									Messages[i].Text,
									&Messages[i].stLocal, COLOR_MESSAGE_ADOPTED);
							Messages[i].AddedToChat = TRUE;
						}
					} else DisplayChat(CALLSIGN, Messages[i].From);
				}
		#else
				if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].From) == -1)
					MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
		#endif
			} else if (Answer == 2)
			{
		#ifdef USING_CHAT
				if (i < MessageCount)
				{	CHAT_INFO_S *newChat = FindChat(CALLSIGN, Messages[i].To);
					if (!newChat)
					{	newChat = DisplayChat(CALLSIGN, Messages[i].To);
						if (newChat)
						if (i < MessageCount && Messages[i].Index == Index
						&& !Messages[i].AddedToChat)
						{	AddToChat(newChat, TRUE, Messages[i].Type,
									Messages[i].Text,
									&Messages[i].stLocal, COLOR_MESSAGE_ADOPTED);
							Messages[i].AddedToChat = TRUE;
						}
					} else DisplayChat(CALLSIGN, Messages[i].To);
				}
		#else
				if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].To) == -1)
					MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
		#endif
			} else if (Answer == 3)
			{	
	#ifdef USING_CHAT
				if (i < MessageCount)
				{	CHAT_INFO_S *newChat = FindChat(Messages[i].From, CALLSIGN);
					if (!newChat)
					{	newChat = DisplayChat(Messages[i].From, CALLSIGN);
						if (newChat)
						if (i < MessageCount && Messages[i].Index == Index
						&& !Messages[i].AddedToChat)
						{	AddToChat(newChat, TRUE, Messages[i].Type,
									Messages[i].Text,
									&Messages[i].stLocal, COLOR_MESSAGE_ADOPTED);
							Messages[i].AddedToChat = TRUE;
						}
					} else DisplayChat(Messages[i].From, CALLSIGN);
				}
		#else
				if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].To) == -1)
					MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
		#endif
		#ifdef USING_CHAT
			} else if (Answer == 4)
			{	if (i < MessageCount)
					DisplayChat(Messages[i].From, Messages[i].To);
		#endif
			} else if (Answer == 5)
			{	STATION_INFO_S *NWSStation = FindStationCall(Messages[i].NWSObject, Messages[i].From);
				char *Seq = strrchr(Messages[i].Text, '{');
				if (Seq)		/* Found a sequence */
				{	TCHAR *mySeq = (TCHAR*) malloc((strlen(Seq)+1)*sizeof(TCHAR));
					StringCbPrintf(mySeq, (strlen(Seq)+1)*sizeof(TCHAR), TEXT("%S"), Seq);
					for (unsigned long s=1; s<CloseStationCount; s++)
					if (pCloseStations[s]->isNWS && pCloseStations[s]->sComment
					&& !strcmp(pCloseStations[s]->Owner, Messages[i].From))
					{	TCHAR *tSeq = wcschr(pCloseStations[s]->pComment, TEXT('{'));
						if (tSeq && !wcsncmp(mySeq, tSeq, 6))
						{	if (!NWSStation || (strlen(pCloseStations[s]->Station) != 9
									|| !islower(pCloseStations[s]->Station[6]&0xff)))	/* Non-Areas are better */
								NWSStation = pCloseStations[s];
						}
					}
					free(mySeq);
				}
				if (!NWSStation) MessageBox(hwnd, TEXT("NWS Object Not Found, Possibly Expired"), TEXT("NWS Not Found"), MB_OK | MB_ICONWARNING);
				else
				{
#if MAX_TRACKERS > 1
					HWND hwndTracker = CreateTrackerWindow(NWSStation->Station, NWSStation->Owner, -1, "NWS Objects");	/* View NWS stuff */
					if (hwndTracker)
						PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);
					else
#endif
						SetCenterTracking(hwnd, NWSStation);
				}
			}
#ifdef OLD_WAY
			for (m=Count-1; m>=0; m--)
			if (Dupes[m].m < MessageCount && Messages[Dupes[m].m].Index == Dupes[m].Index)
				RemoveMessage(Dupes[m].m);
#else
			for (int d=Count-1; d>=0; d--)
			{	for (m=0; m<MessageCount; m++)
				{	if (Messages[m].Index == Dupes[d].Index)
					{	RemoveMessage(m);
						break;
					}
				}
			}
#endif

	#ifdef OLD_WAY
			if (MessageBox(hwnd, Buffer, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{
		#ifdef USING_CHAT
				DisplayChat(CALLSIGN, Messages[i].From);
		#else
				if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].From) == -1)
					MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("WM_LBUTTONUP"), MB_OK | MB_ICONERROR);
		#endif
			}
			for (m=Count-1; m>=0; m--)
				RemoveMessage(Dupes[m].m);
			InvalidateMessage(cInfo->hwnd, TRUE);
			free(Dupes); free(Buffer); free(Title);
	#endif
		}
		InvalidateMessage(TRUE);
		free(Dupes); free(Buffer); free(Title);
	}

#ifdef USING_SIP
	SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif	/* UNDER_CE */
}

static void myMessageCallback(void *userarg, char *from, char *message)
{
}

HWND hwndBulletin = NULL, hwndBulletinEdit = NULL;

	struct
	{	unsigned long TelemetryDefDays;	/* Days */
		unsigned long BulletinHours;	/* Hours */
	} Aging;

static int BulletinCompare(const void *One, const void *Two)
{	BULLETIN_INFO_S *Left = (BULLETIN_INFO_S *) One;
	BULLETIN_INFO_S *Right = (BULLETIN_INFO_S *) Two;
	int r = _stricmp(Left->aFrom, Right->aFrom);
	if (!r) r = _stricmp(Left->aGroup, Right->aGroup);
	if (!r)
	{	if (Left->ID < Right->ID) r = -1;
		else if (Left->ID > Right->ID) r = 1;
	}
	if (!r) r = strcmp(Left->Text, Right->Text);
	return r;
}

static BOOL RealRememberBulletin(CLIENT_INFO_S *Info, char *from, char id, char *group, char *text, SYSTEMTIME *pst, BULLETIN_INFO_S **pBull=NULL)
{	BULLETIN_INFO_S *Bull;
	BOOL New = FALSE;
	int i;

	for (i=0; i<BulletinCount; i++)
	{	if (Bulletins[i].ID == id
		&& !_strnicmp(Bulletins[i].aFrom, from, sizeof(Bulletins[i].aFrom))
		&& !_strnicmp(Bulletins[i].aGroup, group, sizeof(Bulletins[i].aGroup)))
			break;
	}
	if (i>=BulletinCount)
	{	i = BulletinCount++;
		if (BulletinCount >= BulletinSize)
		{	BulletinSize += 4;
			if (BulletinSize < BulletinCount) BulletinSize = BulletinCount+4;
			Bulletins = (BULLETIN_INFO_S *) realloc(Bulletins,sizeof(*Bulletins)*BulletinSize);
		}
		Bull = &Bulletins[i];
		memset(Bull, 0, sizeof(*Bull));
		strncpy(Bull->aFrom,from,sizeof(Bull->aFrom));
		Bull->ID = id;
		strncpy(Bull->aGroup,group,sizeof(Bull->aGroup));
		New = TRUE;
	} else
	{	Bull = &Bulletins[i];
		if (Bull->Text)
		{	New = strcmp(Bull->Text, text);
			free(Bull->Text);
		}
	}
	Bull->Text = _strdup(text);
	Bulletins[i].st = *pst;

//	TraceLog("Bulletins", FALSE, Info->hwnd, "%s%s:%c:%s:%s\n",
//			New?"*NEW* ":"", Bull->aFrom, Bull->ID, Bull->aGroup, Bull->Text);

	if (pBull) *pBull = Bull;
	return New;
}

BOOL RememberBulletin(CLIENT_INFO_S *Info, char *from, char id, char *group, char *text)
{	BULLETIN_INFO_S *Bull;
	SYSTEMTIME stNow;
	BOOL New;

	if (!isprint(id & 0xff))
	{	TraceLogThread("Bulletins", TRUE, "Non-Printable ID(0x%lX) from %s group(%s) %s\n", (long) id, from, group, text);
		id = ' ';
	}

	GetSystemTime(&stNow);
	RememberRcvdBulletin(Info->hwnd, &ActiveConfig, from, id, group, text);
	SaveConfiguration(Info->hwnd, &ActiveConfig, "RcvdBulletin", 300);
	New = RealRememberBulletin(Info, from, id, group, text, &stNow, &Bull);

	if (New)
	{	if (ActiveConfig.Enables.NotifyOnNewBulletin)
		{
#ifdef USING_SHELL
			Bull->pNotification = CreateAndAddNotification();
			FillSHND(Info->hwnd,Bull->pNotification,&Bull->st,Bull->aFrom,Bull->Text);
			SHNotificationAdd(Bull->pNotification);
#elif !defined(UNDER_CE)
			if (!NewBulletins)
				ShowHideBulletinIcon(Info->hwnd, TRUE);
			NewBulletins = TRUE;
			if (isOperatorPresent())
			{	size_t tLen = strlen(from)+strlen(group)+80;
				char *tPopup = (char*)malloc(tLen);
				StringCbPrintfA(tPopup, tLen, "%s:%-5s:%1.1s",
								from, group, &id);
				PopupNotifyIcon(Info->hwnd, tPopup, Bull->Text, 2);
				if (ActiveConfig.Enables.Sound) MessageBeep(MB_ICONINFORMATION);
				free(tPopup);
			}
#endif
		}
		qsort(Bulletins, BulletinCount, sizeof(*Bulletins), BulletinCompare);
	}
#ifdef USING_SHELL
	else Bull->pNotification = 0;
#endif
	if (hwndBulletin) PostMessage(hwndBulletin, WM_USER, 0, 0);
	return New;
}

static void RestoreBulletins(CLIENT_INFO_S *Info)
{	TIMED_STRING_LIST_S *List = &ActiveConfig.RcvdBulletins;
	unsigned long MaxAge = ActiveConfig.Aging.BulletinHours*60*60;

	PurgeOldTimedStrings(List, MaxAge);

	for (size_t b=0; b<List->Count; b++)
	{	BOOL Ok = FALSE;
		char *Temp = _strdup(List->Entries[b].string);
		char *from = strchr(Temp,':');
		if (from)
		{	char *id = strchr(from+1,':');
			if (id)
			{	char *group = strchr(id+1,':');
				if (group)
				{	char *text = strchr(group+1,':');
					if (text)
					{	from++;	/* Skip leading : */
						*id++ = '\0';	/* Null term from */
						*group++ = '\0';	/* Null term ID */
						*text++ = '\0';	/* Null term group */
						RealRememberBulletin(Info, from, *id, group, text, &List->Entries[b].time);
						Ok = TRUE;
					}
				}
			}
		}
		free(Temp);
		if (!Ok)
		{
//			TraceLogThread("Bulletins", TRUE, "Deleting Invalid or Old Bulletin %s\n", List->Entries[b].string);
			List->Entries[b--] = List->Entries[--List->Count];
		}
	}
	qsort(Bulletins, BulletinCount, sizeof(*Bulletins), BulletinCompare);
	if (hwndBulletin) PostMessage(hwndBulletin, WM_USER, 0, 0);
}

static void RemoveBulletin(int i, BOOL NoUpdate=FALSE)
{
	if (i < BulletinCount)
	{	free(Bulletins[i].Text);
#ifdef USING_SHELL
		if (Bulletins[i].pNotification)
			RemoveNotification(Bulletins[i].pNotification->dwID);
		// else TraceError(NULL, "NULL Notification Index[%ld/%ld]\n", (long) i, (long) BulletinCount);
#endif

		if (--BulletinCount)
		{	if (BulletinCount!=i)
				memmove(&Bulletins[i], &Bulletins[i+1], sizeof(Bulletins[0])*(BulletinCount-i));
		} else
		{	free(Bulletins);
			Bulletins = NULL;
			BulletinSize = 0;
		}
		if (!NoUpdate)
		{	qsort(Bulletins, BulletinCount, sizeof(*Bulletins), BulletinCompare);
			if (hwndBulletin) PostMessage(hwndBulletin, WM_USER, 0, 0);
		}
	}
}

size_t PurgeBulletins(BOOL Force = FALSE)
{	size_t Count = 0;
	unsigned long MaxAge = Force?0:ActiveConfig.Aging.BulletinHours*60*60;

	__int64 msNow = llGetMsec();
static __int64 LastPurge;
	if (!LastPurge) LastPurge = msNow-10*60*1000 + 3*60*1000;	/* Trigger in 3 minutes */
	if (!Force && llMsecSince(LastPurge, msNow) < 10*60*1000) return 0;
	LastPurge = msNow;

	if (MaxAge || Force)	/* Is there a limit? */
	for (int i=0; i<BulletinCount; i++)
	{	if (SecondsSince(&Bulletins[i].st) > MaxAge)
		{	BULLETIN_INFO_S *Bull = &Bulletins[i];
			size_t tCnt;
			if ((tCnt=ForgetRcvdBulletin(NULL, &ActiveConfig, Bull->aFrom, Bull->ID, Bull->aGroup)) != 1)
//				TraceLogThread("Bulletins", TRUE, "Deleted %ld for %ld Minutes old %s:%c:%s:%s\n",
//				(long) tCnt, (long) SecondsSince(&Bulletins[i].st)/60,
//				Bull->aFrom, Bull->ID, Bull->aGroup, Bull->Text);
			RemoveBulletin(i,TRUE);
			Count++;
			i--;	/* Check this entry again */
		}
	}
	if (Count)
	{	qsort(Bulletins, BulletinCount, sizeof(*Bulletins), BulletinCompare);
		if (hwndBulletin) PostMessage(hwndBulletin, WM_USER, 0, 0);
	}
	return Count;
}

LRESULT CALLBACK BulletinWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{	CLIENT_INFO_S *Info;

	switch (iMsg)
	{
	case WM_CREATE:
	{	CREATESTRUCT *cs = (CREATESTRUCT *) lParam;
		Info = (CLIENT_INFO_S *) cs->lpCreateParams;
		SetWindowLong(hwnd, GWL_USERDATA, (LONG) Info);
		hwndBulletinEdit = CreateWindow(TEXT("edit"), NULL,
									WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
									ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_READONLY,
									0, 0, 0, 0, hwnd, (HMENU) 1, g_hInstance, NULL);	/* Child window ID 1 */
		SendMessage(hwndBulletinEdit, WM_SETFONT, (WPARAM)GetFixedFont(), 0);
		SendMessage(hwndBulletinEdit, EM_LIMITTEXT, 2000, 0L);
		SendMessage(hwnd, WM_USER, 0, 0);	/* Populate the window */
		return 0;
	}
	case WM_USER:
	{	Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

		SetWindowText(hwndBulletinEdit, TEXT(""));	/* Clear out the old stuff */

		unsigned long CurrentSize = (unsigned long) SendMessage(hwndBulletinEdit, EM_GETLIMITTEXT, 0, 0);
		unsigned long Required = 80;
		int i;

		size_t wFrom=0, wGroup=0, wText=0;

		for (i=0; i<BulletinCount; i++)
		{	if (strlen(Bulletins[i].aFrom) > wFrom)
				wFrom = strlen(Bulletins[i].aFrom);
			if (strlen(Bulletins[i].aGroup) > wGroup)
				wGroup = strlen(Bulletins[i].aGroup);
			if (strlen(Bulletins[i].Text) > wText)
				wText = strlen(Bulletins[i].Text);
		}
		Required += (BulletinCount+1)*(wFrom+wGroup+wText+32);

		if (Required >= CurrentSize)
		{	SendMessage(hwndBulletinEdit, EM_LIMITTEXT, CurrentSize+Required+80+CurrentSize/4, 0);
		}

		size_t Original, Remaining;
		TCHAR *Buff, *Next;

		Original = Remaining = max(256,min(Required,16*1024));	/* no more than 16K at a time */
		Buff = Next = (TCHAR *)malloc(sizeof(*Buff)*Remaining);
		*Buff = *TEXT("");	/* Just in case there's nothing to add */

		StringCchPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("Received %*S:%-*.*S:%1.1S %-*S Date\r\n"),
							(int) wFrom, "From",
							(int) wGroup, (int) wGroup, "Group",
							"*",
							(int) wText, "Text");
		for (i=0; i<BulletinCount; i++)
		{	unsigned __int64 age = SecondsSince(&Bulletins[i].st);
			unsigned __int64 hours = age / (60*60);
			unsigned long minutes = (unsigned long) ((age/60)%60);
			unsigned long seconds = (unsigned long) (age%60);

			if (hours <0 || hours > 99) hours = minutes = seconds = 99;

			if (Remaining < 256)
			{	SendMessage(hwndBulletinEdit, EM_REPLACESEL, FALSE, (LPARAM) Buff);
				Remaining = Original;
				Next = Buff;
			}
			if (i && _stricmp(Bulletins[i-1].aFrom, Bulletins[i].aFrom))
				StringCchPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,TEXT("\r\n"));
			StringCchPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%02ld:%02ld:%02ld %*S:%-*S:%1.1S %-*S %04ld-%02ld-%02ld\r\n"),
								(long) Bulletins[i].st.wHour, 
								(long) Bulletins[i].st.wMinute, 
								(long) Bulletins[i].st.wSecond,
								(int) wFrom, Bulletins[i].aFrom,
								(int) wGroup, Bulletins[i].aGroup,
								&Bulletins[i].ID,
								(int) wText, Bulletins[i].Text,
								(long) Bulletins[i].st.wYear, 
								(long) Bulletins[i].st.wMonth, 
								(long) Bulletins[i].st.wDay);		}
		if (Next != Buff) SendMessage(hwndBulletinEdit, EM_REPLACESEL, FALSE, (LPARAM) Buff);

		if (Buff) free(Buff);
		if (NewBulletins && GetFocus()==hwndBulletinEdit)
		{	ShowHideBulletinIcon(Info->hwnd, FALSE);
			NewBulletins = FALSE;
		}
	}
	break;
	case WM_SETFOCUS:
	{	Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Info && NewBulletins)
		{	ShowHideBulletinIcon(Info->hwnd, FALSE);
			NewBulletins = FALSE;
		}
		SetFocus(hwndBulletinEdit);
#ifdef USING_SHELL
		SHFullScreen(hwnd,SHFS_HIDESIPBUTTON);
#endif
		return 0;
	}
#ifdef USING_SHELL
	case WM_KILLFOCUS:
		SHFullScreen(hwnd,SHFS_SHOWSIPBUTTON);
		return 0;
#endif
	case WM_SIZE:
		MoveWindow(hwndBulletinEdit, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
		return 0;
	case WM_COMMAND:
		Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (lParam && LOWORD(wParam) == 1)
		{	switch (HIWORD(wParam))
			{
			case EN_UPDATE:	/* Flag needs Save */
				return 0;
			case EN_ERRSPACE:
			case EN_MAXTEXT:
//				MessageBox(hwnd, TEXT("Growing Edit Control"), TEXT("EN_MAXTEXT/ERRSPACE"), MB_OK);
				SendMessage(hwndBulletinEdit, EM_SETLIMITTEXT, SendMessage(hwndBulletinEdit, EM_GETLIMITTEXT, 0, 0)+32000, 0);
				return 0;
			}
			break;
		}
		switch (LOWORD(wParam))	/* Handle menu options here */
		{
		case ID_LOG_CLEAR:
			if (MessageBox(hwnd, TEXT("Really Clear ALL Bulletins?"), TEXT("ID_CLEAR"),
							MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				PurgeBulletins(TRUE);
			return 0;
		case ID_LOG_COPY:
		{	int Len = GetWindowTextLength(hwndBulletinEdit);
			if (Len > 0)
			{	SendMessage(hwndBulletinEdit, EM_SETSEL, 0, -1);
				SendMessage(hwndBulletinEdit, WM_COPY, 0, 0);
				SendMessage(hwndBulletinEdit, EM_SETSEL, Len, Len);
			}
			return 0;
		}
		default: ;
		}
		break;
	case WM_CLOSE:
		Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		DestroyWindow(hwndBulletinEdit);
		hwndBulletinEdit = NULL;
		DestroyWindow(hwnd);
		hwndBulletin = NULL;
		return 0;
	case WM_DESTROY:
		Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		/* Deinitialize stuff here */
		return 0;
	default:
		/* Handle registered window messages like Find/Replace */
		;
	}
	return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

void DisplayBulletins(CLIENT_INFO_S *Info, int nShowCmd)
{static	BOOL First = TRUE;
	if (!hwndBulletin)
	{	if (First)
#ifndef UNDER_CE
		{	WNDCLASSEX bullClass = {0};
			bullClass.cbSize = sizeof(bullClass);
			bullClass.style = CS_HREDRAW | CS_VREDRAW;
			bullClass.lpfnWndProc = BulletinWndProc;
			bullClass.hInstance = g_hInstance;
//			if (LoadIconMetric(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON), LIM_SMALL, &bullClass.hIcon) != S_OK)
			bullClass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!bullClass.hIcon)
			bullClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			bullClass.hCursor = LoadCursor(NULL, IDC_ARROW);
//			bullClass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			bullClass.lpszMenuName = MAKEINTRESOURCE(IDM_LOG_W32);
			bullClass.lpszClassName = g_szBullName;
			RegisterClassEx(&bullClass);
			First = FALSE;
		}
#else
		{	WNDCLASS bullClass = {0};
			bullClass.style = CS_HREDRAW | CS_VREDRAW;
			bullClass.lpfnWndProc = BulletinWndProc;
			bullClass.hInstance = g_hInstance;
#ifndef UNDER_CE
			bullClass.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
			if (!bullClass.hIcon)
			bullClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
			bullClass.hCursor = LoadCursor(NULL, IDC_ARROW);
			bullClass.lpszMenuName = MAKEINTRESOURCE(IDM_LOG_W32);
#endif
//			bullClass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
			bullClass.lpszClassName = g_szBullName;
			RegisterClass(&bullClass);
			First = FALSE;
		}
#endif

		TCHAR *szTitle = (TCHAR *)malloc(sizeof(*szTitle)*128);
		StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("Bulletins - %S"), ActiveConfig.CallSign);
#ifdef UNDER_CE
		hwndBulletin = CreateWindow(g_szBullName, szTitle,
									/* WS_EX_CAPTIONOKBTN*/ /*WS_OVERLAPPED |*/ WS_SYSMENU,
									CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
									NULL, NULL, g_hInstance, Info);
#ifdef USING_SHELL
		RemoveBulletinNotifications(Info);
#endif
#else
		hwndBulletin = CreateWindow(g_szBullName, szTitle,
									WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
									WS_OVERLAPPED | WS_SYSMENU,
									CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
									NULL, NULL, g_hInstance, Info);
#endif
		free(szTitle);
		ShowWindow(hwndBulletin, nShowCmd);
	} else ShowWindow(hwndBulletin, SW_RESTORE);
	SetForegroundWindow(hwndBulletin);
	UpdateWindow(hwndBulletin);

#ifdef UNDER_CE
#ifdef USING_SHELL
	RemoveBulletinNotifications(Info);
#endif
#else
	ShowHideBulletinIcon(Info->hwnd, FALSE);
	NewBulletins = FALSE;
#endif
}

#ifdef OBSOLETE
static void DisplayBulletin(HWND hwnd, CLIENT_INFO_S *cInfo, int i)
{	size_t Remaining = sizeof(TCHAR)*256;
	TCHAR *Buffer=(TCHAR*)malloc(Remaining), *Title=(TCHAR*)malloc(sizeof(*Title)*32);
	TCHAR *Next = Buffer;

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("%c:%s:"), Bulletins[i].ID, Bulletins[i].aGroup);
	StringCbPrintExUTF8(Next, Remaining, &Next, &Remaining, -1, Bulletins[i].Text, NULL);

	StringCbPrintf(Title, sizeof(*Title)*32, TEXT("%S %04ld-%02ld-%02ld %02ld:%02ld:%02ld"),
					Bulletins[i].aFrom,
					(long) Bulletins[i].st.wYear, 
					(long) Bulletins[i].st.wMonth, 
					(long) Bulletins[i].st.wDay, 
					(long) Bulletins[i].st.wHour, 
					(long) Bulletins[i].st.wMinute, 
					(long) Bulletins[i].st.wSecond);
	MessageBox(hwnd, Buffer, Title, MB_OK | MB_ICONINFORMATION);

	/* RemoveBulletin(cInfo, i); */
#ifdef USING_SIP
	SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
	free(Buffer); free(Title);
}
#endif

void ShowHideBulletinIcon(HWND hwnd, BOOL Show)
{
#ifndef UNDER_CE
	if (Show)
	{	TCHAR *szTitle = (TCHAR *)malloc(sizeof(*szTitle)*128);
		StringCbPrintf(szTitle, sizeof(*szTitle)*128,
						TEXT("Bulletins - %S"), ActiveConfig.CallSign);
		CreateNotifyIcon(hwnd, szTitle, 2, WM_BULL_NOTIFICATION,
						MakeSymbolIcon(hwnd, GetStationSymbol(MyStation)));
		free(szTitle);
	} else DestroyNotifyIcon(hwnd, 2);
#endif
}
void myBulletinCallback(void *userarg, char *from, char identifier, char *group, char *bulletin)
{
}

size_t PurgeRcvdWeather(BOOL Force = FALSE)
{	size_t Result = ActiveConfig.RcvdWeather.Count;

	//if (Force)
		EmptyColonStringList(&ActiveConfig.RcvdWeather);
//	else Result = PurgeOldTimedStrings(&ActiveConfig.RcvdWeather, 0);

	return Result;
}

#ifndef UNDER_CE
void CreateNotifyIcon(HWND hwnd, TCHAR *Tip, UINT ID, UINT Msg, HICON hIcon)
{
	NOTIFYICONDATA nid = {0};

	nid.cbSize = sizeof(nid);	/* NOTIFYICONDATA_V2_SIZE=Win2K NOTIFYICONDATA_V3_SIZE=XP */
	nid.cbSize = NOTIFYICONDATA_V3_SIZE;
	nid.hWnd = hwnd;
	nid.uID = ID;	/* ID of notification */
	nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP /*| NIF_STATE*/; 
	nid.uCallbackMessage = Msg;
	StringCchCopy(nid.szTip, ARRAYSIZE(nid.szTip), Tip);
	nid.dwState = NIS_SHAREDICON;
	nid.dwStateMask = NIS_SHAREDICON;
	nid.uVersion = NOTIFYICON_VERSION; /* (Maybe NOTIFYICON_VERSION_3, but not _4) */

//	if (LoadIconMetric(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON), LIM_SMALL, &nid.hIcon) != S_OK)
	if (hIcon)
		nid.hIcon = hIcon;
	if (!nid.hIcon)
		nid.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MY_ICON));
	if (!nid.hIcon)
		nid.hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));
	if (!nid.hIcon) nid.uFlags &= ~NIF_ICON;

#ifdef FUTURE_INFO
IDI_APPLICATION Default application icon.
IDI_ASTERISK Same as IDI_INFORMATION.
IDI_ERROR Hand-shaped icon.
IDI_EXCLAMATION Same as IDI_WARNING.
IDI_HAND Same as IDI_ERROR. 
IDI_INFORMATION Asterisk icon.
IDI_QUESTION Question mark icon.
IDI_WARNING Exclamation point icon.
IDI_WINLOGO Windows logo icon. Windows XP: Default application icon.
IDI_SHIELD Security Shield icon. 
#endif

// Show the notification.
	if (!Shell_NotifyIcon(NIM_ADD, &nid))
	{	TraceLog("Messages", TRUE, hwnd, "Shell_NotifyIcon(NIM_ADD)(%ld) Failed with %ld\n", (long) ID, (long) GetLastError());
	}

//	if (!Shell_NotifyIcon(NIM_SETVERSION, &nid))
//	{	TraceLog("Messages", TRUE, hwnd, "Shell_NotifyIcon(NIM_SETVERSION) Failed with %ld\n", (long) GetLastError());
//	}
}

void PopupNotifyIcon(HWND hwnd, char *Title, char *Text, UINT ID)
{	NOTIFYICONDATA nid = {0};

	nid.cbSize = sizeof(nid);	/* NOTIFYICONDATA_V2_SIZE=Win2K NOTIFYICONDATA_V3_SIZE=XP */
	nid.cbSize = NOTIFYICONDATA_V3_SIZE;
	nid.hWnd = hwnd;
	nid.uID = ID;	/* ID of notification */
	nid.uFlags = NIF_INFO; 

	StringCbPrintExUTF8(nid.szInfo, sizeof(nid.szInfo), NULL, NULL, -1, Text, NULL);
	StringCbPrintf(nid.szInfoTitle, sizeof(nid.szInfoTitle), TEXT("%S"), Title);

	nid.dwInfoFlags = NIIF_INFO | !ActiveConfig.Enables.Sound?NIIF_NOSOUND:0;	/* Balloon appearance (NIIF_WARNING/ERROR or NIIF_USER) */

// Show the notification.
	if (!Shell_NotifyIcon(NIM_MODIFY, &nid))
	{	TraceLog("Messages", TRUE, hwnd, "Shell_NotifyIcon(NIM_MODIFY)(%ld) Failed with %ld\n", (long) ID, (long) GetLastError());
	}
}

void DestroyNotifyIcon(HWND hwnd, UINT ID)
{	NOTIFYICONDATA nid = {0};

	nid.cbSize = sizeof(nid);	/* NOTIFYICONDATA_V2_SIZE=Win2K NOTIFYICONDATA_V3_SIZE=XP */
	nid.cbSize = NOTIFYICONDATA_V3_SIZE;
	nid.hWnd = hwnd;
	nid.uID = ID;	/* ID of notification */
	if (!Shell_NotifyIcon(NIM_DELETE, &nid))
		TraceLog("Messages", TRUE, hwnd, "Shell_NotifyIcon(NIM_DELETE)(%ld) Failed with %ld\n", (long) ID, (long) GetLastError());
}
#endif

void FixMaxWidthStation(HWND hwnd)
{	if (!hwnd) hwnd = hwndMain;
	if (hwnd)
	{	HDC hdc = GetDC(hwnd);
		RECT rc;

		GetWindowRect(hwnd, &rc);
		StringCbPrintf(MaxWidthStationID, sizeof(MaxWidthStationID),
						TEXT("%S%S"),
						ActiveConfig.MaxWidthStationID, IGateEnabled?"*9":"");
		MaxWidthStationLength = strlen(ActiveConfig.MaxWidthStationID);
		g_dwFontSize = DrawText(hdc, MaxWidthStationID, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
		MaxWidthStationWidth = rc.right - rc.left + 2;
		ReleaseDC(hwnd, hdc);
	}
}

#ifndef UNDER_CE
static void PrimeAliasTraces(void);
#endif

BOOL FinishMainWindowStartup(HWND hwnd, char *ViewString)
{	CLIENT_INFO_S *Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	TraceActivity(hwndMain,"FinishMainWindowStartup:Running %s(%s)\n", PROGNAME, Timestamp);
	if (!ActiveConfigLoaded)
	{	FirstRun = TRUE;
#ifndef UNDER_CE
		ActiveConfig.Enables.DebugGeneral = ActiveConfig.Enables.DebugFile = TRUE;
#endif
		if (!LoadOrDefaultConfiguration(hwnd, &ActiveConfig, TRUE, TRUE))
		{	/* This means a default configuration was loaded */
			FirstRun = TRUE;
			cInfos[0].CenterTracking = FALSE;	/* We dragged to here */
		} else FirstRun = FALSE;
	} else FirstRun = FALSE;

	if (IsValidLatLon(ActiveConfig.Latitude, ActiveConfig.Longitude))
	{	LastGoodPosition.dblLatitude = ActiveConfig.Latitude;	/* Pre-fill Lat/Long with last known position */
		LastGoodPosition.dblLongitude = ActiveConfig.Longitude;	/* Note that these may be 0, 0 */
		LastGoodPosition.dwValidFields = (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
		if (ActiveConfig.Altitude)
		{	LastGoodPosition.flAltitudeWRTSeaLevel = (float) ActiveConfig.Altitude;
			LastGoodPosition.dwValidFields |= GPS_VALID_ALTITUDE_WRT_SEA_LEVEL;
		}
		cInfos[0].LastCenterPosition = LastGoodPosition;
	}
	if ((ActiveConfig.Center.Latitude || ActiveConfig.Center.Longitude)
	&& IsValidLatLon(ActiveConfig.Center.Latitude, ActiveConfig.Center.Longitude))
	{	cInfos[0].LastCenterPosition.dblLatitude = ActiveConfig.Center.Latitude;
		cInfos[0].LastCenterPosition.dblLongitude = ActiveConfig.Center.Longitude;
		cInfos[0].LastCenterPosition.dwValidFields = (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
		cInfos[0].CenterTracking = FALSE;	/* We dragged to here */
	}

	cInfos[0].Paths = ActiveConfig.Screen.Paths;
	cInfos[0].Paths.All.Time = -1;
#ifdef OLD_WAY_FORCED_DEFAULTS
	cInfos[0].Paths.ShowAllLinks = TRUE;
	cInfos[0].Paths.Flash.Time = 10;
	cInfos[0].Paths.Short.Time = 2*60;
	cInfos[0].Paths.Medium.Time = 10*60;
	cInfos[0].Paths.Long.Time = 30*60;
	cInfos[0].Paths.Last.Time = 0;
	cInfos[0].Paths.All.Time = -1;
#define SETCOLOR(p,w,c) cInfos[0].Paths.p.Width=w, strncpy(cInfos[0].Paths.p.Color,#c,sizeof(cInfos[0].Paths.p.Color))
	SETCOLOR(Packet,2,orange);
	SETCOLOR(Direct,1,salmon);
	SETCOLOR(First,1,red);
	SETCOLOR(Middle,3,lime);
	SETCOLOR(Final,3,lightgreen);
#undef SETCOLOR
#endif

	cInfos[0].Locked = ActiveConfig.Tracking.Locked;
	cInfos[0].Awaiting = ActiveConfig.Tracking.Center;
	strncpy(cInfos[0].CenterID, ActiveConfig.Tracking.Call, sizeof(cInfos[0].CenterID));

#ifndef UNDER_CE
	{	HICON hIcon;
		TCHAR szTitle[80];
		if (!MyStation) DefineME(hwnd);
		hIcon = MakeSymbolIcon(hwnd, GetStationSymbol(MyStation));
		SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
		SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM) hIcon);
		GetWindowText(hwnd, szTitle, 80);
		CreateNotifyIcon(hwnd, szTitle, 1, WM_MSG_NOTIFICATION, hIcon);
	}
#endif

	TraceActivity(hwndMain,"FinishMainWindowStartup:Running %s(%s)\n", PROGNAME, Timestamp);
	msStartRunning = llGetMsec();

#ifdef OLD_WAY
	LoggingEnabled = !ActiveConfig.Enables.Debug;	/* Force it to be different */
	EnableLogging(hwnd, ActiveConfig.Enables.Debug);
#endif

	{	size_t p;
#ifdef USE_TIMED_STRINGS
	for (p=0; p<ActiveConfig.AlwaysTraceLogs.Count; p++)
		TraceLog(ActiveConfig.AlwaysTraceLogs.Entries[p].string, TRUE, hwnd, "Restore Saved ALWAYS Enable");
	for (p=0; p<ActiveConfig.TraceLogs.Count; p++)
		TraceLog(ActiveConfig.TraceLogs.Entries[p].string, TRUE, hwnd, "Restore Saved Enable");
#else
	for (p=0; p<ActiveConfig.AlwaysTraceLogs.Count; p++)
		TraceLog(ActiveConfig.AlwaysTraceLogs.Strings[p], TRUE, hwnd, "Restore Saved ALWAYS Enable");
	for (p=0; p<ActiveConfig.TraceLogs.Count; p++)
		TraceLog(ActiveConfig.TraceLogs.Strings[p], TRUE, hwnd, "Restore Saved Enable");
#endif
	}

#ifdef SUPPORT_TRACE_LOGS
	if (ActiveConfig.Enables.DebugStartup && !FirstRun)
	{	CreateLockWindow();
#ifndef UNDER_CE
		if (ActiveConfig.Enables.DebugGeneral)
			ShowTraceLog("Activity", TRUE);
#endif
	} else if (ActiveConfig.Enables.DebugGeneral)
	{	TRACE_LOG_S *Log = GetTraceLog("Activity");
		if (Log)
		{	Log->Enabled = TRUE;
			UnlockTraceLog(Log,__LINE__);
		}
	}
#endif

	Info->viewBits = MakeViewBits(Info, ViewString);

	if (ActiveConfig.RFIDs.Count
	&& (ActiveConfig.RFIDs.RFID[0].AssocEnabled
		|| ActiveConfig.RFIDs.RFID[0].ServerEnabled))
	{	Info->viewBits &= ~VIEW_ALL;
		Info->viewBits |= VIEW_RFID;
		CheckMenuItem (Info->hMenu, ID_VIEW_RFID, MF_CHECKED);
	}

	if (ActiveConfig.ANDefs.Count)
	{	Info->viewBits &= ~VIEW_ALL;
		Info->viewBits |= VIEW_ANSRVR_MEMBERS;
		InsertMenu(Info->hMenu, ID_VIEW_BUDDIES,
					MF_BYCOMMAND | MF_CHECKED /*| MF_DISABLED*/ | MF_STRING,
					ID_VIEW_ANSRVR_MEMBERS, TEXT("ANSRVR Members"));
	}

	if (!strncmp(CALLSIGN, "KJ4ERJ-15", sizeof(CALLSIGN)))
	{	Info->viewBits |= VIEW_SYMBOLS;
		Info->viewSymbols[APRSSymbolIndex(SymbolInt('\\','S'))] = TRUE;
		Info->viewSymbols[APRSSymbolIndex(SymbolInt('V','S'))] = TRUE;
	}

	if (Info->viewBits & VIEW_ALL) CheckMenuItem (Info->hMenu, ID_VIEW_ALL, MF_CHECKED);

	Info->Scale = ActiveConfig.Scale;
#ifdef DO_OSM
	Info->zoom = ActiveConfig.OSMZoom;
	Info->Percent = ActiveConfig.OSMPercent;

	OriginalScreen.lat = Info->LastCenterPosition.dblLatitude;
	OriginalScreen.lon = Info->LastCenterPosition.dblLongitude;
	OriginalScreen.zoom = Info->zoom;

	FixIGateEnabled();
	FixMaxWidthStation(hwnd);
#ifndef UNDER_CE
	PrimeAliasTraces();
#endif

	if (ActiveConfig.Companions.Count)
		IsTraceLogEnabled("Companions");

	OSMSetTileServerInfo(hwnd, WM_TILES_LOADED, &ActiveConfig.OSM,
						ActiveConfig.OSMMinMBFree);
	OSMSetPurgeEnable(!ActiveConfig.OSMPurgeDisabled);
#endif

	//if (Info->Orientation != ActiveConfig.Orientation)
		SetOrientation(hwnd, ActiveConfig.Orientation);

	set_message_handler(CALLSIGN, myMessageCallback, Info);
	set_bulletin_handler(myBulletinCallback, Info);

	if (!SetTimer(hwnd, TCP_TIMER, TcpPollRate, NULL))
		MessageBox(hwnd, TEXT("SetTimer Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);
	//else tcp_set_host_port(ActiveConfig.APRSServer,ActiveConfig.APRSPort);	/* Force a resolution for round-robin DNS */

	if (!SetTimer(hwnd, GPS_TIMER, GPSRate, NULL))
		MessageBox(hwnd, TEXT("SetTimer(GPS) Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);

	if (!SetTimer(hwnd, PURGE_TIMER, PurgeRate, NULL))
		MessageBox(hwnd, TEXT("SetTimer(Purger) Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);

#ifndef USER_TIMER_MAXIMUM
#define USER_TIMER_MAXIMUM 0x7fffffff
#endif
	if (!SetTimer(hwnd, POWER_TIMER, min(PowerRate,USER_TIMER_MAXIMUM), NULL))
		MessageBox(hwnd, TEXT("SetTimer(Power) Failed"), TEXT("WM_CREATE"), MB_OK | MB_ICONERROR);

	RestoreBulletins(Info);

#ifdef OTHER_THINGS
// KeyboardPresent
// Gets a value indicating whether a keyboard is attached and enabled.
#define SN_KEYBOARDPRESENT_ROOT HKEY_CURRENT_USER
#define SN_KEYBOARDPRESENT_PATH TEXT("Software\\Microsoft\\Shell")
#define SN_KEYBOARDPRESENT_VALUE TEXT("HasKeyboard")// PhoneCellBroadcast
// Gets the cell broadcast message.
#define SN_PHONECELLBROADCAST_ROOT HKEY_LOCAL_MACHINE
#define SN_PHONECELLBROADCAST_PATH TEXT("System\\State\\Phone")
#define SN_PHONECELLBROADCAST_VALUE TEXT("Cell Broadcast")
// PhoneActiveDataCall
// Gets a value indicating whether the phone has an active cellular data connection.
#define SN_PHONEACTIVEDATACALL_ROOT HKEY_LOCAL_MACHINE
#define SN_PHONEACTIVEDATACALL_PATH TEXT("System\\State\\Phone")
#define SN_PHONEACTIVEDATACALL_VALUE TEXT("Status")
#define SN_PHONEACTIVEDATACALL_BITMASK 0x1000
#endif
#ifdef MONITOR_PHONE
{	HRESULT hr;
	hr = RegistryNotifyWindow(SN_PHONEOPERATORNAME_ROOT,
						SN_PHONEOPERATORNAME_PATH,
						SN_PHONEOPERATORNAME_VALUE,
						hwnd, WM_NOTIFY_OPERATOR_NAME, 0, NULL,
						&hNotifyOperatorName);
	if ((hr = RegistryNotifyWindow(SN_PHONESIGNALSTRENGTH_ROOT,
						SN_PHONESIGNALSTRENGTH_PATH,
						SN_PHONESIGNALSTRENGTH_VALUE,
						hwnd, WM_NOTIFY_SIGNAL_STRENGTH, 0, NULL,
						&hNotifySignalStrength)) == S_OK)
	{	DWORD dwSignalStrength = 0;
			if (SUCCEEDED(RegistryGetDWORD(SN_PHONESIGNALSTRENGTH_ROOT,
							SN_PHONESIGNALSTRENGTH_PATH,
							SN_PHONESIGNALSTRENGTH_VALUE,
							&dwSignalStrength)))
		{	PostMessage(hwnd, WM_NOTIFY_SIGNAL_STRENGTH, dwSignalStrength, 0);
		}
	}
#ifdef HAS_CELL_BROADCAST
	if ((hr=RegistryNotifyWindow(SN_PHONECELLBROADCAST_ROOT,
						SN_PHONECELLBROADCAST_PATH,
						SN_PHONECELLBROADCAST_VALUE,
						hwnd, WM_NOTIFY_CELL_BROADCAST, 0, NULL,
						&hNotifyCellBroadcast)) == S_OK)
		PostMessage(hwnd, WM_NOTIFY_CELL_BROADCAST, 0, 0);
	else TraceLog("Phone", FALSE, hwnd, "RegistryNotifyWindow(CellBroadcast) Failed, Error %ld (0x%lX)\n", (long) hr, (long) hr);
#endif
}
#endif
	return TRUE;
}

BOOL OnCreateMainWindow(HWND hwnd, CREATESTRUCT *cs)
{
	CLIENT_INFO_S *Info = &cInfos[(int) cs->lpCreateParams];
//	memset(Info, 0, sizeof(*Info));
//	Info = (CLIENT_INFO_S *) calloc(1,sizeof(*Info));
#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG) Info);
#else
	SetWindowLong(hwnd, GWL_USERDATA, (LONG) Info);
#endif

	HDC hdc = GetDC(hwnd);

	Info->hwnd = hwnd;
	Info->tsInfo = ActiveConfig.OSM;
	for (unsigned int s=0; s<ActiveConfig.TileServers.Count; s++)
	{	OSMRegisterTileServer(&ActiveConfig.TileServers.Server[s], "Config");
	}

	Info->Index = (int) cs->lpCreateParams;
	Info->Active = TRUE;
	SetOrientation(hwnd, ActiveConfig.Orientation);
	FixMaxWidthStation(hwnd);

//	ClearTraceFile(hwnd);

	int DriverVersion = GetDeviceCaps(hdc, DRIVERVERSION);
	int Technology = GetDeviceCaps(hdc, TECHNOLOGY);
	int ShadeBlendCaps = GetDeviceCaps(hdc, SHADEBLENDCAPS);
	char *sTechnology = "*Unknown*";
	char *sBlendCaps = "*Unknown*";
#define DOIT(s) case DT_##s: sTechnology=#s; break
	switch (Technology)
	{
	DOIT(PLOTTER);
	DOIT(RASDISPLAY);
	DOIT(RASPRINTER);
	DOIT(RASCAMERA);
	DOIT(CHARSTREAM);
#ifndef UNDER_CE
	DOIT(METAFILE);
#endif
	DOIT(DISPFILE);
	}
#undef DOIT
#define DOIT(s) case SB_##s: sBlendCaps=#s; break
	switch (ShadeBlendCaps)
	{
	DOIT(GRAD_RECT);
	DOIT(GRAD_TRI);
#ifndef UNDER_CE
	DOIT(NONE);
#endif
	DOIT(PIXEL_ALPHA);
	DOIT(PREMULT_ALPHA);
	}
#undef DOIT

	TraceLog("Activity", TRUE, hwnd, "GetDeviceCaps(DriverVersion)=%ld (0x%lX)\n", DriverVersion, DriverVersion);
	TraceLog("Activity", TRUE, hwnd, "GetDeviceCaps(Technology)=%s or %ld (0x%lX)\n", sTechnology, Technology, Technology);
	TraceLog("Activity", TRUE, hwnd, "GetDeviceCaps(ShadeBlendCaps)=%s or %ld (0x%lX)\n", sBlendCaps, ShadeBlendCaps, ShadeBlendCaps);

	ReleaseDC(hwnd, hdc);
/*
G4ILO - No transparency (8/26/2010)
GetDeviceCaps(DriverVersion)=768 (0x300)
GetDeviceCaps(Technology)=RASDISPLAY or 1 (0x1)
GetDeviceCaps(ShadeBlendCaps)=*Unknown* or 51 (0x33)

KJ4ERJ Win7
> GetDeviceCaps(DriverVersion)=16384 (0x4000)
> GetDeviceCaps(Technology)=RASDISPLAY or 1 (0x1)
> GetDeviceCaps(ShadeBlendCaps)=NONE or 0 (0x0)

*/

#ifdef REFERENCE
Device technology. It can be any one of the following values.
DT_PLOTTERVector plotter
DT_RASDISPLAYRaster display
DT_RASPRINTERRaster printer
DT_RASCAMERARaster camera
DT_CHARSTREAMCharacter stream
DT_METAFILEMetafile
DT_DISPFILEDisplay file

SB_GRAD_RECTCapable of doing GradientFill rectangles.
SB_GRAD_TRICapable of doing GradientFill triangles.
SB_NONEDevice does not support any of these capabilities.
SB_PIXEL_ALPHACapable of handling per-pixel alpha in AlphaBlend.
SB_PREMULT_ALPHACapable of handling premultiplied alpha in AlphaBlend.
#endif

#if defined(USING_SHELL) || defined(CE50)
#ifdef CE50
	{	Info->hwndCB = CommandBar_Create(g_hInstance, hwnd, 0xBEEB);
		if (Info->hwndCB)
		{	if (!CommandBar_InsertMenubar(Info->hwndCB, g_hInstance, IDM_MAIN_W32, 0))
				TraceLogThread("Activity", TRUE, "InsertMenubar(%p) Failed with %ld\n", Info->hwndCB, (long) GetLastError());
			else
			{	Info->hMenu = CommandBar_GetMenu(Info->hwndCB, 0);
				Info->MenuOffset = CommandBar_Height(Info->hwndCB);
				TraceLogThread("Activity", TRUE, "CommandBar_GetMenu(%p) Gave %p\n", Info->hwndCB, Info->hMenu);
			}
			// CommandBar_AddAdornments (hwndCB, 0, 0); /*WM_HELP | CMDBAR_OK*/
		} else TraceLogThread("Activity", TRUE, "CommandBar_Create Failed with %ld\n", (long) GetLastError());
	}
#else
	SHMENUBARINFO shmbi;

	// Create our softkey bar
	ZeroMemory(&shmbi, sizeof(shmbi));
	shmbi.cbSize = sizeof(shmbi);
	shmbi.hwndParent = hwnd;
	shmbi.dwFlags = SHCMBF_HMENU;
#ifdef CE50
	shmbi.nToolBarId = IDM_MAIN_W32;
//	shmbi.nToolBarId = IDM_MAIN;
#else
	shmbi.nToolBarId = IDM_MAIN;
#endif
	shmbi.hInstRes = g_hInstance;
	if (!SHCreateMenuBar(&shmbi))
	{
		// Failed!!
		return FALSE;
	} else
	{	//g_hwndMb          = shmbi.hwndMB;
		TBBUTTONINFO tbbi = {0};
		tbbi.cbSize       = sizeof(tbbi);
#ifdef TBIF_BYINDEX
		tbbi.dwMask       = TBIF_LPARAM | TBIF_BYINDEX;
		if (!SendMessage(shmbi.hwndMB, TB_GETBUTTONINFO, 1, (LPARAM)&tbbi))
			TraceError(hwnd, "TB_GETBUTTONINFO FAILED!\n");
#else
		if (!shmbi.hwndMB)
			TraceError(hwnd, "hwndMB is NULL!\n");
		tbbi.dwMask       = TBIF_LPARAM;
		if (!SendMessage(shmbi.hwndMB, TB_GETBUTTONINFO, shmbi.nToolBarId, (LPARAM)&tbbi))
		{	TraceError(hwnd, "TB_GETBUTTONINFO FAILED!\n");
			tbbi.lParam = (LPARAM) SHMenuBar_GetMenu(shmbi.hwndMB,shmbi.nToolBarId);
			if (!tbbi.lParam)
				TraceError(hwnd, "SHMenuBar_GetMenu FAILED!\n");
		}
#endif
		Info->hMenu      = (HMENU)tbbi.lParam;
	}
#endif

	// Windows Mobile applications should always display their main window
	// full-screen. We're going to let the OS do this for us by calling
	// SHInitDialog, even though technically this window isn't a dialog window.
	SHINITDLGINFO shidi;
	shidi.dwMask = SHIDIM_FLAGS;
	shidi.hDlg = hwnd;
	shidi.dwFlags = SHIDIF_SIZEDLGFULLSCREEN | SHIDIF_SIPDOWN;
	if (!SHInitDialog(&shidi))
	{
		// Failed!!
		return FALSE;
	}

#ifdef USING_SHELL
// Get the current user preference for text size
	SHGetUIMetrics(SHUIM_FONTSIZE_PIXEL,
		&g_dwFontSize, sizeof(g_dwFontSize), NULL);
#endif

	SHDoneButton(hwnd, SHDB_HIDE);	/* SHDB_SHOW, SHDB_HIDE, SHDB_SHOWCANCEL */
#elif !defined(UNDER_CE)
	Info->hMenu = GetMenu(hwnd);
#endif

	// Success
	return TRUE;
}

#ifdef UNDER_CE
#ifdef USING_COMM_MGR
static struct
{	DWORD Status;
	TCHAR *Word;
	BOOL Attempting;
} ConnStatusWords[] = {
{ CONNMGR_STATUS_UNKNOWN, TEXT("Unknown"), FALSE },
{ CONNMGR_STATUS_CONNECTED, TEXT("OK"), TRUE },	/* Was "Connect" */
{ CONNMGR_STATUS_SUSPENDED, TEXT("Suspend"), TRUE },
{ CONNMGR_STATUS_DISCONNECTED, TEXT("Disconn"), FALSE },
{ CONNMGR_STATUS_CONNECTIONFAILED, TEXT("Failed"), FALSE },
{ CONNMGR_STATUS_CONNECTIONCANCELED, TEXT("Canceled"), FALSE },
{ CONNMGR_STATUS_CONNECTIONDISABLED, TEXT("Disabled"), FALSE },
{ CONNMGR_STATUS_NOPATHTODESTINATION, TEXT("No Path"), FALSE },
{ CONNMGR_STATUS_WAITINGFORPATH, TEXT("Wait4Path"), TRUE },
{ CONNMGR_STATUS_WAITINGFORPHONE, TEXT("Wait4Phone"), TRUE },
{ CONNMGR_STATUS_PHONEOFF, TEXT("Phone Off"), FALSE },
{ CONNMGR_STATUS_EXCLUSIVECONFLICT, TEXT("Exclusive"), TRUE },
{ CONNMGR_STATUS_NORESOURCES, TEXT("No Resource"), FALSE },
{ CONNMGR_STATUS_CONNECTIONLINKFAILED, TEXT("ConnLinkFail"), FALSE },
{ CONNMGR_STATUS_AUTHENTICATIONFAILED, TEXT("Auth Fail"), FALSE },
/*{ CONNMGR_STATUS_NOPATHWITHPROPERTY, TEXT("NoPropPath"), FALSE },*/
{ CONNMGR_STATUS_WAITINGCONNECTION, TEXT("WaitConn"), TRUE },
{ CONNMGR_STATUS_WAITINGFORRESOURCE, TEXT("WaitRsrc"), TRUE },
{ CONNMGR_STATUS_WAITINGFORNETWORK, TEXT("WaitNetwork"), TRUE },
{ CONNMGR_STATUS_WAITINGDISCONNECTION, TEXT("WaitDiscon"), TRUE },
{ CONNMGR_STATUS_WAITINGCONNECTIONABORT, TEXT("WaitAbort"), TRUE },
};

static TCHAR *GetConnMgrStatusWord(DWORD ConnStatus)
{	DWORD i;
	for (i=0; i<ARRAYSIZE(ConnStatusWords); i++)
			if (ConnStatusWords[i].Status == ConnStatus)
				return ConnStatusWords[i].Word;
	TraceError(NULL,"GetConnMgrStatusWord:Unrecognized ConnMgr Status %ld (0x%lX)\n", ConnStatus, ConnStatus);
	return ConnStatusWords[0].Word;
}

static BOOL IsConnMgrAttempting(DWORD ConnStatus)
{	DWORD i;
	for (i=0; i<ARRAYSIZE(ConnStatusWords); i++)
			if (ConnStatusWords[i].Status == ConnStatus)
				return ConnStatusWords[i].Attempting;
	TraceError(NULL,"IsConnMgrAttempting:Unrecognized ConnMgr Status %ld (0x%lX)\n", ConnStatus, ConnStatus);
	return ConnStatusWords[0].Attempting;
}

static TCHAR *GetConnMgrTypeSubType(DWORD Type, DWORD SubType)
{	DWORD i;
static TCHAR Buffer[256];
static struct
{	DWORD Type;
	TCHAR *Word;
} Types[] = {
{ CM_CONNTYPE_UNKNOWN, TEXT("Unknown") },
{ CM_CONNTYPE_CELLULAR, TEXT("Cellular") },
{ CM_CONNTYPE_NIC, TEXT("NIC") },
{ CM_CONNTYPE_BLUETOOTH, TEXT("BlueTooth") },
{ CM_CONNTYPE_UNIMODEM, TEXT("UniModem") },
{ CM_CONNTYPE_VPN, TEXT("VPN") },
{ CM_CONNTYPE_PROXY, TEXT("Proxy") },
{ CM_CONNTYPE_PC, TEXT("PC") }
};
	for (i=0; i<ARRAYSIZE(Types); i++)
		if (Types[i].Type == Type)
			break;
	if (i >= ARRAYSIZE(Types)) i = 0;	/* Default to unknown */
	StringCchCopy(Buffer, ARRAYSIZE(Buffer), Types[i].Word);
	if (SubType & CM_DSF_BILLBYTIME) StringCbCat(Buffer, sizeof(Buffer), TEXT("\nTimed"));
	if (SubType & CM_DSF_ALWAYSON) StringCbCat(Buffer, sizeof(Buffer), TEXT("\nAlwaysOn"));
	if (SubType & CM_DSF_SUSPENDRESUME) StringCbCat(Buffer, sizeof(Buffer), TEXT("\nSusp/Res"));
	return Buffer;
}

static BOOL GetConnMgrConnected(HWND hwnd)
{
	DWORD ConnStatus;

	if (!APRSEnabled) return FALSE;
	if (!ActiveConfig.Enables.Internet) return FALSE;

	if (!hConnection) ConnStatus = CONNMGR_STATUS_DISCONNECTED;
	else if (ConnMgrConnectionStatus(hConnection,&ConnStatus) != S_OK)
	{	ConnStatus = CONNMGR_STATUS_UNKNOWN;
		TraceError(hwnd, "ConnMgrConnectionStatus FAILED!\n");
	}

	if (ConnStatus != LastConnMgrStatus)
	{	char Buffer[80];
		TCHAR *StatusWord = GetConnMgrStatusWord(ConnStatus);
		StringCbPrintfA(Buffer, sizeof(Buffer), "%S", StatusWord);
		SetPortStatus(hwnd, 3333, "ConnMgr", Buffer);
		LastConnMgrStatus = ConnStatus;
	}

	if (IsConnMgrAttempting(ConnStatus)) return (ConnStatus == CONNMGR_STATUS_CONNECTED);

static __int64 LastAttempt = 0;
	__int64 msNow = llGetMsec();

	if (llMsecSince(LastAttempt, msNow) >= 30*1000)	/* every 30 seconds, see if it's time */
	{	LastAttempt = msNow;

		TraceError(hwnd, "GetConnMgrConnected:%sEstablishing Connection for %ld (0x%lX)\n",
					hConnection?"Re-":"", (long) ConnStatus, (long) ConnStatus);
	
		if (hConnection) ConnMgrReleaseConnection(hConnection, 0);
		hConnection = NULL;

		ConnInfo.cbSize = sizeof(ConnInfo);
		ConnInfo.dwParams = CONNMGR_PARAM_GUIDDESTNET;
		ConnInfo.dwFlags = CONNMGR_FLAG_SUSPEND_AWARE;
		ConnInfo.dwPriority = CONNMGR_PRIORITY_USERINTERACTIVE;	/* Set to CONNMGR_PRIORITY_USERIDLE if no focus? */
		ConnInfo.bExclusive = FALSE;
		ConnInfo.bDisabled = FALSE;
		ConnInfo.guidDestNet = IID_DestNetInternet;
		ConnInfo.hWnd = hwnd;
		ConnInfo.uMsg = WM_CONNMGR_NOTIFICATION;
		ConnInfo.lParam = (LPARAM) &ConnInfo;
		if (ConnMgrEstablishConnection(&ConnInfo, &hConnection) != S_OK)
		{	TraceError(hwnd, "ConnMgrEstablishConnection Failed");
			if (hConnection) ConnMgrReleaseConnection(hConnection, 0);
			hConnection = NULL;
		}
	}
	return FALSE;
}
#endif
#endif

#ifdef MONITOR_PHONE
void RecordCellularChange(void)
{
	if (!MyStation) return;

	int c = CellularCount++;
	if (CellularCount >= CellularSize)
	{	CellularSize += 64;	/* MUST be the same as the TrackSize increment! */
		Cellulars = (CELLULAR_INFO_S *)realloc(Cellulars, sizeof(*Cellulars)*CellularSize);
	}

	GetSystemTime(&Cellulars[c].st);
	Cellulars[c].pCoord = MyStation->pCoord;
	Cellulars[c].pCoord->References++;
	Cellulars[c].dwSignalStrength = dwOldSignalStrength;
	if (!c || wcscmp(Cellulars[c-1].szOperatorName, szOldOperatorName))
	{	Cellulars[c].szOperatorName = wcsdup(szOldOperatorName);
		Cellulars[c].bFreeName = TRUE;
	} else
	{	Cellulars[c].szOperatorName = Cellulars[c-1].szOperatorName;
		Cellulars[c].bFreeName = FALSE;
	}
}
#endif

#ifndef NO_PATH_TRACKING
void FreePaths(STATION_INFO_S *Station)
{	int p;
	for (p=0; p<Station->PathCount; p++)
	{	DeReferenceCoord("FreePathFrom", Station->Station, Station->Paths[p].from.pCoord);
		DeReferenceCoord("FreePathTo", Station->Station, Station->Paths[p].to.pCoord);
	}
	Station->PathCount = 0;
	Station->PathSize = 0;
	if (Station->Paths)
	{	free(Station->Paths);
		Station->Paths = NULL;
	}
}
#endif

void FreeTracks(STATION_INFO_S *Station, BOOL PathsToo)
{	int t;
	for (t=0; t<Station->TrackCount; t++)
		DeReferenceCoord("FreeTracks", Station->Station, Station->Tracks[t].pCoord);
	Station->TrackCount = 0;
	Station->TrackDupes = 0;
	Station->TrackInvalids = 0;
	Station->TrackSize = 0;
	if (Station->Tracks)
	{	free(Station->Tracks);
		Station->Tracks = NULL;
	}
	memset(&Station->Last, 0, sizeof(Station->Last));
	Station->Last.lat = Station->pCoord->lat;
	Station->Last.lon = Station->pCoord->lon;
	Station->Last.msec = Station->lastMsec;
	Station->hadAltitude = Station->alt != 0;	/* only if we currently have one */
#ifndef NO_PATH_TRACKING
	if (PathsToo) FreePaths(Station);
#endif
#ifdef MONITOR_PHONE
	if (Station == MyStation)	/* Clearing my tracks! */
	{	for (int c=0; c<CellularCount; c++)
		{	if (Cellulars[c].bFreeName) free(Cellulars[c].szOperatorName);
			DeReferenceCoord("Cellular", "Cellular", Cellulars[c].pCoord);
		}
		free(Cellulars);
		Cellulars = NULL;
		CellularCount = CellularSize = 0;
	}
#endif
}

BOOL PurgeTracks(STATION_INFO_S *Station, __int64 msNow)	/* Returns TRUE if any were deleted */
{	BOOL Result = FALSE;

	if (Station != MyStation && Station->TrackCount)	/* (Keep Me!) Have any? */
	{	unsigned long MaxAge = Station->isBuddy?ActiveConfig.Aging.BuddyTrackHours:ActiveConfig.Aging.TrackHours;
		if (MaxAge)	/* Limited? */
		{	int t;
			MaxAge *= 60 * 60;	/* Hours->sec */
			for (t=0; t<Station->TrackCount; t++)
			{	if (llMsecSince(Station->Tracks[t].msec, msNow)/1000 < MaxAge)
					break;
			}
			if (t >= Station->TrackCount/10)	/* At least 10% to remove? */
			{	int p;

				for (p=0; p<t; p++)
					DeReferenceCoord("PurgeTracks", Station->Station, Station->Tracks[p].pCoord);

//TraceLogThread("Tracks", TRUE, "Removing %ld/%ld Tracks from %s\n",
//			   (long) t, (long) Station->TrackCount, Station->Station);

				Station->TrackCount -= t;
				if (Station->TrackCount)	/* Any left? Move them. */
					memmove(&Station->Tracks[0], &Station->Tracks[t],
						sizeof(Station->Tracks[0])*Station->TrackCount);
				else FreeTracks(Station, FALSE);	/* All gone, clear them */
				Result = TRUE;
			}
		}
	}
	return Result;
}

BOOL PurgeCloseStations(HWND hwnd, BOOL ClearAll=FALSE)
{	BOOL Updated = FALSE;
	unsigned long s;
	unsigned long FreeCount = 0;
	unsigned long MaxAge = ActiveConfig.Stations.MaxAge;
	unsigned long BuddyMaxAge = ActiveConfig.Stations.BuddyMaxAge;
	
#ifdef DEBUG_CIRCLE_PAINT
static BOOL First = TRUE;
	if (First)
	{	First = FALSE;
		TraceLogThread("LostVisible", TRUE, "Enable to Diagnose Screen Optimization Problems, Also shows NEW, but KILLed Objects!\n");
	}
#endif

	if (CloseStationFreeze) return FALSE;

//	if (ClearAll || MaxAge > 0)	/* MaxAge == 0 is Unlimited, keep them ALL */
	if (cInfos[0].Active)	/* Main window must be working */
	{	long *LostVisible = (long*)calloc(MAX_TRACKERS,sizeof(*LostVisible));
		__int64 Now = llGetMsec();
		SYSTEMTIME stNow;
		GetSystemTime(&stNow);	/* For NWS object activating/expiring */

		if (ClearAll) BuddyMaxAge = MaxAge = 0;
		else
		{	MaxAge *= 60;
			BuddyMaxAge *= 60;
			if (MaxAge == 0) MaxAge = LONG_MAX;
			if (BuddyMaxAge == 0) BuddyMaxAge = LONG_MAX;
		}
/*
	If MyStation has been heard on RF, fix it up
*/
		if (MyStation
		&& MyStation->HeardOnRF
		&& llMsecSince(MyStation->lastRFMsec, Now) > RECENTLY_HEARD_MINUTES*60*1000)
		{	MyStation->HeardOnRF = FALSE;	/* no longer considered RF */
			MyStation->HeardAsThird = FALSE;	/* Which means no longer 3rd either */
			if (MyStation->pRFpath)
			{	free(MyStation->pRFpath);
				MyStation->pRFpath = NULL;
			}
			MyStation->sRFpath = 0;
		}
/*
	Now do cleanup on the whole station list
*/
		for (s=1; s<CloseStationCount; s++)
		{	STATION_INFO_S *Station = pCloseStations[s];

			if (Station->HeardOnRF
			&& llMsecSince(Station->lastRFMsec, Now) > RECENTLY_HEARD_MINUTES*60*1000)
			{	Station->HeardOnRF = FALSE;	/* no longer considered RF */
				Station->HeardAsThird = FALSE;	/* Which means no longer 3rd either */
				if (Station->pRFpath)
				{	free(Station->pRFpath);
					Station->pRFpath = NULL;
				}
				Station->sRFpath = 0;
				Updated = TRUE;	/* Need to update the circle in case of a View filter */

				for (int tr=0; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active)
				{	if (Station->TInfo[tr].visible
					&& !IsStationVisible(&cInfos[tr], Station))
					{	LostVisible[tr]++;
#ifdef DEBUG_CIRCLE_PAINT
TraceLogThread("LostVisible", FALSE, "[%ld] Lost RF(%s)\n", tr, Station->Station);
#endif
						Station->TInfo[tr].visible = FALSE;	/* We KNOW it's not */
						Station->TInfo[tr].inCircle = Station->TInfo[tr].ptvalid = Station->TInfo[tr].rcsymvalid = Station->TInfo[tr].rclblvalid = FALSE;	/* Force check */
					}
#ifdef DEBUG_CIRCLE_PAINT
					else TraceLogThread("LostVisible", FALSE, "[%ld] Still RF %sVisible(%s)\n", tr, Station->TInfo[tr].visible?"":"IN", Station->Station);
#endif
				}
			}

			if (Station->isCenter)
			{	int tr;
				for (tr=0; tr<MAX_TRACKERS; tr++)
					if (cInfos[tr].Active)
						if (cInfos[tr].CenterStation == Station)
							break;
				if (tr>=MAX_TRACKERS)	/* Not centered anywhere that we can find! */
				{	//TraceLog("isCenter", TRUE, hwnd, "Station(%s)(%s) No Longer Centered, clearing isCenter\n",
					//		Station->Station, Station->Owner);
					Station->isCenter = FALSE;
				}
			}

			if (Station->isNWS && Station->sComment)	/* Active/Kill NWS */
			{	if (FixNWSIssueKill(Station, &stNow))
					Updated = TRUE;
			}

#ifdef OVERLAYS_ARE_OBJECTS
			if (Station->isObject
			&& !Station->isKilled
			&& Station->isMyObject
			&& Station->HeardInternal)
			{	TraceLogThread("Overlays", FALSE, "NOT Purging Overlay(%s)\n", Station->Station);
			}	/* Noop for my overlays */
			else
#endif
			if (!Station->isCenter
			&& (Station->isKilled
			|| llMsecSince(Station->lastMsec, Now)/1000 > (Station->isBuddy?BuddyMaxAge:MaxAge)))
			{	int tr;
				for (tr=0; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active)
				{	if (cInfos[tr].CenterStation == Station)
						break;
					if (Station->TInfo[tr].visible
					&& !IsStationVisible(&cInfos[tr], Station))
					{	LostVisible[tr]++;
#ifdef DEBUG_CIRCLE_PAINT
TraceLogThread("LostVisible", FALSE, "[%ld] Lost Visible(%s)\n", tr, Station->Station);
#endif
						Station->TInfo[tr].visible = FALSE;	/* We KNOW it's not */
					}
#ifdef DEBUG_CIRCLE_PAINT
					else TraceLogThread("LostVisible", FALSE, "[%ld] Still %sVisible(%s)\n", tr, Station->TInfo[tr].visible?"":"IN", Station->Station);
#endif
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]PurgeCloseStations(%s) %s %sVisible\n", (int) tr, Station->isKilled?"KILLED":"Old", Station->Station, Station->TInfo[tr].visible?"":"NOT ");
				}
				if (tr<MAX_TRACKERS)
				{
#ifdef DEBUG_CIRCLE_PAINT
					TraceLog("isCenter", TRUE, hwnd, "NOT Purging Station(%s)(%s) Centered[%ld]\n",
							Station->Station, Station->Owner, tr);
#endif
					continue;	/* NEVER purge a center track */
				}

#ifdef DEBUG_EXPIRES
				if (Station->isNWS)
				{	SYSTEMTIME stRcvd = Station->st;
					TraceLogThread("NWS-Debug", TRUE, "%s(%s) KILLING(%ld vs %ld) Rcvd:%02ld %02ld:%02ld (local) Expires:%02ld %02ld:%02ld%c %S\n",
								Station->Station, Station->Owner,
								(long) MSecSince(Station->lastMsec, Now)/1000,
								(long) (Station->isBuddy?BuddyMaxAge:MaxAge),
								(long) stRcvd.wDay,
								(long) stRcvd.wHour,
								(long) stRcvd.wMinute,
								(long) Station->Time.day, 
								(long) Station->Time.hour, 
								(long) Station->Time.minute, 
								Station->Time.type,
								Station->Comment);
				}
#endif
				FreeTracks(Station, TRUE);
				DeReferencePacketPath(Station);
				DeReferenceCoord(Station->isObject&&Station->isKilled?"KilledObject":"PurgeStations", Station->Station, Station->pCoord);
				if (Station->MultiLine)
				{	MULTILINE_INFO_S *ml = Station->MultiLine;
					if (ml->Points) free(ml->Points);
					if (ml->tCoords) free(ml->tCoords);
					if (ml->SegEnds) free(ml->SegEnds);
					if (ml->SourceString) free(ml->SourceString);
					for (int tr=0; tr<MAX_TRACKERS; tr++)
					{	if (ml->Tracker[tr].ptEnds)
							free(ml->Tracker[tr].ptEnds);
						if (ml->Tracker[tr].pts)
							free(ml->Tracker[tr].pts);
#ifdef SUPPORT_RECTANGLE_FILL
						if (ml->Tracker[tr].rcBounds)
							free(ml->Tracker[tr].rcBounds);
#endif
					}
					free(ml);
				}
/*	If more memory pieces are added, visit GetCloseStationStats() as well */
				if (Station->Weather) free(Station->Weather);
				if (Station->Nickname) free(Station->Nickname);
				if (Station->Frequency) free(Station->Frequency);
				if (Station->Storm) free(Station->Storm);
				if (Station->pBRGNRQ) free(Station->pBRGNRQ);
				if (Station->pPHG) free(Station->pPHG);
				if (Station->pNWSTimes) free(Station->pNWSTimes);
				if (Station->pPath) free(Station->pPath);
				if (Station->pRFpath) free(Station->pRFpath);
				if (Station->pLastPacket) free(Station->pLastPacket);
				if (Station->pLastPositPacket) free(Station->pLastPositPacket);
				if (Station->pCapabilities) free(Station->pCapabilities);
				if (Station->pComment) free(Station->pComment);
				if (Station->pStatusReport) free(Station->pStatusReport);
				if (Station->pPlatform) free(Station->pPlatform);
				pCloseStations[--CloseStationCount]->Index = s;	/* TEMPORARY */
				pCloseStations[s--] = pCloseStations[CloseStationCount];
				free(Station);	/* All gone! */
				Updated = TRUE;
				FreeCount++;
#ifdef TRACK_FIND_STATIONS
				OldStations[0]++;
#endif
				CloseStationSort = 0;
			} else if (PurgeTracks(Station, Now))
				Updated = TRUE;
		}

		if (Updated)
		{	CloseStationSort = 0;	/* Nothing is in order any more */
			if (!SortCloseStations())	/* So try to put it back in order */
				FixStationsCloseIndices();	/* We scavenged these! */
		}
		if (Updated)
		{	for (int tr=0; tr<MAX_TRACKERS; tr++)
			if (cInfos[tr].Active)
			{	if (LostVisible[tr])
				{	cInfos[tr].Circle.StationsValid = FALSE;
					cInfos[tr].Circle.InvalidReason = "PurgeCloseStations";
					InvalidateCircle(hwndTracker[tr], FALSE, TRUE, 5000);
#ifdef DEBUG_CIRCLE_PAINT
TraceLogThread("LostVisible", FALSE, "[%ld] Invalidating Circle for %ld Stations\n", tr, (long) LostVisible[tr]);
#endif
				}
			}
		}
		free(LostVisible);
	}
	if (FreeCount)
	{	char FreeBuff[80];
		sprintf(FreeBuff, "Freed %ld", (long) FreeCount);
		PurgeFreeCoords("PurgeStations",FreeBuff);
//TraceLogThread("Config", FALSE, "PurgeCloseStations:Purged %ld Stations\n", FreeCount);
	}
	return Updated;
}

static char *GetCloseStationStats(void)
{
	unsigned long Pths = 0, PthCount = 0;
	unsigned long PthMem = 0;
	unsigned long Trks = 0, TrkCount = 0;
	unsigned long TrkMem = 0;
	unsigned long MLs = 0;
	unsigned long MLMem = 0, MLpMem=0, MLcMem=0, MLsMem=0, MLtMem=0;
	unsigned long Storms = 0;
	unsigned long StormMem = 0;
	unsigned long Wthrs = 0;
	unsigned long WthrMem = 0;
	unsigned long BRGs = 0;
	unsigned long BRGMem = 0;
	unsigned long PHGs = 0;
	unsigned long PHGMem = 0;
	unsigned long Nicks = 0;
	unsigned long NickMem = 0;
	unsigned long Freqs = 0;
	unsigned long FreqMem = 0;
	unsigned long NWSTimes = 0;
	unsigned long NWSTimeMem = 0;
	unsigned long PktTimes = 0;
	unsigned long PktTimeMem = 0;
	unsigned long StringMem = 0;
	unsigned long StationMem = 0;

	for (unsigned long s=0; s<CloseStationCount; s++)
	{	STATION_INFO_S *Station = pCloseStations[s];

		if (Station->Time.day
		|| Station->Time.hour
		|| Station->Time.minute)
		{	PktTimes++;
			PktTimeMem += sizeof(Station->Time);
		}

		if (Station->Nickname)
		{	Nicks++;
			NickMem += sizeof(*Station->Nickname);
		}

#ifndef NO_PATH_TRACKING
		if (Station->PathSize)
		{	Pths++;
			PthCount += Station->PathSize;
			PthMem += sizeof(*Station->Paths)*Station->PathSize;
		}
#endif
		if (Station->TrackSize)
		{	Trks++;
			TrkCount += Station->TrackSize;
			TrkMem += sizeof(*Station->Tracks)*Station->TrackSize;
		}
		if (Station->MultiLine)
		{	MULTILINE_INFO_S *ml = Station->MultiLine;
			MLs++;
			MLpMem += sizeof(*ml->Points)*ml->Count;
			MLcMem += sizeof(*ml->tCoords)*ml->Count;
			MLsMem += sizeof(*ml->SegEnds)*ml->Segments;
			for (int tr=0; tr<MAX_TRACKERS; tr++)
			{	if (ml->Tracker[tr].ptEnds)
					MLtMem += sizeof(*ml->Tracker[tr].ptEnds)*ml->Segments;
				if (ml->Tracker[tr].pts)
					MLtMem += sizeof(*ml->Tracker[tr].pts)*ml->Count;
#ifdef SUPPORT_RECTANGLE_FILL
				if (ml->Tracker[tr].rcBounds)
					MLtMem += sizeof(*ml->Tracker[tr].rcBounds)*ml->Segments;
#endif
			}
			MLMem += sizeof(*ml);
		}
		if (Station->Weather)
		{	Wthrs++;
			WthrMem += sizeof(*Station->Weather);
		}
		if (Station->Storm)
		{	Storms++;
			StormMem += sizeof(*Station->Storm);
		}
		if (Station->Frequency)
		{	Freqs++;
			FreqMem += sizeof(*Station->Frequency);
		}
		if (Station->pBRGNRQ)
		{	BRGs++;
			BRGMem += sizeof(*Station->pBRGNRQ);
		}
		if (Station->pPHG)
		{	PHGs++;
			PHGMem += sizeof(*Station->pPHG);
		}
		if (Station->pNWSTimes)
		{	NWSTimes++;
			NWSTimeMem += sizeof(*Station->pNWSTimes);
			if (!Station->Time.day && !Station->Time.hour && !Station->Time.minute)
			{	TraceLogThread("HUH", TRUE, "NWS:%s Has zero %02d-%02d %02d:%02d:%02d\n",
								Station->Station,
								Station->Time.month,
								Station->Time.day,
								Station->Time.hour,
								Station->Time.minute,
								Station->Time.second);
				ShowTraceLog("HUH");
			}
		}
		StringMem += Station->sCapabilities*sizeof(TCHAR);
		StringMem += Station->sComment*sizeof(TCHAR);
		StringMem += Station->sStatusReport*sizeof(TCHAR);
		StringMem += Station->sPath;
		StringMem += Station->sRFpath;
		StringMem += Station->sLastPacket;
		StringMem += Station->sLastPositPacket;
		if (Station->pPlatform) StringMem += strlen(Station->pPlatform)+1;
		StationMem += sizeof(*Station);
	}

	size_t Remainder = 1024;
	char *Output = (char*)malloc(Remainder);
	char *Next = Output;

	MLMem += MLpMem+MLcMem+MLsMem+MLtMem;	/* Count it all as ML */

	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
					"Station Memory: %lu",
					StationMem + StringMem + PthMem + TrkMem + MLMem + WthrMem + PHGMem + FreqMem + PacketPathCount*sizeof(PACKET_PATH_S));
	if (StationMem || StringMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nStations: %ld in %lu +%lu Strs\n(%lu/Fixed +%lu/Strs)", CloseStationCount, StationMem, StringMem, StationMem/CloseStationCount, StringMem/CloseStationCount);
	}
#ifndef NO_PATH_TRACKING
	if (PacketPathCount)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nPktPaths: %ld in %lu (%ldea)",
						PacketPathCount, PacketPathCount*sizeof(PACKET_PATH_S), sizeof(PACKET_PATH_S));
	}
	if (Pths || PthMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nPaths: %ld/%ld in %lu (%ldea)", Pths, PthCount, PthMem, PthCount?PthMem/PthCount:0);
	}
#endif
	if (Trks || TrkMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nTracks: %ld/%ld in %lu (%ldea)", Trks, TrkCount, TrkMem, TrkCount?TrkMem/TrkCount:0);
	}
#ifdef MONITOR_PHONE
	if (CellularSize)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nCellular: %ld/%ld in %lu (%ldea)", CellularCount, CellularSize, CellularSize*sizeof(*Cellulars), sizeof(*Cellulars));
	}
#endif

	if (MLs || MLMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
			"\nMultiLines: %ld in %lu\n(p:%lu c:%lu s:%lu t:%lu)",
			MLs, MLMem, MLpMem, MLcMem, MLsMem, MLtMem);
	}
	if (NWSTimes || NWSTimeMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nNWSTimes: %ld in %lu (%ldea)", NWSTimes, NWSTimeMem, NWSTimes?NWSTimeMem/NWSTimes:0);
	}
	if (Storms || StormMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nStorm: %ld in %lu (%ldea)", Storms, StormMem, Storms?StormMem/Storms:0);
	}
	if (Wthrs || WthrMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nWeather: %ld in %lu (%ldea)", Wthrs, WthrMem, Wthrs?WthrMem/Wthrs:0);
	}
	if (Freqs || FreqMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nFreqs: %ld in %lu (%ldea)", Freqs, FreqMem, Freqs?FreqMem/Freqs:0);
	}
	if (Nicks || NickMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nNicks: %ld in %lu (%ldea)", Nicks, NickMem, Nicks?NickMem/Nicks:0);
	}
	if (PktTimes || PktTimeMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nPktTimes: %ld in %lu (%ldea)", PktTimes, PktTimeMem, PktTimes?PktTimeMem/PktTimes:0);
	}
	if (BRGs || BRGMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nBRGs: %ld in %lu (%ldea)", PHGs, PHGMem, PHGs?PHGMem/PHGs:0);
	}
	if (PHGs || PHGMem)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nPHGs: %ld in %lu (%ldea)", PHGs, PHGMem, PHGs?PHGMem/PHGs:0);
	}
	if (SeenStationSize)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nSeenStations: %ld/%ld in %lu (%ldea)", (long) SeenStationCount, (long) SeenStationSize, (long) (SeenStationSize*sizeof(*SeenStations)), sizeof(*SeenStations));
	}
	if (FriendSize)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nFriends: %ld/%ld in %lu (%ldea)", (long) FriendCount, (long) FriendSize, (long) (FriendSize*sizeof(*Friends)), sizeof(*Friends));
	}
	if (CoordSize)
	{	unsigned long FreeCount = 0, UsageCount = 0;
		unsigned long f;
		for (f=0; f<CoordCount; f++)
			if (!SortedCoords[f]->References)
				FreeCount++;
			else UsageCount += SortedCoords[f]->References;
		StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
						"\nCoords: %ld/%ld (%lu Free) in %lu (%ldea)\n(Hits:%lu/%lu Purge:%lu Ref:%lu)",
						(long) CoordCount, (long) CoordSize, (long) FreeCount, 
						(long) (CoordSize*sizeof(**SortedCoords)), sizeof(**SortedCoords),
						(long) CoordFinds, (long) CoordSearches, (long) CoordPurges, (long) UsageCount);
	}
	return Output;
}

static char *GetDupeStats(void)
{	long MaxPkt = 0;
	unsigned long PktUse = 0;
	unsigned long PktMemSize = 0;
	unsigned long PktMemUse = 0;
	unsigned long DupeMem = sizeof(*Dupes)*DupeSize;
	__int64 msOldest = 0;

	for (long dp=0; dp<DupeSize; dp++)
	{	if (Dupes[dp].PacketSize)
		{	PktMemSize += Dupes[dp].PacketSize;
			PktMemUse += Dupes[dp].PacketUse;
			PktUse++;
			if (Dupes[dp].PacketSize > MaxPkt)
				MaxPkt = Dupes[dp].PacketSize;
		}
		if (!msOldest
		|| (Dupes[dp].lastMsec
				&& Dupes[dp].lastMsec < msOldest))
			msOldest = Dupes[dp].lastMsec;
	}

	size_t Remainder = 1024;
	char *Output = (char*)malloc(Remainder);
	char *Next = Output;

	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
		"Dupes: %ld/%ld/%ld in %lu +%lu Pkts",
					(long) DupeInUse, (long) DupeUseMax, (long) DupeSize,
					DupeMem, PktMemSize);
	if (MaxPkt && PktUse)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
					"\nPktLen: Avg: %ld/%ld Max: %ld",
					(long) PktMemUse / PktUse,
					(long) PktMemSize / PktUse,
					(long) MaxPkt);
	}
	if (msOldest)
	{	__int64 msNow = llGetMsec();
		StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
					"\nOldest: %ld sec (Check: %ld)",
					 (long) llMsecSince(msOldest,msNow)/1000,
					 (long) DUPLICATE_DETECT_SECONDS);
	}
	if (DupeUseCount)
	{	StringCbPrintfExA(Next, Remainder, &Next, &Remainder, STRSAFE_IGNORE_NULLS,
					"\nPkts Seen: %lu",
					(unsigned long) DupeUseCount);
	}
	return Output;
}

static BOOL UpdateStationPosition(HWND hwnd, STATION_INFO_S *Station, double lat, double lon, double alt, BOOL altValid, char *IGate, SYSTEMTIME *stWhen, BOOL Internal, __int64 msNow, char *pkt=NULL)
{static char Routine[] = "UpdateStationPosition";
	BOOL Moved = FALSE;
	BOOL ThisOK = TRUE;
	BOOL Duplicate = FALSE;
	double speed = 0;
	double dlat = fabs(Station->Last.lat-lat);
	double dlon = fabs(Station->Last.lon-lon);

#ifdef OBSOLETE
	if (Station->isBuddy)
	{	TCHAR *LatLon = APRSLatLon(lat, lon, ' ', ' ', 2);
		TraceLog("Buddies", FALSE, hwnd, "%s:%s %S via %s (Moved %.4lf %.4lf)\n",Routine,
					Station->Station, LatLon, IGate, (double) dlat, (double) dlon);
		free(LatLon);
	}
#endif

	if (!altValid) alt = 0.0;	/* Just in case */
	else if (!dlat && !dlon && Station->alt != alt)	/* Have a valid altitude, Maybe adopt if not moved */
	{	if (Station->alt)
		{	//Moved = TRUE;	/* Force this one to be adopted as we moved in altitude */
			TraceLogThread("Altitude", FALSE, "%s(%s) NOT Moving Altitude from %ld to %ld feet\n", Station->Station, Station->pPlatform, (long)(Station->alt*FeetPerMeter), (long)(alt*FeetPerMeter));
		} else
		{	BOOL CriticalLog = (Station->alt!=0);
			TraceLogThread("Altitude", CriticalLog, "%s(%s) Changing Altitude from %ld to %ld feet\n", Station->Station, Station->pPlatform, (long)(Station->alt*FeetPerMeter), (long)(alt*FeetPerMeter));
			Station->alt = alt;	/* Remember this one */
			Station->hadAltitude = TRUE;
			if (Station->TrackCount)
			{	int t = Station->TrackCount-1;	/* Index of last track */
				if (Station->Tracks[t].pCoord->lat == lat
				&& Station->Tracks[t].pCoord->lon == lon
				&& Station->Tracks[t].alt == 0
				&& Station->Tracks[t].Invalid == TRACK_OK)
				{	Station->Tracks[t].alt = (long) (alt*FeetPerMeter);
					TraceLogThread("Altitude", CriticalLog, "%s(%s) Setting Track[%ld] Alt to %ld feet\n", Station->Station, Station->pPlatform, t, Station->Tracks[t].alt);
				} else if (Station->Tracks[t].alt != (long)(alt*FeetPerMeter))
				{	if (Station->Tracks[t].alt) CriticalLog = TRUE;
					TraceLogThread("Altitude", CriticalLog, "%s(%s) Track[%ld] %s%sAlt:%ld vs %ld %s%s%.5lf vs %.5lf or %s%.5lf vs %.5lf\n",
										Station->Station, Station->pPlatform, t,
										Station->Tracks[t].Invalid == TRACK_OK?"":"INVALID ",
										Station->Tracks[t].alt?"ALTITUDE ":"",
										Station->Tracks[t].alt, (long)(alt*FeetPerMeter), 
										Station->Tracks[t].pCoord->lat==lat&&Station->Tracks[t].pCoord->lon==lon?"":"COORD ",
										Station->Tracks[t].pCoord->lat==lat?"":"LAT:",
										Station->Tracks[t].pCoord->lat, lat,
										Station->Tracks[t].pCoord->lon==lon?"":"LON:",
										Station->Tracks[t].pCoord->lon, lon);
				}
			}
		}
	}

	if (dlat || dlon || Moved)	/* not where I was, moved somehow */
	{	Moved = TRUE;

		if (!strcmp(MyDestination.Owner, Station->Owner)
		&& !strcmp(MyDestination.Station, Station->Station))
		{	MyDestination.lat = lat;
			MyDestination.lon = lon;
			InvalidateDestination(TRUE);	/* Get the update on-screen */
		}

		if (Station->Last.lat!=0 || Station->Last.lon!=0)		/* And I WAS somewhere */
		{	int t = Station->TrackCount++;
			if (Station->TrackCount >= Station->TrackSize)
			{	Station->TrackSize += 32;	/* Code below assumes this is at least 2 or 4 */
				Station->Tracks = (TRACK_INFO_S *) realloc(Station->Tracks, sizeof(*Station->Tracks)*Station->TrackSize);
				InvalidateStatUsage(FALSE);
			}

			if (!t)	/* First one gets current location */
			{
#ifdef TRACE_TRACKS
				TraceActivity(hwnd,"[%ld][%ld] lat %lf != %lf or lon %lf != %lf\n",
							(long) s, (long) t,
							(double) Station->lat, (double) lat,
							(double) Station->lon, (double) lon);
#endif
				SetupStationTrackColor(Station);
				Station->Tracks[t].pCoord = Station->pCoord;
				Station->Tracks[t].pCoord->References++;
				Station->Tracks[t].alt = (long) (Station->alt*FeetPerMeter);
				Station->Tracks[t].msec = msNow;
				if (Station->stPos.wYear)
					Station->Tracks[t].st = Station->stPos;
				else Station->Tracks[t].st = *stWhen;
				Station->Tracks[t].Invalid = TRACK_OK;
#ifndef UNDER_CE
				strncpy(Station->Tracks[t].IGate, IGate, sizeof(Station->Tracks[t].IGate));
#endif
				t = Station->TrackCount++;	/* Move on to the next point */

			}
#ifdef TRACE_TRACKS
			TraceActivity(hwnd,"[%ld][%ld] lat %lf != %lf or lon %lf != %lf\n",
						(long) s, (long) t,
						(double) Station->lat, (double) lat,
						(double) Station->lon, (double) lon);
#endif
			Station->Tracks[t].pCoord = GetCoordIndex(lat, lon, "StationTrackOK", Station->Station, NULL);
			Station->Tracks[t].alt = (long) (alt*FeetPerMeter);
			Station->Tracks[t].msec = msNow;
			Station->Tracks[t].st = *stWhen;
			Station->Tracks[t].Invalid = TRACK_OK;
#ifndef UNDER_CE
			strncpy(Station->Tracks[t].IGate, IGate, sizeof(Station->Tracks[t].IGate));
#endif

			if (!Internal	/* Internal's don't dupe check */
			&& !Station->isMyObject	/* My objects aren't checked */
			&& (dlat > 0.02/60.0 || dlon > 0.02/60.0))	/* Only a duplicate if we moved more than a wiggle */
			{	int o;
				BOOL Adjacent = FALSE;
				for (o=t-1; o>0; o--)	/* 10 minute lookback may jump out sooner */
				{	if (Station->Tracks[t].msec-Station->Tracks[o].msec > 10*60*1000.0) break;
					if (Station->Tracks[o].pCoord == Station->Tracks[t].pCoord
					&& Station->Tracks[o].alt == Station->Tracks[t].alt)
					{
						if (o == t-1)
						{	Adjacent = TRUE;
#ifndef UNDER_CE
{
TraceLog("Invalids", FALSE, hwnd, "%s ADJACENT Non-Duplicate in %.2lfsec [%ld] %s vs [%ld] %s at %.5lf %.5lf %.2lf (Last Move %s)\n",
		   Station->Station,
			(Station->Tracks[t].msec-Station->Tracks[o].msec) / 1000.0,
		   (long) t,
		   Station->Tracks[t].IGate,
		   (long) o,
		   Station->Tracks[o].IGate,
		   (double) Station->Tracks[t].pCoord->lat,
		   (double) Station->Tracks[t].pCoord->lon,
		   (double) Station->Tracks[t].alt,
		   Station->Tracks[t-1].Invalid?"Was INVALID!":"");
}
#endif
//							break;	/* Two consecutive reports needs to be considered */
						} else
						{
							Duplicate = TRUE;
							Station->Tracks[t].Invalid = TRACK_DUP;
							Station->TrackDupes++;
#ifndef UNDER_CE
{double distance, bearing;
AprsHaversineLatLon(Station->Tracks[t].pCoord->lat, Station->Tracks[t].pCoord->lon,
					Station->Tracks[t-1].pCoord->lat, Station->Tracks[t-1].pCoord->lon,
					&distance, &bearing);

TraceLog("Invalids", FALSE, hwnd, "%s Duplicate in %.2lfsec [%ld] %s vs [%ld] %s at %.5lf %.5lf %.2lf (Last Move %.3lfmi @ %ld %s) %s\n",
		   Station->Station,
			(Station->Tracks[t].msec-Station->Tracks[o].msec) / 1000.0,
		   (long) t,
		   Station->Tracks[t].IGate,
		   (long) o,
		   Station->Tracks[o].IGate,
		   (double) Station->Tracks[t].pCoord->lat,
		   (double) Station->Tracks[t].pCoord->lon,
		   (double) Station->Tracks[t].alt,
		   (double) distance, (long) bearing,
		   Station->Tracks[t-1].Invalid?"Was INVALID!":"",
		   Adjacent?"ADJACENT":"");
}
#endif
							break;
						}
					}
				}
			}

			if (!Duplicate && !Station->isMyObject)
			{	double distance, bearing;
				__int64 msDelta = msNow - Station->Last.msec;

				AprsHaversineLatLon(Station->Last.lat, Station->Last.lon,
									lat, lon, &distance, &bearing);

				if (Station->Last.lat == 0 && Station->Last.lon == 0) speed = 0;
				else if (msDelta) speed = distance / (msDelta/1000.0/60.0/60.0);
				else speed = 500 + 1;	/* Trip this one out */

				if (msDelta < 10000)	/* Ignore anything less than 10 second */
				{
#ifndef UNDER_CE
					TraceLog("Invalids", FALSE, hwnd, "%s Moved TOO SOON %.3lfmi @ %ld in %.4lf sec or %.2lfmph (last %.2lf Avg %.2lf) from %.5lf %.5lf to %.5lf %.5lf  IGNORED!\n",
						   Station->Station,
						   (double) distance, (long) bearing,
						   (double) msDelta/1000.0, (double) speed,
						   (double) Station->Last.speed,
						   (double) Station->speedAverage,
						   (double) Station->Last.lat,
						   (double) Station->Last.lon,
						   (double) lat, (double) lon);
#endif
					Station->Tracks[t].Invalid = TRACK_QUICK;
					Station->TrackInvalids++;
					ThisOK = FALSE;
				} else if (distance > 0.1	/* Little wiggle can be FAST */
				&& speed > 500)	/* Arbitrary upper "normal" speed limit */
				{
					if (speed > 20000	/* I don't care, NOTHING moves THAT fast!  (Satellites do about 15,000) */
					|| speed > Station->speedAverage * 2)	/* And MUCH more than before */
					{
#ifndef UNDER_CE
						TraceLog("Invalids", FALSE, hwnd, "%s Moved TOO FAST %.3lfmi @ %ld in %.2lf sec or %.2lfmph (last %.2lf Avg %.2lf) from %.5lf %.5lf to %.5lf %.5lf\n",
								   Station->Station,
								   (double) distance, (long) bearing,
								   (double) msDelta/1000.0, (double) speed,
								   (double) Station->Last.speed,
								   (double) Station->speedAverage,
								   (double) Station->Last.lat,
								   (double) Station->Last.lon,
								   (double) lat, (double) lon);
						//if (distance>1000)
						{	if (Station->sLastPositPacket && Station->pLastPositPacket)
								TraceLog("Invalids", FALSE, hwnd, "Frm:%.*s\n", Station->sLastPositPacket, Station->pLastPositPacket);
							if (pkt) TraceLog("Invalids", FALSE, hwnd, "New:%s\n", pkt);
						}
#endif
						Station->Tracks[t].Invalid = TRACK_FAST;	/* Default this one bad */
						Station->TrackInvalids++;
						ThisOK = FALSE;

						if (Station->Bad.msec	/* If we have a previously bad one, see if this is ok by that */
						&& msNow > Station->Bad.msec+1000)	/* And long enough ago to calculate */
						{	msDelta = msNow - Station->Bad.msec;
							AprsHaversineLatLon(Station->Bad.lat, Station->Bad.lon,
												lat, lon, &distance, &bearing);
							speed = distance / (msDelta/1000.0/60.0/60.0);
							if (distance < 0.1 || speed < 500)	/* This looks good! */
							{
#ifndef UNDER_CE
								TraceLog("Invalids", TRUE, hwnd, "%s BAD Move(%ld) MADE GOOD %.3lfmi @ %ld in %.2lf sec or %.2lfmph (last %.2lf Avg %.2lf) from %.5lf %.5lf to %.5lf %.5lf\n",
										   Station->Station, (long) Station->TrackCount,
										   (double) distance, (long) bearing,
										   (double) msDelta/1000.0, (double) speed,
										   (double) Station->Bad.speed,
										   (double) Station->speedAverage,
										   (double) Station->Bad.lat,
										   (double) Station->Bad.lon,
										   (double) lat, (double) lon);
#endif

								FreeTracks(Station, FALSE);

								t = 3;
								Station->TrackCount = 4;
								if (Station->TrackCount >= Station->TrackSize)
								{	Station->TrackSize += 32;	/* This code assumes this is at least 2 or 4 */
									Station->Tracks = (TRACK_INFO_S *) realloc(Station->Tracks, sizeof(*Station->Tracks)*Station->TrackSize);
									InvalidateStatUsage(FALSE);
								}

								Station->Tracks[0].pCoord = GetCoordIndex(Station->Bad.lat, Station->Bad.lon, "StationTrack0", Station->Station, NULL);
								Station->Tracks[0].alt = (long) (alt*FeetPerMeter);
								Station->Tracks[0].msec = Station->Bad.msec;
								Station->Tracks[0].st = *stWhen;
								Station->Tracks[0].Invalid = TRACK_RESTART;
#ifndef UNDER_CE
								strncpy(Station->Tracks[0].IGate, IGate, sizeof(Station->Tracks[0].IGate));
#endif

								Station->Tracks[1].pCoord = GetCoordIndex(lat, lon, "StationTrackOK", Station->Station, NULL);
								Station->Tracks[1].alt = (long) (alt*FeetPerMeter);
								Station->Tracks[1].msec = msNow;
								Station->Tracks[1].st = *stWhen;
								Station->Tracks[1].Invalid = TRACK_RESTART;
#ifndef UNDER_CE
								strncpy(Station->Tracks[1].IGate, IGate, sizeof(Station->Tracks[1].IGate));
#endif
								Station->TrackInvalids = 2;
								Station->TrackDupes = 0;
								Station->Tracks[2] = Station->Tracks[0];
								Station->Tracks[3] = Station->Tracks[1];
								Station->Tracks[2].Invalid = TRACK_OK;
								Station->Tracks[3].Invalid = TRACK_OK;
								Station->Tracks[2].pCoord = GetCoordIndex(Station->Bad.lat, Station->Bad.lon, "StationTrack0", Station->Station, NULL);
								Station->Tracks[3].pCoord = GetCoordIndex(lat, lon, "StationTrackOK", Station->Station, NULL);
								Station->speedAverage = 0;
								ThisOK = TRUE;
							}
						}
					} else
					{
#ifndef UNDER_CE
#ifdef TRACK_BEARING
						Station->Tracks[t].bearing = bearing;
#endif
						TraceLog("Invalids", FALSE, hwnd, "%s Moved %.3lfmi @ %ld in %.2lf sec or %.2lfmph (last %.2lf Avg %.2lf) from %.5lf %.5lf to %.5lf %.5lf\n",
								   Station->Station,
								   (double) distance, (long) bearing,
								   (double) msDelta/1000.0, (double) speed,
								   (double) Station->Last.speed,
								   (double) Station->speedAverage,
								   (double) Station->Last.lat,
								   (double) Station->Last.lon,
								   (double) lat, (double) lon);
#endif
					}
				}
				if (speed > 20000) speed = 20000;	/* Cap the speed we're accumulating (Satellites are about 15,000) */
				Station->speedAverage -= Station->speedAverage / 4;
				Station->speedAverage += speed / 4;
				Station->speedCalculated = speed;
				Station->courseCalculated = bearing;

#ifdef TRACK_SPEED
				if (Station->CSEParsed)
					Station->Tracks[t].speed = Station->speed;
				else Station->Tracks[t].speed = Station->speedAverage;
#endif

				if (Station->isBuddy)
				{	TraceLog("Buddies", FALSE, hwnd, "%s:%s speed:%ld avg:%ld bearing:%ld %S\n", Routine,
								Station->Station, (long) Station->speedCalculated, (long) Station->speedAverage, (long) (Station->courseCalculated+0.5), GetCompassPoint((long)(Station->courseCalculated+0.5)));

					if (Station->CSEParsed)
						TraceLog("Buddies", FALSE, hwnd, "%s:%s Beacon Spd: %ld Cse:%ld %S", Routine,
						Station->Station, (long) Station->speed, Station->course, GetCompassPoint(Station->course));

				}
			}
			else if (Station->isBuddy)
			{	TraceLog("Buddies", FALSE, hwnd, "%s:%s Duplicate!\n", Routine,
							Station->Station);
			}
		}
		if (Station==MyStation || Internal) ThisOK = TRUE;
		if (!Duplicate && ThisOK)	/* Always remember me */
		{	Station->Last.lat = lat;	/* Remember where I was */
			Station->Last.lon = lon;
			Station->Last.msec = msNow;
			Station->Last.speed = speed;
			Station->Bad.msec = 0;	/* We don't have BAD any more */
		}
	}	/* Didn't move */
	else
	{
		// Station->speedAverage -= Station->speedAverage / 4;	/* reduce the average speed */
		// Station->speedAverage += speed / 4;	/* Unnecessary */
		// Station->speedCalculated = 0;
		// Station->courseCalculated = 0;

		if (Station->isBuddy)
		{	TraceLog("Buddies", FALSE, hwnd, "%s:%s Didn't Move!\n", Routine,
						Station->Station);
			TraceLog("Buddies", FALSE, hwnd, "%s:%s speed:%ld avg:%ld bearing:%ld %S\n", Routine,
						Station->Station, (long) Station->speedCalculated,
						(long) Station->speedAverage, (long) (Station->courseCalculated+0.5),
						GetCompassPoint((long)(Station->courseCalculated+0.5)));
			if (Station->CSEParsed)
				TraceLog("Buddies", FALSE, hwnd, "%s:%s Beacon Spd: %ld Cse:%ld %S", Routine,
						Station->Station, (long) Station->speed,
						Station->course, GetCompassPoint(Station->course));
		}
	}

	if (!ThisOK)
	{	Station->Bad.lat = lat;
		Station->Bad.lon = lon;
		Station->Bad.msec = msNow;
		Station->Bad.speed = speed;
	} else if (!Duplicate)
	{	Station->stPos = *stWhen;
		if (Station->pCoord->lat != lat || Station->pCoord->lon != lon)	/* Moved? */
		{	Station->pCoord = GetCoordIndex(lat, lon, "StationPos", Station->Station, Station->pCoord);
//			Station->lat = lat;
//			Station->lon = lon;
//			Station->tileX = long2tilex(Station->lon, MAX_OSM_ZOOM);
//			Station->tileY = lat2tiley(Station->lat, MAX_OSM_ZOOM);
//			Station->tileZ = MAX_OSM_ZOOM;
		}
		if (Station->isFriend) SetFriendCoordinates(Station->Station, lat, lon);
		Station->alt = alt;	/* Remember current altitude if we have a position */
		if (altValid) Station->hadAltitude = TRUE;	/* We had one */
		if (Moved)
		{	for (int tr=0; tr<MAX_TRACKERS; tr++)
			if (cInfos[tr].Active)
			{	if (cInfos[tr].CenterTracking
				&& cInfos[tr].CenterStation == Station)
				if (cInfos[tr].Dragging
				|| cInfos[tr].msDragComplete > msNow-5000)	/* 5 second drag freeze */
				{	;	/* Need a timer or something? */
				} else
				{	cInfos[tr].LastCenterPosition.dblLatitude = lat;
					cInfos[tr].LastCenterPosition.dblLongitude = lon;
					cInfos[tr].LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
					InvalidateStationPoints(tr, "UpdateStationPosition", TRUE);
					InvalidateCenter(hwndTracker[tr], TRUE);
					cInfos[tr].msLastSigChange = msNow;
				}
			}
			if (Station->AutoSaveGPX	/* Automatically saving updates? */
			/*|| (Station == MyStation && ActiveConfig.Enables.AutoSaveGPX)*/)
				SaveTrackToGPX(hwnd, Station);	/* Overwrites based on starting timestamp */
		}
	}
	return Moved && ThisOK;
}

typedef struct BUDDY_S
{	BOOL isWild;
	int CallLen;
	char Call[STATION_SIZE];
} BUDDY_S;
static BUDDY_S *Buddies = NULL;
static unsigned long BuddyCount = 0;
static unsigned long BuddySize = 0;
static char *LastFilter = NULL;

static void AddBuddy(char *Call)
{	unsigned long b = BuddyCount++;
	if (b >= BuddySize)
	{	BuddySize += 8;
		if (b >= BuddySize) BuddySize = b+1;
		Buddies = (BUDDY_S *)realloc(Buddies,sizeof(*Buddies)*BuddySize);
	}
	strncpy(Buddies[b].Call, Call, sizeof(Buddies[b].Call));
	Buddies[b].CallLen = sizeof(Buddies[b].Call);
	if (Buddies[b].Call[sizeof(Buddies[b].Call)-1])
	{	TraceLog("Buddies", TRUE, NULL, "BuddyCall(%s) Too Long, Truncating and calling Wild!\n",
					Call);
		Buddies[b].Call[--Buddies[b].CallLen] = '\0';
		Buddies[b].isWild = TRUE;
	} else
	{	Buddies[b].CallLen = strlen(Buddies[b].Call);
		if ((Buddies[b].isWild=Buddies[b].Call[Buddies[b].CallLen-1] == '*'))
			Buddies[b].Call[--Buddies[b].CallLen] = '\0';
	}
	TraceLog("Buddies", TRUE, NULL, "Buddy(%.*s%s)\n", (int) Buddies[b].CallLen, Buddies[b].Call, Buddies[b].isWild?"*":"");
}

static BOOL IsBuddyStation(char *Station)
{	unsigned long b;

	for (b=0; b<BuddyCount; b++)
	{	if (Buddies[b].isWild)
		{	if (!_strnicmp(Buddies[b].Call, Station, Buddies[b].CallLen)
			&& (Station[Buddies[b].CallLen] == '-'	/* Only base call */
				|| Station[Buddies[b].CallLen] == '\0'))	/* or whole call */
				return TRUE;
		} else if (!_stricmp(Buddies[b].Call, Station))
			return TRUE;
	}
	return FALSE;
}

static void FreeSplitPieces(char **Array)
{
	if (Array) free(Array[0]);
}

static int SplitFilterPieces(char *Filter, int aSize, char **Array)
{	char *p;
	int aCount=0;

	if (!*Filter)	/* Empty string? */
	{	Array[0] = NULL;
		return 0;
	}
	Array[aCount++] = _strdup(Filter);
	for (p=Array[0]; *p; p++)
	{	if (*p == '/')	/* Filter delimiter */
		{	*p = '\0';	/* Null terminate previous piece */
			if (aCount < aSize)
			{	Array[aCount++] = p+1;
			} else
			{	TraceLog("Filter", TRUE, NULL, "SplitFilterPieces:Filter(%s) Has > %ld Pieces!\n", 
							Array[0], (long) aSize);
				break;
			}
		}
	}
	if (!*Array[aCount-1]) aCount--;
	return aCount;
}

static void ProcessFilterPiece(char *Piece)
{	int o, p, pCount;
	char *Pieces[16];

	if (!*Piece) return;	/* Empty pieces don't matter */
	o = *Piece=='-'?1:0;	/* o=1 for negative (NOT), 0 for positive */

	if (Piece[o+1] != '/')
	{	TraceLog("Filter", TRUE, NULL, "Filter Error:Piece(%s) missing / as second character\n", Piece);	
		return;	/* Not a b/ or f/, probably not a good filter piece! */
	}

	pCount = SplitFilterPieces(Piece+o+2, ARRAYSIZE(Pieces), Pieces);
	switch (Piece[o])
	{
	case 'b':	/* Budlist: b/call1/call2... (support *) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Buddy(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		else if (!o)	/* Only if not negated */
		for (p=0; p<pCount; p++)
		{	AddBuddy(Pieces[p]);
		}
		break;
	case 'f':	/* Friend: f/call/dist (up to 9) */
		if (pCount != 2) TraceLog("Filter", TRUE, NULL, "FilterError:Friend(%s) Has %ld Pieces, should be 2\n", Piece, (long) pCount);
		else if (!o)	/* Only if not negated */
			AddBuddy(Pieces[0]);
		break;
	case 'r':	/* Range: r/lat/lon/dist (up to 9) */
		if (pCount != 3) TraceLog("Filter", TRUE, NULL, "FilterError:Range(%s) Has %ld Pieces, should be 3\n", Piece, (long) pCount);
		break;
	case 'p':	/* Prefix: p/aa/bb/cc... (implied *?) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Prefix(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		break;
	case 'o':	/* Object: o/obj1/obj2... (supports *) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Object(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		break;
	case 't':	/* Type: t/poimqstunw or t/poimqstu/call/km (Might work for t/m/CALLSIGN/Range?) */
		if (pCount != 1 && pCount != 3)
			TraceLog("Filter", TRUE, NULL, "FilterError:Type(%s) Has %ld Pieces, should be 1 or 3\n", Piece, (long) pCount);
		break;
	case 's':	/* Symbol: s/pri/alt/over */
		if (pCount != 1 && pCount != 2 && pCount != 3)
			TraceLog("Filter", TRUE, NULL, "FilterError:Symbol(%s) Has %ld Pieces, should be 1, 2, or 3\n", Piece, (long) pCount);
		break;
	case 'd':	/* Digi: d/digi1/digi2... (supports *) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Digi(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		break;
	case 'a':	/* Area: a/latN/lonW/latS/lonE (up to 9) */
		if (pCount != 4) TraceLog("Filter", TRUE, NULL, "FilterError:Area(%s) Has %ld Pieces, should be 4\n", Piece, (long) pCount);
		break;
	case 'e':	/* Entry: e/call1/call2/... (supports *) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Entry(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		break;
	case 'u':	/* Unproto: u/unproto1/unproto2/... (supports *) */
		if (pCount < 1) TraceLog("Filter", TRUE, NULL, "FilterError:Unproto(%s) Has %ld Pieces, should be at least 1\n", Piece, (long) pCount);
		break;
	case 'q':	/* qConstruct: q/con/ana */
		if (pCount != 3) TraceLog("Filter", TRUE, NULL, "FilterError:qConstruct(%s) Has %ld Pieces, should be 2\n", Piece, (long) pCount);
		break;
	case 'm':	/* My Range: m/dist */
		if (pCount != 1) TraceLog("Filter", TRUE, NULL, "FilterError:MyRange(%s) Has %ld Pieces, should be 1\n", Piece, (long) pCount);
		break;
	default:
		TraceLog("Filter", TRUE, NULL, "Filter Error:Unrecognized Piece(%s), invalid first character\n", Piece);
	}
	FreeSplitPieces(Pieces);
}

static void RefreshBuddyList(char *Filter)
{
	Filter = SkipWhite(Filter);	/* Don't care about leading whitespace */
	if (!LastFilter || strcmp(Filter, LastFilter))
	{	int HadBuddies = BuddyCount;	/* If we had some, we need to refresh */
		char *fp, *FreeMe = _strdup(Filter);
		if (LastFilter) free(LastFilter);
		LastFilter = _strdup(Filter);		/* Remember for change detection */

		fp = FreeMe;	/* Start at the first piece */
		BuddyCount = 0;	/* Re-initialize from scratch */
		for (char *p=FreeMe; *p; p++)
		{	if (isspace(*p & 0xff))
			{	*p = '\0';	/* Null terminate previous piece */
				ProcessFilterPiece(fp);
				fp = SkipWhite(p+1);	/* Skip to next piece */
				p = fp-1;	/* loop will increment */
			}
		}
		ProcessFilterPiece(fp);	/* And the last piece */
		free(FreeMe);

		if (BuddyCount || HadBuddies)	/* No sense if there's no buddies (unless there WAS) */
		{	unsigned long s;
			TraceLog("Buddies", TRUE, NULL, "Refreshing %ld Stations isBuddy Status (%ld Buddies, Was %ld)\n",
						(long) CloseStationCount, (long) BuddyCount, (long) HadBuddies);
			for (s=0; s<CloseStationCount; s++)
			{	pCloseStations[s]->isBuddy = IsBuddyStation(pCloseStations[s]->Station);
			}
			InvalidateStations(hwndMain, TRUE);
		}
	}
}

static STATION_INFO_S *GetOrCreateStationID(HWND hwnd, char *StationID, char *OwnerID, __int64 msNow, BOOL *pNew=NULL, BOOL *pGrew=NULL)
{	STATION_INFO_S *Station = FindStationCall(StationID, OwnerID);;
	unsigned long s;

	if (pNew) *pNew = FALSE;
	if (pGrew) *pGrew = FALSE;

	if (Station) return Station;

	if (pNew) *pNew = TRUE;	/* For paint optimization */

	s = CloseStationCount++;
	if (s >= CloseStationSize)
	{	if (CloseStationSize > ActiveConfig.Stations.AvgCount)
			CloseStationSize += max(8,CloseStationSize/20);
		else CloseStationSize += max(16,CloseStationSize/10);
		pCloseStations = (STATION_INFO_S **)realloc(pCloseStations, sizeof(*pCloseStations)*CloseStationSize);
		if (pGrew) *pGrew = TRUE;
	}
	Station = pCloseStations[s] = (STATION_INFO_S *) calloc(1,sizeof(*Station));
	/*memset(Station, 0, sizeof(*Station)); */

	Station->Index = s;	/* TEMPORARY */
	Station->SeenIndex = GetSeenStationIndex(StationID);	/* Yes, objects have a single entry */

#ifdef TRACK_FIND_STATIONS
	NewStations[0]++;
#endif

	InvalidateStatUsage(FALSE);
	strncpy(Station->Station, StationID, sizeof(Station->Station));
	strncpy(Station->Owner, OwnerID, sizeof(Station->Owner));
	Station->Station[sizeof(Station->Station)-1] = '\0';
	Station->Owner[sizeof(Station->Owner)-1] = '\0';

//	TraceLogThread("ValidVisible", TRUE, "New Station(%s)\n", Station->Station);

	Station->isObject = (*Station->Station != *Station->Owner) || strcmp(Station->Station, Station->Owner);
	if (Station->isObject)
		Station->isMyObject = !strcmp(Station->Owner,CALLSIGN);

	Station->isMine = IsSameBaseCallsign(Station->Station, CALLSIGN);
	if (Station->Station[0] == 'Q'
	&& Station->Station[1] == 'R'
	&& Station->Station[2] == 'U'
	&& !Station->isMine
	&& IsSameBaseCallsign(&Station->Station[3], CALLSIGN))
		Station->isMine = TRUE;
	Station->isBuddy = IsBuddyStation(Station->Station);
	Station->isFriend = IsFriendStation(Station->Station);
	SetupStationNickname(Station);
	Station->pCoord = GetCoordIndex(0.0, 0.0, "GetOrCreateStationID", Station->Station, NULL);

	for (int m=0; m<PendingMsgCount; m++)
	if (!PendingMsgs[m].Subordinated
	&& !_stricmp(Station->Station,PendingMsgs[m].MsgAckFrom))
	{	Station->MessagePending = TRUE;
	TraceLog("Messages", TRUE, hwnd, "New Station %s:%s Has MessagePending\n", Station->Station, Station->Owner);
		break;	/* It only takes one! */
	}

	if (strlen(Station->Station) >= MaxWidthStationLength)
	{	HDC hdc = GetDC(hwnd);
		TCHAR TempID[sizeof(Station->Station)+2+1];
		RECT rc;
		GetWindowRect(hwnd, &rc);
		StringCbPrintf(TempID, sizeof(TempID), TEXT("%S%S"), Station->Station, IGateEnabled?"*9":"");
		if (DrawText(hdc, TempID, -1, &rc, DT_NOPREFIX | DT_CALCRECT))
		{	int mwidth = rc.right - rc.left + 2;
			if (mwidth > MaxWidthStationWidth)
			{	TraceError(hwnd, "New MaxWidth(%S)=%ld Was(%S)=%ld\n",
									TempID, (long) mwidth,
									MaxWidthStationID, (long) MaxWidthStationWidth);
				strncpy(ActiveConfig.MaxWidthStationID, Station->Station, sizeof(ActiveConfig.MaxWidthStationID));
				StringCbPrintf(MaxWidthStationID, sizeof(MaxWidthStationID), TEXT("%s"), TempID);
				MaxWidthStationLength = strlen(Station->Station);
				MaxWidthStationWidth = mwidth;
				ShuffleScreenElements(hwnd);
			}
		} else TraceError(hwnd, "DrawText(%S) Failed Last Error=%ld\n", TempID, (long) GetLastError());
		ReleaseDC(hwnd, hdc);
	}

	SortCloseStations();

	return Station;
}

static STATION_INFO_S *GetOrCreateStation(HWND hwnd, APRS_PARSED_INFO_S *APRS, __int64 msNow, BOOL *pNew=NULL, BOOL *pGrew=NULL)
{	STATION_INFO_S * Station = GetOrCreateStationID(hwnd, APRS->objCall, APRS->srcCall, msNow, pNew, pGrew);
	Station->isClient = !strncmp(APRS->dstCall,DESTWM,4)
						|| !strncmp(APRS->dstCall, DEST32, 4);
	return Station;
}

static void DefineME(HWND hwnd)
{
		if (!CloseStationCount)
		{	int s = CloseStationCount++;
			if (!CloseStationSize && ActiveConfig.Stations.AvgIntervals > 2)
			{	CloseStationSize = max(16,ActiveConfig.Stations.AvgCount);
			} else CloseStationSize += 16;
			CloseStationSize = max(CloseStationSize,ActiveConfig.SavedPosits.Count);
			TraceError(hwnd, "DefineME:Starting With %ld Stations\n", CloseStationSize);
			pCloseStations = (STATION_INFO_S **)realloc(pCloseStations, sizeof(*pCloseStations)*CloseStationSize);
			MyStation = pCloseStations[s] = (STATION_INFO_S *) calloc(1,sizeof(*MyStation));
			/* memset(&CloseStations[s], 0, sizeof(CloseStations[s])); */
			strncpy(MyStation->Station, CALLSIGN, sizeof(MyStation->Station));
			strncpy(MyStation->Owner, CALLSIGN, sizeof(MyStation->Owner));
			UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
			MyStation->isMine = TRUE;
			MyStation->isBuddy = TRUE;
			MyStation->lastMsec = llGetMsec();	/* Make it visible (and record UpTime?) */
			GetSystemTime(&MyStation->stLast);
			MyStation->Last.lat = LastGoodPosition.dblLatitude;
			MyStation->Last.lon = LastGoodPosition.dblLongitude;
			GetCoordIndex(0.0, 0.0, "MyStation", "Zero", NULL);	/* Prime the zero and reference it */
			MyStation->pCoord = GetCoordIndex(MyStation->Last.lat, MyStation->Last.lon, "MyStation", MyStation->Station, MyStation->pCoord);
//			MyStation->lat = MyStation->Last.lat = LastGoodPosition.dblLatitude;
//			MyStation->lon = MyStation->Last.lon = LastGoodPosition.dblLongitude;
//			MyStation->tileX = long2tilex(MyStation->lon, MAX_OSM_ZOOM);
//			MyStation->tileY = lat2tiley(MyStation->lat, MAX_OSM_ZOOM);
//			MyStation->tileZ = MAX_OSM_ZOOM;
			MyStation->latlonExtended = 2;	/* I have one extra digit */
			MyStation->alt = 0;
			char Symbol[2] = { SYMBOL };
			MyStation->isymbol = SymbolInt(Symbol[0], Symbol[1]);
			StrSave(&MyStation->sPath, &MyStation->pPath, ActiveConfig.APRSIS.Port HERE);
#ifdef UNDER_CE
			MyStation->tPlatform = PLATFORM_APRSISCE;
			MyStation->pPlatform = strdup("APRSISCE");
#else
			MyStation->tPlatform = PLATFORM_APRSIS32;
			MyStation->pPlatform = _strdup("APRSIS32");
#endif

			if (ActiveConfig.Beacon.Precision < 0)
				MyStation->Ambiguity = (char) -ActiveConfig.Beacon.Precision;

			{	NICKNAME_INFO_S *MyNick = GetOrCreateNickname(&ActiveConfig, CALLSIGN, "ME", FALSE, FALSE);
				if (!MyNick)
				{	MyNick = GetOrCreateNickname(&ActiveConfig, CALLSIGN, "ME", TRUE, TRUE);
					if (MyNick) MyNick->Enabled = TRUE;
				}
				if (MyNick)
				{	SetupStationNickname(MyStation);
					if (MyStation->Nickname
					&& !MyStation->Nickname->OverrideSymbol)
					{	char Overlay = (MyStation->isymbol>>8);
						char Symbol = MyStation->isymbol&0xff;
						if (MyStation->isymbol&0xff0000)
							Overlay = (MyStation->isymbol>>16)&0xff;
						else Overlay = Overlay?'\\':'/';
						MyStation->Nickname->Symbol.Table = Overlay;
						MyStation->Nickname->Symbol.Symbol = Symbol;
						SetNicknameSymbol(&ActiveConfig, MyStation->Station, &MyStation->Nickname->Symbol);
					}
				}
			}
			MyStation->SeenIndex = GetSeenStationIndex(MyStation->Station);

			if (ActiveConfig.Tracking.Center	/* Looking for someone? */
			&& !_strnicmp(ActiveConfig.Tracking.Call, MyStation->Station, sizeof(ActiveConfig.Tracking.Call)))
			{	SetCenterTracking(hwnd, MyStation);
			}
			InvalidateCircle(NULL, TRUE, TRUE);
		}
}

static void AutoZoomMultiLine(HWND hwnd, BOOL ShowAll)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	if (cInfo)
	{	if (//cInfo->Index	/* Don't auto-zoom main window */
		/*&&*/ cInfo->CenterTracking	/* Must be Tracking */
		&& cInfo->CenterStation	/* We must be centering */
		&& cInfo->CenterStation->MultiLine)	/* On a MultiLine */
		{	int tr = cInfo->Index;
			InvalidateCircle(hwnd, TRUE, TRUE);
//			InvalidateRect(hwnd, &rcCircle(tr), FALSE);
			UpdateWindow(hwnd);
			while (cInfo->zoom > ActiveConfig.View.ZoomMin)	/* give up when zoomed the whole way out */
			{	RECT rcDiff;
				RECT rcML = cInfo->CenterStation->MultiLine->Tracker[tr].rcMinMax;
				IntersectRect(&rcDiff, &rcML, &rcCircle(tr));
//TraceLog("AutoZoom", TRUE, hwnd, "Diff %ld %ld x %ld %ld ML %ld %ld x %ld %ld Circle %ld %ld x %ld %ld\n",
//		 rcDiff.left, rcDiff.top, rcDiff.right, rcDiff.bottom,
//		 rcML.left, rcML.top, rcML.right, rcML.bottom,
//		 rcCircle(tr).left, rcCircle(tr).top, rcCircle(tr).right, rcCircle(tr).bottom);
				if (EqualRect(&rcDiff, &rcML)) break;
				cInfo->zoom--;	/* Zoom out one level */
				cInfo->msLastSigChange = llGetMsec();
				InvalidateCircle(hwnd, TRUE, TRUE);
//				InvalidateRect(hwnd, &rcCircle(tr), FALSE);
				UpdateWindow(hwnd);
			}
			cInfo->msLastSigChange = llGetMsec();
		}
//		else TraceLog("AutoZoom", TRUE, hwnd, "Index[%ld] viewBits:%ld %s %s %p\n", cInfo->Index, cInfo->viewBits, cInfo->CenterTracking?"Tracking":"NOT Tracking", cInfo->CenterStation?cInfo->CenterStation->Station:"Station(NONE)", cInfo->CenterStation?cInfo->CenterStation->MultiLine:NULL);
		else if (ShowAll)
		{	int tr = cInfo->Index;
			BOOL First = TRUE;

			InvalidateCircle(hwnd, TRUE, TRUE);
			UpdateWindow(hwnd);

			TraceLog("AutoZoom", FALSE, hwnd, "[%ld] AutoZooming from %ld\n", tr, cInfo->zoom);
			while (cInfo->zoom >= ActiveConfig.View.ZoomMin)	/* give up when zoomed the whole way out */
			{	unsigned long s;
				BOOL moved = FALSE;
				int hits = 0, misses = 0;
				double minlat=0, minlon=0, maxlat=0, maxlon=0, ttlat=0, ttlon=0;

				for (s=cInfo->AutoZoomME?0:1; s<CloseStationCount; s++)
				{	STATION_INFO_S *Station = pCloseStations[s];
					if (Station->pCoord->lat || Station->pCoord->lon)	/* Skip 0,0 */
					if (Station->TInfo[tr].viewed)
					{	if (!hits++)
						{	minlat = maxlat = ttlat = Station->pCoord->lat;
							minlon = maxlon = ttlon = Station->pCoord->lon;
						} else
						{	double lat = Station->pCoord->lat;
							double lon = Station->pCoord->lon;
							if (lat < minlat) minlat = lat;
							if (lat > maxlat) maxlat = lat;
							if (lon < minlon) minlon = lon;
							if (lon > maxlon) maxlon = lon;
							ttlat += lat;
							ttlon += lon;
						}
						if (!Station->TInfo[tr].inCircle)
						{	BOOL Valid = IsValidLatLon(Station->pCoord->lat, Station->pCoord->lon);
							if (Valid) misses++;
							if (!cInfo->zoom)	/* Zoomed all the way out and not-visible? */
								TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Station: %s%s Not inCircle at %s%.4lf %.4lf Tile:%ld %ld\n",
										tr, Station->Station,
										Station->isKilled?"(KILLED)":"",
										Valid?"":"INVALID ",
										Station->pCoord->lat, Station->pCoord->lon,
										Station->pCoord->TileCoord.x, Station->pCoord->TileCoord.y);
						}
					}
				}
				if (hits)
				{	ttlat /= (double) hits;
					ttlon /= (double) hits;
				}
				double newLat, newLon;
				newLat = (minlat+maxlat)/2;
				newLon = (minlon+maxlon)/2;
				TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Hits:%ld Misses:%ld %.4lf %.4lf -> %.4lf %.4lf Center: %.4lf %.4lf Weighted: %.4lf %.4lf (%ld Stations, Zoom:%ld)\n",
							tr, hits, misses, minlat, minlon, maxlat, maxlon, newLat, newLon, ttlat, ttlon, CloseStationCount, cInfo->zoom);

				if (hits && cInfo->AutoZoomViewCtr)
				{	double newLat, newLon;
					if (!cInfo->CenterTracking || !cInfo->Locked)
					{	newLat = (minlat+maxlat)/2;
						newLon = (minlon+maxlon)/2;
						moved = (newLat != cInfo->LastCenterPosition.dblLatitude)
							|| (newLon != cInfo->LastCenterPosition.dblLongitude);
						//if (moved)
							SetCenterLatLon(hwnd, newLat, newLon);
					} else	/* Put followed station back into center */
					{	newLat = cInfo->CenterStation->pCoord->lat;
						newLon = cInfo->CenterStation->pCoord->lon;
						moved = (newLat != cInfo->LastCenterPosition.dblLatitude)
							|| (newLon != cInfo->LastCenterPosition.dblLongitude);
						//if (moved)
						{	cInfo->LastCenterPosition.dblLatitude = newLat;
							cInfo->LastCenterPosition.dblLongitude = newLon;
							cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
							InvalidateStationPoints(tr, "UpdateStationPosition", TRUE);
							InvalidateCenter(hwnd, TRUE);
							cInfo->msLastSigChange = llGetMsec();
						}
					}
				}

				if (!First || !moved)	/* First pass just sets center (or not) */
				{	if (!misses) break;	/* End game! */
TraceLog("AutoZoom", FALSE, hwnd, "[%ld] AutoZoomMultiline NOT Zooming out!\n", (long) cInfo->Index);
					break;	/* No zooming here for now */
					if (cInfo->zoom <= ActiveConfig.View.ZoomMin) break;	/* Done */
					cInfo->zoom--;	/* Zoom out one level, but only second pass */
					cInfo->msLastSigChange = llGetMsec();
				} else First = FALSE;	/* Do a zoom pass */
				InvalidateCircle(hwnd, TRUE, TRUE);
				UpdateWindow(hwnd);
			}

			{	MSG msg;
				while (PeekMessage(&msg, hwnd, WM_AUTO_ZOOM, WM_AUTO_ZOOM, PM_REMOVE))
					TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Removed Redundant WM_AUTO_ZOOM center %.4lf %.4lf\n",
								cInfo->Index,
								cInfo->LastCenterPosition.dblLatitude,
								cInfo->LastCenterPosition.dblLongitude);
			}
		}
	}
}

static BOOL AreaObjectToMultiLine(APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{	int T, C;
	double xOff, yOff;

#ifdef FROM_XASTIR
    colors[0x21] = GetPixelByName(w,"black");   // AREA_BLACK_HI
000 000 000 black
    colors[0x22] = GetPixelByName(w,"blue");    // AREA_BLUE_HI
000 000 255 blue
    colors[0x23] = GetPixelByName(w,"green");   // AREA_GREEN_HI
000 255 000 green
    colors[0x24] = GetPixelByName(w,"cyan3");    // AREA_CYAN_HI
000 205 205 cyan3
    colors[0x25] = GetPixelByName(w,"red");     // AREA_RED_HI
255 000 000 red
    colors[0x26] = GetPixelByName(w,"magenta"); // AREA_VIOLET_HI
255 000 255 magenta
    colors[0x27] = GetPixelByName(w,"yellow");  // AREA_YELLOW_HI
255 255 000 yellow
    colors[0x28] = GetPixelByName(w,"gray35");  // AREA_GRAY_HI
089 089 089 gray35
#endif
static	COLORREF Colors[] = {
//			Black		Blue			Green		Cyan
			RGB(1,1,1), RGB(0,0,255), RGB(0,255,0), RGB(0,255,255),
//			Red				Magenta			Yellow			gray (35)
			RGB(255,0,0), RGB(255,0,255), RGB(255,255,0), RGB(89,89,89),
//			gray (27)		Blue			Green		Cyan
			RGB(69,69,69), RGB(0,0,139), RGB(0,139,0), RGB(0,139,139),
//			Red				Magenta			Yellow			gray (53)
			RGB(139,0,0), RGB(139,0,139), RGB(139,139,0), RGB(135,135,135) };
#ifdef FROM_XASTIR
// Low
    colors[0x29] = GetPixelByName(w,"gray27");   // AREA_BLACK_LO
069 069 069 gray27
    colors[0x2a] = GetPixelByName(w,"blue4");    // AREA_BLUE_LO
000 000 139 blue4
    colors[0x2b] = GetPixelByName(w,"green4");   // AREA_GREEN_LO
000 139 000 green4
    colors[0x2c] = GetPixelByName(w,"cyan4");    // AREA_CYAN_LO
000 139 139 cyan4
    colors[0x2d] = GetPixelByName(w,"red4");     // AREA_RED_LO
139 000 000 red4
    colors[0x2e] = GetPixelByName(w,"magenta4"); // AREA_VIOLET_LO
139 000 139 magenta4
    colors[0x2f] = GetPixelByName(w,"yellow4");  // AREA_YELLOW_LO
139 139 000 yellow4
    colors[0x30] = GetPixelByName(w,"gray53"); // AREA_GRAY_LO
135 135 135 gray53
#endif

	if (!(APRS->Valid & APRS_AREA_OBJECT_VALID)) return FALSE;

//	/1500 from http://www.aprs.org/aprs11/areaobjects.txt not /100 in aprs101
	T = APRS->course / 100;
	yOff = APRS->course % 100; yOff *= yOff; yOff /= 1500.0;// Degrees
	C = APRS->speed / 100;
	xOff = APRS->speed % 100; xOff *= xOff; xOff /= 1500.0;	// Degrees

	TraceLogThread("MultiLine", FALSE, "%s->%s Area @ %.5lf %.5lf T:%ld C:%ld xOff:%.5lf yOff:%.5lf\n",
					APRS->srcCall, APRS->objCall,
					(double) APRS->lat, (double) APRS->lon,
					APRS->srcCall, APRS->objCall,
					(long) T, (long) C, (double) xOff, (double) yOff);

	if (C < 0 || C >= ARRAYSIZE(Colors)) return FALSE;
	if (T < 0 || T > 9) return FALSE;
#ifdef OBJECT_TYPE
See also: http://www.aprs.org/aprs11/areaobjects.txt
0 Open Circle
1 Line (offset: down/right)
2 Open ellipse
3 Open triangle
4 Open box
5 Color-filled circle
6 Line (offset: down/left)
7 Color-filled ellipse
8 Color-filled triangle
9 Color-filled box
#endif

	if (!Station->MultiLine) Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
	else
	{	if (Station->MultiLine->Points) free(Station->MultiLine->Points);
		if (Station->MultiLine->tCoords) free(Station->MultiLine->tCoords);
		if (Station->MultiLine->SegEnds) free(Station->MultiLine->SegEnds);
	}

	MULTILINE_INFO_S *ml = Station->MultiLine;
	BOOL Closed = FALSE;

	ml->At.Lat = APRS->lat;
	ml->At.Lon = APRS->lon;
//	GetCoordIndex(APRS->lat, APRS->lon, "mlAt");
	ml->Max = ml->Min = ml->At;
	ml->Segments = 1;
	ml->SegEnds = NULL;	/* Not needed */

	ml->Area.Color = C;
	ml->Area.Type = T;
	ml->Area.xOff = xOff;
	ml->Area.yOff = yOff;

	ml->style = PS_SOLID;
	ml->color = Colors[C];
	ml->Filled = FALSE;

	switch (T)
	{
	case 5: // Color-filled circle
		ml->Filled = TRUE;
	case 0: // Open Circle
	{	double a, radius = (xOff+yOff)/2;
		double step = 20;
		int p;
		Closed = TRUE;
		ml->Count = (int)((360.0/step)+1);
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(ml->Count+1));	/* +1 for possible closure */
		for (p=0, a=0; a<360+step; p++, a+=step)
		{	ml->Points[p].Lat = APRS->lat - radius * sin(DegToRad(a));
			ml->Points[p].Lon = APRS->lon + radius * cos(DegToRad(a));
		}
		break;
	}
	case 7: // Color-filled ellipse
		ml->Filled = TRUE;
	case 2: // Open ellipse
	{	double t;
		double step = 20;
		int p;
//	for t=0->360 & r = primary axis rotation from x
//  a = x axis width, = y axis height
//	x(t) = xc + a cos(t)cos(r) - b sin(t)sin(r)
//	y(t) = yc + a cos(t)sin(r) + b sin(t)cos(r)

		Closed = TRUE;
		ml->Count = (int)((360.0/step)+1);
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(ml->Count+1));	/* +1 for possible closure */
		for (p=0, t=0; t<360+step; p++, t+=step)
		{	double rads = DegToRad(t);
			if (yOff > xOff)
			{	ml->Points[p].Lat = APRS->lat + yOff*sin(rads);
				ml->Points[p].Lon = APRS->lon + xOff*cos(rads);
			} else
			{	ml->Points[p].Lat = APRS->lat + yOff*cos(rads);
				ml->Points[p].Lon = APRS->lon + xOff*sin(rads);
			}
		}
		break;
	}
	case 9: // Color-filled box
		ml->Filled = TRUE;
	case 4: // Open box
		Closed = TRUE;
		ml->Count = 4;
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(ml->Count+1));	/* +1 for possible closure */
		ml->Points[0].Lat = APRS->lat;
		ml->Points[0].Lon = APRS->lon;
		ml->Points[3] = ml->Points[2] = ml->Points[1] = ml->Points[0];
		ml->Points[1].Lat += yOff;
		ml->Points[2].Lat += yOff;
		ml->Points[2].Lon -= xOff;
		ml->Points[3].Lon -= xOff;
		break;
	case 8: // Color-filled triangle
		ml->Filled = TRUE;
	case 3: // Open triangle
		Closed = TRUE;
		ml->Count = 3;
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(ml->Count+1));	/* +1 for possible closure */
		ml->Points[0].Lat = APRS->lat;
		ml->Points[0].Lon = APRS->lon;
		ml->Points[2] = ml->Points[1] = ml->Points[0];
		ml->Points[1].Lat += yOff;
		ml->Points[1].Lon -= xOff;
		ml->Points[2].Lon -= xOff*2;
		break;
	case 1: // Line (offset: down/right)
		ml->Count = 2;
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*ml->Count);
		ml->Points[0].Lat = APRS->lat;
		ml->Points[0].Lon = APRS->lon;
		ml->Points[1] = ml->Points[0];
		ml->Points[1].Lat += yOff;
		ml->Points[1].Lon -= xOff;
		break;
	case 6: // Line (offset: down/left)
		ml->Count = 2;
		ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*ml->Count);
		ml->Points[0].Lat = APRS->lat;
		ml->Points[0].Lon = APRS->lon;
		ml->Points[1] = ml->Points[0];
		ml->Points[1].Lat += yOff;
		ml->Points[1].Lon += xOff;
		break;
	default:
		return FALSE;
	}
/*	Figure out if the line objects have a "corridor" {miles} */
	if (T == 1 || T == 6)
	if (ml->Count == 2)	/* Simple line */
	{	char *o = strchr(APRS->Comment,'{');
		if (o)
		{	char *e;
			long width = strtol(o+1, &e, 10);
			if (*e == '}')
			{	double length, bearing;
				ml->Area.Width = width;
				AprsHaversineLatLon(ml->Points[0].Lat, ml->Points[0].Lon,
									ml->Points[1].Lat, ml->Points[1].Lon,
									&length, &bearing);
				ml->Count = 7;
				ml->Points = (MULTILINE_POINT_S *)realloc(ml->Points, sizeof(*ml->Points)*(ml->Count+1));	/* +1 for closure */
				AprsProjectLatLon(ml->Points[1].Lat, ml->Points[1].Lon,
								width, bearing+90,
								&ml->Points[2].Lat, &ml->Points[2].Lon);
				AprsProjectLatLon(ml->Points[0].Lat, ml->Points[0].Lon,
								width, bearing+90,
								&ml->Points[3].Lat, &ml->Points[3].Lon);
				AprsProjectLatLon(ml->Points[0].Lat, ml->Points[0].Lon,
								width, bearing-90,
								&ml->Points[4].Lat, &ml->Points[4].Lon);
				AprsProjectLatLon(ml->Points[1].Lat, ml->Points[1].Lon,
								width, bearing-90,
								&ml->Points[5].Lat, &ml->Points[5].Lon);
				ml->Points[6] = ml->Points[1];
				ml->Filled = Closed = TRUE;
			} else TraceLogThread("AreaLine", TRUE, "Line(%s) Has Invalid Width(%ld) in %s\n", Station->Station, (long) width, APRS->Comment);
		}
	}

	if (Closed)	/* Close the Polygon if necessary */
	if (ml->Count > 2)	/* Need at least 3 points! */
	{	int p = ml->Count-1;
		if (ml->Points[0].Lat != ml->Points[p].Lat
		|| ml->Points[0].Lon != ml->Points[p].Lon)
		{	p = ml->Count++;
			ml->Points[p] = ml->Points[0];
		}
	}
	ml->tCoords = (OSM_TILE_COORD_S *)malloc(sizeof(*ml->tCoords)*ml->Count);

	for (int p=0; p<ml->Count; p++)
	{	LatLonToTileCoord(ml->Points[p].Lat, ml->Points[p].Lon, &ml->tCoords[p]);
		if (ml->Min.Lat > ml->Points[p].Lat)
			ml->Min.Lat = ml->Points[p].Lat;
		if (ml->Min.Lon > ml->Points[p].Lon)
			ml->Min.Lon = ml->Points[p].Lon;
		if (ml->Max.Lat < ml->Points[p].Lat)
			ml->Max.Lat = ml->Points[p].Lat;
		if (ml->Max.Lon < ml->Points[p].Lon)
			ml->Max.Lon = ml->Points[p].Lon;
	}
	ml->SegEnds = (int *) malloc(sizeof(*ml->SegEnds));
	ml->SegEnds[0] = ml->Count;

	ml->tileMinMax.left = long2tilex(ml->Min.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.right = long2tilex(ml->Max.Lon, MAX_OSM_ZOOM)+1;
	ml->tileMinMax.top = lat2tiley(ml->Max.Lat, MAX_OSM_ZOOM);
	ml->tileMinMax.bottom = lat2tiley(ml->Min.Lat, MAX_OSM_ZOOM)+1;

	return TRUE;
}


static void mlSetLineType(MULTILINE_INFO_S *ml, char LineType)
{
#ifndef PS_DASHDOT
#define PS_DASHDOT PS_DASH
#endif
#ifndef PS_DOT
#define PS_DOT PS_DASH
#endif
	ml->MultiLine.LineType = LineType;
	switch (LineType)
	{
	case 'a':	/* Red solid Tornado Warning */
		ml->color = RGB(192,0,0);
		ml->style = PS_SOLID;
		break;
	case 'b':	/* Red dashed Tornado Watch */
		ml->color = RGB(192,0,0);
		ml->style = PS_DASH;
		break;
	case 'c':	/* Red double-dashed */
		ml->color = RGB(192,0,0);
		ml->style = PS_DASHDOT;
		break;
	case 'd':	/* Yellow solid Severe Thunderstorm Warning */
		ml->color = RGB(192,192,0);
		ml->style = PS_SOLID;
		break;
	case 'e':	/* Yellow dashed Severe Thunderstorm Watch */
		ml->color = RGB(192,192,0);
		ml->style = PS_DASH;
		break;
	case 'f':	/* Yellow double-dashed */
		ml->color = RGB(192,192,0);
		ml->style = PS_DASHDOT;
		break;
	case 'g':	/* Blue solid Test Warning */
		ml->color = RGB(0,0,192);
		ml->style = PS_SOLID;
		break;
	case 'h':	/* Blue dashed Test Watch */
		ml->color = RGB(0,0,192);
		ml->style = PS_DASH;
		break;
	case 'i':	/* Blue double-dashed */
		ml->color = RGB(0,0,192);
		ml->style = PS_DASHDOT;
		break;
	case 'j':	/* green solid  */
		ml->color = RGB(0,192,0);
		ml->style = PS_SOLID;
		break;
	case 'k':	/* green dashed Mesoscale Discussion Areas */
		ml->color = RGB(0,192,0);
		ml->style = PS_DASH;
		break;
	case 'l':	/* green double-dashed */
		ml->color = RGB(0,192,0);
		ml->style = PS_DASHDOT;
		break;
	default:
		ml->color = RGB(64,64,64);	/* Gray */
		ml->style = PS_DOT;
	}
}

static BOOL ParseCoordMultiLineObject(char *c, char *e, APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{	char *o, *t;
	int Count;

	if (!c) return FALSE;

	if (strlen(e) != 1)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Seq 1 not %ld char(%s)", Station->Station, strlen(e), e);
		return FALSE;
	}
	Count = strtol(e, &t, 36);
	if (*t)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Non-Hex Seq(%s)", Station->Station, e);
		return FALSE;
	}

	if (strlen(c) < 10)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Need at least 10 not %ld char(%s)", Station->Station, strlen(c), c);
		return FALSE;
	}
	if ((int) strlen(c) != Count*8+2)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): %ld Coords is %ld not %ld(%s)", Station->Station, (long) Count, (long) Count*8+2, strlen(c), c);
		return FALSE;
	}

	{	TCHAR *LatLon = APRSLatLon(APRS->lat, APRS->lon, ' ',' ',0);
		TraceLogThread("MultiLine", FALSE, "LineType(%c) ObjType(%c) at %S\n", c[0], c[1], LatLon);
		free(LatLon);
	}
/*
user KJ4ERJ-TS pass 24231
KJ4ERJ-TS>APRS:;MULTITEST*250400z2800.00NF07800.00Wx TEST MultiLine }j0]KTRKQHPHPHOHJMJTKT{OMDAA
*/

	if (!Station->MultiLine) Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
	else
	{	if (Station->MultiLine->Points) free(Station->MultiLine->Points);
		if (Station->MultiLine->tCoords) free(Station->MultiLine->tCoords);
	}

	MULTILINE_INFO_S *ml = Station->MultiLine;

	mlSetLineType(ml, c[0]);
	ml->MultiLine.ObjType = c[1];
	ml->Filled = (c[1]=='0');	/* Closed area */
	ml->MultiLine.Scale = 1;

	ml->At.Lat = APRS->lat;
	ml->At.Lon = APRS->lon;
//	GetCoordIndex(APRS->lat, APRS->lon, "mlAt");
	ml->Max = ml->Min = ml->At;
	ml->Segments = 1;
	ml->SegEnds = NULL;	/* Not needed */
	ml->Count = 0;
	ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(Count+1));	/* +1 for possible closure */
	ml->tCoords = (OSM_TILE_COORD_S *)malloc(sizeof(*ml->tCoords)*(Count+1));	/* +1 for possible closure */

	for (o=c+2; Count--; o+=8)
	{	signed long sslat, sslon;
		if (!newbase91decode(&o[0], 4, &sslat)
		|| !newbase91decode(&o[4], 4, &sslon))
		{
TraceLogThread("MultiLine", TRUE, "INVALID(%s) Compressed(%.8s) INVALID\n", Station->Station, &o[0]);
		} else
		{	int p = ml->Count++;
			{	ml->Points[p].Lat = 90.0 - sslat / 380926.0;
				ml->Points[p].Lon = sslon / 190463.0 - 180.0;
				LatLonToTileCoord(ml->Points[p].Lat, ml->Points[p].Lon, &ml->tCoords[p]);

				if (ml->Min.Lat > ml->Points[p].Lat)
					ml->Min.Lat = ml->Points[p].Lat;
				if (ml->Min.Lon > ml->Points[p].Lon)
					ml->Min.Lon = ml->Points[p].Lon;
				if (ml->Max.Lat < ml->Points[p].Lat)
					ml->Max.Lat = ml->Points[p].Lat;
				if (ml->Max.Lon < ml->Points[p].Lon)
					ml->Max.Lon = ml->Points[p].Lon;

				{	TCHAR *LatLon = APRSLatLon(ml->Points[p].Lat, ml->Points[p].Lon,
										' ',' ',0);
					TraceLogThread("MultiLine", FALSE, "o[%ld]=%ld %ld or %S\n",
								(long)ml->Count, sslat, sslon, LatLon);
					free(LatLon);
				}
			}
		}
	}
	if (ml->Filled)	/* Close the Polygon if necessary */
	if (ml->Count > 1)	/* Need at least 2 points! */
	{	int p = ml->Count-1;
		if (ml->Points[0].Lat != ml->Points[p].Lat
		|| ml->Points[0].Lon != ml->Points[p].Lon)
		{	TraceLogThread("MultiLine", TRUE, "%s->%s MultiLine(%s) didn't close [0]@ %.5lf %.5lf != [%ld]@ %.5lf %.5lf\n",
						APRS->srcCall, APRS->objCall, APRS->Comment,
						(double) ml->Points[0].Lat, (double) ml->Points[0].Lon,
						(long) p,
						(double) ml->Points[p].Lat, (double) ml->Points[p].Lon);
			p = ml->Count++;
			ml->Points[p] = ml->Points[0];
			ml->tCoords[p] = ml->tCoords[0];
		}
	}
	ml->SegEnds = (int *) malloc(sizeof(*ml->SegEnds));
	ml->SegEnds[0] = ml->Count;

	ml->tileMinMax.left = long2tilex(ml->Min.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.right = long2tilex(ml->Max.Lon, MAX_OSM_ZOOM)+1;
	ml->tileMinMax.top = lat2tiley(ml->Max.Lat, MAX_OSM_ZOOM);
	ml->tileMinMax.bottom = lat2tiley(ml->Min.Lat, MAX_OSM_ZOOM)+1;

	return TRUE;
}

static char *TrackToVariableMultiLine(STATION_INFO_S *Station, int MaxLen, BOOL Close=FALSE)
{	return CoordTrackToVariableMultiLine("TrackToMultiLine",
										 Station->pCoord->lat, Station->pCoord->lon, 
										 Station->TrackCount, Station->Tracks,
										 MaxLen, Close);
}

static BOOL ParseVariableMultiLineObject(char *c, char *e, APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{	char *o;
	int Count, LatLen, LonLen, LatMid, LonMid;
	double nowLat = APRS->lat, nowLon = APRS->lon;

	if (!c) return FALSE;

	if (strlen(e) != 3)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Seq 3 not %ld char(%s)", Station->Station, strlen(e), e);
		return FALSE;
	}
	Count = *e++;
	if (Count > '9') Count = Count - 'A' + 10;
	else Count = Count - '0';
	LatLen = *e++ - '0';
	LonLen = *e++ - '0';
	if (Count < 0 || LatLen < 1 || LonLen < 1 || LatLen > 4 || LonLen > 4)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Invalid Count(%ld) LatLen(%ld) or LonLen(%ld)\n", Station->Station, (long) Count, (long) LatLen, (long) LonLen);
		return FALSE;
	}
	LatMid = (long) pow(91.0,LatLen)/2;
	LonMid = (long) pow(91.0,LonLen)/2;
	TraceLogThread("MultiLine", FALSE, "Count:%ld Lat:%ld(%ld) Lon:%ld(%ld)\n",
					(long) Count, (long) LatMid, (long) LatLen,
					(long) LonMid, (long) LonLen);

	if ((long)strlen(c) < 2+LatLen+LonLen)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Need at least %ld (2+%ld+%ld) not %ld char(%s)", Station->Station, (long) 2+LatLen+LonLen, (long) LatLen, (long) LonLen, strlen(c), c);
		return FALSE;
	}
	if ((int) strlen(c) != 2+Count*(LatLen+LonLen))
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): %ld Coords is %ld not %ld(%s)", Station->Station, (long) Count, (long) 2+Count*(LatLen+LonLen), strlen(c), c);
		return FALSE;
	}

	{	TCHAR *LatLon = APRSLatLon(nowLat, nowLon, ' ',' ',0);
		TraceLogThread("MultiLine", FALSE, "LineType(%c) ObjType(%c) at %S\n", c[0], c[1], LatLon);
		free(LatLon);
	}

	if (!Station->MultiLine) Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
	else
	{	if (Station->MultiLine->Points) free(Station->MultiLine->Points);
		if (Station->MultiLine->tCoords) free(Station->MultiLine->tCoords);
	}

	MULTILINE_INFO_S *ml = Station->MultiLine;

	mlSetLineType(ml, c[0]);
	ml->MultiLine.ObjType = c[1];
	ml->Filled = (c[1]=='0');	/* Closed area */
	ml->MultiLine.Scale = 1;

	ml->At.Lat = APRS->lat;
	ml->At.Lon = APRS->lon;
//	GetCoordIndex(APRS->lat, APRS->lon, "mlAt");
	ml->Max = ml->Min = ml->At;
	ml->Segments = 1;
	ml->SegEnds = NULL;	/* Not needed */
	ml->Count = 0;
	ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(Count+1));	/* +1 for possible closure */
	ml->tCoords = (OSM_TILE_COORD_S *)malloc(sizeof(*ml->tCoords)*(Count+1));	/* +1 for possible closure */

	for (o=c+2; Count--; o+=LatLen+LonLen)
	{	signed long sslat, sslon;

		if (!newbase91decode(&o[0], LatLen, &sslat)
		|| !newbase91decode(&o[LatLen], LonLen, &sslon))
		{
TraceLogThread("MultiLine", TRUE, "INVALID(%s) Compressed(%.8s) INVALID\n", Station->Station, &o[0]);
		} else
		{	int p = ml->Count++;
				
			{	nowLat += (sslat-LatMid) / 380926.0;
				nowLon -= (sslon-LonMid) / 190463.0;
				ml->Points[p].Lat = nowLat;
				ml->Points[p].Lon = nowLon;
				LatLonToTileCoord(ml->Points[p].Lat, ml->Points[p].Lon, &ml->tCoords[p]);

				if (ml->Min.Lat > ml->Points[p].Lat)
					ml->Min.Lat = ml->Points[p].Lat;
				if (ml->Min.Lon > ml->Points[p].Lon)
					ml->Min.Lon = ml->Points[p].Lon;
				if (ml->Max.Lat < ml->Points[p].Lat)
					ml->Max.Lat = ml->Points[p].Lat;
				if (ml->Max.Lon < ml->Points[p].Lon)
					ml->Max.Lon = ml->Points[p].Lon;

				{	TCHAR *LatLon = APRSLatLon(ml->Points[p].Lat, ml->Points[p].Lon, ' ',' ',0);
				TraceLogThread("MultiLine", FALSE, "o[%ld]=%ld %ld or %S\n",
							(long)ml->Count, sslat, sslon,
							LatLon);
				free(LatLon);
				}
			}
		}
	}
	if (ml->Filled)	/* Close the Polygon if necessary */
	if (ml->Count > 1)	/* Need at least 2 points! */
	{	int p = ml->Count-1;
		if (ml->Points[0].Lat != ml->Points[p].Lat
		|| ml->Points[0].Lon != ml->Points[p].Lon)
		{	TraceLogThread("MultiLine", TRUE, "%s->%s MultiLine(%s) didn't close [0]@ %.5lf %.5lf != [%ld]@ %.5lf %.5lf\n",
						APRS->srcCall, APRS->objCall, APRS->Comment,
						(double) ml->Points[0].Lat, (double) ml->Points[0].Lon,
						(long) p,
						(double) ml->Points[p].Lat, (double) ml->Points[p].Lon);
			p = ml->Count++;
			ml->Points[p] = ml->Points[0];
			ml->tCoords[p] = ml->tCoords[0];
		}
	}
	ml->SegEnds = (int *) malloc(sizeof(*ml->SegEnds));
	ml->SegEnds[0] = ml->Count;

	ml->tileMinMax.left = long2tilex(ml->Min.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.right = long2tilex(ml->Max.Lon, MAX_OSM_ZOOM)+1;
	ml->tileMinMax.top = lat2tiley(ml->Max.Lat, MAX_OSM_ZOOM);
	ml->tileMinMax.bottom = lat2tiley(ml->Min.Lat, MAX_OSM_ZOOM)+1;

	return TRUE;
}

static char *ScaleTrackToMultiLine(STATION_INFO_S *Station, int MaxLen, BOOL Close=FALSE)
{	return CoordTrackToMultiLine(Station->Station, Station->pCoord->lat, Station->pCoord->lon, Station->TrackCount, Station->Tracks, MaxLen, Close);
}
#ifdef OLD_WAY
	int t;
	double nowLat=Station->lat, nowLon=Station->lon;
	double MaxOff=0, MinOff=0;
	double Scale1=0, Scale2=0, Scale=0;
	long IntScale, reqLat=1, reqLon=1;
	char *Result = (char*)malloc(1+(Station->TrackCount+1)*2+1+1);
	char *p = Result;

	if (Station->TrackCount+(Close?1:0) > 23	/* Spec max count */
	|| 1+(Station->TrackCount+(Close?1:0))*2+2 > MaxLen)	/* or too long */
		return NULL;

	for (t=0; t<Station->TrackCount; t++)
	{	double latOff = -(Station->lat - LONG2DEG(Station->Tracks[t].lat));
		double lonOff = (Station->lon - LONG2DEG(Station->Tracks[t].lon));
		double latDlt = -(nowLat - LONG2DEG(Station->Tracks[t].lat));
		double lonDlt = (nowLon - LONG2DEG(Station->Tracks[t].lon));
		char b91Lat[4], b91Lon[4];
		int latDigs = MakeBase91((long)fabs(latDlt*380926)*2,sizeof(b91Lat),b91Lat);
		int lonDigs = MakeBase91((long)fabs(lonDlt*190463)*2,sizeof(b91Lon),b91Lon);
		if (latDigs > reqLat) reqLat = latDigs;
		if (lonDigs > reqLon) reqLon = lonDigs;
		TraceLogThread("Track2ML", TRUE, "Track[%ld] Offset %.8lf %.8lf Comp(%ld %ld) B91(%.*s %.*s) or %ld %ld\n",
						(long) t, latDlt, lonDlt,
						(long)(latDlt*380926), (long)(lonDlt*190463),
						4, b91Lat, 4, b91Lon,
						(long) latDigs, (long) lonDigs);
		if (latOff > MaxOff) MaxOff = latOff;
		if (lonOff > MaxOff) MaxOff = lonOff;
		if (latOff < MinOff) MinOff = latOff;
		if (lonOff < MinOff) MinOff = lonOff;
		nowLat = LONG2DEG(Station->Tracks[t].lat);
		nowLon = LONG2DEG(Station->Tracks[t].lon);
	}
	TraceLogThread("Track2ML", TRUE, "MaxOff %.8lf (%ld) MinOff %.8lf (%ld) Requires %ld and %ld Digits\n", MaxOff, (long) (MaxOff/0.0001), MinOff, (long) (MinOff/0.0001), (long) reqLat, (long) reqLon);

	Scale1 = (MaxOff / 44.0); Scale2 = (-MinOff / 45.0);
	Scale = Scale1>Scale2?Scale1:Scale2;

	TraceLogThread("Track2ML", TRUE, "+Scale %.8lf -Scale %.8lf =Scale %.8lf\n", Scale1, Scale2, Scale);

	if (Scale<0.0001) return NULL;	/* Can't take log(0) */

	IntScale = (long) (log10(Scale/0.0001)*20);
	*p++ = (char) IntScale+33;

	Scale1 = MultiLineScale(*Result);
	TraceLogThread("Track2ML", TRUE, "Scale %.8lf or %.8lf is %ld giving %.8lf\n",
					Scale, Scale/0.0001, IntScale, Scale1);

	for (t=0; t<Station->TrackCount; t++)
	{	double latOff = -(Station->lat - LONG2DEG(Station->Tracks[t].lat));
		double lonOff = (Station->lon - LONG2DEG(Station->Tracks[t].lon));
		double latNew = ((long)(latOff/Scale)) * Scale1;
		double lonNew = ((long)(lonOff/Scale)) * Scale1;
		TraceLogThread("Track2ML", TRUE, "Track[%ld] Offset %.8lf %.8lf or %ld %ld giving %.8lf %.8lf or %.8lf %.8lf Error\n",
						(long) t, latOff, lonOff,
						(long) (latOff/Scale), (long) (lonOff/Scale),
						latNew, lonNew,
						latOff-latNew, lonOff-lonNew);
		*p++ = ((char)(latOff/Scale))+78;
		*p++ = ((char)(lonOff/Scale))+78;
	}
	if (Close)
	{	*p++ = Result[1];
		*p++ = Result[2];
	}
	*p++ = '{';	/* !DAO! will end up after this */
	*p++ = '\0';

	return Result;
}
#endif

static BOOL ParseOriginalMultiLineObject(char *c, char *e, APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{	char *o;
	double Scale;

	if (!c) return FALSE;

	if (strlen(e) != 5)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Seq 5 not %ld char(%s)", Station->Station, strlen(e), e);
		return FALSE;
	}

	if (strlen(c) < 5)
	{	TraceLogThread("MultiLine", TRUE, "BOGUS%s): Need at least 5 not %ld char(%s)", Station->Station, strlen(c), c);
		return FALSE;
	}
	if (!(strlen(c)&1))
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Need Odd, not Even %ld(%s)", Station->Station, strlen(c), c);
		return FALSE;
	}

	Scale = MultiLineScale(c[2]);
	{	TCHAR *LatLon = APRSLatLon(APRS->lat, APRS->lon, ' ',' ',0);
	TraceLogThread("MultiLine", FALSE, "LineType(%c) ObjType(%c) Scale(%c(%ld))=%lf at %S\n", c[0], c[1], c[2], (long) c[2], (double) Scale, LatLon);
		free(LatLon);
	}
/*
user KJ4ERJ-TS pass 24231
KJ4ERJ-TS>APRS:;MULTITEST*250400z2800.00NF07800.00Wx TEST MultiLine }j0]KTRKQHPHPHOHJMJTKT{OMDAA
*/

	if (!Station->MultiLine) Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
	else
	{	if (Station->MultiLine->Points) free(Station->MultiLine->Points);
		if (Station->MultiLine->tCoords) free(Station->MultiLine->tCoords);
		if (Station->MultiLine->SegEnds) free(Station->MultiLine->SegEnds);
	}

	MULTILINE_INFO_S *ml = Station->MultiLine;

	mlSetLineType(ml, c[0]);
	ml->MultiLine.ObjType = c[1];
	ml->Filled = (c[1]=='0');	/* Closed area */
	ml->MultiLine.Scale = Scale;

	ml->At.Lat = APRS->lat;
	ml->At.Lon = APRS->lon;
//	GetCoordIndex(APRS->lat, APRS->lon, "mlAt");
	ml->Max = ml->Min = ml->At;
	ml->Segments = 1;
	ml->SegEnds = NULL;	/* Not needed yet */
	ml->Count = 0;
	ml->Points = (MULTILINE_POINT_S *)malloc(sizeof(*ml->Points)*(strlen(c)/2+1));	/* +1 for possible closure */
	ml->tCoords = (OSM_TILE_COORD_S *)malloc(sizeof(*ml->tCoords)*(strlen(c)/2+1));	/* +1 for possible closure */

	for (o=c+3; o[0] && o[1] && o[0]!='{' && o[1]!='{'; o+=2)
	{	int dlat = o[0]-78;
		int dlon = o[1]-78;
		int p = ml->Count++;
		{	ml->Points[p].Lat = APRS->lat+dlat*Scale;
			ml->Points[p].Lon = APRS->lon-dlon*Scale;
			LatLonToTileCoord(ml->Points[p].Lat, ml->Points[p].Lon, &ml->tCoords[p]);

			if (ml->Min.Lat > ml->Points[p].Lat)
				ml->Min.Lat = ml->Points[p].Lat;
			if (ml->Min.Lon > ml->Points[p].Lon)
				ml->Min.Lon = ml->Points[p].Lon;
			if (ml->Max.Lat < ml->Points[p].Lat)
				ml->Max.Lat = ml->Points[p].Lat;
			if (ml->Max.Lon < ml->Points[p].Lon)
				ml->Max.Lon = ml->Points[p].Lon;

			{	TCHAR *LatLon = APRSLatLon(APRS->lat+dlat*Scale,
									APRS->lon-dlon*Scale,
									' ',' ',0);
			TraceLogThread("MultiLine", FALSE, "o[%ld]=%ld %ld or %lf %lf or %S\n",
						(long)(o-c-3)/2, dlat, dlon,
						(double)dlat*Scale, (double)dlon*Scale,
						LatLon);
			free(LatLon);
			}
		}
#ifdef NOT_ANY_MORE
	else TraceLogThread("MultiLine", TRUE, "%s->%s MultiLine(%s) OVERFLOWS %ld Entries with o[%ld]=%ld %ld or %lf %lf or %S\n",
						APRS->srcCall, APRS->objCall, APRS->Comment,
						(long)(o-c-3)/2, dlat, dlon,
						(double)dlat*Scale, (double)dlon*Scale,
						APRSLatLon(APRS->lat+dlat*Scale,
									APRS->lon-dlon*Scale,
									' ',' ',0));
#endif
	}
	if (ml->Filled)	/* Close the Polygon if necessary */
	if (ml->Count > 1)	/* Need at least 2 points! */
	{	int p = ml->Count-1;
		if (ml->Points[0].Lat != ml->Points[p].Lat
		|| ml->Points[0].Lon != ml->Points[p].Lon)
		{	TraceLogThread("MultiLine", TRUE, "%s->%s MultiLine(%s) didn't close [0]@ %.5lf %.5lf != [%ld]@ %.5lf %.5lf\n",
						APRS->srcCall, APRS->objCall, APRS->Comment,
						(double) ml->Points[0].Lat, (double) ml->Points[0].Lon,
						(long) p,
						(double) ml->Points[p].Lat, (double) ml->Points[p].Lon);
			p = ml->Count++;
			ml->Points[p] = ml->Points[0];
			ml->tCoords[p] = ml->tCoords[0];
		}
	}
	ml->SegEnds = (int *) malloc(sizeof(*ml->SegEnds));
	ml->SegEnds[0] = ml->Count;

	ml->tileMinMax.left = long2tilex(ml->Min.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.right = long2tilex(ml->Max.Lon, MAX_OSM_ZOOM)+1;
	ml->tileMinMax.top = lat2tiley(ml->Max.Lat, MAX_OSM_ZOOM);
	ml->tileMinMax.bottom = lat2tiley(ml->Min.Lat, MAX_OSM_ZOOM)+1;

	return TRUE;
}

static BOOL ParseMultiLineObject(APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{	char *e, *c = APRS->Comment?strchr(APRS->Comment, '}'):NULL;
	BOOL Result;

	if (!c) return FALSE;

	TraceLogThread("MultiLine", FALSE, "%s->%s MultiLine(%s)\n",
					APRS->srcCall, APRS->objCall, APRS->Comment);
	if (c[-1] != ' ')
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): No preceding space(%s)", Station->Station, c-1);
		return FALSE;
	}

	c = strdup(c+1);
	e = strrchr(c,'{');
	if (!e) e = strchr(c,'\0');
	*e++ = '\0';
	switch (strlen(e))
	{
	case 1:	/* {n */
/*  }j1
@@-V:*l>
@@&9:*l5
@@$Q:*Q%
@?jO:*QF
@?b@:*RQ
@>Aj:*ST
@>Cw:+`A
@@'5:+`9
@@&+:*lE
@@-j:*l^
{: */
		Result = ParseCoordMultiLineObject(c, e, APRS, Station);
		break;
	case 3:	/* {nyx */
		Result = ParseVariableMultiLineObject(c, e, APRS, Station);
		break;
	case 5:	/* {XXXXX */
		Result = ParseOriginalMultiLineObject(c, e, APRS, Station);
		break;
	default:
	{	TraceLogThread("MultiLine", TRUE, "BOGUS(%s): Unsupported Seq Len %ld Seq(%s)", Station->Station, strlen(e), e);
		Result = FALSE;
	}
	}
	free(c);
	return Result;
}

#ifdef MULTIPLE_AREA_ALERTS

#ifdef SUPPORT_SHAPEFILES

static BOOL CompleteNWSShape(APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{
	if (Station->isObject && Station->isNWS	/* an NWS Object? */
	&& strlen(Station->Station) == 9)	/* Smell right? */
	{	char *Code = &Station->Station[3];	/* Last 6 are the Code/Zone */
		SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
		if (Obj)
		{	TraceLogThread("ShapeFile", TRUE, "Code(%s)(%.3s) %S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
						Code, APRS->srcCall,
						APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2),
						(double) Obj->Lat, (double) Obj->Lon,
						STRING(Obj->ID), STRING(Obj->State),
						STRING(Obj->FIPS), STRING(Obj->Zone),
						STRING(Obj->Office), STRING(Obj->County),
						STRING(Obj->ShortName), STRING(Obj->Name));
			TraceLogThread("ShapeFile", FALSE, "Code(%s) Min %.5lf %.5lf Max %.5lf %.5lf (Avg: %.5lf %.5lf)\n",
						Code,
						(double) Obj->minLat, (double) Obj->minLon,
						(double) Obj->maxLat, (double) Obj->maxLon,
						(double) (Obj->minLat + Obj->maxLat) / 2.0,
						(double) (Obj->minLon + Obj->maxLon) / 2.0);
			TraceLogThread("ShapeFile", FALSE, "Code(%s) has %ld Points In %ld Parts\n",
						Code, (long) Obj->PointCount,
						(long) Obj->PartCount);

			if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
			{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
				Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//				GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
			}

			NWS_PRODUCT_S *NWSProd = GetNWSProduct(&ActiveConfig, Station->Owner+3);

			MULTILINE_INFO_S *ml = Station->MultiLine;
			if (!ml)
				ml = Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
			else
			{	if (ml->Points) free(ml->Points);
				if (ml->SegEnds) free(ml->SegEnds);
				for (int tr=0; tr<MAX_TRACKERS; tr++)	/* Force all windows to re-optimize */
					SetRectEmpty(&ml->Tracker[tr].rcMinMax);
			}

			ml->LineType = NWSProd->LineType;
			ml->ObjType = '0';	/* Closed Polygon */
			ml->At.Lat = Obj->Lat;
			ml->At.Lon = Obj->Lon;
//			GetCoordIndex(Obj->Lat, Obj->Lon, "mlAt");
			ml->Min = ml->Max = ml->At;
			ml->Count = Obj->PointCount;
			ml->Points = (MULTILINE_POINT_S*)malloc(sizeof(*ml->Points)*Obj->PointCount);
			for (int p=0; p<ml->Count; p++)
			{	ml->Points[p].Lat = Obj->Points[p].Lat;
				ml->Points[p].Lon = Obj->Points[p].Lon;
				if (ml->Min.Lat > ml->Points[p].Lat)
					ml->Min.Lat = ml->Points[p].Lat;
				if (ml->Min.Lon > ml->Points[p].Lon)
					ml->Min.Lon = ml->Points[p].Lon;
				if (ml->Max.Lat < ml->Points[p].Lat)
					ml->Max.Lat = ml->Points[p].Lat;
				if (ml->Max.Lon < ml->Points[p].Lon)
					ml->Max.Lon = ml->Points[p].Lon;
			}
			ml->Segments = Obj->PartCount;
			ml->SegEnds = (int *)malloc(sizeof(*ml->SegEnds)*Obj->PartCount);
			for (unsigned long p=0; p<Obj->PartCount; p++)
			{	if (p<Obj->PartCount-1)
					ml->SegEnds[p] = Obj->PartStarts[p+1];
				else ml->SegEnds[p] = ml->Count;
			}
			FreeShapeObject(Obj);
			return TRUE;
		} else TraceLogThread("ShapeFile", TRUE, "CompleteNWSShape:Failed To Make Object(%s)\n", Code);
	}
	return FALSE;
}
#endif

static void AprsLogInternalPacket(char *Why, HWND hwnd, char *Packet, BOOL FreeIt=FALSE, BOOL *ForcePost=FALSE);

void CreateNWSObjects(APRS_PARSED_INFO_S *APRS, HWND hwnd, CLIENT_INFO_S *Info)
{
//CWAPID>APRS::NWS-TTTTT:DDHHMMz,ADVISETYPE,zcs{seq#
//CWAPID>APRS::NWS_TTTTT:DDHHMMz,ADVISETYPE,compressed zcs{seq#
//CWAPID>APRS::SKYCWA   :DDHHMMz,ADVISETYPE,zcs{seq#
//zcs are comma separated zone codes or county codes (see the databases linked to the left to find the zone or county code for your area), or statement text.
//compressed zcs is a compressed listing of zones or counties (see example below) (note underscore in To address instead of hyphen).
//MLBTOR>APRS,qAO,AE5PL-WX::NWS-WARN :260215z,TORNADO,FLC061-093-111{Q1CAA
//MLBTOR>APRS,qAO,AE5PL-WX::NWS_WARN :260215z,TORNADO,FLC061-093-111{Q1CAA
//MLBSVR>APRS,qAO,AE5PL-WX::NWS-WARN :260200z,SVR_STORM,FLC061-093-111{Q14AA
//MLBSVR>APRS,qAO,AE5PL-WX::NWS_WARN :260200z,SVR_STORM,FLC061-093-111{Q14AA
//TBWTOR>APRS,qAO,AE5PL-WX::NWS-WARN :260130z,TORNADO,FLC027-055{Q0gAA
//TBWTOR>APRS,qAO,AE5PL-WX::NWS_WARN :260130z,TORNADO,FLC027-055{Q0gAA	
//TBWNPW>APRS,qAo,WE7U-3::NWS_ADVIS:252300z,URGENT_WEATHER,FLZ039-042-043-048>052-055>057-060>062-065 {PEXAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ630-650-651-670-671 {PFGAA
//KEYMWW>APRS,qAo,WE7U-3::NWS_ADVIS:252100z,URGENT_MARINE_WX,GMZ052>054-072>075 {PFJAA
//TBWMWW>APRS,qAo,WE7U-3::NWS_ADVIS:270300z,URGENT_MARINE_WX,GMZ830-850-853-856-870-873-876 {PFZAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:260900z,URGENT_MARINE_WX,GMZ656-657-676 {PJUAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ610 {PJUAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ630-650-651-670-671 {PJUAA
//KEYMWW>APRS,qAo,WE7U-3::NWS_ADVIS:260400z,URGENT_MARINE_WX,GMZ052>054-072>075 {PKMAA
//TBWMWW>APRS,qAo,WE7U-3::NWS_ADVIS:271500z,URGENT_MARINE_WX,GMZ830-850-853-856-870-873-876 {PKpAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC017 {PLCAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC053-101 {PLDAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_CANCL:252145z,SEVERE_WEATHER,FLC017 {PLYAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC053-101 {PLaAA
//MLBSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252230z,SEVERE_WEATHER,FLC069-095-117-127 {PLxAA


	TraceLogThread("ShapeFile", FALSE, "MsgFrom:%s MsgTo:%s Body:%s\n",
					APRS->srcCall, APRS->msgCall, APRS->Comment);
#ifdef SUPPORT_SHAPEFILES
	if (ActiveConfig.NWS.ShapesEnabled)
	{
	char *Date = strdup(APRS->Comment);
	char *Type = strchr(Date,',');
	if (Type)
	{	char *Zones = strchr(Type+1,',');
		if (Zones)
		{	char *Seq = strchr(Zones+1,'{');
			if (Seq)
			{	*Type++ = *Zones++ = *Seq++ = '\0';
				TraceLogThread("ShapeFile", FALSE, "Date:%s Type:%s Zones:%s Seq:%s\n",
							Date, Type, Zones, Seq);
				char *State = Zones;
				char *End = Zones;
				for (char *z=Zones; *z; )
				{	if (!isdigit(*z&0xff))
					{	State = End = z;
//MEGWSW>APRS,qAo,WE7U-3::NWS_CANCL:260600z,WINTER_WEATHER,ARZ026>028-035-036-048-049-058-MOZ113-115 {Q3KAA
						while (*End && !isdigit(*End&0xff)) End++;
						z = End;	/* Pick it up at the digit */
					}
					if (*z)
					{	char *e;
						unsigned long ve, vs = strtol(z,&e,10);
						if (*e == '>')	/* Range! */
						{	ve = strtol(e+1, &e, 10);
						} else ve = vs;
						if (ve >= vs)
						for (unsigned long v=vs; v<=ve; v++)
						{	char *Code = (char*)malloc((int)(End-State)+33+1);
							sprintf(Code, "%.*s%03ld",(int)(End-State),State,(long)v);
//							TraceLogThread("ShapeFile", TRUE, "Zone(%s)\n", Code);
							SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
							if (Obj)
							{	TraceLogThread("ShapeFile", TRUE, "Code(%s)(%.3s) %S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
											Code, APRS->srcCall,
											APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2),
											(double) Obj->Lat, (double) Obj->Lon,
											STRING(Obj->ID), STRING(Obj->State),
											STRING(Obj->FIPS), STRING(Obj->Zone),
											STRING(Obj->Office), STRING(Obj->County),
											STRING(Obj->ShortName), STRING(Obj->Name));
								if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
								{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
									Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//									GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
								}

								NWS_PRODUCT_S *NWSProd = GetNWSProduct(&ActiveConfig, APRS->srcCall+3);

								char *Packet = (char*)malloc(2048), *DAO;
								TCHAR *LatLon = APRSLatLon(Obj->Lat, Obj->Lon,
															NWSProd->Symbol.Table, NWSProd->Symbol.Symbol,
															0, 2, &DAO);
								char ObjName[16];
								// Note that we extract the code out of ObjName elsewhere */
								sprintf(ObjName,"%3.3s%-6.6s", Seq, Code);
								sprintf(Packet, "%s>%s,%s,%s:;%-9.9s*%s%S%s %s%s{%s",
										APRS->srcCall, "APRS",
										APRS->Path.Hops[APRS->Path.hopCount-2],
										APRS->Path.Hops[APRS->Path.hopCount-1],
										ObjName, Date, LatLon, Type,
										*Obj->County?Obj->County:(*Obj->ShortName?Obj->ShortName:Obj->Name), DAO, Seq);
								TraceLogThread("ShapeFile", TRUE, "Code(%s) %s\n", Code, Packet);
								AprsLogInternalPacket("ShapeFile", hwnd, Packet, TRUE);
								FreeShapeObject(Obj);
							} else TraceLogThread("ShapeFile", TRUE, "CreateNWSObjects:Failed To Make Object(%s)\n", Code);
							free(Code);
						} else TraceLogThread("ShapeFile", TRUE, "Bad Range from %ld -> %ld\n", (long) vs, (long) ve);
						z = *e?e+1:e;	/* Don't skip the NULL! */
						while (isspace(*z&0xff)) z++;	/* Skip trailing blanks */
					}
				}
			}
		}
	}
	free(Date);
	}
#endif
}
#else	/* MULTIPLE_AREA_ALERTS */

#ifdef SUPPORT_SHAPEFILES

static BOOL AddShapeToML(SHAPEFILE_OBJECT_S *Obj, MULTILINE_INFO_S *ml)
{
	if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
	{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
		Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//		GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
	}

	{	TCHAR *LatLon = APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2);
		TraceLogThread("ShapeFile", FALSE, "Code(%s) %S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
					Obj->Code,
					LatLon,
					(double) Obj->Lat, (double) Obj->Lon,
					STRING(Obj->ID), STRING(Obj->State),
					STRING(Obj->FIPS), STRING(Obj->Zone),
					STRING(Obj->Office), STRING(Obj->County),
					STRING(Obj->ShortName), STRING(Obj->Name));
		free(LatLon);
	}
#ifdef VERBOSE
	TraceLogThread("ShapeFile", FALSE, "Code(%s) %ld Points %ld Parts Min %.5lf %.5lf Max %.5lf %.5lf (Avg: %.5lf %.5lf)\n",
					Obj->Code, (long) Obj->PointCount,
					(long) Obj->PartCount,
					(double) Obj->minLat, (double) Obj->minLon,
					(double) Obj->maxLat, (double) Obj->maxLon,
					(double) (Obj->minLat + Obj->maxLat) / 2.0,
					(double) (Obj->minLon + Obj->maxLon) / 2.0);
#endif

	unsigned long pStart = ml->Count;
	ml->SegEnds = (int *)realloc(ml->SegEnds, sizeof(*ml->SegEnds)*(ml->Segments+Obj->PartCount));

	for (unsigned long s=0; s<Obj->PartCount; s++)
	{	int pFirst = Obj->PartStarts[s];
		int pLast = Obj->PartStarts[s+1];
		int pCount = pLast - pFirst;

		Point *sV, *V = Obj->Points;
		double perc, minLat=0, minLon=0, maxLat=0, maxLon=0;
		sV= (Point *)malloc(sizeof(*sV)*pCount);
		minLat = maxLat = V[pFirst].Lat;
		minLon = maxLon = V[pFirst].Lon;
		for (int i=pFirst; i<pLast; i++)
		{	if (V[i].Lat < minLat) minLat = V[i].Lat;
			else if (V[i].Lat > maxLat) maxLat = V[i].Lat;
			if (V[i].Lon < minLon) minLon = V[i].Lon;
			else if (V[i].Lon > maxLon) maxLon = V[i].Lon;
		}
		TraceLogThread("ShapeFile", FALSE, "(%s)[%ld] %ld-%ld (%ld Points)(%.5lf-%.5lf %.5lf-%.5lf)\n",
				Obj->Code, s, pFirst, pLast, pCount,
				minLat, maxLat, minLon, maxLon);
		perc = 10.0-ActiveConfig.NWS.Quality/10.0;	/* 100=0, 0=10 */
		if (perc < 0) perc = 0;
		if (perc > 100) perc = 100;
		{	double tol = max((maxLat-minLat)*perc/100.0, (maxLon-minLon)*perc/100.0);
			long New = poly_simplify(tol, &V[pFirst], pCount, sV);

			ml->Count += New;
			ml->Points = (MULTILINE_POINT_S*)realloc(ml->Points, sizeof(*ml->Points)*ml->Count);
			ml->tCoords = (OSM_TILE_COORD_S*)realloc(ml->tCoords, sizeof(*ml->tCoords)*ml->Count);

			TraceLogThread("ShapeFile", FALSE, "Code(%s)[%ld] has %ld/%ld Points, ML Now %ld Points (%.2lf%% tol:%.5lf %.5lf-%.5lf %.5lf-%.5lf)\n",
						Obj->Code, s, (long) New, (long) pCount,
						(long) ml->Count,
						perc, tol, minLat, maxLat, minLon, maxLon);

			for (int p=0; p<New; p++, pStart++)
			{	ml->Points[pStart].Lat = sV[p].Lat;
				ml->Points[pStart].Lon = sV[p].Lon;
				LatLonToTileCoord(ml->Points[pStart].Lat, ml->Points[pStart].Lon, &ml->tCoords[pStart]);
				if (ml->Min.Lat > ml->Points[pStart].Lat)
					ml->Min.Lat = ml->Points[pStart].Lat;
				if (ml->Min.Lon > ml->Points[pStart].Lon)
					ml->Min.Lon = ml->Points[pStart].Lon;
				if (ml->Max.Lat < ml->Points[pStart].Lat)
					ml->Max.Lat = ml->Points[pStart].Lat;
				if (ml->Max.Lon < ml->Points[pStart].Lon)
					ml->Max.Lon = ml->Points[pStart].Lon;
			}
			ml->SegEnds[ml->Segments++] = pStart;	/* And next one starts */
		}
		free(sV);
	}

	ml->tileMinMax.left = long2tilex(ml->Min.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.right = long2tilex(ml->Max.Lon, MAX_OSM_ZOOM);
	ml->tileMinMax.top = lat2tiley(ml->Max.Lat, MAX_OSM_ZOOM);
	ml->tileMinMax.bottom = lat2tiley(ml->Min.Lat, MAX_OSM_ZOOM);

	return TRUE;
}

static MULTILINE_INFO_S *ShapeToML(SHAPEFILE_OBJECT_S *Obj, MULTILINE_INFO_S *ml, char LineType)
{
	if (!ml)
		ml = (MULTILINE_INFO_S *)calloc(1,sizeof(*ml));
	else
	{	if (ml->Points) free(ml->Points);
		if (ml->SegEnds) free(ml->SegEnds);
		memset(ml, 0, sizeof(*ml));
	}
	mlSetLineType(ml, LineType);
	ml->MultiLine.ObjType = '0';	/* Closed Polygon */
	ml->Filled = TRUE;	/* Closed area */
	ml->At.Lat = Obj->Lat;
	ml->At.Lon = Obj->Lon;
	ml->Min = ml->Max = ml->At;
//	GetCoordIndex(Obj->Lat, Obj->Lon, "mlAt");
	AddShapeToML(Obj, ml);

	return ml;
}

static BOOL CompleteNWSShape(APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{
	if (Station->isObject && Station->isNWS	/* an NWS Object? */
	&& strlen(Station->Station) == 9)	/* Smell right? */
	{
		BOOL ErrorsOccurred = FALSE;
		char Message[80];
		int Areas=0, Points=0, Parts=0;
		__int64 Start = llGetMsec();
static __int64 msLast=0, msMax=0;

//CWAPID>APRS::NWS-TTTTT:DDHHMMz,ADVISETYPE,zcs{seq#
//CWAPID>APRS::NWS_TTTTT:DDHHMMz,ADVISETYPE,compressed zcs{seq#
//CWAPID>APRS::SKYCWA   :DDHHMMz,ADVISETYPE,zcs{seq#
//zcs are comma separated zone codes or county codes (see the databases linked to the left to find the zone or county code for your area), or statement text.
//compressed zcs is a compressed listing of zones or counties (see example below) (note underscore in To address instead of hyphen).
//MLBTOR>APRS,qAO,AE5PL-WX::NWS-WARN :260215z,TORNADO,FLC061-093-111{Q1CAA
//MLBTOR>APRS,qAO,AE5PL-WX::NWS_WARN :260215z,TORNADO,FLC061-093-111{Q1CAA
//MLBSVR>APRS,qAO,AE5PL-WX::NWS-WARN :260200z,SVR_STORM,FLC061-093-111{Q14AA
//MLBSVR>APRS,qAO,AE5PL-WX::NWS_WARN :260200z,SVR_STORM,FLC061-093-111{Q14AA
//TBWTOR>APRS,qAO,AE5PL-WX::NWS-WARN :260130z,TORNADO,FLC027-055{Q0gAA
//TBWTOR>APRS,qAO,AE5PL-WX::NWS_WARN :260130z,TORNADO,FLC027-055{Q0gAA	
//TBWNPW>APRS,qAo,WE7U-3::NWS_ADVIS:252300z,URGENT_WEATHER,FLZ039-042-043-048>052-055>057-060>062-065 {PEXAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ630-650-651-670-671 {PFGAA
//KEYMWW>APRS,qAo,WE7U-3::NWS_ADVIS:252100z,URGENT_MARINE_WX,GMZ052>054-072>075 {PFJAA
//TBWMWW>APRS,qAo,WE7U-3::NWS_ADVIS:270300z,URGENT_MARINE_WX,GMZ830-850-853-856-870-873-876 {PFZAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:260900z,URGENT_MARINE_WX,GMZ656-657-676 {PJUAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ610 {PJUAA
//MFLMWW>APRS,qAo,WE7U-3::NWS_ADVIS:261900z,URGENT_MARINE_WX,AMZ630-650-651-670-671 {PJUAA
//KEYMWW>APRS,qAo,WE7U-3::NWS_ADVIS:260400z,URGENT_MARINE_WX,GMZ052>054-072>075 {PKMAA
//TBWMWW>APRS,qAo,WE7U-3::NWS_ADVIS:271500z,URGENT_MARINE_WX,GMZ830-850-853-856-870-873-876 {PKpAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC017 {PLCAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC053-101 {PLDAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_CANCL:252145z,SEVERE_WEATHER,FLC017 {PLYAA
//TBWSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252145z,SEVERE_WEATHER,FLC053-101 {PLaAA
//MLBSVS>APRS,qAo,WE7U-3::NWS_ADVIS:252230z,SEVERE_WEATHER,FLC069-095-117-127 {PLxAA
		
		char *To = strdup(APRS->CleanComment);
		char *Type = strchr(To,',');
		if (Type)
		{
			char *Zones = strchr(Type+1,',');
			if (Zones)
			{	char *Seq = strchr(Zones+1,'{');
				if (Seq)
				{	NWS_PRODUCT_S *NWSProd = GetNWSProduct(&ActiveConfig, Station->Owner+3, Station->Owner, *APRS->entryCall?APRS->entryCall:APRS->relayCall);
					*Type++ = *Zones++ = *Seq++ = '\0';
					TraceLogThread("ShapeFile", FALSE, "From:%s Type:%s Zones:%s Seq:%s Prod(%s:%s)\n",
								To, Type, Zones, Seq, NWSProd->PID, NWSProd->Desc);

					{	size_t cLen = strlen(To)+strlen(Type)+strlen(Seq)+80;
						char *tc = (char*)malloc(cLen);
						sprintf(tc,"%s %s{%s", To, Type, Seq);
						UTF8Save(&Station->sComment, &Station->pComment, tc HERE);
						free(tc);
					}

					MULTILINE_INFO_S *ml = Station->MultiLine;

					if (ml
					&& !ml->Errors
					&& ml->SourceString
					&& !strcmp(ml->SourceString,Zones))
					{	TraceLogThread("NWS-Debug", FALSE, "CompleteNWSShape:%s Recycling %ld/%ld for %s\n",
										Station->Station, ml->Count, ml->Segments,
										Zones);
						free(To);
						return TRUE;
					} else
					{	char *SafeZones = _strdup(Zones);
						if (!ml)
							ml = Station->MultiLine = (MULTILINE_INFO_S *)calloc(1,sizeof(*Station->MultiLine));
						else
						{
TraceLogThread("NWS-Debug", TRUE, "CompleteNWSShape:%s Replacing %ld/%ld for %s %s (Was:%s) To:%s Type:%s\n",
				Station->Station, ml->Count, ml->Segments,
				(ml->SourceString&&!strcmp(ml->SourceString,SafeZones))?"MATCHED":"DIFFERENT",
				SafeZones, ml->SourceString?ml->SourceString:"*NULL*",
				To, Type);
							if (ml->Points) free(ml->Points);
							if (ml->tCoords) free(ml->tCoords);
							if (ml->SegEnds) free(ml->SegEnds);
							if (ml->SourceString) free(ml->SourceString);
							memset(ml, 0, sizeof(*ml));
						}
						mlSetLineType(ml,NWSProd->LineType);
						ml->MultiLine.ObjType = '0';	/* Closed Polygon */
						ml->Filled = TRUE;
						ml->At.Lat = APRS->lat;
						ml->At.Lon = APRS->lon;
//						GetCoordIndex(APRS->lat, APRS->lon, "mlAt");
						ml->Min = ml->Max = ml->At;

#define FLESH_OUT_SHAPES
#ifdef FLESH_OUT_SHAPES
						char *State = Zones;
						char *End = Zones;
						for (char *z=Zones; *z; )
						{	if (!isdigit(*z&0xff))
							{	State = End = z;
//MEGWSW>APRS,qAo,WE7U-3::NWS_CANCL:260600z,WINTER_WEATHER,ARZ026>028-035-036-048-049-058-MOZ113-115 {Q3KAA
								while (*End && !isdigit(*End&0xff)) End++;
								z = End;	/* Pick it up at the digit */
							}
							if (*z)
							{	char *e;
								unsigned long ve, vs = strtol(z,&e,10);
								if (*e == '>')	/* Range! */
								{	ve = strtol(e+1, &e, 10);
								} else ve = vs;
								if (ve >= vs)
								for (unsigned long v=vs; v<=ve; v++)
								{	char *Code = (char*)malloc((int)(End-State)+33+1);
									sprintf(Code, "%.*s%03ld",(int)(End-State),State,(long)v);
									SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
									if (Obj)
									{	AddShapeToML(Obj, Station->MultiLine);

										Areas++;
										Points += Obj->PointCount;
										Parts += Obj->PartCount;

										FreeShapeObject("CompleteNWSShape", Obj);

									} else
									{	TraceLogThread("ShapeFile", TRUE, "CompleteNWSShape:Failed To Make Object(%s)\n", Code);
										ErrorsOccurred = TRUE;
									}
									free(Code);
								} else
								{	TraceLogThread("ShapeFile", TRUE, "Bad Range from %ld -> %ld\n", (long) vs, (long) ve);
									ErrorsOccurred = TRUE;
								}
								z = *e?e+1:e;	/* Don't skip the NULL! */
								while (isspace(*z&0xff)) z++;	/* Skip trailing blanks */
							}
						}

						if (!ml->Count || !ml->Segments)
						{	Station->MultiLine = NULL;
							free(ml);
							ErrorsOccurred = TRUE;
							TraceLogThread("ShapeFile", TRUE, "(%s)(%s) No MultiLines Found In %s\n",
											Station->Station, Station->Owner, APRS->CleanComment);
						}
#endif
						ml->Errors = ErrorsOccurred;
						ml->SourceString = SafeZones;
					}
				}
			}
		}
		free(To);

		sprintf(Message,"%s(%ld/%ld/%ld)",Station->Station,Points,Parts,Areas);
		{	__int64 msElapsed = llGetMsec()-Start;
			TraceLogThread("NWS-Debug", ErrorsOccurred, "CompleteNWSShape:%s %sML:%ld/%ld in %ldmsec for %s\n",
							Message, ErrorsOccurred?"WITH ERRORS ":"",
							Station->MultiLine?Station->MultiLine->Count:0,
							Station->MultiLine?Station->MultiLine->Segments:0,
							(long) msElapsed, APRS->CleanComment);
		}
		Start = DebugTimer("CompleteNWSShape",Message,Start,&msMax,&msLast, hwndMain);
		return TRUE;

//	This code never executes!

//		Start = DebugTimer("CompleteNWSShape(Fail)",Station->Station,Start,&msMax,&msLast, hwndMain);
//		if (ErrorsOccurred)
//		{	TraceLogThread("ShapeFile", TRUE, "CompleteNWSShape:Error Completing %s from %s, Body(%s)\n", APRS->objCall, APRS->srcCall, APRS->CleanComment);
//			char Buffer[80];
//			StringCbPrintfA(Buffer, sizeof(Buffer), "Error Completing %s->%s, See ShapeFile TraceLog", APRS->srcCall, APRS->objCall);
//			QueueInternalMessage(Buffer, FALSE);
//		}
	}
	return FALSE;
}
#endif

char *CreateNWSObjects(APRS_PARSED_INFO_S *APRS, HWND hwnd, CLIENT_INFO_S *Info)
{	char *ReturnObject = NULL;
	TraceLogThread("ShapeFile", FALSE, "MsgFrom:%s MsgTo:%s Body:%s\n",
					APRS->srcCall, APRS->msgCall, APRS->Comment);
#ifdef SUPPORT_SHAPEFILES
	if (ActiveConfig.NWS.ShapesEnabled)
	{
	BOOL ErrorsOccurred = FALSE;
	char Message[80];
	int Areas=0, Points=0, Parts=0;
	__int64 Start = llGetMsec();
static __int64 msLast=0, msMax=0;
		
	char *Date = strdup(APRS->Comment);
	char *Type = strchr(Date,',');
	if (Type)
	{	char *Zones = strchr(Type+1,',');
		if (Zones)
		{	char *Seq = strchr(Zones+1,'{');
			if (Seq)
			{	*Type++ = *Zones++ = *Seq++ = '\0';

				if ((APRS->Valid & (APRS_DATE_VALID | APRS_TIME_VALID)) != (APRS_DATE_VALID | APRS_TIME_VALID))
				{	if (cFromDec(&Date[0], 2, (unsigned char*)&APRS->Time.day)
					&& cFromDec(&Date[2], 2, (unsigned char*)&APRS->Time.hour)
					&& cFromDec(&Date[4], 2, (unsigned char*)&APRS->Time.minute))
						APRS->Valid |= APRS_DATE_VALID | APRS_TIME_VALID;
				}
			
				TraceLogThread("ShapeFile", FALSE, "Date:%s (APRS:%02ld %02ld %02ldz) Type:%s Zones:%s Seq:%s\n",
							Date, APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
							Type, Zones, Seq);
				char *State = Zones;
				char *End = Zones;
				long LatLonCount = 0;
				double Lat=0, Lon = 0;

				for (char *z=Zones; *z; )
				{	if (!isdigit(*z&0xff))
					{	State = End = z;
//MEGWSW>APRS,qAo,WE7U-3::NWS_CANCL:260600z,WINTER_WEATHER,ARZ026>028-035-036-048-049-058-MOZ113-115 {Q3KAA
						while (*End && !isdigit(*End&0xff)) End++;
						z = End;	/* Pick it up at the digit */
					}
					if (*z)
					{	char *e;
						unsigned long ve, vs = strtol(z,&e,10);
						if (*e == '>')	/* Range! */
						{	ve = strtol(e+1, &e, 10);
						} else ve = vs;
						if (ve >= vs)
						for (unsigned long v=vs; v<=ve; v++)
						{	char *Code = (char*)malloc((int)(End-State)+33+1);
							sprintf(Code, "%.*s%03ld",(int)(End-State),State,(long)v);
//							TraceLogThread("ShapeFile", TRUE, "Zone(%s)\n", Code);
							SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
							if (Obj)
							{	TCHAR *LatLon = APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2);
								TraceLogThread("ShapeFile", FALSE, "Code(%s)(%.3s) %S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
											Code, APRS->srcCall,
											LatLon,
											(double) Obj->Lat, (double) Obj->Lon,
											STRING(Obj->ID), STRING(Obj->State),
											STRING(Obj->FIPS), STRING(Obj->Zone),
											STRING(Obj->Office), STRING(Obj->County),
											STRING(Obj->ShortName), STRING(Obj->Name));
								free(LatLon);
								if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
								{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
									Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//									GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
								}

								Lat += Obj->Lat;
								Lon += Obj->Lon;
								LatLonCount++;

								Areas++;
								Points += Obj->PointCount;
								Parts += Obj->PartCount;

								FreeShapeObject("CreateNWSObjects", Obj);
							} else
							{	TraceLogThread("ShapeFile", TRUE, "CreateNWSObjects:Failed To Make Object(%s)\n", Code);
								ErrorsOccurred = TRUE;
							}
							free(Code);
						} else
						{	TraceLogThread("ShapeFile", TRUE, "Bad Range from %ld -> %ld\n", (long) vs, (long) ve);
							ErrorsOccurred = TRUE;
						}
						z = *e?e+1:e;	/* Don't skip the NULL! */
						while (isspace(*z&0xff)) z++;	/* Skip trailing blanks */
					}
				}
				if (LatLonCount)
				{	NWS_PRODUCT_S *NWSProd = GetNWSProduct(&ActiveConfig, APRS->srcCall+3, APRS->srcCall, *APRS->entryCall?APRS->entryCall:APRS->relayCall);

					Lat /= (double) LatLonCount;	/* Average out the object locations */
					Lon /= (double) LatLonCount;

					char *Packet = (char*)malloc(2048), *DAO=NULL;
					TCHAR *LatLon = APRSLatLon(Lat, Lon,
												NWSProd->Symbol.Table, NWSProd->Symbol.Symbol,
												0, 2, &DAO);

					char ObjName[16] = {0};
					BOOL FoundInLast = FALSE;
				static struct
					{	char Seq[6];
						char Obj[16];
						char Owner[16];
					} Last[16] = {0};
				static unsigned long MasterSeq = 0;

					for (int l=0; l<ARRAYSIZE(Last); l++)
					{	if (Last[l].Seq[0] == Seq[0] && Last[l].Seq[1] == Seq[1]
						&& Last[l].Seq[2] == Seq[2] && Last[l].Seq[3] == Seq[3]
						&& Last[l].Seq[4] == Seq[4]
						&& !strncmp(Last[l].Owner, APRS->srcCall, sizeof(Last[l].Owner)))
						{	strncpy(ObjName, Last[l].Obj, sizeof(ObjName));
							FoundInLast = TRUE;
							TraceLogThread("ShapeFile", FALSE, "RecentObj:[%ld/%ld]%s(%s) Date:%s (APRS:%02ld %02ld %02ldz) Seq:%.4s vs %s\n",
			(long) l, (long) ARRAYSIZE(Last),
			Last[l].Obj, Last[l].Owner,
			Date, APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
			Last[l].Seq, Seq);
							break;
						}
					}
					if (!*ObjName)
					for (unsigned long s=1; s<CloseStationCount; s++)
					if (pCloseStations[s]->isNWS && pCloseStations[s]->sComment
					&& !strcmp(pCloseStations[s]->Owner, APRS->srcCall)
					&& strlen(pCloseStations[s]->Station) == 9	/* Long enough */
					&& islower(pCloseStations[s]->Station[6]&0xff))	/* one of mine? */
					{	STATION_INFO_S *Station = pCloseStations[s];
						TCHAR *tSeq = wcschr(Station->pComment, TEXT('{'));
						if (tSeq++)
						{	if (tSeq[0] == Seq[0] && tSeq[1] == Seq[1]
							&& tSeq[2] == Seq[2] && tSeq[3] == Seq[3]
							&& tSeq[4] == Seq[4]
							&& Station->Time.day == APRS->Time.day
							&& Station->Time.hour == APRS->Time.hour
							&& Station->Time.minute == APRS->Time.minute)
							{	strncpy(ObjName, Station->Station, sizeof(ObjName));
TraceLogThread("ShapeFile", FALSE, "ExistingObj:%s(%s) Date:%s (APRS:%02ld %02ld %02ldz) Seq:%.4S vs %s\n",
			Station->Station, Station->Owner,
			Date, APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
			tSeq, Seq);
								break;
							}
						}
					}
					if (!*ObjName)
					do
					{static char Set[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
#define SetSize (sizeof(Set)-1)
						int b1 = MasterSeq % SetSize;
						int b2 = MasterSeq / SetSize;
						char b3 = ((b2 / SetSize) % 26) + 'a';
						if (!islower(b3&0xff)) b3 = 'z';	/* lock out there */
						b2 = b2 % SetSize;
						sprintf(ObjName,"%6.6s%c%c%c",
								APRS->srcCall, b3, Set[b2], Set[b1]);
						MasterSeq++;
TraceLogThread("ShapeFile", FALSE, "NewObj:%s Date:%s (APRS:%02ld %02ld %02ldz) Using(%s) MasterSeq(%ld)\n",
			APRS->srcCall,
			Date, APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
			ObjName, MasterSeq);
					} while (FindStationCall(ObjName,NULL,TRUE));
					if (!FoundInLast)
					{	memmove(&Last[1], &Last[0], sizeof(Last)-sizeof(Last[0]));
						strncpy(Last[0].Seq, Seq, sizeof(Last[0].Seq));
						strncpy(Last[0].Obj, ObjName, sizeof(Last[0].Obj));
						strncpy(Last[0].Owner, APRS->srcCall, sizeof(Last[0].Owner));
					}

					if (!_strnicmp(APRS->msgCall,"NWS-CANCL",sizeof(APRS->msgCall))
					|| !_strnicmp(APRS->msgCall,"NWS_CANCL",sizeof(APRS->msgCall)))
					{	SYSTEMTIME st;
						GetSystemTime(&st);
						APRS->Time.day = (char)st.wDay;
						APRS->Time.hour = (char)st.wHour;
						APRS->Time.minute = (char)st.wMinute;
						TraceLogThread("NWS-Debug",TRUE,"%s(%s) Cancel(%s) Date(%s)->%02ld%02ld%02ldz\n",
									ObjName, APRS->srcCall, APRS->msgCall,
									Date, APRS->Time.day,
									APRS->Time.hour, APRS->Time.minute);
					}

					if (APRS->Path.Hops[APRS->Path.hopCount-2][0] == 'q')
						sprintf(Packet, "%s>%s,%s,%s:;%-9.9s*%02ld%02ld%02ldz%S%s,%s,%s%s{%s",
							APRS->srcCall,
							APRS->Path.Hops[1],
							APRS->Path.Hops[APRS->Path.hopCount-2],
							APRS->Path.Hops[APRS->Path.hopCount-1],
							ObjName,
							APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
							LatLon,
							APRS->msgCall, Type, Zones, DAO, Seq);
					else if (APRS->Path.hopCount > 2)
						sprintf(Packet, "%s>%s,%s:;%-9.9s*%02ld%02ld%02ldz%S%s,%s,%s%s{%s",
							APRS->srcCall,
							APRS->Path.Hops[1],
							APRS->Path.Hops[APRS->Path.hopCount-1],
							ObjName,
							APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
							LatLon,
							APRS->msgCall, Type, Zones, DAO, Seq);
					else sprintf(Packet, "%s>%s:;%-9.9s*%02ld%02ld%02ldz%S%s,%s,%s%s{%s",
							APRS->srcCall,
							APRS->Path.Hops[1],
							ObjName,
							APRS->Time.day, APRS->Time.hour, APRS->Time.minute,
							LatLon,
							APRS->msgCall, Type, Zones, DAO, Seq);
					TraceLogThread("NWS-Debug", FALSE, "CreateNWSObjects:%s->%s=%s %s\n", APRS->srcCall, APRS->msgCall, ObjName, Packet);
					AprsLogInternalPacket("ShapeFile", hwnd, Packet, TRUE);
					ReturnObject = _strdup(ObjName);
					free(LatLon);
					if (DAO) free(DAO);
				}
			}
		}
	}
	free(Date);
	sprintf(Message,"%s(%ld/%ld/%ld)",APRS->srcCall,Points,Parts,Areas);
	Start = DebugTimer("CreateNWSObjects",Message,Start,&msMax,&msLast, hwnd);
	if (ErrorsOccurred)
	{	TraceLogThread("ShapeFile", TRUE, "CreateNWSObjects:Error Completing %s from %s, Body(%s)\n", APRS->objCall, APRS->srcCall, APRS->CleanComment);
//		char Buffer[80];
//		StringCbPrintfA(Buffer, sizeof(Buffer), "Error Completing %s->%s, See ShapeFile TraceLog", APRS->srcCall, APRS->objCall);
//		QueueInternalMessage(Buffer, FALSE);
	}
	}
#endif
	return ReturnObject;
}
#endif

static BOOL CheckMultiLineObject(APRS_PARSED_INFO_S *APRS, STATION_INFO_S *Station)
{
	if (ParseMultiLineObject(APRS, Station)) return TRUE;	/* Simple one first */

#ifdef SUPPORT_SHAPEFILES
	if (CompleteNWSShape(APRS, Station)) return TRUE;
#endif

	return FALSE;
}

static BOOL MeInMultiLineRectangle(MULTILINE_INFO_S *ml)
{	if (!ml) return FALSE;
	if (!MyStation) return FALSE;
	return MyStation->pCoord->lat >= ml->Min.Lat && MyStation->pCoord->lat <= ml->Max.Lat
		&& MyStation->pCoord->lon >= ml->Min.Lon && MyStation->pCoord->lon <= ml->Max.Lon;
}

static BOOL MyRangeInMultiLineRectangle(MULTILINE_INFO_S *ml)
{	double Dist[4], Bearing[4];
	if (!ml) return FALSE;
	if (!MyStation) return FALSE;
	if (MeInMultiLineRectangle(ml)) return TRUE;
	if (ActiveConfig.Range <= 0) return FALSE;
	AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon, ml->Min.Lat, ml->Min.Lon, &Dist[0], &Bearing[0]);
	if (Dist[0] <= ActiveConfig.Range/10.0) return TRUE;
	AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon, ml->Max.Lat, ml->Max.Lon, &Dist[1], &Bearing[1]);
	if (Dist[1] <= ActiveConfig.Range/10.0) return TRUE;
	AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon, ml->Min.Lat, ml->Max.Lon, &Dist[2], &Bearing[2]);
	if (Dist[2] <= ActiveConfig.Range/10.0) return TRUE;
	AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon, ml->Max.Lat, ml->Min.Lon, &Dist[3], &Bearing[3]);
	if (Dist[3] <= ActiveConfig.Range/10.0) return TRUE;

#ifdef VERBOSE
	TraceLogThread("MLRange", TRUE, "%s %.5lf %.5lf to %.5lf %.5lf is %.1lf @ %ld\n", Dist[0] <= ActiveConfig.Range/10.0?"YES":"no", MyStation->lat, MyStation->lon, ml->Min.Lat, ml->Min.Lon, Dist[0], (long) Bearing[0]);
	TraceLogThread("MLRange", TRUE, "%s %.5lf %.5lf to %.5lf %.5lf is %.1lf @ %ld\n", Dist[1] <= ActiveConfig.Range/10.0?"YES":"no", MyStation->lat, MyStation->lon, ml->Max.Lat, ml->Max.Lon, Dist[1], (long) Bearing[1]);
	TraceLogThread("MLRange", TRUE, "%s %.5lf %.5lf to %.5lf %.5lf is %.1lf @ %ld\n", Dist[2] <= ActiveConfig.Range/10.0?"YES":"no", MyStation->lat, MyStation->lon, ml->Min.Lat, ml->Max.Lon, Dist[2], (long) Bearing[2]);
	TraceLogThread("MLRange", TRUE, "%s %.5lf %.5lf to %.5lf %.5lf is %.1lf @ %ld\n\n", Dist[3] <= ActiveConfig.Range/10.0?"YES":"no", MyStation->lat, MyStation->lon, ml->Max.Lat, ml->Min.Lon, Dist[3], (long) Bearing[3]);
	return Dist[0] <= ActiveConfig.Range/10.0
		|| Dist[1] <= ActiveConfig.Range/10.0
		|| Dist[2] <= ActiveConfig.Range/10.0
		|| Dist[3] <= ActiveConfig.Range/10.0;
#endif
	return FALSE;
}

static int CountOrTransmitGroupObjects(HWND hwnd, char *Group, BOOL Transmit, double Lat=0, double Lon=0, double MaxRange=0, BOOL Metric=FALSE)
{	int Count = 0;
	for (unsigned long o=0; o<ActiveConfig.Objects.Count; o++)
	{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[o];
		if (!_strnicmp(Obj->Group, Group, sizeof(Obj->Group)))
		if (Obj->Enabled && (Obj->ISEnabled || Obj->RFEnabled))
		if ((Lat==0 || Lon==0)
		|| IsObjectInRange(MaxRange, Metric, Obj, Lat, Lon))
		{	if (Transmit) TransmitObject(Obj);
			Count++;
		}
	}
	return Count;
}

typedef struct CLOSE_OBJECT_S
{	double Range;
	double Bearing;
	OBJECT_CONFIG_INFO_S *Obj;
} CLOSE_OBJECT_S;

static int CompareCloseObjs(const void *One, const void *Two)
{	CLOSE_OBJECT_S *Left = (CLOSE_OBJECT_S *)One;
	CLOSE_OBJECT_S *Right = (CLOSE_OBJECT_S *)Two;

	if (Left->Range < Right->Range) return -1;
	else if (Left->Range > Right->Range) return 1;
	else if (Left->Bearing < Right->Bearing) return -1;
	else if (Left->Bearing > Right->Bearing) return 1;
	else return _stricmp(Left->Obj->Name, Right->Obj->Name);
}

BOOL TransmitAsItemTo(char *From, STATION_INFO_S *ToStation, char *Name,
							double Lat, double Lon, BOOL Compressed, long Precision,
							char Table, char Symbol, char *Comment, BOOL Kill=FALSE)
{	char *DAO=NULL;
	TCHAR *LatLon = Compressed /*&& !isdigit(Obj->Symbol.Table & 0xff)*/
					?	APRSCompressLatLon(Lat, Lon,
										Table, Symbol,
										FALSE, 0, 0, FALSE, 0)
					:	APRSLatLon(Lat, Lon,
										Table, Symbol,
										0, Precision, &DAO);
	size_t Remaining = sizeof(TCHAR) * (256 + strlen(Comment));
	TCHAR *Buffer = (TCHAR*)malloc(Remaining);
	TCHAR *Next = Buffer;

	if (Compressed
	&& (wcschr(LatLon,TEXT('|')) || wcschr(LatLon,TEXT('{')) || wcschr(LatLon,TEXT('~'))))
	{	LatLon = APRSLatLon(Lat, Lon,
							Table, Symbol,
							0, Precision, &DAO);
	}

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(")%.9S%S%s%S%S"),	/* Item, Kill, Lat/Lon, Comment, !DAO! */
					Name, (Kill?"_":"!"),
					LatLon, Comment, Compressed?"":(DAO?DAO:""));

	if (wcschr(Buffer,TEXT('|')) || wcschr(Buffer,TEXT('{')) || wcschr(Buffer,TEXT('~')))
	{	TraceLogThread("Objects", TRUE, "Non-Messagable Characters In %S\n", Buffer);
		TraceLogThread(From, TRUE, "Non-Messagable Characters In %S\n", Buffer);
	} else
	{	TraceLogThread("Objects", TRUE, "%S", Buffer);
		SendAPRSMessageFrom(From, ToStation->Station, 0, Buffer,
						ActiveConfig.QRU.RetryMessages, FALSE, FALSE, FALSE, 0, TRUE);
		RememberMessage2(From, ToStation->Station, Buffer, MESSAGE_ME);
		TraceLogThread(From, TRUE, "%s>%s:%S\n", From, ToStation->Station, Buffer);
	}
	free(Buffer);
	free(LatLon);
	if (DAO) free(DAO);
	return TRUE;
}

BOOL TransmitAsMessageTo(char *From, STATION_INFO_S *ToStation, char *Name,
							double Lat, double Lon,
							char Table, char Symbol, char *Comment)
{	size_t Remaining = sizeof(TCHAR) * (256 + strlen(Comment));
	TCHAR *Buffer = (TCHAR*)malloc(Remaining);
	TCHAR *Next = Buffer;
	long SymInt = SymbolInt(Table, Symbol);
	char *SymName = GetDisplayableSymbol(SymInt);

	if (Lat || Lon)	/* We know where it is? */
	{	if (ToStation->pCoord
		&& ToStation->pCoord->lat
		&& ToStation->pCoord->lon)
		{	double distance, bearing;
			AprsHaversineLatLon(ToStation->pCoord->lat, ToStation->pCoord->lon,
								Lat, Lon,
								&distance, &bearing);

			TCHAR *pDistance = GetPrettyDistance(distance);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S %s %s %S %S"),	/* Name dist bearing Comment Symbol */
							Name,
							GetPrettyDistance(distance),
							GetCompassPoint((int)bearing),
							Comment, SymName);
			free(pDistance);
		} else	/* Don't know where the requester is */
		{	TCHAR *LatLon = APRSLatLon(Lat, Lon, ' ',' ',0);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S %s %S %S"),	/* Name LatLon Comment Symbol */
							Name, LatLon,
							Comment, SymName);
			free(LatLon);
		}
	} else	/* Don't know where this one is! */
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S NoPosit %S %S"),	/* Name NoPosit Comment Symbol */
							Name, Comment, SymName);
	}

	TraceLogThread("Objects", TRUE, "%S", Buffer);

	SendAPRSMessageFrom(From, ToStation->Station, 0, Buffer,
						ActiveConfig.QRU.RetryMessages, FALSE, FALSE, FALSE, 0, TRUE);
	RememberMessage2(From, ToStation->Station, Buffer, MESSAGE_ME);
	TraceLogThread(From, TRUE, "%s>%s %S\n", From, ToStation->Station, Buffer);
	free(Buffer);
	free(SymName);
	return TRUE;
}

BOOL TransmitObjectAsItemTo(OBJECT_CONFIG_INFO_S *Obj, STATION_INFO_S *Station, char *From)
{
#ifdef OLD_WAY
	char *DAO=NULL;
	TCHAR *LatLon = Obj->Compressed /*&& !isdigit(Obj->Symbol.Table & 0xff)*/
					?	APRSCompressLatLon(Obj->Latitude, Obj->Longitude,
										Obj->Symbol.Table, Obj->Symbol.Symbol,
										FALSE, 0, 0, FALSE, 0)
					:	APRSLatLon(Obj->Latitude, Obj->Longitude,
										Obj->Symbol.Table, Obj->Symbol.Symbol,
										0, Obj->Precision, &DAO);
	size_t Remaining = sizeof(TCHAR) * (256 + sizeof(Obj->Comment));
	TCHAR *Buffer = (TCHAR*)malloc(Remaining);
	TCHAR *Next = Buffer;

	if (Obj->Compressed
	&& (wcschr(LatLon,TEXT('|')) || wcschr(LatLon,TEXT('{')) || wcschr(LatLon,TEXT('~'))))
	{	LatLon = APRSLatLon(Obj->Latitude, Obj->Longitude,
							Obj->Symbol.Table, Obj->Symbol.Symbol,
							0, Obj->Precision, &DAO);
	}

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(")%.9S%S%s%S%S"),	/* Item, Kill, Lat/Lon, Comment, !DAO! */
					Obj->Name, (Obj->Kill?"_":"!"),
					LatLon, Obj->Comment, Obj->Compressed?"":(DAO?DAO:""));

	if (wcschr(Buffer,TEXT('|')) || wcschr(Buffer,TEXT('{')) || wcschr(Buffer,TEXT('~')))
	{	TraceLogThread("Objects", TRUE, "Non-Messagable Characters In %S\n", Buffer);
		TraceLogThread(From, TRUE, "Non-Messagable Characters In %S\n", Buffer);
	} else
	{	TraceLogThread("Objects", TRUE, "%S", Buffer);
		SendAPRSMessageFrom(From, Station->Station, 0, Buffer,
						ActiveConfig.QRU.RetryMessages, FALSE, FALSE, FALSE, 0, TRUE);
		RememberMessage2(From, Station->Station, Buffer, MESSAGE_ME);
		TraceLogThread(From, TRUE, "%s>%s:%S\n", "QRU", Station->Station, Buffer);
	}
	free(Buffer);
	free(LatLon);
	if (DAO) free(DAO);
	return TRUE;
#else
	return TransmitAsItemTo(From, Station, Obj->Name, Obj->Latitude, Obj->Longitude,
					Obj->Compressed, Obj->Precision, Obj->Symbol.Table, Obj->Symbol.Symbol,
					Obj->Comment, Obj->Kill);
#endif
}

BOOL TransmitObjectAsMessageTo(OBJECT_CONFIG_INFO_S *Obj, STATION_INFO_S *Station, char *From)
{
#ifdef OLD_WAY
	size_t Remaining = sizeof(TCHAR) * (256 + sizeof(Obj->Comment));
	TCHAR *Buffer = (TCHAR*)malloc(Remaining);
	TCHAR *Next = Buffer;

	double distance, bearing;
	AprsHaversineLatLon(Station->pCoord->lat, Station->pCoord->lon,
						Obj->Latitude, Obj->Longitude,
						&distance, &bearing);

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("%.1lf%S %s %S %S"),	/* dist @ bearing Comment Name */
					(double) (distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
					ActiveConfig.View.Metric.Distance?"km":"mi",
					GetCompassPoint((int)bearing),
					Obj->Comment, Obj->Name);

	TraceLogThread("Objects", TRUE, "%S", Buffer);

	SendAPRSMessageFrom(From, Station->Station, 0, Buffer,
						ActiveConfig.QRU.RetryMessages, FALSE, FALSE, FALSE, 0, TRUE);
	RememberMessage2(From, Station->Station, Buffer, MESSAGE_ME);
	TraceLogThread(From, TRUE, "%s>%s %S\n", "QRU", Station->Station, Buffer);
	free(Buffer);
	return TRUE;
#else
	return TransmitAsMessageTo(From, Station, Obj->Name, Obj->Latitude, Obj->Longitude,
						Obj->Symbol.Table, Obj->Symbol.Symbol, Obj->Comment);
#endif
}

BOOL TransmitStationTo(STATION_INFO_S *Stat, STATION_INFO_S *ToStation, char *From)
{	BOOL Result = FALSE;
	int Overlay = (Stat->isymbol>>16)&0xff;
	int Table = (Stat->isymbol>>8)&0xff;
	int Symbol = Stat->isymbol & 0xff;
	if (!Table) Overlay = '/';	/* Primary table */
	else if (!Overlay) Overlay = '\\';	/* Secondary table */

	char *Comment;
	if (Stat->pComment)
	{	int cLen = wcslen(Stat->pComment);
		Comment = (char*)malloc(cLen+1);
		if (cLen > 43)	/* 43 is the max comment length */
			StringCbPrintfA(Comment, cLen+1, "%.40S...", Stat->pComment);
		else StringCbPrintfA(Comment, cLen+1, "%.*S", Stat->sComment, Stat->pComment);
	} else Comment = _strdup("");

	if (Stat->pCoord && (Stat->pCoord->lat || Stat->pCoord->lon)	/* Must know where */
	&&
	//ToStation->tPlatform == PLATFORM_APRSISCE	/* Understands Item-In-Message */
	//|| ToStation->tPlatform == PLATFORM_APRSIS32	/* Understands Item-In-Message */
	ToStation->tPlatform == PLATFORM_APRSISDR)	/* Handles stations vs objects via Item-In-Message */
	{	Result = TransmitAsItemTo(From, ToStation, Stat->Station,
									Stat->pCoord->lat, Stat->pCoord->lon,
									Stat->isKilled, 0, Overlay, Symbol, Comment);
	} else	/* Everyone else gets a "normal" message" */
	{	Result = TransmitAsMessageTo(From, ToStation, Stat->Station,
									Stat->pCoord->lat, Stat->pCoord->lon,
									Overlay, Symbol, Comment);
	}
	free(Comment);
	return Result;
}

BOOL TransmitObjectTo(OBJECT_CONFIG_INFO_S *Obj, STATION_INFO_S *Station, char *From)
{	BOOL Result = FALSE;

	if (!Station)
	{	Result = TransmitObject(Obj) != NULL;
	} else if (Station->tPlatform == PLATFORM_APRSISCE	/* Understands Item-In-Message */
	|| Station->tPlatform == PLATFORM_APRSISDR	/* Understands Item-In-Message */
	|| Station->tPlatform == PLATFORM_APRSIS32)	/* Understands Item-In-Message */
	{	Result = TransmitObjectAsItemTo(Obj, Station, From);
	} else if (Station->HeardOnRF
	&& Station->HeardOnRF <= LOCAL_MAX_HOPS+1	/* Local */
	&& Obj->RFEnabled)
	{	Result = TransmitObject(Obj) != NULL;
	} else if (Station->HeardRemoteRF	/* RemRF, needs IGating, so do a message */
	&& !Station->HeardAsTCPIP)		/* and no -IS definitely needs message */
	{	Result = TransmitObjectAsMessageTo(Obj, Station, From);
	} else	/* Everyone else gets a "normal" object */
	{	Result = TransmitObject(Obj) != NULL;
	}
	return Result;
}

static int TransmitClosestGroupObjects(HWND hwnd, char *Group,  STATION_INFO_S *Station, double MaxRange, BOOL Metric, int MaxObjs)
{	int c=0, Count = CountOrTransmitGroupObjects(hwnd, Group, FALSE, Station->pCoord->lat, Station->pCoord->lon,  MaxRange, Metric);
	unsigned long o;

	if (!Count) return Count;	/* None to do */
	CLOSE_OBJECT_S *Objs = (CLOSE_OBJECT_S*)calloc(Count+1,sizeof(*Objs));

	for (o=0; o<ActiveConfig.Objects.Count; o++)
	{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[o];
		if (!_strnicmp(Obj->Group, Group, sizeof(Obj->Group)))
		if (Obj->Enabled && (Obj->ISEnabled || Obj->RFEnabled))
		if (IsObjectInRange(MaxRange, Metric, Obj, Station->pCoord->lat, Station->pCoord->lon, &Objs[c].Range, &Objs[c].Bearing))
		{	Objs[c].Obj = Obj;
TraceLog("QRU", TRUE, hwnd, "Found Obj[%ld]=%s %.2lf @ %.0lf\n", (long) c, Obj->Name, (double) Objs[c].Range, (double) Objs[c].Bearing);
			c++;
		}
	}
	if (c != Count) TraceLog("Oops", TRUE, hwnd, "Counted %ld InRange, but found %ld Close!\n", (long) Count, (long) c);

	if (Count > 1) qsort(Objs, Count, sizeof(*Objs), CompareCloseObjs);
	if (Count > MaxObjs) Count = MaxObjs;
	for (o=0; o<(unsigned long)Count; o++)
	{	TransmitObjectTo(Objs[o].Obj, Station, "QRU");
	}
	free(Objs);

	return Count;
}

static BOOL IsTcpPath(char *p)
{
	if (*p == 'T')
		if (!strcmp(p,"TCPIP")
		|| !strcmp(p,"TCPXX*")
		|| !strcmp(p,"TCPIP*"))
			return TRUE;
	return FALSE;
}

static BOOL IsValidPathAlias(char *a)
{	char *p;
	if (!*a) return FALSE;
	for (p=a; *p; p++)
	{	if (!isalpha(*p&0xff)) return FALSE;
		if (!isupper(*p&0xff)) return FALSE;
	}
	return TRUE;
}

static BOOL IsPathAliasTrailer(char *t)
{	for (; *t; t++)
		if (!isdigit(*t) && *t != '-' && *t != '*')
			return FALSE;
	return TRUE;
}

static BOOL MatchPathAlias(char *p, char *test)
{	int l = strlen(test);
	return !strncmp(p,test,l) && IsPathAliasTrailer(p+l);
}

static BOOL IsPathAlias(char *p, BOOL EvenDisabled=FALSE)
{	unsigned long i;
	for (i=0; i<ActiveConfig.PathAliases.Count; i++)
	if (EvenDisabled
	|| !ActiveConfig.PathAliases.Entries[i].value)	/* Not disabled */
	{	if (MatchPathAlias(p, ActiveConfig.PathAliases.Entries[i].string))
		{	GetSystemTime(&ActiveConfig.PathAliases.Entries[i].time);
			return TRUE;
		}
	}
	return FALSE;
}

#ifndef UNDER_CE

static void PrimeAliasTraces(void)
{	if (ActiveConfig.AccumulateAliases) 
	{	IsTraceLogEnabled("Alias(New)");
		IsTraceLogEnabled("Alias(Used)");
		IsTraceLogEnabled("Alias(Numeric)");
		IsTraceLogEnabled("Alias(First-0)");
		IsTraceLogEnabled("Alias(Dbl-0)");
		IsTraceLogEnabled("Alias(-0)");
	}
}

static BOOL CheckPathAlias(char *p, char *pkt)
{	char *t;
/* Check for possible alias, return TRUE if Unused-0 (ends after XXXn) */
//W1WAB-9>R7TR8R,NI4CE-12*,KG4YZY-10*,WIDE2:`n1.l j/"46}
	for (t=p; *t; t++)
	{	if (!isalpha(*t&0xff)) break;	/* Break on non-alpha */
	}
	if (isdigit(*t&0xff))	/* XXXn */
	{	if (!t[1])	/* -0 alias? */
			return TRUE;
		else if ((t[1] == '*' && !t[2])		/* XXXn* */
		|| (t[1] == '-' && isdigit(t[2]&0xff) && !t[3]))	/* XXXn-n */
		{	if (t==p)
				TraceLogThread("Alias(Numeric)", FALSE,
							"Numeric Alias %s in %s\n", p, pkt);
			else if (!IsPathAlias(p, TRUE))	/* Ignore defined known aliases */
			{	char *Copy = _strdup(p);
				Copy[t-p] = '\0';
				BOOL New = CheckIgnoreString(NULL, &ActiveConfig.NewAliases, Copy, TRUE);
				if (!New)
				{	DefineIgnoreString(NULL, &ActiveConfig.NewAliases, Copy);
					TraceLogThread("Alias(New)", TRUE,
								"New Alias %s in %s\n", Copy, pkt);
				}
				TraceLogThread("Alias(Used)", FALSE,
							"Alias %s Used in %s\n", p, pkt);
				free(Copy);
			}
		}
	}
	return FALSE;
}

static void CheckPathAliases(APRS_PARSED_INFO_S *APRS, char *Pkt)
{
	/* If watching for aliases, check the rest of path */
	if (ActiveConfig.AccumulateAliases)
	{	for (int h=2; h<APRS->Path.hopCount; h++)
		{	if (*APRS->Path.Hops[h] == 'q') break;
			if (IsTcpPath(APRS->Path.Hops[h])) break;
			if (CheckPathAlias(APRS->Path.Hops[h], Pkt)	/* Unused-0 Alias? (XXXn) */
			&& h==APRS->Path.hopUnused)
			{	if (h > 2)
				{	char *Digi = _strdup(APRS->Path.Hops[h-1]);
					Digi[strlen(Digi)-1] = '\0';
//W4POX-5>SVUP0Q,KB4ZIN-5*,WIDE1*,K4MQF-1*,NV4FM-5*,WIDE2*,VA2,qAR,KG4LAA:'h.#l #/]Portsmouth EOC
					if (!IsPathAlias(Digi,TRUE))
					{	STATION_INFO_S *Stat = FindStationCall(Digi);
						BOOL New = FALSE;
						if (Stat && Stat->pPlatform)
						{	size_t Len = strlen(APRS->Path.Hops[h]);
							if (Len > 1)	/* Skip the n paths */
							{	size_t Size = Len+1+strlen(Digi)+1+strlen(Stat->pPlatform)+1+1;
								char *Copy = (char*)malloc(Size);
								StringCbPrintfA(Copy, Size, "%.*s-%s(%s)",	/* Note: This drops N */
												Len-1, APRS->Path.Hops[h],
												Digi, Stat->pPlatform);
								New = !CheckIgnoreString(NULL, &ActiveConfig.ZeroAliases, Copy, TRUE);
								if (New)
								{	DefineIgnoreString(NULL, &ActiveConfig.ZeroAliases, Copy);
								}
								free(Copy);
							}
						}
						TraceLogThread("Alias(-0)", New, "Unused -0 Alias %s After %s(%s) in %s\n",
											APRS->Path.Hops[h],
											APRS->Path.Hops[h-1],
											Stat&&Stat->pPlatform?Stat->pPlatform:"",
											Pkt);
					} else TraceLogThread("Alias(Dbl-0)", FALSE, "Doubled -0 Alias %s After %s in %s\n",
											APRS->Path.Hops[h],
											APRS->Path.Hops[h-1],
											Pkt);
					free(Digi);
				} else TraceLogThread("Alias(First-0)", FALSE, "Unused -0 Alias %s FIRST in %s\n",
										APRS->Path.Hops[h], Pkt);
			}
		}
	}
}
#endif

#ifndef NO_PATH_TRACKING
static void AddPacketPathEntry(STATION_INFO_S *Station, STATION_INFO_S *From, STATION_INFO_S *To, PATH_LINE_TYPE_V Type, __int64 msNow, BOOL FromRF)
{
	if (From->pCoord && (From->pCoord->lat || From->pCoord->lon))	/* Ignore 0,0 */
	if (To->pCoord && (To->pCoord->lat || To->pCoord->lon))		/* On either end */
	{	int p;
#ifdef FOR_INFO_ONLY
typedef struct PATH_LINE_S
{	BOOL Direct;
	__int64 msec;		/* For aging calculations */
	struct
	{	long lat, lon;
	} from, to;
} PATH_LINE_S;
#endif
		for (p=0; p<Station->PathCount; p++)
			if (Station->Paths[p].Type == Type
			&& Station->Paths[p].FromRF == FromRF
			&& Station->Paths[p].from.SeenIndex == From->SeenIndex
			&& Station->Paths[p].to.SeenIndex == To->SeenIndex
			&& Station->Paths[p].from.pCoord == From->pCoord
			&& Station->Paths[p].to.pCoord == To->pCoord)
				break;
		if (p >= Station->PathCount)
		{	p = Station->PathCount++;
			if (Station->PathCount >= Station->PathSize)
			{	Station->PathSize += 32;	/* Code below assumes this is at least 2 or 4 */
				Station->Paths = (PATH_LINE_S *) realloc(Station->Paths, sizeof(*Station->Paths)*Station->PathSize);
			}
			memset(&Station->Paths[p], 0, sizeof(Station->Paths[p]));

			Station->Paths[p].Type = Type;
			Station->Paths[p].FromRF = FromRF;
			Station->Paths[p].from.SeenIndex = From->SeenIndex;
			Station->Paths[p].from.pCoord = From->pCoord;
			From->pCoord->References++;
			Station->Paths[p].to.SeenIndex = To->SeenIndex;
			Station->Paths[p].to.pCoord = To->pCoord;
			To->pCoord->References++;
			double Distance, Bearing;
			AprsHaversineLatLon(To->pCoord->lat, To->pCoord->lon, From->pCoord->lat, From->pCoord->lon, &Distance, &Bearing);
			Station->Paths[p].Length = (unsigned short) (Distance+0.5);
#ifdef DEBUG_PATHS
			TraceLogThread("Paths", FALSE, "Adding %c Path[%ld] For %s From %s (%.4lf %.4lf) to %s (%.4lf %.4lf) (X<-R %.0lfmi @ %lddeg)\n",
					isprint(Type&0xff)?Type:'?', (long) p,
					Station->Station,
					From->Station, (double) From->pCoord->lat, (double) From->pCoord->lon,
					To->Station, (double) To->pCoord->lat, (double) To->pCoord->lon,
					(double) Distance, (long) Bearing);
#endif
		}
#ifdef DEBUG_PATHS
		else TraceLogThread("Paths", FALSE, "Incrementing %c Path[%ld/%ld] Used %ld For %s From %s to %s (%ldmi)\n",
					isprint(Type&0xff)?Type:'?', (long) p, (long) Station->PathCount, (long) Station->Paths[p].UseCount,
					Station->Station,
					From->Station, To->Station, (long) Station->Paths[p].Length);
#endif

		Station->Paths[p].msec = msNow;
		if (Station->Paths[p].UseCount < USHRT_MAX)
			Station->Paths[p].UseCount++;
	}
}
#endif

static void AccumulatePacketPath(STATION_INFO_S *Station, APRS_PARSED_INFO_S *APRS, char *safebuf, BOOL FromRF, unsigned long RfPort, __int64 msNow, STATION_INFO_S *ObjStat=NULL)
{	STATION_INFO_S *LastStat = Station;

	if (!Station) return;	/* Self-preservation */
	if (!ObjStat) ObjStat = Station;

#ifdef SUPPORT_HOURLY_PACKET_COUNT
	if (FromRF) ObjStat->Packets[0].RF++;
	else ObjStat->Packets[0].IS++;
#endif

#ifdef DEBUG_PATHS
	if (FromRF) TraceLogThread("Paths", FALSE, "Accumulating %ld RF Paths (%ld Used) From %s\n", (long) APRS->Path.hopCount, (long) APRS->Path.hopUnused, safebuf);
#endif

	if (ObjStat != MyStation)	/* do this stuff for everyone BUT me! */
	{	ObjStat->LastFromRF = FromRF;
		StrSave(&ObjStat->sLastPacket, &ObjStat->pLastPacket, safebuf HERE);
		strncpy(ObjStat->IGate, APRS->relayCall, sizeof(ObjStat->IGate));
	}

	if (RfPort == RFPORT_INTERNAL)	/* Not much to do with this one */
	{	ObjStat->HeardInternal = TRUE;
	} else if (APRS->Path.TCPIP)	/* Only count the TCP/IP ones */
	{	ObjStat->Packets[0].TCPIP++;
		ObjStat->HeardAsTCPIP = TRUE;
	} else if (FromRF && *APRS->thirdCall)
	{		ObjStat->HeardAsThird = TRUE;	/* Heard as a 3rd party packet */
	} else
	{	if (!FromRF && strcmp(APRS->srcCall, CALLSIGN))	/* I am NOT remote!*/
			ObjStat->HeardRemoteRF = TRUE;
/*
	And now a BUNCH of path analysis
*/
#ifndef NO_PATH_TRACKING
		PACKET_PATH_S *PktPath = (PACKET_PATH_S *)calloc(1,sizeof(*PktPath));
		PacketPathCount++;
		PktPath->FromRF = FromRF;
		PktPath->msec = msNow;
		ReferencePacketPathHop(Station->Station, Station, PktPath, safebuf);
#endif

		for (long h=2; h<APRS->Path.hopCount; h++)
		{	char *tStat = NULL;
			PATH_LINE_TYPE_V Type;

			if (*APRS->Path.Hops[h] == 'q')	/* Found the q-Construct? */
			{	char *q = APRS->Path.Hops[h];
				if (!strcmp(q,"qAC") || !strcmp(q,"qAX") || !strcmp(q,"qAU"))	/* All APRS-IS servers */
					break;	/* No IGates here */
				else if (h+1 >= APRS->Path.hopCount)
					break;	/* Bogus q-Construct at the end */
				else
				{	tStat = APRS->Path.Hops[h+1];	/* Point to the IGate */
					Type = APRS->Path.hopUnused<=2?PATH_LINE_DIRECT:PATH_LINE_LAST;
				}
			} else if (h < APRS->Path.hopUnused)
			{	tStat = APRS->Path.Hops[h];
				Type = h==2?Type=PATH_LINE_FIRST:PATH_LINE_MIDDLE;
			}

			if (tStat	/* Got one to look for? */
			&& !IsPathAlias(tStat))	/* And not an alias? */
			{	size_t hLen = strlen(tStat);
				BOOL MustFree = FALSE;
				if (tStat[hLen-1] == '*')
				{	tStat = strcpy((char*)malloc(hLen+1),tStat);
					tStat[hLen-1] = '\0';	/* Wipe out * */
					MustFree = TRUE;
				}
				STATION_INFO_S *dStation = FindStationCall(tStat);
				ReferencePacketPathHop(tStat, dStation, PktPath, safebuf);	/* NULL is OK here */
				if (dStation)	/* Known station? */
				{
#ifndef NO_PATH_TRACKING
					if (LastStat)
					{	AddPacketPathEntry(Station, LastStat, dStation, Type, msNow, FromRF);	/* Track entire path outbound */
						AddPacketPathEntry(dStation, LastStat, dStation, Type, msNow, FromRF);	/* And all inbounds */
					}
					UpdateStationVisibility(dStation, "PathMiddle", FALSE, FALSE, TRUE);

#ifdef FOR_INFO_ONLY
typedef struct PACKET_PATH_S
{	char FromRF;
	char References;	/* Up to 9, really */
	struct
	{	unsigned long SeenIndex;	/* Who it is */
		COORDINATE_S *pCoord;		/* Where it was */
	} Hops[9];	/* source->path*7->dest */
	__int64 msec;		/* For aging calculations */
} PACKET_PATH_S;
#endif



#endif
					if (*APRS->Path.Hops[h] == 'q')	/* Got the IGate? */
					{	BOOL wasIGate = dStation->HeardAsIGate;
						dStation->HeardAsIGate = TRUE;
						dStation->Packets[0].IGate++;
						if (!wasIGate)
						{	size_t Remaining = 1024;
							char *Buffer = (char *)malloc(Remaining);
							char *Next = Buffer;
							for (long h=0; h<APRS->Path.hopCount; h++)
							{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												"%s%s", h==0?"":(h==1?">":","), APRS->Path.Hops[h]);
							}
#ifdef DEBUG_PATHS
							TraceLogThread("Paths", FALSE, "[%ld] New IGate %s(%s) for %s(%s) with %ld Hops (%s)\n", dStation->Packets[0].IGate, APRS->relayCall, dStation->Station, APRS->srcCall, Station->Station, APRS->Path.hopCount, Buffer);
#endif
							free(Buffer);
						}
						break;	/* We're all done with the path parsing */
					} else if (FromRF)
					{	dStation->HeardAsRFDigi = TRUE;
						dStation->Packets[0].RFDigi++;
					} else
					{	dStation->HeardAsDigi = TRUE;
						dStation->Packets[0].Digi++;
					}
				}
				if (MustFree) free(tStat);
				LastStat = dStation;	/* Even if NULL */
			}
		}
		if (FromRF && LastStat && LastStat != MyStation)
		{	PATH_LINE_TYPE_V Type = LastStat==Station?PATH_LINE_DIRECT:PATH_LINE_LAST;
			AddPacketPathEntry(Station, LastStat, MyStation, Type, msNow, FromRF);	/* Track entire path outbound */
			AddPacketPathEntry(MyStation, LastStat, MyStation, Type, msNow, FromRF);	/* And all inbounds */
			ReferencePacketPathHop(MyStation->Station, MyStation, PktPath, safebuf);
		}
		if (FromRF) UpdateStationVisibility(MyStation, "PathFinal", FALSE, FALSE, TRUE);
		UpdateStationVisibility(Station, "PathFirst", FALSE, FALSE, TRUE);

#ifdef NOT_ANY_MORE
		for (int h=0; h<PktPath->HopCount; h++)
			if (PktPath->Hops[h].pCoord)	/* Don't use SeenStations[0] for unknowns */
				if (!strcmp(SeenStations[PktPath->Hops[h].SeenIndex].Station, CALLSIGN))
				{	TraceLogThread("PathError", TRUE, "PktPath(%p)[%ld]->%ld or %s from %s\n",
									PktPath, (long) h, (long) PktPath->Hops[h].SeenIndex,
									SeenStations[PktPath->Hops[h].SeenIndex].Station, safebuf);
					ShowTraceLog("PathError");
				}
#endif
	}

#ifdef OBSOLETE
		if (*APRS->relayCall)
		{	STATION_INFO_S *rStation = FindStationCall(APRS->relayCall);
			if (rStation)
			{	BOOL wasIGate = rStation->HeardAsIGate;
				rStation->HeardAsIGate = TRUE;
				rStation->Packets[0].IGate++;
				if (!wasIGate)
				{	size_t Remaining = 1024;
					char *Buffer = (char *)malloc(Remaining);
					char *Next = Buffer;
					for (long h=0; h<APRS->Path.hopCount; h++)
					{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s%s", h==0?"":(h==1?">":","), APRS->Path.Hops[h]);
					}
					TraceLogThread("LWDTest", TRUE, "[%ld] New IGate %s(%s) for %s(%s) with %ld Hops (%s)\n", rStation->Packets[0].IGate, APRS->relayCall, rStation->Station, APRS->srcCall, Station->Station, APRS->Path.hopCount, Buffer);
					free(Buffer);
				}
			}
		}
#endif
}

static void UpdateStationScrollerPath(STATION_INFO_S *Station, STATION_SCROLLER_S *Scroll, APRS_PARSED_INFO_S *APRS, BOOL FromRF, unsigned long RfPort, __int64 msNow, SYSTEMTIME *pstSystem)
{
	if (!Station) return;

	if (Scroll)
	{	Scroll->CloseIndex = Station->Index;	/* Remember for distance color */
		if (HasNickLabelNonBlank(Station))
			strncpy(Scroll->Label, Station->Nickname->Label,
					sizeof(Scroll->Label));
	}

	if (!*APRS->thirdCall)	/* NOT third-party traffic */
	{	int h, l=0, e, extra=0, f=TRUE;
		char *path;
		for (e=2; e<APRS->Path.hopCount; e++)
		{	if (*APRS->Path.Hops[e] == 'q')	/* Stop at the q-Construct */
				break;
			l += strlen(APRS->Path.Hops[e]);
		}
		if (Station->isObject)
			extra = sizeof(Station->Owner)+2;
		path = (char*)malloc(l+APRS->Path.hopCount-2+1+extra);
		*path = '\0';
		if (extra) strcat(strncpy(path,Station->Owner,sizeof(Station->Owner)),"->");
		for (h=2; h<e; h++)
		{	if (!f) strcat(path,",");
			strcat(path,APRS->Path.Hops[h]);
			f = FALSE;
		}

		if (FromRF)
		{	int Used = APRS->Path.hopUnused-2;
			if (Station->RFCRC32 == APRS->CRC32
			&& llMsecSince(Station->lastRFMsec, msNow) < DUPLICATE_DETECT_SECONDS*1000)
			{	Station->RFDupes++;
			} else
			{	Station->RFDupes = 0;
				Station->RFCRC32 = APRS->CRC32;
			}
			if (Scroll)
			{	if (!Scroll->HeardOnRF
				|| Scroll->HeardOnRF > Used+1)
				{	Scroll->HeardOnRF = Used+1;
				}
			}
			if (!Station->HeardOnRF
			|| Station->HeardOnRF > Used+1)
			{	if (!*APRS->thirdCall) Station->HeardOnRF = Used+1;
				StrSave(&Station->sRFpath, &Station->pRFpath, path HERE);
			} else if (!Station->RFDupes)	/* New one */
			{	StrSave(&Station->sRFpath, &Station->pRFpath, path HERE);
			}
			Station->lastRFMsec = msNow;	/* Mark the time */
		} else if (Station != MyStation)	/* Don't clobber my original path! */
		{	if (Station->CRC32 == APRS->CRC32
			&& llMsecSince(Station->lastMsec, msNow) < DUPLICATE_DETECT_SECONDS*1000)
			{	Station->Dupes++;
			} else
			{	Station->Dupes = 0;
				Station->CRC32 = APRS->CRC32;
				StrSave(&Station->sPath, &Station->pPath, path HERE);
			}
		}
		free(path);
	}
	if (Station != MyStation)	/* MyStation tracks uptime */
		if (pstSystem)
			Station->stLast = *pstSystem;
	Station->lastMsec = msNow;
}

static unsigned long InsideLogPacket = 0;
static char InsideProcessing[1024];

STATION_INFO_S *AprsLogPacket(char *Why, HWND hwnd, CLIENT_INFO_S *Info, char *safebuf, BOOL FromRF, unsigned long RfPort=0, __int64 msNow=0, SYSTEMTIME *pstSystem=NULL, BOOL NoPopups=FALSE)
{	APRS_PARSED_INFO_S *APRS = (APRS_PARSED_INFO_S *) malloc(sizeof(*APRS));
	STATION_INFO_S *Result = NULL;
	unsigned long st = -1;	/* Index to Station scrolling list */
	SYSTEMTIME stSystem;
	BOOL isRFDupe = FALSE;
	__int64 Start = llGetMsec();
	__int64 msStart = Start;
static __int64 msLast=0, msMax=0;
static __int64 msLast1=0, msMax1=0;
	char *InBuf = _strdup(safebuf);

	if (!msNow) msNow = llGetMsec();
	if (!pstSystem)
	{	pstSystem = &stSystem;
		GetSystemTime(pstSystem);
	} else stSystem = *pstSystem;

	if (InsideLogPacket++)		/* Prevent recursion! */
	{	TraceError(hwnd, "Recursing[%ld] AprsLogPacket(%s RfPort(%ld) %s\n\tWas(%s)\n",
					(long) InsideLogPacket, Why, RfPort, InBuf, InsideProcessing);
	}
	strncpy(InsideProcessing, InBuf, sizeof(InsideProcessing));

#ifndef UNDER_CE
	strncpy(gCurrentPacket, InBuf, sizeof(gCurrentPacket));	// Record for crash dump
#endif

	if (!CloseStationCount) DefineME(hwnd);
	if (!PacketScrollerSize
	|| PacketScrollerSize < ActiveConfig.PacketScrollerSize)
	{	ReSizePacketScroller(hwnd);
	}

	BOOL pIndexValid = RfPort>=0 && RfPort<ActiveConfig.RFPorts.Count;
	PORT_CONFIG_INFO_S *pPort = pIndexValid?&ActiveConfig.RFPorts.Port[RfPort]:NULL;
	if (!pPort)
	switch (RfPort)
	{
	case APRSISWP:	pPort = &APRSISPort; break;
	case GPSWP:		pPort = &GPSPort; break;
	case RFPORT_INTERNAL:
	{
static PORT_CONFIG_INFO_S InternalPort = {0};
		strncpy(InternalPort.Name, "*INT*", sizeof(InternalPort.Name));
		strncpy(InternalPort.Protocol, "Internal", sizeof(InternalPort.Protocol)); 
		pPort = &InternalPort;
		break;
	}
	}

#ifdef SUPPORT_HOURLY_PACKET_COUNT
	if (!NoPopups)	/* Don't count startups */
	{	if (LastPacketHour == -1) stHourlyStart[0] = stSystem;	/* Get the first one */
		else if (LastPacketHour != stSystem.wHour)	/* Shuffle all packet counts down */
		{	unsigned long s;
			memmove(&stHourlyStart[1], &stHourlyStart[0], sizeof(stHourlyStart)-sizeof(stHourlyStart[0]));
			stHourlyStart[0] = stSystem;
			for (s=0; s<CloseStationCount; s++)
			{	memmove(&pCloseStations[s]->Packets[1], &pCloseStations[s]->Packets[0],
						sizeof(pCloseStations[s]->Packets)-sizeof(pCloseStations[s]->Packets[0]));
				memset(&pCloseStations[s]->Packets[0], 0, sizeof(pCloseStations[s]->Packets[0]));
			}
			for (s=0; s<PortPacketCount; s++)
			{	memmove(&PortPackets[s].DX[1], &PortPackets[s].DX[0],
						sizeof(PortPackets[s].DX)-sizeof(PortPackets[s].DX[0]));
				memset(&PortPackets[s].DX[0], 0, sizeof(PortPackets[s].DX[0]));
#define DOPKT(w) \
	memmove(&PortPackets[s].w[1], &PortPackets[s].w[0], sizeof(PortPackets[s].w)-sizeof(PortPackets[s].w[0])); \
	memset(&PortPackets[s].w[0], 0, sizeof(PortPackets[s].w[0]))
				DOPKT(RcvPackets);
				DOPKT(XmtPackets);
				DOPKT(PktPosition);
				DOPKT(PktObject);
				DOPKT(PktItem);
				DOPKT(PktMessage);
				DOPKT(PktQuery);
				DOPKT(PktStatus);
				DOPKT(PktTelemetry);
				DOPKT(PktUser);
				DOPKT(PktNWS);
				DOPKT(PktWeather);
				DOPKT(PktOther);
#undef DOPKT
			}
#ifdef TRACK_FIND_STATIONS
			memmove(&Find1Stations[1], &Find1Stations[0], sizeof(Find1Stations)-sizeof(Find1Stations[0]));
			memset(&Find1Stations[0], 0, sizeof(Find1Stations[0]));
			memmove(&Find2Stations[1], &Find2Stations[0], sizeof(Find2Stations)-sizeof(Find2Stations[0]));
			memset(&Find2Stations[0], 0, sizeof(Find2Stations[0]));
			memmove(&SortStations[1], &SortStations[0], sizeof(SortStations)-sizeof(SortStations[0]));
			memset(&SortStations[0], 0, sizeof(SortStations[0]));
			memmove(&NewStations[1], &NewStations[0], sizeof(NewStations)-sizeof(NewStations[0]));
			memset(&NewStations[0], 0, sizeof(NewStations[0]));
			memmove(&OldStations[1], &OldStations[0], sizeof(OldStations)-sizeof(OldStations[0]));
			memset(&OldStations[0], 0, sizeof(OldStations[0]));
#endif
#define DOPKT(w) \
	memmove(&w[1], &w[0], sizeof(w)-sizeof(w[0])); \
	memset(&w[0], 0, sizeof(w[0]))
			DOPKT(PktPosition);
			DOPKT(PktObject);
			DOPKT(PktItem);
			DOPKT(PktMessage);
			DOPKT(PktQuery);
			DOPKT(PktStatus);
			DOPKT(PktTelemetry);
			DOPKT(PktUser);
			DOPKT(PktNWS);
			DOPKT(PktWeather);
			DOPKT(PktOther);
#undef DOPKT

{	char Buffer[80];
	sprintf(Buffer,"Hourly(%ld+%ld)",CloseStationCount,PortPacketCount);
	Start = DebugTimer("AprsLogPacket",Buffer,Start,&msMax,&msLast, hwnd);
}
			LastPacketHour = stHourlyStart[0].wHour;
		}
	}
#endif

#ifdef SUPPORT_HOURLY_PACKET_COUNT
	unsigned long ppc = GetPortPacketIndex(RfPort,NULL);
#endif
	if (FromRF)
	{	if (RfPort >= 0 && RfPort < ActiveConfig.RFPorts.Count)
		{	PORT_CONFIG_INFO_S *pPort= &ActiveConfig.RFPorts.Port[RfPort];
			if (ActiveConfig.Enables.RFPktLog
			&& !pPort->NotRF)	/* Actually RF? */
			{	char *Name = GetPktLogFileName(hwnd);
				if (Name && *Name)
				{	FILE *Log = fopen(Name,"a+");
					if (Log)
					{	SYSTEMTIME st;
						GetSystemTime(&st);
						fprintf(Log, "%04d-%02d-%02d %02d:%02d:%02d RF(%s) %s\n",
								(int) st.wYear, (int) st.wMonth, (int) st.wDay,
								(int) st.wHour, (int) st.wMinute, (int) st.wSecond,
								pPort->Name,
								InBuf);
						fclose(Log);
					}
					TraceLog("Packets", Log==NULL, hwnd, "RF[%s][%ld] %s", ActiveConfig.RFPorts.Port[RfPort].Name, pPort->RfBaud, InBuf);
				}
			} else 	TraceLog("Packets", FALSE, hwnd, "RF[%s][%ld] %s", pPort->Name, pPort->RfBaud, InBuf);
		} else
		{	TraceLog("Packets", FALSE, hwnd, "RF[%s] %s",
						pPort?pPort->Name:"*NULL*", InBuf);
		}
Start = DebugTimer("AprsLogPacket","RFPacketLog",Start,&msMax,&msLast, hwnd);
	} else
	{
		if (RfPort == RFPORT_INTERNAL)
		{	TraceLogThread("Transmit", FALSE, "Transmit(INT) %s\n", InBuf);
			TraceLog("Packets(Internal)", FALSE, hwnd, "%s", InBuf);
		}
		TraceLog("Packets", FALSE, hwnd, "IS[%s] %s",
				NoPopups?"Recovery":(pPort?pPort->Name:"*NULL*"), InBuf);
Start = DebugTimer("AprsLogPacket","PacketLog",Start,&msMax,&msLast, hwnd);
	}
#ifdef SUPPORT_HOURLY_PACKET_COUNT
	if (!NoPopups)	/* Don't count recoveries */
	{	if (PortPackets[ppc].wpPort != RfPort+1)
		{	TraceLog("PortPackets", TRUE, hwnd, "%sInitializing PortPackets[%ld/%ld] for RfPort:%ld - Log was %ld\n",
					PortPackets[ppc].wpPort?"Re-":"", ppc, PortPacketCount, RfPort, PortPackets[ppc].wpPort);
			memset(&PortPackets[ppc], 0, sizeof(PortPackets[ppc]));
			PortPackets[ppc].wpPort = RfPort+1;
		}
		PortPackets[ppc].RcvPackets[0]++;
	}
#endif

	if (IsTraceLogEnabled("MyCall"))
	{	char *c;
		for (c=InBuf; *c; c++)
		{	if (toupper(*c) == *CALLSIGN)
			{	size_t i;
				for (i=1; i<sizeof(CALLSIGN); i++)
				{	if (!CALLSIGN[i]) break;
					if (toupper(c[i]) != CALLSIGN[i]) break;
					if (CALLSIGN[i] == '-') break;
				}
				if (i>=sizeof(CALLSIGN) || !CALLSIGN[i] || CALLSIGN[i] == '-')
				{	TraceLog("MyCall", TRUE, hwnd, "[%s] %s", Why, InBuf);
					break;
				}
			}
		}
	}

	if (!parse_full_aprs(InBuf, APRS) || !APRS->srcCall[0])
	{	char *e = strchr(InBuf,'>');
Start = DebugTimer("AprsLogPacket","NoParse",Start,&msMax,&msLast, hwnd);
TraceLog("NoParse", FALSE, hwnd, "%s %s\n", APRS?(APRS->ParseError?APRS->ParseError:"*UNKNOWN*"):"*NULL*", safebuf);
		if (e)
		{	*e = 0;
			if (ActiveConfig.Scroller.ShowAll
			|| !ActiveConfig.Scroller.HideNoParse)
			if (strncmp(Stations[0].Owner, InBuf, sizeof(Stations[0].Owner)))
			{	int s1 = PacketScrollerSize-1;	/* Size minus 1 */
				memmove(&Stations[1], &Stations[0], sizeof(Stations[0])*s1);
				st = 0;	/* Remember the used entry */
				memset(&Stations[st], 0, sizeof(Stations[st]));	/* Initialize additional elements */
				strncpy(Stations[st].Station, InBuf, sizeof(Stations[st].Station));
				strncpy(Stations[st].Owner, InBuf, sizeof(Stations[st].Owner));
				strncpy(Stations[st].Label, InBuf, sizeof(Stations[st].Label));
				strncpy(Stations[st].Packet, safebuf, sizeof(Stations[st].Packet));
				Stations[st].Packet[sizeof(Stations[st].Packet)-1] = '\0';	/* Null terminate */
				Stations[st].stPacket = *pstSystem;
				Stations[st].BackColor = GetSysColor(COLOR_WINDOW);
				Stations[st].CloseIndex = -1;	/* Unknown entry */
				if (FromRF) Stations[st].HeardOnRF = 7;	/* Arbitrarily high number */
				PendingStationsCount++;	/* Got one to copy to PaintingStations */
			}
			*e = '>';
Start = DebugTimer("AprsLogPacket","Scroller",Start,&msMax,&msLast, hwnd);
		}
	} else	/* Parse succeeded, trust the APRS-> structure */
	{	long dp, dFound=FALSE;
		long d;
		BOOL MsgNew = FALSE;	/* TRUE if a message station is new */

#ifndef UNDER_CE
		if (ActiveConfig.Update.Development
		&& APRS->relayCall[0])	/* Must have a q-construct */
		{	if (strchr(APRS->relayCall,'*'))	/* Used? */
				TraceLogThread("Concat", FALSE, "Q*: %s\n", safebuf);
		}
#endif

Start = DebugTimer("AprsLogPacket","Parse",Start,&msMax,&msLast, hwnd);

		if (!(APRS->Valid & APRS_OBJECT_VALID)
		&& !(APRS->Valid & APRS_ITEM_VALID))
			strncpy(APRS->objCall, APRS->srcCall, sizeof(APRS->objCall));

		for (dp=DupeStart, d=0; d<DupeInUse; d++, dp--)
		{	if (dp < 0) dp = DupeSize-1;
			else if (dp >= DupeSize) dp = 0;	/* Wrap the indexer */

#ifdef VERBOSE
TraceLog("Dupes", FALSE, hwnd, "Checking %ld/%ld [%ld/%ld]=%ldmsec old\n",
		 (long) d, (long) DupeInUse, (long) dp, (long) DupeSize,
		 (long) llMsecSince(Dupes[dp].lastMsec,msNow));
#endif

			if (llMsecSince(Dupes[dp].lastMsec, msNow) > DUPLICATE_DETECT_SECONDS*1000)
			{
#ifdef VERBOSE
TraceLog("Dupes", FALSE, hwnd, "Dropping DupeInUse from %ld to %ld of %ld at [%ld]=%ldms\n",
		 (long) DupeInUse, (long) d, (long) DupeSize,
		 (long) dp, (long) llMsecSince(Dupes[dp].lastMsec,msNow));
#endif
				if (!strcmp(CALLSIGN,"KJ4ERJ-RO")
				&& IsTraceLogEnabled("PacketLoss"))
				{	int d2 = d;
					for (; d2<DupeInUse; d2++, dp--)
					{	if (dp < 0) dp = DupeSize-1;
						else if (dp >= DupeSize) dp = 0;	/* Wrap the indexer */
						if (Dupes[dp].ISDupeCount
						&& Dupes[dp].ISDupeCount+1 < OKPortCount)
						{	size_t hRemain = (OKPortCount+1)*sizeof(ActiveConfig.RFPorts.Port[0].Name);
							char *hBuff = (char*)malloc(hRemain);
							char *hNext = hBuff;
							*hNext = '\0';
				
							for (int p=0; p<PortStatusCount; p++)
							if (PortStatuses[p].WasOK)
							if (PortStatuses[p].wp >= 0 && PortStatuses[p].wp < 32)
							if (!(Dupes[dp].PortsHeard&(1<<PortStatuses[p].wp)))
							{	StringCbPrintfExA(hNext, hRemain, &hNext, &hRemain, STRSAFE_IGNORE_NULLS,
												"%s%s", *hBuff?" ":" [",
												ActiveConfig.RFPorts.Port[PortStatuses[p].wp].Name);
							}
							if (*hBuff) StringCbPrintfExA(hNext, hRemain, &hNext, &hRemain, STRSAFE_IGNORE_NULLS, "]");
							TraceLog("PacketLoss", TRUE, hwnd,
									"%ld/%ld%s %.*s\n",
									Dupes[dp].ISDupeCount+1,
									OKPortCount, hBuff,
									Dupes[dp].PacketUse,
									Dupes[dp].pPacket);
							free(hBuff);
						}
					}
				}
				if (DupeInUse != d) InvalidateStatUsage(FALSE);
				DupeInUse = d;	/* Only using this many now */
				break;	/* Done looking backwards */
			}
			if (Dupes[dp].CRC32 == APRS->CRC32
			&& !strncmp(Dupes[dp].Station, APRS->objCall, sizeof(Dupes[dp].Station))
			&& !strncmp(Dupes[dp].Owner, APRS->srcCall, sizeof(Dupes[dp].Owner)))
			{
				if (strncmp(Dupes[dp].ToCall, APRS->dstCall,
							sizeof(Dupes[dp].ToCall)))
				{	TraceLog(FromRF?"Packets":"Packets(ISDupe)", FALSE, hwnd, "(Near)DUPE[%ldms]IS[%s] %.*s>%.*s Changed To >%.*s in Raw:%s",
								(long) llMsecSince(Dupes[dp].lastMsec, msNow),
								pPort?pPort->Name:"*NULL*",
								STRING(APRS->srcCall),
								STRING(Dupes[dp].ToCall),
								STRING(APRS->dstCall),
								safebuf);
				} else
				{	dFound = TRUE;
					break;
				}
			}
		}

		if (dFound)
		{	if (FromRF)
			{	Dupes[dp].RFDupeCount++;
			} else
			{	Dupes[dp].ISDupeCount++;

{	char *p1 = strchr(safebuf, ':');
	char *p2 = strchr(Dupes[dp].pPacket, ':');
	if (p1 && p2 && strcmp(p1, p2))
	{	
		TraceLog("Packets(ISDupe)", FALSE, hwnd, "NOT-DUPE[%ldms]IS[%s] %.*s %ld vs %ld Raw: %s",
					(long) llMsecSince(Dupes[dp].lastMsec, msNow),
					pPort?pPort->Name:"*NULL*",
					STRING(APRS->srcCall),
					strlen(p1), strlen(p2),
					safebuf);
	}
}
				if (Dupes[dp].LastISPort == RfPort)
				{	if (RfPort == APRSISWP) PacketsDupe++;
					if (!strncmp(Dupes[dp].qConstruct,
								APRS->Path.Hops[APRS->Path.hopCount-2],
								sizeof(Dupes[dp].qConstruct))
					&& !strncmp(Dupes[dp].IGate,
								APRS->Path.Hops[APRS->Path.hopCount-1],
								sizeof(Dupes[dp].IGate)))
					TraceLog("Packets(ISDupe)", FALSE, hwnd, "TRUE-DUPE[%ldms]IS[%s] %.*s %.*s %.*s in Raw:%s",
								(long) llMsecSince(Dupes[dp].lastMsec, msNow),
								pPort?pPort->Name:"*NULL*",
								STRING(APRS->srcCall),
								STRING(Dupes[dp].qConstruct),
								STRING(Dupes[dp].IGate),
								safebuf);
					else TraceLog("Packets(ISDupe)", FALSE, hwnd, "DUPE[%ldms]IS[%s] %.*s %.*s %.*s now %.*s %.*s in Raw:%s",
								(long) llMsecSince(Dupes[dp].lastMsec, msNow),
								pPort?pPort->Name:"*NULL*",
								STRING(APRS->srcCall),
								STRING(Dupes[dp].qConstruct),
								STRING(Dupes[dp].IGate),
								STRING(APRS->Path.Hops[APRS->Path.hopCount-2]),
								STRING(APRS->Path.Hops[APRS->Path.hopCount-1]),
								safebuf);
				}
			}

			if (FromRF)
			if (Dupes[dp].LastFromRF
			|| Dupes[dp].RFDupeCount > 1)
				isRFDupe = TRUE;
		} else
		{	if (DupeInUse >= DupeSize)	/* Full up table */
			{	DUPE_CHECK_S *NewDupes;
				unsigned long NewSize = DupeSize + DUPLICATE_DETECT_SECONDS;	/* Add 1/sec more */

#ifdef VERBOSE
TraceLog("Dupes", TRUE, hwnd, "Growing from %ld to %ld (Using %ld)\n", (long) DupeSize, (long) NewSize, DupeInUse);
#endif
				NewDupes = (DUPE_CHECK_S *)calloc(NewSize, sizeof(*NewDupes));
				for (dp=DupeStart, d=DupeInUse-1; d>=0; d--, dp--)
				{	if (dp < 0) dp = DupeSize-1;	/* Wrap the indexer */
					else if (dp >= DupeSize) dp = 0;
					NewDupes[d] = Dupes[dp];
				}
				if (Dupes) free(Dupes);
				DupeStart = DupeInUse;	/* Newest entry */
				DupeSize = NewSize;
				Dupes = NewDupes;
				dp = DupeInUse;	/* Where new one goes */
			} else
			{	dp = ++DupeStart;
				if (dp >= DupeSize) dp = 0;
				else if (dp < 0) dp = DupeSize-1;
				DupeStart = dp;
#ifdef VERBOSE
TraceLog("Dupes", FALSE, hwnd, "(Re?)Using [%ld] InUse %ld/%ld\n",
			  (long) dp, (long) DupeInUse, (long) DupeSize);
#endif
			}

			InvalidateStatUsage(FALSE);
			DupeInUse++;	/* Count the newly used entry */
			if (DupeInUse > DupeUseMax) DupeUseMax = DupeInUse;
			{	int Size = Dupes[dp].PacketSize;	/* Save the packet */
				char *Packet = Dupes[dp].pPacket;
				memset(&Dupes[dp], 0, sizeof(Dupes[dp]));	/* Initialize new entry */
				Dupes[dp].PacketSize = Size;
				Dupes[dp].pPacket = Packet;
			}
			Dupes[dp].DupeUseCount = ++DupeUseCount;
			strncpy(Dupes[dp].Station, APRS->objCall, sizeof(Dupes[dp].Station));
			strncpy(Dupes[dp].Owner, APRS->srcCall, sizeof(Dupes[dp].Owner));
			strncpy(Dupes[dp].ToCall, APRS->dstCall, sizeof(Dupes[dp].ToCall));
			strncpy(Dupes[dp].qConstruct, APRS->Path.Hops[APRS->Path.hopCount-2], sizeof(Dupes[dp].qConstruct));
			strncpy(Dupes[dp].IGate, APRS->Path.Hops[APRS->Path.hopCount-1], sizeof(Dupes[dp].IGate));
			Dupes[dp].CRC32 = APRS->CRC32;
			Dupes[dp].lastMsec = msNow;	/* Stamp it once only when new */
		}
#ifdef VERBOSE
TraceLog("Dupes", FALSE, hwnd, "Populating [%ld] or %ld/%ld with %s\n",
		 (long) dp, (long) DupeInUse, (long) DupeSize, safebuf);
#endif
		// Dupes[dp].lastMsec = msNow;	/* Don't do this out here! */
		Dupes[dp].LastFromRF = FromRF;
		if (!FromRF) Dupes[dp].LastISPort = RfPort;
		if (RfPort >= 0 && RfPort < 32)
		{	if (!strcmp(CALLSIGN,"KJ4ERJ-RO")
			&& IsTraceLogEnabled("PacketLoss")
			&& (Dupes[dp].PortsHeard & (1<<RfPort)))
				TraceLog("PacketLoss", FALSE, hwnd, "%sDuplicate[%s](%ldms) %s\n",
							strncmp(Dupes[dp].pPacket, safebuf, Dupes[dp].PacketUse)?"NOT ":"",
							pPort?pPort->Name:"*NULL*",
							(long) llMsecSince(Dupes[dp].lastMsec, msNow),
							safebuf);
			Dupes[dp].PortsHeard |= 1<<RfPort;
		}
		{	int PktLen = strlen(safebuf)+1;
			if (Dupes[dp].PacketSize < PktLen)
			{	if (Dupes[dp].pPacket)
					free(Dupes[dp].pPacket);
#ifdef VERBOSE
TraceLog("Dupes", Dupes[dp].PacketSize, hwnd, "Increasing [%ld].pPacket from %ld to %ld bytes for %s\n",
		 (long) dp, (long) Dupes[dp].PacketSize, PktLen, safebuf);
#endif
				Dupes[dp].PacketSize = PktLen;
				Dupes[dp].pPacket = (char*)malloc(PktLen);
			}
			Dupes[dp].PacketUse = PktLen;
			memcpy(Dupes[dp].pPacket, safebuf, PktLen);
		}
Start = DebugTimer("AprsLogPacket","Dupes",Start,&msMax,&msLast, hwnd);
/*
	Not a dupe, count it by type
*/
		if (!NoPopups)	/* Don't count recoveries */
		{	int Did = 0;
#define INC(w) { PortPackets[ppc].w[0]++; if (!dFound) w[0]++; Did++; }	/* Hopefully [ppc] is always ok */
			if (APRS->Valid & APRS_LATLON_VALID) INC(PktPosition)
			if (APRS->Valid & APRS_OBJECT_VALID) INC(PktObject)
			if (APRS->Valid & APRS_ITEM_VALID) INC(PktItem)
			if (APRS->Valid & APRS_MESSAGE_VALID) INC(PktMessage)
			if (APRS->datatype == '?') INC(PktQuery)
			if (APRS->datatype == '>') INC(PktStatus);
			if ((APRS->Valid & APRS_TELEMETRY_VALID)
			|| (APRS->Valid & APRS_TELEMETRYDEF_VALID)) INC(PktTelemetry)
			if (APRS->datatype == '{') INC(PktUser)
			if (APRS->Valid & APRS_NWS_VALID) INC(PktNWS)
			if (APRS->Valid & APRS_WEATHER_VALID) INC(PktWeather)
			if (!Did) INC(PktOther)
#undef INC
		}

/*
	Now copy into the scrolling station buffer if allowed
*/
		st = -1;	/* Establish a default */
		if (!NoPopups)	/* Don't scroll recoveries */
		if (ActiveConfig.Scroller.ShowAll
		|| !ActiveConfig.Scroller.NoInternals
		|| RfPort != RFPORT_INTERNAL)
		if (ActiveConfig.Scroller.ShowAll
		|| !ActiveConfig.Scroller.RFOnly
		|| FromRF)
		if (ActiveConfig.Scroller.ShowAll
		|| !ActiveConfig.Scroller.NotME
		|| strncmp(APRS->srcCall, CALLSIGN, sizeof(APRS->srcCall)))
		if (ActiveConfig.Scroller.ShowAll
		|| !ActiveConfig.Scroller.NotMine
		|| !IsSameBaseCallsign(APRS->srcCall, CALLSIGN))
		if (ActiveConfig.Scroller.ShowAll
		|| !ScrollerFilter.FilterText
		|| !*ScrollerFilter.FilterText
		|| FilterPacket(&ScrollerFilter, APRS))
		{
			for (st=0; st<PacketScrollerSize; st++)
				if (Stations[st].DupeUseCount == Dupes[dp].DupeUseCount)
					break;

			if (ActiveConfig.Scroller.ShowIGateOrDigi	/* Force a new one for this setting */
			|| st >= PacketScrollerSize)	/* Not found */
			{	int h, s1 = PacketScrollerSize-1;	/* Size minus 1 */
				memmove(&Stations[1], &Stations[0], sizeof(Stations[0])*s1);
				memset(&Stations[0], 0, sizeof(Stations[0]));	/* Initialize additional elements */
				st = 0;
				strncpy(Stations[st].Station, APRS->objCall, sizeof(Stations[st].Station));
				strncpy(Stations[st].Owner, APRS->srcCall, sizeof(Stations[st].Owner));
				strncpy(Stations[st].Label, APRS->objCall, sizeof(Stations[st].Label));
				strncpy(Stations[st].Packet, safebuf, sizeof(Stations[st].Packet));
				Stations[st].Packet[sizeof(Stations[st].Packet)-1] = '\0';	/* Null terminate */
				Stations[st].stPacket = *pstSystem;
				if (RfPort == RFPORT_INTERNAL)
					strncpy(Stations[st].IGateOrDigi, "*Int*", sizeof(Stations[st].IGateOrDigi));
				else if (FromRF)
				{	if (*APRS->thirdCall)
						strncpy(Stations[st].IGateOrDigi, APRS->thirdCall, sizeof(Stations[st].IGateOrDigi));
					else
					{	int h = APRS->Path.hopUnused-1;
						if (h <= 1)	/* direct reception? */
							strncpy(Stations[st].IGateOrDigi, APRS->srcCall, sizeof(Stations[st].IGateOrDigi));
						else
						{	while (h > 2 && IsPathAlias(APRS->Path.Hops[h]))
								h--;
							strncpy(Stations[st].IGateOrDigi, APRS->Path.Hops[h], sizeof(Stations[st].IGateOrDigi));
							if (Stations[st].IGateOrDigi[strlen(Stations[st].IGateOrDigi)-1] == '*')
								Stations[st].IGateOrDigi[strlen(Stations[st].IGateOrDigi)-1] = '\0';
						}
						// Stations[st].UsedHops = APRS->Path.hopUnused-2;
					}
				} else
				{	h = APRS->Path.hopCount;
					while (h >= 4)
					{	if (*APRS->Path.Hops[h-2] == 'q')	/* Find the q-Construct */
							break;
						h--;
					}
					if (h >= 4)
					{	char *q = APRS->Path.Hops[h-2];
						if (!strcmp(q,"qAC") || !strcmp(q,"qAX") || !strcmp(q,"qAU"))	/* All APRS-IS servers */
							strncpy(Stations[st].IGateOrDigi, APRS->srcCall, sizeof(Stations[st].IGateOrDigi));
						else
						{	strncpy(Stations[st].IGateOrDigi, APRS->Path.Hops[h-1], sizeof(Stations[st].IGateOrDigi));
							if (Stations[st].IGateOrDigi[strlen(Stations[st].IGateOrDigi)-1] == '*')
								Stations[st].IGateOrDigi[strlen(Stations[st].IGateOrDigi)-1] = '\0';
						}
					} else strncpy(Stations[st].IGateOrDigi, "*NoQ*", sizeof(Stations[st].IGateOrDigi));
				}
				Stations[st].HeardViaTCP = FALSE;
				for (h=2; h<APRS->Path.hopCount; h++)
				{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
					if (IsTcpPath(APRS->Path.Hops[h]))
					{	Stations[st].HeardViaTCP = TRUE;
						break;
					}
				}
				Stations[st].aUsedHops = 0;
				for (h=2; h<APRS->Path.hopUnused; h++)
				{	if (!IsPathAlias(APRS->Path.Hops[h]))
					{	Stations[st].aUsedHops++;
					}
				}
				Stations[st].pUsedHops = APRS->Path.hopUnused-2;
				Stations[st].CloseIndex = -1;	/* Unknown entry */
				Stations[st].DupeUseCount = Dupes[dp].DupeUseCount;
				PendingStationsCount++;	/* Got one to copy to PaintingStations */
			}

			if (FromRF && *APRS->thirdCall)
				Stations[st].HeardAsThird = TRUE;
			Stations[st].RFDupeCount = Dupes[dp].RFDupeCount;
			Stations[st].ISDupeCount = Dupes[dp].ISDupeCount;

#ifdef REMOVE_NON_MISSING
				if (!strcmp(CALLSIGN,"KJ4ERJ-RO")
				&& IsTraceLogEnabled("PacketLoss"))
				{	int d2 = d;
					for (; d2<DupeInUse; d2++, dp--)
					{	if (dp < 0) dp = DupeSize-1;
						else if (dp >= DupeSize) dp = 0;	/* Wrap the indexer */
						if (Dupes[dp].ISDupeCount
						&& Dupes[dp].ISDupeCount+1 < OKPortCount)
#endif

		}
Start = DebugTimer("AprsLogPacket","Scroller",Start,&msMax,&msLast, hwnd);

#ifndef UNDER_CE
		if (ActiveConfig.Update.Development		// Only Development mode
		&& ActiveConfig.AccumulateAliases)
			CheckPathAliases(APRS, safebuf);
#endif

/*
	Figure out if we think this packet is worth DigiPeating...
*/
//	STRING_LIST_S DigiXforms;	/* List of callsign-SSID>callsign-SSID */

		if (FromRF)	/* We only digi things heard from RF */
		if (ActiveConfig.DigiXforms.Count)	/* We need at least one transform */
		if (!*APRS->thirdCall)					/* We can't (yet) digi 3rd party packets */
		if (!Dupes[dp].Digipeated)		/* We already digi'd this one */
		if (APRS->Path.hopCount > 2)					/* Need at least one hop for alias */
		if (APRS->Path.hopUnused < APRS->Path.hopCount)	/* Need at least on unused hop */
		if (APRS->Path.hopCount < 10)				/* Need room for a substitution */
		if (*CALLSIGN!=*APRS->Path.Hops[0] || strncmp(CALLSIGN,APRS->Path.Hops[0],sizeof(APRS->Path.Hops[0])))		/* Not from me */
		{	char *Payload = strchr(safebuf,':');	/* : delimits the end of the header */
			if (Payload++)						/* We need a colon and we need to skip over the : */
			if (*Payload && *Payload == APRS->datatype)	/* And the datatype better be there! */
			{	unsigned long t;
				char *Transform = NULL;
				BOOL FreeTransform = FALSE;
				size_t l = strlen(APRS->Path.Hops[APRS->Path.hopUnused]);

				if (*APRS->Path.Hops[APRS->Path.hopUnused] == *CALLSIGN
				&& !strncmp(APRS->Path.Hops[APRS->Path.hopUnused], CALLSIGN, sizeof(APRS->Path.Hops[APRS->Path.hopUnused])))	/* if it is me, use a special transform */
				{	size_t tLen = strlen(CALLSIGN)+2;
					Transform = (char*)malloc(tLen);
					StringCbPrintfA(Transform, tLen, "%s=", CALLSIGN);
					FreeTransform = TRUE;
				} else for (t=0; t<ActiveConfig.DigiXforms.Count; t++)
				{
#ifdef USE_TIMED_STRINGS
					if (ActiveConfig.DigiXforms.Entries[t].string[l] == '='
					&& !strncmp(APRS->Path.Hops[APRS->Path.hopUnused], ActiveConfig.DigiXforms.Entries[t].string, l))
					{	Transform = ActiveConfig.DigiXforms.Entries[t].string;
						break;
					}
#else
					if (ActiveConfig.DigiXforms.Strings[t][l] == '='
					&& !strncmp(APRS->Path.Hops[APRS->Path.hopUnused], ActiveConfig.DigiXforms.Strings[t], l))
					{	Transform = ActiveConfig.DigiXforms.Strings[t];
						break;
					}
#endif
				}
				if (Transform)	/* We have a transform, build up the new packet */
				{	int h;
					int FoundMe = FALSE;
					size_t Remaining = strlen(safebuf)+strlen(CALLSIGN)+1+strlen(Transform)+1;
					char *Buffer = (char*)malloc(Remaining);
					char *Next = Buffer;
					char *NewPath = Transform+l+1;	/* Point after the = */
					BOOL NoID = FALSE;
					BOOL TrashUsed = FALSE;

					if (NewPath[0] == '!')	/* ! says NO ID Insertion */
					{	NoID = TRUE; NewPath++;
					}
					if (NewPath[0] == '@')	/* @ says trash previously used path (UIFLOOD) */
					{	TrashUsed = TRUE; NewPath++;
					}
					if (NewPath[0] == '!')	/* So it can be !@ or @! */
					{	NoID = TRUE; NewPath++;
					}

					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%.*s>%.*s",
									sizeof(APRS->Path.Hops[0]), APRS->Path.Hops[0],
									sizeof(APRS->Path.Hops[1]), APRS->Path.Hops[1]);
					for (h=2; h<APRS->Path.hopCount; h++)
					{	if (h == APRS->Path.hopUnused)
						{	if (!NoID) StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, ",%s*", CALLSIGN);
							if (*NewPath)	/* Is there something left to insert? */
								StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, ",%s", NewPath);
						} else if (h<APRS->Path.hopUnused
						&& (!strncmp(CALLSIGN, APRS->Path.Hops[h], sizeof(APRS->Path.Hops[h]))
						|| (!strncmp(CALLSIGN, APRS->Path.Hops[h], strlen(CALLSIGN)) && APRS->Path.Hops[h][strlen(CALLSIGN)]=='*')))
						{	FoundMe = TRUE;
							break;
						} else if (h > APRS->Path.hopUnused || !TrashUsed)
						{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, ",%.*s", sizeof(APRS->Path.Hops[h]), APRS->Path.Hops[h]);
						}
					}

					if (FoundMe)
					{	TraceLog("Digi(NOT)", FALSE, hwnd, "Suppressing Redundant Digi Of(%s)\n", safebuf);
					} else
					{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, ":%s", Payload);

						TraceLog("Digi", TRUE, hwnd, "Digipeating %.*s (%.*s) via(%s)\n",
									STRING(APRS->srcCall), STRING(APRS->Path.Hops[APRS->Path.hopUnused]), Transform);
						TraceLog("Digi", TRUE, hwnd, "Original(%s)", safebuf);
						TraceLog("Digi", TRUE, hwnd, "Transmit(%s)", Buffer);

						Dupes[dp].Digipeated = TRUE;
						if (st != -1)
							Stations[st].Digipeated = TRUE;	/* For display */
#define REALLY_DIGIPEAT
#ifdef REALLY_DIGIPEAT
						QueueToTransmit(DIGIPEAT_PACKET, Buffer, TRUE, FALSE);
						if (IGateEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)	/* Some RF Interface active, log the Digi */
						{	char *Temp = (char *) malloc(strlen(Buffer)+80);
							int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld RFtoRF:%s:[%ld]%s",
												(long) stSystem.wYear, 
												(long) stSystem.wMonth, 
												(long) stSystem.wDay, 
												(long) stSystem.wHour, 
												(long) stSystem.wMinute, 
												(long) stSystem.wSecond,
												CALLSIGN, (long) UDPSeq++,
												Buffer);
							if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
								TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Temp);
							free(Temp);
						}
#endif
					}
					if (FreeTransform) free(Transform);
					PacketsDigid++;
					free(Buffer);
				}
#define DEBUG_DIGI
#ifdef DEBUG_DIGI
				else TraceLog("Digi(NOT)", FALSE, hwnd, "Unused Hop(%.*s) Has No DigiXform in (%s)\n", sizeof(APRS->Path.Hops[APRS->Path.hopUnused]), APRS->Path.Hops[APRS->Path.hopUnused], safebuf);
#endif
			}
			else TraceLog("Digi(NOT)", TRUE, hwnd, "Empty Payload(0x%lX) or MisMatched Datatype(0x%lX)(%c)\n",
						(long) *Payload, (long) APRS->datatype, isprint(APRS->datatype&0xff)?APRS->datatype:'?');
			else TraceLog("Digi(NOT)", TRUE, hwnd, "Missing Payload(:) in (%s)\n", safebuf);
		}
#ifdef DEBUG_DIGI
		else TraceLog("Digi(NOT)", FALSE, hwnd, "MY(%s) Packet(%s)\n", CALLSIGN, safebuf);
		else TraceLog("Digi(NOT)", FALSE, hwnd, "Full Path (%ld Hops) in (%s)\n", (long) APRS->Path.hopCount, safebuf);
		else TraceLog("Digi(NOT)", FALSE, hwnd, "All Hops Used (%ld/%ld) in (%s)\n", (long) APRS->Path.hopUnused, (long) APRS->Path.hopCount, safebuf);
		else TraceLog("Digi(NOT)", FALSE, hwnd, "Empty Path (%ld Hops) in (%s)\n", (long) APRS->Path.hopCount, safebuf);
		else TraceLog("Digi(NOT)", FALSE, hwnd, "Already Digied (%s)\n", safebuf);
		else TraceLog("Digi(NOT)", TRUE, hwnd, "Can't (yet) do Third-party (%.*s) Packet (%s)\n", STRING(APRS->thirdCall), safebuf);
#ifdef DEBUG_NON_DIGI
		else TraceLog("Digi(NOT)", FALSE, hwnd, "No <DigiXform> configured for (%s)\n", safebuf);
		else TraceLog("Digi(NOT)", FALSE, hwnd, "No Digi of -IS Packet (%s)\n", safebuf);
#endif
#endif
Start = DebugTimer("AprsLogPacket","Digi",Start,&msMax,&msLast, hwnd);

/*
	Testing filters...
*/
		if (IsTraceLogEnabled("FilterTest")
		&& FilterPacket(&TestFilter, APRS))
		{
			TraceLog("FilterTest", FALSE, hwnd, "%s[%s](%s) [%ld]%s\n",
						FromRF?"RF":"IS", pPort?pPort->Name:"*NULL*",
						GetHitNixDetail(&TestFilter),
						Dupes[dp].ISDupeCount, safebuf);
		}
Start = DebugTimer("AprsLogPacket","Filter",Start,&msMax,&msLast, hwnd);

/*
	Check for filtered -IS to RF Gating
*/
		if (!FromRF)	/* RF is called digipeating! */
		if (RfPort != RFPORT_INTERNAL)	/* Internals will have already transmitted */
		if (IGateEnabled)					/* Don't bother if no RF Interface */
		if (!IGateReceiveOnly)				/* or not transmitting */
		if (ActiveConfig.APRSIS.IStoRFEnabled)
		if (ActiveConfig.Update.Development)
		if (IsTraceLogEnabled("IGate(Filter)"))
		if (FilterPacket(&IStoRFFilter, APRS))
		if (!Dupes[dp].RFDupeCount		/* Duplicates don't go out either */
		&& !Dupes[dp].ISDupeCount)		/* Especially not -IS dupes! (caused by multi-feeds) */
		if (!*APRS->thirdCall)					/* We don't gate 3rd party packets */
		{	STATION_INFO_S *fromStat = FindStationCall(APRS->srcCall);

			if (fromStat)
			{	char *newBody = BuildHourlyStationString(fromStat);
				if (newBody)
				{	if (fromStat->HeardOnRF)	/* Direct */
						TraceLog("IGate(Filter)", FALSE, hwnd, "Considering:%s(%ld) %s", APRS->srcCall, fromStat->HeardOnRF-1, newBody);
					else TraceLog("IGate(Filter)", FALSE, hwnd, "Considering:%s(IS) %s", APRS->srcCall, newBody);
					free(newBody);
				} else
				{	TraceLog("IGate(Filter)", FALSE, hwnd, "Considering:%s Nothing Heard Recently", APRS->srcCall);
				}
			} else
			{	TraceLog("IGate(Filter)", FALSE, hwnd, "Considering:%s Not Found", APRS->srcCall);
			}
		
			if (fromStat != MyStation)	/* Never gate ME! */
			if (!fromStat				/* Unknowns gate */
			|| !fromStat->HeardOnRF			/* Not heard on RF */
			|| fromStat->HeardOnRF > LOCAL_MAX_HOPS+1)	/* Or heard too far out */
			{	int h;
				int cLen = strlen(CALLSIGN);
				int MyHop = 0;
				char *Payload = strchr(safebuf,':');	/* : delimits the end of the header */

				for (h=2; h<APRS->Path.hopUnused; h++)	/* Only check used path components */
				{	if (!strncmp(APRS->Path.Hops[h],CALLSIGN,cLen)
					&& (!APRS->Path.Hops[h][cLen] || APRS->Path.Hops[h][cLen]=='*'))
					{	MyHop = h;
						break;	/* If I've already processed this, don't do it again! */
					}
				}

				if (!MyHop && Payload)
				{
					size_t Remaining = 512;
					char *Buffer = (char*)malloc(Remaining);
					char *Next = Buffer;
		/* KJ4ERJ-2>APJI23,WX4MLB-3,WIDE2*:}KJ4ERJ-AP>APWW00,TCPIP,KJ4ERJ-2*::WI8H-9   :Test for 3rd party format{225 */

					TraceLog("IGate(Filter)", FALSE, hwnd, "IStoRF:%s[%s](%s) [%ld]%s\n",
								FromRF?"RF":"IS", pPort?pPort->Name:"*NULL*",
								GetHitNixDetail(&TestFilter),
								Dupes[dp].ISDupeCount, safebuf);

#ifdef USING_ME_NOT_3RD
					/* Should check port's MyCallNot3rd */
					if (IsSameBaseCallsign(CALLSIGN, APRS->Path.Hops[0])	/* from my call? */
					&& IsAX25Safe((unsigned char *) APRS->Path.Hops[0]))	/* Must be 00-15 SSID */
					{
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s>%s", APRS->Path.Hops[0], APRS->Path.Hops[1]);
					{	BOOL FoundUsed = FALSE;
						size_t initRemain = Remaining;
						char *initNext = Next;

						for (h=2; h<APRS->Path.hopCount; h++)
						{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												",%s", APRS->Path.Hops[h]);
							if (strchr(APRS->Path.Hops[h],'*'))
							{	FoundUsed = TRUE;
								if (Next[-1] == '*') *--Next = '\0';
								break;	/* Quit after the used packet */
							}
						}
						if (!FoundUsed)	/* It was direct before now */
						{	Remaining = initRemain;
							Next = initNext;
						}
					}
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										",%s*%s%s:%s",
										CALLSIGN, *PATH?",":"", PATH, Payload+1);
/*WinMain:2010-05-30T02:59:38.757 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:41.765 RFtoIS:Igated 
KJ4ERJ-1>APWW02,WX4MLB-3*,WIDE2*:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:42.016 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 W
*/
					} else	/* Make it a 3rd party transmission */
					{
#endif
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s>%s%s%s:}",
										CALLSIGN, DESTID, *PATH?",":"", PATH);

					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%s>%s", APRS->Path.Hops[0], APRS->Path.Hops[1]);
					{	BOOL FoundUsed = FALSE;
						BOOL FoundTcpIP = FALSE;
						size_t initRemain = Remaining;
						char *initNext = Next;

						for (h=2; h<APRS->Path.hopCount; h++)
						{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												",%s", APRS->Path.Hops[h]);
							if (IsTcpPath(APRS->Path.Hops[h]))
								FoundTcpIP = TRUE;
							if (strchr(APRS->Path.Hops[h],'*'))
							{	FoundUsed = TRUE;
								if (Next[-1] == '*') *--Next = '\0';
								break;	/* Quit after the used packet */
							}
						}
						if (!FoundUsed)	/* It was direct before now */
						{	Remaining = initRemain;
							Next = initNext;
						}
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s,%s*:%s", !FoundTcpIP?",TCPIP":"", CALLSIGN, Payload+1);
/*WinMain:2010-05-30T02:59:38.757 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:41.765 RFtoIS:Igated 
KJ4ERJ-1>APWW02,WX4MLB-3*,WIDE2*:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:42.016 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 W
*/
					}
#ifdef USING_ME_NOT_3RD
					}
#endif

					QueueToTransmit(IS2RF_IGATE_PACKET, Buffer, TRUE, FALSE);
					TraceLog("IGate(Filter)", TRUE, hwnd, "IStoRF:Packet(%.*s) %s\n", STRING(APRS->srcCall), Buffer);
					if (IGateEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
					{	char *Temp = (char *) malloc(strlen(Buffer)+80);
						int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld IStoRF:%s:[%ld]%s",
											(long) stSystem.wYear, 
											(long) stSystem.wMonth, 
											(long) stSystem.wDay, 
											(long) stSystem.wHour, 
											(long) stSystem.wMinute, 
											(long) stSystem.wSecond,
											CALLSIGN, (long) UDPSeq++,
											Buffer);
						if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
							TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Temp);
						free(Temp);
					}

					PacketsRGated++;
					free(Buffer);
				} else TraceLog("IGate(Filter)", FALSE, hwnd, "IStoRF:Packet(%.*s), Already Handled By ME! ([%ld]=%s) %s\n",
								STRING(APRS->srcCall), (long) MyHop, APRS->Path.Hops[MyHop], safebuf);
			}
			else // fromStat heard on RF
				TraceLog("IGate(Filter)", FALSE, hwnd, "IStoRF:Packet(%.*s) HeardOnRF, and Local (%ld vs %ld) (Possibly ME) %s\n",
								STRING(fromStat->Station),
								(long) fromStat->HeardOnRF-1, (long) LOCAL_MAX_HOPS,
								safebuf);
			else // fromStat == MyStation
				TraceLog("IGate(Filter)", FALSE, hwnd, "IStoRF:Packet(%.*s) Never gate ME! %s\n",
								STRING(fromStat->Station),
								safebuf);
		}
		else TraceLog("IGate(Filter)", TRUE, hwnd, "IStoRF:Packet(%.*s) is Third-Party (%.*s) %s\n", STRING(APRS->srcCall), STRING(APRS->thirdCall), safebuf);
		else TraceLog("IGate(Filter)", FALSE, hwnd, "IStoRF:Packet(%.*s) is DUPLICATE(RF:%d IS:%d) %s\n", STRING(APRS->srcCall), (long) Dupes[dp].RFDupeCount, (long) Dupes[dp].ISDupeCount, safebuf);
		else /*TraceLog("IGate(Filter)", false, HWND, "IStoRF:Packet(%.*s) Failed Filter\n", STRING(APRS->srcCall))*/;

Start = DebugTimer("AprsLogPacket","IStoRFGate",Start,&msMax,&msLast, hwnd);

/*
	Do all message functions here so we don't create extra stations
*/
		if (APRS->Valid & APRS_BULLETIN_VALID)	/* Bulletin? */
		{
//			TraceLog("Bulletins", TRUE, hwnd, "Log:from:%s ID:%c Grp:%s Text:%s\n",
//					APRS->srcCall, APRS->msgCall[3], &APRS->msgCall[4], APRS->Comment);
			RememberBulletin(Info, APRS->srcCall, APRS->msgCall[3], &APRS->msgCall[4], APRS->Comment);
		} else if (APRS->Valid & APRS_MESSAGE_VALID)	/* Message? */
		{	BOOL Grew = FALSE;
			_int64 pStart = llGetMsec();
static __int64 mspLast=0, mspMax=0;
			BOOL MyMessage = *APRS->msgCall == *CALLSIGN		/* Cheap first character check */
				&& !_stricmp(APRS->msgCall, CALLSIGN);	/* Handle my Trace query here */
			STATION_INFO_S *fromStat = NULL;

			if (MyMessage)
			{	fromStat = GetOrCreateStation(hwnd, APRS, msNow, &MsgNew, &Grew);
			} else fromStat = FindStationCall(APRS->objCall, APRS->srcCall);

			Result = fromStat;	/* For the caller's interest */

{	char Buffer[80];
sprintf(Buffer,"p(MyMessage)%ld%s%s",CloseStationCount,MsgNew?"N":"",Grew?"G":"");
pStart = DebugTimer("AprsLogPacket",Buffer,pStart,&mspMax,&mspLast, hwnd, 1000);
}

			/* Update the packet count and CloseIndex for distances */
			if (fromStat)
			{	if (dFound) fromStat->Packets[0].Dupes++;
				AccumulatePacketPath(fromStat, APRS, safebuf, FromRF, RfPort, msNow);
				UpdateStationScrollerPath(fromStat, st==-1?NULL:&Stations[st], APRS, FromRF, RfPort, msNow, pstSystem);
			}

			if (APRS->Valid & APRS_TELEMETRYDEF_VALID)	/* Telemetry definition?*/
			{	if (!strncmp(APRS->Comment, "PARM.", 5))
				{	unsigned long t = FindTelemetryCall(APRS->msgCall, FALSE);
					if (t != -1 && Telemetry[t].PARM)
					{	free(Telemetry[t].PARM);
						Telemetry[t].PARM = NULL;
					}
					RememberTelemetryDefinition(hwnd, &ActiveConfig, APRS->msgCall, APRS->Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "TelemetryDef:PARM", 300);
				} else if (!strncmp(APRS->Comment, "UNIT.", 5))
				{	unsigned long t = FindTelemetryCall(APRS->msgCall, FALSE);
					if (t != -1 && Telemetry[t].UNIT)
					{	free(Telemetry[t].UNIT);
						Telemetry[t].UNIT = NULL;
					}
					RememberTelemetryDefinition(hwnd, &ActiveConfig, APRS->msgCall, APRS->Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "TelemetryDef:UNIT", 300);
				} else if (!strncmp(APRS->Comment, "EQNS.", 5))
				{	unsigned long t = FindTelemetryCall(APRS->msgCall, FALSE);
					if (t != -1 && Telemetry[t].EQNS)
					{	free(Telemetry[t].EQNS);
						Telemetry[t].EQNS = NULL;
					}
					RememberTelemetryDefinition(hwnd, &ActiveConfig, APRS->msgCall, APRS->Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "TelemetryDef:EQNS", 300);
				} else if (!strncmp(APRS->Comment, "BITS.", 5))
				{	unsigned long t = FindTelemetryCall(APRS->msgCall, FALSE);
					if (t != -1 && Telemetry[t].BITS)
					{	free(Telemetry[t].BITS);
						Telemetry[t].BITS = NULL;
					}
					RememberTelemetryDefinition(hwnd, &ActiveConfig, APRS->msgCall, APRS->Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "TelemetryDef:BITS", 300);
				} else TraceLog("Telemetry", TRUE, hwnd, "%s->%s Unrecognized TelemetryDef(%s)\n",
								APRS->srcCall, APRS->msgCall, APRS->Comment);
			}
/*
	Handle messages directed to me that couldn't be handled in the callback
*/
			else	/* Don't let Telemetry defs in here! */
			{	if (fromStat && fromStat != MyStation)	/* Do this here because telemetry defs don't count */
				{	fromStat->hasMessaging = TRUE;	/* If it sends one, it can receive one! */
				}

				if (MyMessage)	/* Handle my messages here */
				{	char *from = _strdup(APRS->srcCall);
					char *message = _strdup(APRS->Comment);

					TraceLog("Messages", FALSE, hwnd, "%s->%s %s", from, CALLSIGN, message);

					if ((!strncmp(message, "ack", 3)
					|| !strncmp(message, "rej", 3))
					&& message[5] == '}')	/* Is it my Reply-Ack? */
					{	SpaceCompress(-1, message);	/* We only want the purest essence (no trailing spaces, at least) */
						CheckAndHandlePendingAck(from, message, &message[3]);
				//		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
					} else	/* New message received */
					{	BOOL AckReq = APRS->msgAck[0];
						int m;
						if (APRS->Valid & APRS_ITEM_VALID)	/* Item-In-Message? */
						{	if (!NoPopups)	/* Don't message recalled items */
							{	char *symName2 = GetDisplayableSymbol(APRS->symbol);
								char *Beef = (char*)malloc(strlen(APRS->CleanComment)+strlen(symName2)+80);
								double distance, bearing;
								AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon,
													APRS->lat, APRS->lon,
													&distance, &bearing);
								sprintf(Beef, "Item:%.*s(%s) %.1lf%s %S %s",
										STRING(APRS->objCall), symName2,
										(double) (distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
										ActiveConfig.View.Metric.Distance?"km":"mi",
										GetCompassPoint((int)bearing),
										APRS->CleanComment);
								m = RememberMessage(from, APRS->msgCall, Beef, MESSAGE_ME);
								free(symName2); free(Beef);
							}
						} else m = RememberMessage(from, APRS->msgCall, message, MESSAGE_ME);	/* BEFORE stripping off ack */
						if (AckReq) SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, message);	/* this strips ack */
						if (*message != '?')	/* not a query, see if we need to auto-reply */
						{	if (ActiveConfig.Messaging.AutoAnswer.Reply[0])	/* AutoReply Set? */
							if (AckReq)	/* Must be an ack-able message */
							{	if (m >= 0 && m < MessageCount)	/* Is it remembered? */
								{	if (Messages[m].Type != MESSAGE_RUNNING)	/* Don't auto-reply RUNNING messages */
										PendingAutoReply = Messages[m].PendingAutoReply = TRUE;	/* Send it after initial delay */
								} else if (ActiveConfig.Messaging.AutoAnswer.Delay != LONG_MAX	/* Configured delay */
								&& IsSystemTimeout(&stLastActivity, ActiveConfig.Messaging.AutoAnswer.Delay*60)) /* and time? */
								{	if (!SendAutoReply(hwnd, from))	/* Did we send it? */
										TraceLog("AutoAnswer", TRUE, hwnd, "Too Soon to AutoAnswer %s, Active Chat Open\n", from);
								} else
								{	TraceLog("AutoAnswer", TRUE, hwnd, "Cannot Queue AutoAnswer to %s, Active Chat Open\n", from);
								}
							} else
							{	TraceLog("AutoAnswer", FALSE, hwnd, "No AutoAnswer to %s from NonAck(%s)\n", from, message);
							}
						}
				/*
					Handle auto-response queries here (may not even want to queue them for the user)
				*/
						else	/* It's a query */
						{	char *Prefix = "", *Body = NULL;
							int ListCount=0, ListSize = 0;
							char **List = NULL;
							BOOL ListWrap = TRUE;

							if (!_strnicmp(message,"?APRSD",6))	/* Direct stations */
							{	int dCount = 0;
								unsigned int s;
								BOOL NeedLabels = TRUE;
								for (s=1; s<CloseStationCount; s++)
								{	if (pCloseStations[s]->HeardOnRF == 1)	/* Direct */
									if (!pCloseStations[s]->isObject)	/* Not an object */
									{	if (ListCount >= ListSize)
										{	ListSize += 16;
											List = (char**)realloc(List, sizeof(*List)*ListSize);
										}
										if (!fromStat || fromStat->HeardOnRF
										|| (fromStat->pCoord->lat == 0.0 && fromStat->pCoord->lon == 0.0))
										{	List[ListCount++] = _strdup(pCloseStations[s]->Station);
										} else
										{	STATION_INFO_S *Stat = pCloseStations[s];
											double distance, bearing;
											int Len = sizeof(Stat->Station)+80;
											List[ListCount] = (char*)malloc(Len);
											AprsHaversineLatLon(LastGoodPosition.dblLatitude,
																LastGoodPosition.dblLongitude,
																Stat->pCoord->lat, Stat->pCoord->lon,
																&distance, &bearing);
											if (ActiveConfig.View.Metric.Distance) distance *= KmPerMile;
											if (distance < 0.1)
											{	List[ListCount++] = _strdup(pCloseStations[s]->Station);
											} else
											{	StringCbPrintfA(List[ListCount], Len, "%s(%.1lf%s@%ld%s)",
														Stat->Station, (double) distance,
														NeedLabels?(ActiveConfig.View.Metric.Distance?"km":"mi"):"",
														(long) bearing, NeedLabels?"":"");
												NeedLabels = FALSE;
												ListCount++;
											}
										}
									}
								}
								Prefix = ListCount?"Directs":"Nothing Heard Direct";
							} else if (!_strnicmp(message,"?APRSL",6))	/* Local stations - Extended query */
							{	int dCount = 0;
								unsigned int s;
								for (s=1; s<CloseStationCount; s++)
								{	if (pCloseStations[s]->HeardOnRF
									&& pCloseStations[s]->HeardOnRF <= LOCAL_MAX_HOPS+1	/* Local */
									&& !pCloseStations[s]->isObject)	/* Not an object */
									{	if (ListCount >= ListSize)
										{	ListSize += 16;
											List = (char**)realloc(List, sizeof(*List)*ListSize);
										}
										List[ListCount] = (char*) malloc(strlen(pCloseStations[s]->Station)+33);
										if (pCloseStations[s]->HeardOnRF == 1)	/* Direct */
											sprintf(List[ListCount], "%.*s",
												STRING(pCloseStations[s]->Station));
										else sprintf(List[ListCount], "%.*s(%ld)",
												STRING(pCloseStations[s]->Station),
												(long) pCloseStations[s]->HeardOnRF-1);
										ListCount++;
									}
								}
								Prefix = ListCount?"Locals":"Nothing Heard Local";
				#ifdef DOCUMENTATION
				:KH2ZVVVVV:?APRSH N0QBF     :N8URVVVVV:N0QBFVHEARD:V1V3V2V.V.V4V5V6
				A query asking for the number of times
				N0QBF was heard in each of the last
				8 hours. (Note the trailing spaces in the
				callsign following APRSH, padding the
				callsign to 9 characters).
				#endif
							} else if (!_strnicmp(message,"?APRSH",6))	/* Heard station? */
							{	int dCount = 0;
								unsigned int s;
								char *Who = _strdup(message+6);
								SpaceCompress(-1, Who);
								if (!*Who)
								{	free(Who);
									Who = _strdup(APRS->srcCall);
								}
				#ifdef SUPPORT_HOURLY_PACKET_COUNT
								if (strcmp(Who,"*"))
								{	STATION_INFO_S *Stat = FindStationCall(Who);
									if (!Stat)
									{	char *Who2 = _strupr(_strdup(Who));
										Stat = FindStationCall(Who2);
										if (Stat)
										{	free(Who); Who = Who2;
										} else free(Who2);
									}
									if (Stat)
									{	char *newBody = BuildHourlyStationString(Stat);
										if (newBody)
										{	int Len = strlen(newBody)+strlen(Who)+80;
											Body = (char*)malloc(Len);
											if (Stat->HeardOnRF)	/* Direct */
												StringCbPrintfA(Body, Len, "%s(%ld) %s", Who, Stat->HeardOnRF-1, newBody);
											else StringCbPrintfA(Body, Len, "%s %s", Who, newBody);
											free(newBody);
										} else
										{	int Len = strlen(Who)+80;
											Body = (char*)malloc(Len);
											StringCbPrintfA(Body, Len, "Nothing Heard From %s", Who);
										}
									} else
									{	int Len = strlen(Who)+80;
										Body = (char*)malloc(Len);
										StringCbPrintfA(Body, Len, "Station %s Not Found", Who);
									}
								} else	/* General Heard Station query (extension) */
				#endif
								{	for (s=1; s<CloseStationCount; s++)
									{	if (pCloseStations[s]->HeardOnRF	/* Heard stations */
										&& !pCloseStations[s]->isObject)	/* Not an object */
										{	if (ListCount >= ListSize)
											{	ListSize += 16;
												List = (char**)realloc(List, sizeof(*List)*ListSize);
											}
											List[ListCount] = (char*) malloc(strlen(pCloseStations[s]->Station)+33);
											if (pCloseStations[s]->HeardOnRF == 1)	/* Direct */
												sprintf(List[ListCount], "%.*s",
													STRING(pCloseStations[s]->Station));
											else sprintf(List[ListCount], "%.*s(%ld)",
													STRING(pCloseStations[s]->Station),
													(long) pCloseStations[s]->HeardOnRF-1);
											ListCount++;
										}
									}
									Prefix = ListCount?"Heard":"Nothing Heard via RF";
								}
								free(Who);
				#ifdef DOCUMENTATION
				:KH2ZVVVVV:?APRSM :N8URVVVVV:Testing{003
				A query asking KH2Z for any
				unacknowledged or undelivered
				messages for him. KH2Z responds
				with all such messages.
				#endif
							} else if (!_strnicmp(message,"?APRSM",6))	/* Pending messages? */
							{	int m, count=0;
								for (m=0; m<PendingMsgCount; m++)
								{	if (!_stricmp(from,PendingMsgs[m].MsgAckFrom))
									{	count++;	/* Count the message */
										if (!PendingMsgs[m].Subordinated)
											RetriggerPendingMessage(m, "?APRSM", TRUE);	/* Retrigger retries */
									}
								}
								Body = (char*)malloc(80);
								StringCbPrintfA(Body, 80, "%ld Message%s Requeued", (long) count, count==1?"":"s");
							} else if (!_strnicmp(message,"?APRSO",6))	/* Object query */
							{	Body = (char*)malloc(80);
								char *objid = strchr(message,' ');
								while (objid && *objid==' ') objid++;
								if (objid && *objid)
								{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, objid);
									if (Obj)
									{	if (Obj->Enabled)
										{	//TransmitObjectTo(Obj,FindStationCall(APRS->srcCall));
											TransmitObject(Obj);
											StringCbPrintfA(Body, 80, "%s Transmitted", Obj->Name);
										} else
										{	StringCbPrintfA(Body, 80, "%s Disabled", Obj->Name);
										}
									} else
									{	StringCbPrintfA(Body, 80, "%s Not Found", objid);
									}
								} else
								{	unsigned long o, ObjCount=0;
									char *Group = NULL;	/* For the future */
	for (o=0; o<ActiveConfig.Objects.Count; o++)
	{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[o];
		if (Obj->Enabled	/* Must be enabled */
		&& !Obj->JT65		/* JT65 are never solicited */
		&& !Obj->Weather	/* Weathers are never solicited */
		&& Obj->Interval	/* Have an interval? */
		&& (Obj->ISEnabled || Obj->RFEnabled)		/* Must have at least one via */
		&& SecondsSince(&Obj->LastTransmit) > 60)	/* Never faster than 60 seconds */
		{	if ((!Group /*&& Obj->Group[0] != '?'*/)	/* ?group only explicitly */
			|| (Group && !_stricmp(Group,Obj->Group)))	/* Explicitly */
			{	if (FromRF && Obj->RFEnabled)	/* RF is only requested from RF */
				{	memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					ObjCount++;
				} else if (!FromRF && Obj->ISEnabled) /* -IS's can just go out */
				{	TransmitObject(Obj, FALSE, TRUE);
					ObjCount++;
				}
			}
		}
	}
	StringCbPrintfA(Body, 80, "%ld Object%s %s", (long) ObjCount, ObjCount==1?"":"s", FromRF?"Queued":"Transmitted");
								}
							} else if (!_strnicmp(message,"?APRSP",6))	/* Position query */
	/* Also general Pos query */
							{	ForceTransmit = TRUE;
							} else if (!_strnicmp(message,"?TRAP", 5))
							{	char *p = (char*)1;
								*p = 0;
							} else if (!_strnicmp(message,"?APRSS",6))	/* Status query */
							{	TransmitStatusReport(TRUE);
								if (PortStatusCount)
								{	ListWrap = FALSE;
									ListCount = max(1,PortStatusCount);
									List = (char **) calloc(ListCount,sizeof(*List));
									for (int p=0; p<PortStatusCount; p++)
										List[p] = BuildPortStatusString(p,FALSE);
									Prefix = "Ports";
								} else Prefix = "No Configured Ports";
							} else if (!_strnicmp(message,"?APRST",6)		/* Trace query */
							|| !_strnicmp(message,"?PING?",6))			/* Also trace query */
							{	int h;
								size_t Remaining = 512;
								Body = (char*) malloc(Remaining);
								char *Next = Body;
					/* KJ4ERJ-2>APJI23,WX4MLB-3,WIDE2*:}KJ4ERJ-AP>APWW00,TCPIP,KJ4ERJ-2*::WI8H-9   :Test for 3rd party format{225 */
					/* :N8URVVVVV:KH2Z>APRS,DIGI1,WIDE*: - Typical trace response? */
								StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%s>%s", CALLSIGN, DESTID);
								for (h=2; h<APRS->Path.hopCount; h++)
								{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														",%.*s", sizeof(APRS->Path.Hops[h]), APRS->Path.Hops[h]);
								}
								if (*APRS->thirdCall)
								{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													" via %s", APRS->thirdCall);
								}
							} else if (!_strnicmp(message,"?APRSV",6)		/* APRS-type query extention */
							|| !_strnicmp(message,"?ABOUT",6)			/* Or About */
							|| !_strnicmp(message,"?VER",4))			/* Or just a version */
							{	OSVERSIONINFO osvi = {0};
								Prefix = Timestamp;					/* Just send back the software timestamp */
								osvi.dwOSVersionInfoSize = sizeof(osvi);
								if (GetVersionEx(&osvi))
								{	float KernelT, UserT, KernelD, UserD;
									CalculateCPU(&KernelT, &UserT, &KernelD, &UserD);
									Body = (char*) malloc(132);
									StringCbPrintfA(Body, 132, " %s Win v%ld.%ld b%ld p%ld %.1f/%.1f%%",
										PROGNAME,
										(long) osvi.dwMajorVersion,
										(long) osvi.dwMinorVersion,
										(long) osvi.dwBuildNumber,
										(long) osvi.dwPlatformId,
										(float) UserD+KernelD, (float) UserT+KernelT);
								}
							} else if (!_strnicmp(message,"?CPU",4))			/* Or just a version */
							{	OSVERSIONINFO osvi = {0};
								osvi.dwOSVersionInfoSize = sizeof(osvi);
								if (GetVersionEx(&osvi))
								{	float KernelT, UserT, KernelD, UserD;
									CalculateCPU(&KernelT, &UserT, &KernelD, &UserD);
									Body = (char*) malloc(132);
#ifdef UNDER_CE
									StringCbPrintfA(Body, 132, "%s Windows v%ld.%ld b%ld p%ld %.1f/%.1f%%",
										PROGNAME,
										(long) osvi.dwMajorVersion,
										(long) osvi.dwMinorVersion,
										(long) osvi.dwBuildNumber,
										(long) osvi.dwPlatformId,
										(float) UserD, (float) UserT);
#else
									StringCbPrintfA(Body, 132, "%s Windows v%ld.%ld b%ld p%ld K:%.1f/%.1f%% U:%.1f/%.1f%%",
										PROGNAME,
										(long) osvi.dwMajorVersion,
										(long) osvi.dwMinorVersion,
										(long) osvi.dwBuildNumber,
										(long) osvi.dwPlatformId,
										(float) KernelD, (float) KernelT,
										(float) UserD, (float) UserT);
#endif
								}
							} else if (!_strnicmp(message,"?IGATE",6))	/* IGate status query */
							{	size_t Remaining = 128;
								char *Next = (char*)malloc(Remaining);
								unsigned long DirectStationCount = 0, LocalStationCount = 0, RFStationCount = 0;
								GetStationCounts(&DirectStationCount, &LocalStationCount, &RFStationCount);
								Body = Next;
								*Next = '\0';	/* Null terminate initially */

								if (MessagesGated)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%sMSG_CNT=%ld", *Body?" ":"", (long) MessagesGated);
								if (LocalStationCount)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%sLOC_CNT=%ld", *Body?" ":"", (long) LocalStationCount);
								if (DirectStationCount)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%sDIR_CNT=%ld", *Body?" ":"", (long) DirectStationCount);
								if (RFStationCount)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%sRF_CNT=%ld", *Body?" ":"", (long) RFStationCount);
								if (PacketsRGated)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													"%sPKT_CNT=%ld", *Body?" ":"", (long) PacketsRGated);
								if (!*Body)
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									IGateEnabled?"No IGate Activity":(ActiveConfig.RFPorts.Count?"IGate Not Active":"No RF Ports!"));
								if (IGateEnabled)
								{
									if (!ActiveConfig.RFPorts.Count)
										StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
															"%sNo RF Ports!", *Body?" ":"");
									else if (ActiveConfig.Enables.RFReceiveOnly)
										StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														"%sRF Receive-Only!", *Body?" ":"");
									else if (IGateReceiveOnly)
											StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
															"%sReceive-Only!", *Body?" ":"");

									if (ActiveConfig.RFPorts.Count)
									{	unsigned long l = 0;
										ListWrap = FALSE;
										ListCount = max(1,ActiveConfig.RFPorts.Count+1);
										List = (char **) calloc(ListCount,sizeof(*List));
										List[l++] = Body;
										for (unsigned long p=0; p<ActiveConfig.RFPorts.Count; p++)
										if (RFPortRunnable(&ActiveConfig.RFPorts.Port[p])	/* Ignore disabled ports */
										&& !ActiveConfig.RFPorts.Port[p].NotRF)
										{	size_t Remaining = 128+128;
											char *Next;
											Next = List[l++] = (char*)malloc(Remaining);
											StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
															"%s[%s]", ActiveConfig.RFPorts.Port[p].Name, ActiveConfig.RFPorts.Port[p].Protocol);
											if (ActiveConfig.Enables.RFReceiveOnly
											|| !ActiveConfig.RFPorts.Port[p].XmitEnabled)
											{	if (ActiveConfig.RFPorts.Port[p].RFtoISEnabled)
													StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																	" Receive-Only");
												else 	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																	" Disabled");
											}
											else	/* Transmit is enabled at least */
											{	if (ActiveConfig.RFPorts.Port[p].IStoRFEnabled
												&& ActiveConfig.RFPorts.Port[p].RFtoISEnabled)
													StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																	" Bi-Directional");
												else if (ActiveConfig.RFPorts.Port[p].RFtoISEnabled)
														StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																		" Receive-Only");
												else if (ActiveConfig.RFPorts.Port[p].IStoRFEnabled)
														StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																		" Xmit-Only");
												else
														StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																		" Disabled");
											}
			{	unsigned long ppc = GetPortPacketIndex(p,ActiveConfig.RFPorts.Port[p].Name);
				if (PortPackets[ppc].DXCount)
				{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										" DX=%ld*%.*s(%.0lf%s@%ld)",
										(long) PortPackets[ppc].DXList[0].Count,
										STRING(PortPackets[ppc].DXList[0].Station),
										(double) (PortPackets[ppc].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
										ActiveConfig.View.Metric.Distance?"km":"mi",
										(long) PortPackets[ppc].DXList[0].Bearing);
				}
			}
										}
										ListCount = l;	/* Final, actual count */
										Prefix = "IGate";
									}
								}
/*
	Respond to a ?DX with every RF Port that has a defined
	DX station.  Include hourly packet counts if the station
	is known (and it should be!)
*/
							} else if (!_strnicmp(message,"?DX",3))	/* Distant Station? */
							{	unsigned long l = 0;
								int RFCount = 0;
								int RadioActive = 0;
								TransmitDXReport(TRUE);
								if (ActiveConfig.RFPorts.Count)
								{	ListWrap = FALSE;
									ListCount = max(1,ActiveConfig.RFPorts.Count+1);
									List = (char **) calloc(ListCount,sizeof(*List));
									for (unsigned long p=0; p<ActiveConfig.RFPorts.Count; p++)
									if (!ActiveConfig.RFPorts.Port[p].NotRF)
									if (RFPortRunnable(&ActiveConfig.RFPorts.Port[p]))	/* Ignore disabled ports */
									{	unsigned long ppc = GetPortPacketIndex(p,ActiveConfig.RFPorts.Port[p].Name);
										if (PortPackets[ppc].DXCount)
										{	size_t Remaining = 128+128;
											char *Next;
											Next = List[l++] = (char*)malloc(Remaining);
											StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
															"%s[%s] %ld*%.*s(%.0lf%s@%ld)",
															ActiveConfig.RFPorts.Port[p].Name,
															ActiveConfig.RFPorts.Port[p].Protocol,
															(long) PortPackets[ppc].DXList[0].Count,
															STRING(PortPackets[ppc].DXList[0].Station),
															(double) (PortPackets[ppc].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
															ActiveConfig.View.Metric.Distance?"km":"mi",
															(long) PortPackets[ppc].DXList[0].Bearing);
											STATION_INFO_S *Stat = FindStationCall(PortPackets[ppc].DXList[0].Station);
											if (Stat)
											{	char *newBody = BuildHourlyStationString(Stat);
												if (newBody)
												{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
																			" %s", newBody);
													free(newBody);
												}
											}
										}
										RadioActive++;
									} else RFCount++;
									if (l) Prefix = "DX";
									else if (RadioActive)
									{	char *Next = List[l++] = (char*)malloc(80);
										StringCbPrintfA(Next, 80, "No DX > %ld%s",
														(long) ActiveConfig.DX.MinDist,
														ActiveConfig.View.Metric.Distance?"km":"mi");
									} else if (RFCount)
										Body = _strdup("No Active RF Ports");
									else Body = _strdup("No RF Ports");
									ListCount = l;	/* Final, actual count */
								} else Body = _strdup("No Ports Configured");
#ifdef OBSOLETE
								if (!l)	/* No DX Stations? */
								{	Body = _strdup("No DX Stations Found");
								}
#endif
							} else
							{	unsigned long count = CountOrTransmitGroupObjects(hwnd, message, FALSE);
								if (count > ActiveConfig.MaxGroupObjs)
								{	Body = (char*)malloc(80);
									StringCbPrintfA(Body, 80, "Too Many Object%s (%ld/%ld) In %s", count==1?"":"s", (long) count, (long) ActiveConfig.MaxGroupObjs, message);
								} else if (count)
								{	count = CountOrTransmitGroupObjects(hwnd, message, TRUE);
									Body = (char*)malloc(80);
									StringCbPrintfA(Body, 80, "%ld Object%s Queued From %s", (long) count, count==1?"":"s", message);
								} else
								{	Prefix = "Support";
								static char *DefaultSupport = "?APRSD ?APRSL ?APRSH ?APRSM ?APRSO ?APRSP ?APRSS ?APRST/?PING? ?ABOUT/?APRSV/?VER ?CPU ?DX ?IGATE";

									Body = GetQRUGroups(&ActiveConfig);
									if (!Body) Body = _strdup("");
								
									if (_strnicmp(message,"?INFO",5))
									{	char *NewBody = (char*)malloc(strlen(DefaultSupport)+1+strlen(Body)+1);
										sprintf(NewBody,"%s %s", Body, DefaultSupport);
										free(Body);
										Body = NewBody;
									}
									if (!*Body)
									{	free(Body); Body = _strdup(DefaultSupport);
									}
								}
							}

							if (!ListWrap && ListCount)	/* Preformatted lines */
							{	int l, Len = 0;

								for (l=0; l<ListCount; l++)
								{	int iLen = strlen(List[l]);
									if (iLen > Len) Len = iLen;
								}
								Len += 80+strlen(Prefix);
								TCHAR *Buffer = (TCHAR *)malloc(Len*sizeof(*Buffer));

								for (l=0; l<ListCount; l++)
								{	if (ListCount > 1)
										StringCbPrintf(Buffer, sizeof(*Buffer)*Len,
													TEXT("%S[%ld/%ld] %S"),
													Prefix, l+1, ListCount, List[l]);
									else StringCbPrintf(Buffer, sizeof(*Buffer)*Len,
													TEXT("%S%S%S"),
													Prefix, *Prefix?":":"", List[l]);
									SendAPRSMessage(/*Info->hwnd,*/ from, 0, Buffer, FALSE,
													FALSE, FALSE, ActiveConfig.Messaging.HideQueries);
									free(List[l]);
								}
								free(List);
								free(Buffer);
							} else
							{	if (ListCount)
								{	int l, Len=0;
									for (l=0; l<ListCount; l++)
										Len += strlen(List[l]);
									Body = (char*)malloc(80+Len+ListCount);
									*Body = '\0';
									qsort(List, ListCount, sizeof(*List), CmpCharChar);
									for (l=0; l<ListCount; l++)
									{	if (*Body) strcat(Body," ");
										strcat(Body,List[l]);
										free(List[l]);
									}
									free(List);
								}

								if (Body)
								{	int Len = 80+strlen(Body)+strlen(Prefix);
									TCHAR *Buffer = (TCHAR *) malloc(Len*sizeof(*Buffer));
									size_t l, m=0, n = 1, Avail=DEFAULT_WRAP_WIDTH-strlen(Prefix)-((strlen(Body)>7*DEFAULT_WRAP_WIDTH)?9:7);
									char *p, *e;

									if (!*Body && *Prefix)
									{	StringCbPrintf(Buffer, sizeof(*Buffer)*Len, TEXT("%S"));
									} else for (l=0; l<2; l++)	/* First pass to count, second pass to send */
									{	int n = 1;
										for (p=Body; *p; p=e, n++)
										{	if (strlen(p) > Avail)
											{	for (e=p+Avail; e>p && e>p+(Avail-15); e--)
													if (isspace(*e & 0xff)) break;
												if (!isspace(*e & 0xff)) e = p+Avail;
											} else e = p+strlen(p);
											if (p==Body && strlen(p) <= Avail)
											{	StringCbPrintf(Buffer, sizeof(*Buffer)*Len, TEXT("%S%S%S"), Prefix, *Prefix?":":"", Body);
											} else if (*Prefix)
											{	StringCbPrintf(Buffer, sizeof(*Buffer)*Len, TEXT("%S[%ld/%ld]:%.*S"), Prefix, (long) n, (long) m, (int) (e-p), p);
											} else
											{	StringCbPrintf(Buffer, sizeof(*Buffer)*Len, TEXT("[%ld/%ld]:%.*S"), (long) n, (long) m, (int) (e-p), p);
											}
											if (l) SendAPRSMessage(/*Info->hwnd,*/ from, 0, Buffer, FALSE,
																	FALSE, FALSE, ActiveConfig.Messaging.HideQueries);
											while (*e && isspace(*e & 0xff)) e++;
										}
										m = n-1;
									}
									free(Buffer); free(Body);
								} else if (Prefix && *Prefix)
								{	int Len = 80+strlen(Prefix);
									TCHAR *Buffer = (TCHAR *) malloc(Len*sizeof(*Buffer));
									StringCbPrintf(Buffer, sizeof(*Buffer)*Len, TEXT("%S"), Prefix);
									SendAPRSMessage(/*Info->hwnd,*/ from, 0, Buffer, FALSE,
													FALSE, FALSE, ActiveConfig.Messaging.HideQueries);
									free(Buffer);
								}
							}
						}
					}
					free(message);
					free(from);
				}					
/*
	Not one explicitly for me, check for NWS, MessageGroups (Spec or Configured)
*/
				else
				{	BOOL DidOne = FALSE;
					MESSAGE_TYPE_V RememberAs = MESSAGE_UNSPECIFIED;
					unsigned long i;

					if (!DidOne && ActiveConfig.CompanionsEnabled)
					{	for (i=0; i<ActiveConfig.Companions.Count; i++)
						{	COMPANION_INFO_S *Obj = &ActiveConfig.Companions.Companion[i];
							if (Obj->Enabled && Obj->Messaging
							&& !_stricmp(APRS->msgCall, ActiveConfig.Companions.Companion[i].Name))
							{	BOOL AckReq = APRS->msgAck[0];
								TraceLogThread("Companions", TRUE, "Companion(%s) Message From(%s) %s\n",
												APRS->msgCall, APRS->srcCall, APRS->Comment);
								RememberAs = MESSAGE_COMPANION;
								if (AckReq) SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, APRS->Comment);	/* this strips ack */
								DidOne = TRUE;
								break;
							}
						}
					}

					if (!DidOne
					&& ActiveConfig.Messaging.MyMessages		/* Promiscious mode for MYCALL? */
					&& IsSameBaseCallsign(CALLSIGN, APRS->msgCall))
					{	RememberAs = MESSAGE_MY;
						DidOne = TRUE;
					}

					if (!DidOne
					&& APRS->Valid & APRS_NWS_VALID)	/* Smell like NWS? */
					{	STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
						unsigned long i = LocateTimedStringEntry(pList, APRS->srcCall, 3);
						if (i == -1 || pList->Entries[i].value)	/* Didn't * find or disabled */
						{	i = LocateTimedStringEntry(pList, "*");
						}
						if (i != -1						/* Found it*/
						&& !pList->Entries[i].value)	/* Not disabled */
						{	NWS_ENTRY_SERVER_S *Srv;
							if (*APRS->Path.Hops[APRS->Path.hopCount-2] == 'q')
							{	Srv = GetNWSServer(&ActiveConfig, APRS->Path.Hops[APRS->Path.hopCount-1], APRS->Path.Hops[APRS->Path.hopCount-2], APRS->srcCall, TRUE);
							} else Srv = NULL;
							if (!Srv || !Srv->Disabled)
							{	char *NWSObj = CreateNWSObjects(APRS, hwnd, Info);	/* Expand them anyway, if not disabled by Entry or CWA */
								if (ActiveConfig.NWS.Messages)
								{	if (!ActiveConfig.NWS.MessagesNotAll
									|| *pList->Entries[i].string != '*')
									{	if (!NoPopups) RememberMessage(APRS->srcCall,
														APRS->msgCall,
														APRS->Comment,
														MESSAGE_NWS, NWSObj);
										DidOne = TRUE;
									}
								}
								RememberRcvdWeather(hwnd, &ActiveConfig, APRS->srcCall, APRS->msgCall, APRS->Comment, safebuf);
								free(NWSObj);
							}
						}
					}
					if (!DidOne)	/* Is it a TACTICAL callsign def? */
					{	if (!_stricmp(APRS->msgCall, "TACTICAL"))
						{	if (LocateSimpleStringEntry(&ActiveConfig.TacticalNevers, APRS->srcCall)!=-1)
							{	TraceLog("Tactical", TRUE, hwnd, "AprsLogPacket:Ignoring %s's TACTICAL %s\n", APRS->srcCall, APRS->Comment);
							} else if (_stricmp(APRS->srcCall, CALLSIGN)
							&& LocateSimpleStringEntry(&ActiveConfig.TacticalSources, APRS->srcCall)==-1)
							{	RememberAs = MESSAGE_TACTICAL;
								TraceLog("Tactical", TRUE, hwnd, "AprsLogPacket:Queueing %s's TACTICAL %s\n", APRS->srcCall, APRS->Comment);
							} else
							{	SYSTEMTIME stLocal;
								GetLocalTime(&stLocal);
								TraceLog("Tactical", TRUE, hwnd, "AprsLogPacket:Accepting %s's TACTICAL %s\n", APRS->srcCall, APRS->Comment);
								ParseAndDefineTacticals(hwnd, APRS->srcCall, APRS->Comment, &stLocal);
							}
							DidOne = TRUE;
						}
					}
					if (!DidOne)
					{	for (i=0; i<ARRAYSIZE(SpecMessageGroups); i++)
						{	if (!_stricmp(APRS->msgCall, SpecMessageGroups[i]))
							{	RememberAs = MESSAGE_SPECIAL;
								DidOne = TRUE;
								break;
							}
						}
					}
					if (!DidOne)
					{	if (LocateSimpleStringEntry(&ActiveConfig.MessageGroups, APRS->msgCall) != -1)
						{	RememberAs = MESSAGE_GROUP;
							DidOne = TRUE;
						}
					}
/*
	See if this is a promiscuous mode reception for RF Messages
*/
					if (!DidOne)
					{	if (ActiveConfig.Messaging.RFMessages		/* Promiscious mode? */
						&& FromRF)
						if (!ActiveConfig.Messaging.HideNWS	/* Not hiding */
						|| !(APRS->Valid & APRS_NWS_VALID))	/* or not NWS */
						{	RememberAs = (APRS->Valid&APRS_NWS_VALID)?MESSAGE_NWS:MESSAGE_RF;
							DidOne = TRUE;
						}
					}
/*
	See if this is Eavesdropping mode and remember EVERYTHING!
*/
					if (!DidOne)
					{	if (ActiveConfig.Messaging.AllMessages)	/* Eavesdropping mode? */
						if (!ActiveConfig.Messaging.HideNWS	/* Not hiding */
						|| !(APRS->Valid & APRS_NWS_VALID))	/* or not NWS */
						{	RememberAs = (APRS->Valid&APRS_NWS_VALID)?MESSAGE_NWS:MESSAGE_EAVESDROP;
							DidOne = TRUE;
						}
					}
					if (!NoPopups
					&& RememberAs != MESSAGE_UNSPECIFIED)	/* Picking up an Eavesdrop */
					if (!_stricmp(APRS->srcCall, CALLSIGN))
					{	TraceLog("Messages", TRUE, NULL, "NOT Eavesdropping(%ld) My Message %s>%s:%s\n",
								(long) RememberAs, APRS->srcCall, APRS->msgCall, APRS->Comment);
					} else
					{	if (APRS->Valid&APRS_NWS_VALID) RememberAs = MESSAGE_NWS;
						if (APRS->Valid & APRS_ITEM_VALID)	/* Item-In-Message? */
						{	char *symName2 = GetDisplayableSymbol(APRS->symbol);
							char *Beef = (char*)malloc(strlen(APRS->CleanComment)+strlen(symName2)+80);
							double distance, bearing;
							AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon,
												APRS->lat, APRS->lon,
												&distance, &bearing);
							sprintf(Beef, "Item:%.*s(%s) %.1lf%s %S %s",
									STRING(APRS->objCall), symName2,
									(double) (distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
									ActiveConfig.View.Metric.Distance?"km":"mi",
									GetCompassPoint((int)bearing),
									APRS->CleanComment);
							RememberMessage(APRS->srcCall, APRS->msgCall, Beef, RememberAs);
							free(symName2); free(Beef);
						} else RememberMessage(APRS->srcCall, APRS->msgCall, APRS->Comment, RememberAs);
					}
				}
			}
Start = DebugTimer("AprsLogPacket","Message",Start,&msMax,&msLast, hwnd);

/*
	Check for messages that need to gate to RF
*/
			if (!NoPopups)		/* Not while recalling posits! */
			if (IGateEnabled)						/* Don't bother if no RF Interface */
			if (!IGateReceiveOnly)					/* or not transmitting */
			if (ActiveConfig.APRSIS.IStoRFEnabled)
			if (!*APRS->thirdCall)					/* We don't gate 3rd party packets */
			if (!(APRS->Valid & APRS_TELEMETRYDEF_VALID))	/* Don't send Telemetry Definitions out */
			if (!FromRF)							/* Don't put these back out there! */
			if (!fromStat							/* Go ahead if we don't know the source */
			|| !fromStat->HeardOnRF					/* or if we think the source is NOT on RF */
			|| fromStat->HeardOnRF > LOCAL_MAX_HOPS+1)	/* or NOT local enough to be heard */
			if (!Dupes[dp].RFDupeCount		/* Duplicates don't go out either */
			&& !Dupes[dp].ISDupeCount)		/* Not even -IS dupes! */
			{	STATION_INFO_S *msgStat = FindStationCall(APRS->msgCall);
				if (msgStat)						/* Actually found one */
				if (msgStat != MyStation)	/* Don't IGate my own messages! */
				if (msgStat->HeardOnRF)	/* Actually found one and it was on RF */
				if (msgStat->HeardOnRF <= LOCAL_MAX_HOPS+1)	/* And local enough */
				if (!msgStat->HeardAsThird)	/* But NOT if inside 3rd party packet */
				{	int h;
					int cLen = strlen(CALLSIGN);
					int MyHop = 0;
					char *Payload = strchr(safebuf,':');	/* : delimits the end of the header */

					for (h=2; h<APRS->Path.hopUnused; h++)	/* Only check used path components */
					{	if (!strncmp(APRS->Path.Hops[h],CALLSIGN,cLen)
						&& (!APRS->Path.Hops[h][cLen] || APRS->Path.Hops[h][cLen]=='*'))
						{	MyHop = h;
							break;	/* If I've already processed this, don't do it again! */
						}
					}

					if (!MyHop && Payload)
					{				
					size_t Remaining = 512;
					char *Buffer = (char*)malloc(Remaining);
					char *Next = Buffer;
		/* KJ4ERJ-2>APJI23,WX4MLB-3,WIDE2*:}KJ4ERJ-AP>APWW00,TCPIP,KJ4ERJ-2*::WI8H-9   :Test for 3rd party format{225 */

					TraceLog("IGate", FALSE, hwnd, "Msg2RF:Message(%.*s) HeardOnRF, Local (%ld vs %ld), %ld Hops To(%s) Payload(%s)\n",
									STRING(msgStat->Station),
									(long) msgStat->HeardOnRF-1, (long) LOCAL_MAX_HOPS,
									(long) APRS->Path.hopCount, APRS->msgCall, Payload+1);

#ifdef USING_ME_NOT_3RD
					/* Should check port's MyCallNot3rd */
					if (IsSameBaseCallsign(CALLSIGN, APRS->Path.Hops[0])	/* from my call? */
					&& IsAX25Safe((unsigned char *) APRS->Path.Hops[0]))	/* Must be 00-15 SSID */
					{
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s>%s", APRS->Path.Hops[0], APRS->Path.Hops[1]);
					{	BOOL FoundUsed = FALSE;
						size_t initRemain = Remaining;
						char *initNext = Next;

						for (h=2; h<APRS->Path.hopCount; h++)
						{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												",%s", APRS->Path.Hops[h]);
							if (strchr(APRS->Path.Hops[h],'*'))
							{	FoundUsed = TRUE;
								if (Next[-1] == '*') *--Next = '\0';
								break;	/* Quit after the used packet */
							}
						}
						if (!FoundUsed)	/* It was direct before now */
						{	Remaining = initRemain;
							Next = initNext;
						}
					}
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										",%s*%s%s:%s",
										CALLSIGN, *PATH?",":"", PATH, Payload+1);
/*WinMain:2010-05-30T02:59:38.757 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:41.765 RFtoIS:Igated 
KJ4ERJ-1>APWW02,WX4MLB-3*,WIDE2*:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:42.016 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 W
*/
					} else	/* Make it a 3rd party transmission */
					{
#endif
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s>%s%s%s:}",
										CALLSIGN, DESTID, *PATH?",":"", PATH);

					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%s>%s", APRS->Path.Hops[0], APRS->Path.Hops[1]);
					{	BOOL FoundUsed = FALSE;
						BOOL FoundTcpIP = FALSE;
						size_t initRemain = Remaining;
						char *initNext = Next;

						for (h=2; h<APRS->Path.hopCount; h++)
						{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												",%s", APRS->Path.Hops[h]);
							if (IsTcpPath(APRS->Path.Hops[h]))
								FoundTcpIP = TRUE;
							if (strchr(APRS->Path.Hops[h],'*'))
							{	FoundUsed = TRUE;
								if (Next[-1] == '*') *--Next = '\0';
								break;	/* Quit after the used packet */
							}
						}
						if (!FoundUsed)	/* It was direct before now */
						{	Remaining = initRemain;
							Next = initNext;
						}
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s,%s*:%s", !FoundTcpIP?",TCPIP":"", CALLSIGN, Payload+1);
/*WinMain:2010-05-30T02:59:38.757 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:41.765 RFtoIS:Igated 
KJ4ERJ-1>APWW02,WX4MLB-3*,WIDE2*:}KJ4ERJ>APZAPM,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 Was APRSIS32 2010/05/23 07:25

WinMain:2010-05-30T02:59:42.016 Msg2RF:Message(KJ4ERJ-12) 
KJ4ERJ-1>APWW02,WIDE2-1:}KJ4ERJ>APZAPM,KJ4ERJ-1,KJ4ERJ-1*::KJ4ERJ-12:ZL3REW-8 Running APRSIS32 2010/05/29 22:27 W
*/
					}
#ifdef USING_ME_NOT_3RD
					}
#endif

					QueueToTransmit(IS2RF_IGATE_PACKET, Buffer, TRUE, FALSE);
					TraceLog("IGate", TRUE, hwnd, "Msg2RF:Message(%.*s) %s\n", STRING(msgStat->Station), Buffer);
					if (IGateEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
					{	char *Temp = (char *) malloc(strlen(Buffer)+80);
						int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld Msg2RF:%s:[%ld]%s",
											(long) stSystem.wYear, 
											(long) stSystem.wMonth, 
											(long) stSystem.wDay, 
											(long) stSystem.wHour, 
											(long) stSystem.wMinute, 
											(long) stSystem.wSecond,
											CALLSIGN, (long) UDPSeq++,
											Buffer);
						if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
							TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Temp);
						free(Temp);
					}
					if (!fromStat) fromStat = GetOrCreateStation(hwnd, APRS, msNow, &MsgNew, &Grew);
					if (fromStat)
					{	TraceLog("IGate", TRUE, hwnd, "Pos2RF:Need FreePosition(%s) For(%s)\n", fromStat->Station, APRS->msgCall);
						fromStat->NeedPosGate = TRUE;
					} else TraceLog("IGate", TRUE, hwnd, "Pos2RF:Skipping FreePosition UNKNOWN(%s) For(%s)\n", APRS->srcCall, APRS->msgCall);

					MessagesGated++;
					free(Buffer);
					} else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) HeardOnRF, Already Handled By ME! ([%ld]=%s\n",
									STRING(msgStat->Station), (long) MyHop, APRS->Path.Hops[MyHop]);
				}
				else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) HeardOnRF, but ALSO HeardAsThird\n",
									STRING(msgStat->Station));
				else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) HeardOnRF, but NOT Local (%ld vs %ld)\n",
									STRING(msgStat->Station),
									(long) msgStat->HeardOnRF-1, (long) LOCAL_MAX_HOPS);
				else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) NOT HeardOnRF(%ld)\n", STRING(msgStat->Station), (long) msgStat->HeardOnRF);
				else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) IS ME! %.*s=%.*s\n",
									STRING(APRS->msgCall),
									STRING(MyStation->Station),
									STRING(msgStat->Station));
				else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s) Station Not Found\n", STRING(APRS->msgCall));
			}
			else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s)->(%.*s) is DUPLICATE(RF:%d IS:%d)\n", STRING(APRS->srcCall), STRING(APRS->msgCall), (long) Dupes[dp].RFDupeCount, (long) Dupes[dp].ISDupeCount);
			else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s)->(%.*s) is from HeardOnRF Station %s\n", STRING(APRS->srcCall), STRING(APRS->msgCall), fromStat->Station);
//			else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s)->(%.*s) is from RF\n", STRING(APRS->srcCall), STRING(APRS->msgCall));
//			else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s)->(%.*s) is Telemetry Definition Body(%s)\n", STRING(APRS->srcCall), STRING(APRS->msgCall), APRS->Comment);
//			else TraceLog("IGate(NOT)", FALSE, hwnd, "Msg2RF:Message(%.*s)->(%.*s) is Third-Party (%.*s)\n", STRING(APRS->srcCall), STRING(APRS->msgCall), STRING(APRS->thirdCall));

Start = DebugTimer("AprsLogPacket","MsgGate",Start,&msMax,&msLast, hwnd);

			if (fromStat)
			{	if (MsgNew || fromStat->wasRecalled)	/* New station? */
				{	if (NoPopups) fromStat->wasRecalled = TRUE;	/* Not really new */
					else
					{	fromStat->wasRecalled = FALSE;	/* Really new now */
						if (fromStat->Nickname && fromStat->Nickname->MultiTrackNew)
						{	RestoreOrCreateTrackerWindow(fromStat->Station, fromStat->Owner);
						}
					}
				}
				if (!NoPopups	/* Not during reload */
				&& fromStat->Nickname
				&& (fromStat->Nickname->MultiTrackActive
					|| fromStat->Nickname->MultiTrackAlways)
				&& !GetMultiTrackWindow(fromStat->Station, fromStat))
					RestoreOrCreateTrackerWindow(fromStat->Station, fromStat->Owner);
			}
		}
/*
	Handle Generic queries first
*/
		if (APRS->datatype == '?')	/* Generic query */
		{
		// Queries ?APRS ?IGATE ?WX or is it ?APRS? ?IGATE? and ?WX?
			if (!_strnicmp(APRS->Comment, "?APRS", 5))
			{	ForceTransmit = TRUE;
				TransmitStatusReport(TRUE);
			} else if (!_strnicmp(APRS->Comment, "?IGATE", 6))
			{	TransmitIGate(TRUE);	/* Transmitted there, no body */
			} else if (!_strnicmp(APRS->Comment, "?WX", 3))
			{	TransmitWeather(TRUE);
			} else TraceError(hwnd, "Unrecognized Generic Query(%s) From(%s)\n", APRS->Comment, APRS->srcCall);
		}
/*	Not a generic query, keep processing */
		else if (!(APRS->Valid & APRS_MESSAGE_VALID)	/* Not a Message */
		|| (APRS->Valid & APRS_ITEM_VALID))	/* Or there's an ITEM in the message */
		{	BOOL NewOne = FALSE, Grew = FALSE, MovedOK = FALSE, FirstMicE = FALSE, MicEChanged = FALSE;
	__int64 pStart = llGetMsec();
static __int64 mspLast=0, mspMax=0;
			STATION_INFO_S *Station = GetOrCreateStation(hwnd, APRS, msNow, &NewOne, &Grew);

			Result = Station;	/* For the caller's interest */

{	char Buffer[80];
sprintf(Buffer,"p(GetOrCreate)%ld%s%s",CloseStationCount,NewOne?"N":"",Grew?"G":"");
pStart = DebugTimer("AprsLogPacket",Buffer,pStart,&mspMax,&mspLast, hwnd, 1000);
}

//if ((!Station->WeatherParsed || !Station->Weather)
//&& APRS->symbol == '_'
//&& !(APRS->Valid & APRS_WEATHER_VALID))
//	TraceLogThread("Non-Weather", TRUE, "%s\n", safebuf);

			if (APRS->Valid & (APRS_DATE_VALID | APRS_TIME_VALID))
			{	Station->Time = APRS->Time;
			}

			if (APRS->Valid & APRS_NWS_VALID)
			{	Station->isNWS = TRUE;
				if (*APRS->Path.Hops[APRS->Path.hopCount-2] == 'q')
					strncpy(Station->IGate, APRS->Path.Hops[APRS->Path.hopCount-1], sizeof(Station->IGate));
				FixNWSIssueKill(Station, &stSystem, TRUE);
				if (NewOne)
				{	UTF8Save(&Station->sStatusReport, &Station->pStatusReport,
							GetNWSProduct(&ActiveConfig, Station->Owner+3, Station->Owner,
											*APRS->entryCall?APRS->entryCall:APRS->relayCall)->Desc HERE);
				}
			}

			if (APRS->Valid & APRS_WEATHER_VALID)	/* Maybe my weather station data! */
			{	Station->WeatherParsed = TRUE;
				if (!Station->Weather) Station->Weather = (WEATHER_INFO_S *) calloc(1,sizeof(*Station->Weather));
				*Station->Weather = APRS->Weather;
			}

			{	BOOL Changed = (!Station->isKilled!=!APRS->ObjectKilled);
				Station->isKilled = APRS->ObjectKilled;	/* Have to refresh this here */
				if (Changed)	/* Pretend it moved to force update */
				{	UpdateStationVisibility(Station, "Killed", TRUE, NewOne);
#ifdef DEBUG_CIRCLE_PAINT
TraceLogThread("LostVisible", FALSE, "%sObject(%s) %s Status Changed! - %s\n", NewOne?"NEW ":"", Station->Station, Station->isKilled?"KILLED":"ACTIVE", safebuf);
#endif
				}
			}
/*
	Process my own telemetry so I can graph it (and refresh the definitions)
*/
			if (APRS->Valid & APRS_TELEMETRY_VALID)	/* Telemetry? */
			{	unsigned long t = FindTelemetryCall(APRS->srcCall, TRUE);
				Station->hasTelemetry = TRUE;
				GetLocalTime(&Telemetry[t].stLast);
				Telemetry[t].Telemetry = APRS->Telemetry;
				RefreshTelemetryDefinition(hwnd, &ActiveConfig, Station->Station);
Start = DebugTimer("AprsLogPacket","Telemetry",Start,&msMax,&msLast, hwnd);
pStart = DebugTimer("AprsLogPacket","p(Telemetry)",pStart,&mspMax,&mspLast, hwnd, 1000);
			}

			if (APRS->Valid & APRS_BRGNRQ_VALID)
			{	if (!Station->pBRGNRQ)
					Station->pBRGNRQ = (BRGNRQ_INFO_S *)malloc(sizeof(*Station->pBRGNRQ));
				*Station->pBRGNRQ = APRS->BRGNRQ;
				Station->BRGNRQParsed = TRUE;
			}
			if (APRS->Valid & APRS_PHG_VALID)
			{	if (APRS->PHG.power == 0			/* 0 power */
				&& APRS->PHG.height == (1<<0)*10	/* 0 height */
				&& APRS->PHG.gain == 0				/* 0 gain */
				&& APRS->PHG.dir == 0)				/* 0 direction */
				{	Station->PHGParsed = FALSE;		/* this is aprs.fi's "clear PHG" request */
					if (Station->pPHG)
					{	free(Station->pPHG);
						Station->pPHG = NULL;
					}
				} else
				{	if (!Station->pPHG)
						Station->pPHG = (PHG_INFO_S *)malloc(sizeof(*Station->pPHG));
					*Station->pPHG = APRS->PHG;
					Station->PHGParsed = TRUE;
				}
			} else if (APRS->Valid & APRS_DFS_VALID)
			{	if (!Station->pPHG)
					Station->pPHG = (PHG_INFO_S *)malloc(sizeof(*Station->pPHG));
				*Station->pPHG = APRS->PHG;
				Station->DFSParsed = TRUE;
			} else if (APRS->Valid & APRS_PHG_RANGE_VALID)
			{	if (!Station->pPHG)
					Station->pPHG = (PHG_INFO_S *)calloc(1,sizeof(*Station->pPHG));
				else memset(Station->pPHG, 0, sizeof(*Station->pPHG));
				Station->PHGParsed = TRUE;	/* To enable painting */
				Station->pPHG->range = APRS->PHG.range;
			} else if (APRS->Valid & APRS_ALTITUDE_VALID
			&& APRS->alt > 0)
			{	if (!Station->pPHG)
					Station->pPHG = (PHG_INFO_S *)calloc(1,sizeof(*Station->pPHG));
				else memset(Station->pPHG, 0, sizeof(*Station->pPHG));
				/* http://en.wikipedia.org/wiki/Line-of-sight_propagation */
				Station->pPHG->range = 1.23*sqrt(APRS->alt*FeetPerMeter);
			}

			if (Station != MyStation)	/* do this stuff for everyone BUT me! */
			{
				if (!(APRS->Valid & APRS_MICE_MESSAGE_VALID)
				&& strncmp(Station->dstCall, APRS->dstCall, sizeof(Station->dstCall)))
				{	strncpy(Station->dstCall, APRS->dstCall, sizeof(Station->dstCall));
#ifndef UNDER_CE
					if (APRS->Valid & (APRS_LATLON_VALID|APRS_MESSAGE_VALID|APRS_BULLETIN_VALID|APRS_OBJECT_VALID|APRS_ITEM_VALID))	/* Got to have something going for it */
					if (IsValidAltNet(Station->dstCall))
					{
						//TraceLog("AltNet", FALSE, hwnd, "%s>%s\n", Station->Station, Station->dstCall);
						if (RememberAltNetChoice(hwnd, &ActiveConfig, Station->dstCall, FALSE))
						{	//TraceLog("AltNet", TRUE, hwnd, "New AltNet:%s\n", Station->dstCall);
							SaveConfiguration(hwnd, &ActiveConfig, "AltNetChoice", 600);
						}
					}
pStart = DebugTimer("AprsLogPacket","p(AltNet)",pStart,&mspMax,&mspLast, hwnd, 1000);
#endif
				}

				if (APRS->MessageCapable)
						Station->hasMessaging = TRUE;
				if (APRS->Valid & APRS_SYMBOL_VALID)
				{	if (Station->isymbol != APRS->symbol)
					{	Station->isymbol = APRS->symbol;
						if (Station->Nickname && !Station->Nickname->OverrideSymbol)
						{	Station->isymbol = APRS->symbol;
							char Overlay = (Station->isymbol>>8);
							char Symbol = Station->isymbol&0xff;
							if (Station->isymbol&0xff0000)
								Overlay = (Station->isymbol>>16)&0xff;
							else Overlay = Overlay?'\\':'/';
							Station->Nickname->Symbol.Table = Overlay;
							Station->Nickname->Symbol.Symbol = Symbol;
							SetNicknameSymbol(&ActiveConfig, Station->Station, &Station->Nickname->Symbol);
						}
						if (APRS->symbol == SymbolInt('\\','!'))	/* Emergency? */
						{	unsigned char SymIndex = GetMicEActionIndex(&ActiveConfig, "Sym(Emergency)", "Symbol");
							if (Station->MicEIndex != SymIndex)	/* Not already Emergency? */
							{	FirstMicE = !Station->MicEIndex;	/* TRUE if this is the first Mic-E for Station */
								Station->MicEIndex = SymIndex;	/* Set it to Emergency */
								Station->isEmergencySymbol = TRUE;
								MicEChanged = TRUE;
							}
						} else if (Station->isEmergencySymbol)	/* Is in emergency? */
						{	Station->MicEIndex = 0;	/* Take out the Mic-E status */
							MicEChanged = TRUE;
						}
					}

					if (APRS->symbol == SymbolInt('\\','m'))	/* Signpost */
					{	char *o = strchr(APRS->CleanComment,'{');
						if (o)
						{	char *c = strchr(o,'}');
							if (c && c > o)
							{	Station->isSignpost = TRUE;
							}
						}
					} else if (APRS->symbol == SymbolInt('H', 'A')
					|| APRS->symbol == SymbolInt('R', 'A'))
						Station->isRFID = TRUE;
				} else if (!Station->isymbol && (APRS->Valid & APRS_SYMBOL_DEFAULTED))
				{	Station->isymbol = APRS->symbol;
					if (Station->Nickname && !Station->Nickname->OverrideSymbol)
					{	char Overlay = (Station->isymbol>>8);
						char Symbol = Station->isymbol&0xff;
						if (Station->isymbol&0xff0000)
							Overlay = (Station->isymbol>>16)&0xff;
						else Overlay = Overlay?'\\':'/';
						Station->Nickname->Symbol.Table = Overlay;
						Station->Nickname->Symbol.Symbol = Symbol;
						SetNicknameSymbol(&ActiveConfig, Station->Station, &Station->Nickname->Symbol);
					}
				}

				if (!strncmp(APRS->dstCall,"APRFI",5))
				{	Station->isRFID = TRUE;
				}

				if (APRS->Valid & APRS_CRSSPD_VALID)
				{	Station->course = APRS->course;
					Station->speed = APRS->speed;
					Station->CSEParsed = TRUE;
				} else if (APRS->Valid & APRS_AREA_OBJECT_VALID)
				{	Station->course = APRS->course;	/* Actually Tyy */
					Station->speed = APRS->speed;	/* Actually Cxx */
					Station->AreaObjParsed = AreaObjectToMultiLine(APRS, Station);
					Station->CSEParsed = FALSE;	/* NOT a speed any more */
				} else if (APRS->Valid & APRS_LATLON_VALID)
					Station->CSEParsed = FALSE;	/* Only clear if a position packet */

				if (APRS->Valid & APRS_STORM_VALID)
				{	if (!Station->Storm) Station->Storm = (STORM_INFO_S *) calloc(1,sizeof(*Station->Storm));
					*Station->Storm = APRS->Storm;
				}

				if (APRS->Valid & APRS_MICE_MESSAGE_VALID)
				{	//if (!NoPopups)	/* Don't process Mic-Es on recalls */
					if (!Station->isEmergencySymbol)	/* Don't clobber Emergency Symbol settings */
					if (!Station->MicEIndex
					|| _strnicmp(APRS->MicEMessage, ActiveConfig.MicEs.MicE[Station->MicEIndex].Name,
								sizeof(ActiveConfig.MicEs.MicE[Station->MicEIndex].Name)))
					{	FirstMicE = !Station->MicEIndex;	/* TRUE if this is the first Mic-E for Station */
						Station->MicEIndex = (unsigned char) GetMicEActionIndex(&ActiveConfig, APRS->MicEMessage, APRS->srcCall);
						if (!_stricmp(APRS->MicEMessage, "unknown"))
						{	TraceError(hwnd, "Mic-E(%s) from %s\n", APRS->MicEMessage, safebuf);
						}
						MicEChanged = TRUE;
					}
				}

				if ((APRS->Valid & APRS_PLATFORM_VALID) && APRS->Platform[0]
				&& strncmp(APRS->StatusReport, "DX de ", 6))	/* DX packets have bogus platforms */
				{	if (!Station->pPlatform
					|| strncmp(Station->pPlatform, APRS->Platform, sizeof(APRS->Platform)))
					{	size_t Len = APRS->Platform[sizeof(APRS->Platform)-1]?sizeof(APRS->Platform):strlen(APRS->Platform);
						if (Station->pPlatform) free(Station->pPlatform);
						Station->pPlatform = (char*)malloc(Len+1);
						strncpy(Station->pPlatform, APRS->Platform, Len);
						Station->pPlatform[Len] = '\0';
					}
					if (APRS->tPlatform)	/* Has one */
					{	if (!Station->tPlatform)	/* Don't have one */
							Station->tPlatform = APRS->tPlatform;
						else if ((APRS->tPlatform!=PLATFORM_OTHER
							&& !IsPlatformGeneric(APRS->tPlatform))	/* Don't replace one with generic */
						|| (APRS->tPlatform==PLATFORM_OTHER					/* OTHERs (non-mainstream) */
								&& (Station->tPlatform == PLATFORM_OTHER	/* replace other OTHERs */
								|| IsPlatformGeneric(Station->tPlatform))))	/* or GENERICs */
						{
#ifdef VERBOSE
							if (Station->tPlatform != APRS->tPlatform)
							{	char *Was = GetPlatformString(Station->tPlatform,NULL);
								char *Now = GetPlatformString(APRS->tPlatform,NULL);
								TraceLogThread("Change(Platform)", APRS->tPlatform==PLATFORM_OTHER || IsPlatformGeneric(APRS->tPlatform),
												"%s Changes from %s to %s(%s) in %s\n", Station->Station, Was, Now, Station->pPlatform, safebuf);
							}
#endif
							Station->tPlatform = APRS->tPlatform;
						}
					}
				}
				
				if (!HasNickComment(Station)
				&& APRS->datatype != '{')	// Not from user-defined packets
					UpdateShriekStatus(Station, APRS->CleanComment);

				if (APRS->CleanComment[0])
				{	UTF8Save(&Station->sComment, &Station->pComment,
										APRS->CleanComment HERE);
					FixNWSIssueKill(Station, &stSystem, TRUE);
				}

				if (APRS->Capabilities[0])
					UTF8Save(&Station->sCapabilities, &Station->pCapabilities,
										APRS->Capabilities HERE);

				if (APRS->StatusReport[0])
				{	BOOL isStatusReport = (APRS->Valid&APRS_DATATYPE_VALID)
											&& (APRS->datatype=='>');
					APRS->StatusReport[sizeof(APRS->StatusReport)-1] = '\0';
					if (!strncmp(APRS->StatusReport, "DX de ", 6))
					{	char *p;
						for (p=APRS->StatusReport; *p; p++)
						{	if (isspace(*p&0xff) && isspace(p[1]&0xff))
							{	char *q;
								for (q=p+2; *q; q++)
									if (!isspace(*q&0xff))
										break;
								memmove(p+1, q, strlen(q)+1);	/* keep 1 space and copy \0 */
							}
						}
						TraceLogThread("DX", FALSE, "%s via %s %s\n",
										APRS->srcCall, APRS->relayCall,
										APRS->StatusReport);
					} else if (isStatusReport)
						UpdateShriekStatus(Station, APRS->StatusReport);

					if (isStatusReport || !Station->hasStatusReport)
					{	Station->hasStatusReport = isStatusReport;
						UTF8Save(&Station->sStatusReport, &Station->pStatusReport,
								APRS->StatusReport HERE);
					} else TraceLogThread("StatusReport", FALSE, "%s via %s Has Status(%S), Ignoring(%s)\n",
											Station->Station, APRS->relayCall,
											Station->pStatusReport,
											APRS->StatusReport);
				}

pStart = DebugTimer("AprsLogPacket","p(Valid)",pStart,&mspMax,&mspLast, hwnd, 1000);

				if (APRS->Valid & APRS_LATLON_VALID)
				{	MovedOK = UpdateStationPosition(hwnd, Station, APRS->lat, APRS->lon, APRS->alt, APRS->Valid&APRS_ALTITUDE_VALID, APRS->relayCall, &stSystem, (RfPort == RFPORT_INTERNAL), msNow, safebuf);
					if (MovedOK) StrSave(&Station->sLastPositPacket, &Station->pLastPositPacket, safebuf HERE);

					if (Station->NeedPosGate)	/* We need to gate a "free" position packet */
					if (!(APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID)))	/* Real station */
					{	int h;
						int cLen = strlen(CALLSIGN);
						int MyHop = 0;
						char *Payload = strchr(safebuf,':');	/* : delimits the end of the header */
					
						for (h=2; h<APRS->Path.hopUnused; h++)	/* Only check used path components */
						{	if (!strncmp(APRS->Path.Hops[h],CALLSIGN,cLen)
							&& (!APRS->Path.Hops[h][cLen] || APRS->Path.Hops[h][cLen]=='*'))
							{	MyHop = h;
								break;	/* If I've already processed this, don't do it again! */
							}
						}

						if (!MyHop && Payload)
						{	size_t Remaining = 512;
							char *Buffer = (char*)malloc(Remaining);
							char *Next = Buffer;
	/* KJ4ERJ-2>APJI23,WX4MLB-3,WIDE2*:}KJ4ERJ-AP>APWW00,TCPIP,KJ4ERJ-2*::WI8H-9   :Test for 3rd party format{225 */

							TraceLog("IGate", FALSE, hwnd, "Pos2RF:Position(%.*s), Local (%ld vs %ld), %ld Hops Body(%s)\n",
											STRING(Station->Station),
											(long) APRS->Path.hopCount, Payload+1);

							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												"%s>%s%s%s:}",
												CALLSIGN, DESTID, *PATH?",":"", PATH);

							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											"%s>%s", APRS->Path.Hops[0], APRS->Path.Hops[1]);
							{	BOOL FoundUsed = FALSE;
								BOOL FoundTcpIP = FALSE;
								size_t initRemain = Remaining;
								char *initNext = Next;

								for (h=2; h<APRS->Path.hopCount; h++)
								{	if (*APRS->Path.Hops[h] == 'q') break;	/* Don't include remote gate info */
									StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														",%s", APRS->Path.Hops[h]);
									if (IsTcpPath(APRS->Path.Hops[h]))
										FoundTcpIP = TRUE;
									if (strchr(APRS->Path.Hops[h],'*'))
									{	FoundUsed = TRUE;
										if (Next[-1] == '*') *--Next = '\0';
										break;	/* Quit after the used packet */
									}
								}
								if (!FoundUsed)	/* It was direct before now */
								{	Remaining = initRemain;
									Next = initNext;
								}
								StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											"%s,%s*:%s", !FoundTcpIP?",TCPIP":"", CALLSIGN, Payload+1);
							}

							QueueToTransmit(IS2RF_IGATE_PACKET, Buffer, TRUE, FALSE);
							TraceLog("IGate", TRUE, hwnd, "Pos2RF:Position(%.*s) %s\n", STRING(Station->Station), Buffer);
							if (IGateEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
							{	char *Temp = (char *) malloc(strlen(Buffer)+80);
								int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld Pos2RF:%s:[%ld]%s",
													(long) stSystem.wYear, 
													(long) stSystem.wMonth, 
													(long) stSystem.wDay, 
													(long) stSystem.wHour, 
													(long) stSystem.wMinute, 
													(long) stSystem.wSecond,
													CALLSIGN, (long) UDPSeq++,
													Buffer);
								if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
									TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Temp);
								free(Temp);
							}
							Station->NeedPosGate = FALSE;
							TraceLog("IGate", TRUE, hwnd, "Pos2RF:Delivered FreePosition(%s)\n", Station->Station);
							PositionsGated++;
							free(Buffer);
						} else TraceLog("IGate(NOT)", FALSE, hwnd, "Pos2RF:Position(%.*s), Already Handled By ME! ([%ld]=%s\n",
										STRING(Station->Station), (long) MyHop, APRS->Path.Hops[MyHop]);
					} else TraceLog("IGate(NOT)", FALSE, hwnd, "Pos2RF:Position(%.*s) Is Object or Item (%.*s)\n",
										STRING(Station->Station), STRING(APRS->objCall));

				if (FromRF && !*APRS->thirdCall)	/* Not third party */
				if (APRS->Path.hopUnused == 2)		/* Only direct */
				if (!Station->isObject)				/* No objects! */
				if (Station->pCoord->lat || Station->pCoord->lon)	/* NOT at 0,0 */
				if (!isRFDupe)					/* Don't count Dupes */
				if (!CheckIgnoreString(hwnd, &ActiveConfig.DX.Excluded, APRS->srcCall, TRUE))
				{	double distance, bearing, CmpDist;

					PurgeDXList(&PortPackets[ppc]);

					AprsHaversineLatLon(LastGoodPosition.dblLatitude,
									LastGoodPosition.dblLongitude,
									Station->pCoord->lat, Station->pCoord->lon,
									&distance, &bearing);
					CmpDist = distance * (ActiveConfig.View.Metric.Distance?KmPerMile:1);
					if (CmpDist >= ActiveConfig.DX.MinDist)
					{	BOOL NewOne = FALSE;
						int d;
						for (d=PortPackets[ppc].DXCount-1; d>=0; d--)
						{	if (PortPackets[ppc].DXList[d].Distance >= distance)
								break;
						}
						if (d >= 0
						&& !strncmp(PortPackets[ppc].DXList[d].Station, APRS->srcCall,
								sizeof(PortPackets[ppc].DXList[d].Station)))
						{	if (PortPackets[ppc].DXList[d].Distance == distance)
								PortPackets[ppc].DXList[d].Count++;
							else PortPackets[ppc].DXList[d].Count = 1;
							PortPackets[ppc].DXCount = d+1;	/* Truncate the list since this is new */
						} else
						{	if (d >= 0
							&& PortPackets[ppc].DXList[d].Distance == distance)
							{	TraceLogThread("DX", TRUE, "%s:TIE DX from %s %.2lfmi at %ld degrees, Overwriting[%ld] %s %.2lfmi @ %ld deg\n",
											PortPackets[ppc].Name,
											APRS->srcCall, 
											(double) distance, (long) bearing,
											(long) d, PortPackets[ppc].DX[d].Station,
											(double) PortPackets[ppc].DX[d].Distance,
											(long) PortPackets[ppc].DX[d].Bearing);
							} else
							{	d++;	/* Move up to available entry */
								NewOne = TRUE;	/* Only if distance is new! */
							}
							PortPackets[ppc].DXCount = d+1;
							if (PortPackets[ppc].DXCount > PortPackets[ppc].DXSize)
							{	PortPackets[ppc].DXSize += 8;
								PortPackets[ppc].DXList = (DX_PACKET_INFO_S *)realloc(PortPackets[ppc].DXList,PortPackets[ppc].DXSize*sizeof(*PortPackets[ppc].DXList));
							}
							strncpy(PortPackets[ppc].DXList[d].Station, APRS->srcCall,
									sizeof(PortPackets[ppc].DXList[d].Station));
							PortPackets[ppc].DXList[d].Count = 1;
						}

						PortPackets[ppc].DXList[d].Distance = distance;
						PortPackets[ppc].DXList[d].Bearing = bearing;
						PortPackets[ppc].DXList[d].lat = Station->pCoord->lat;
						PortPackets[ppc].DXList[d].lon = Station->pCoord->lon;
						GetSystemTime(&PortPackets[ppc].DXList[d].st);

						if (CmpDist >= ActiveConfig.DX.MinTrigger	// Far enough for trigger?
						&& (!d || PortPackets[ppc].DXList[0].Distance == distance))	// first or tie?
						{	TriggerDXReport(NewOne);	// New ones always transmit
						}

						// Now update the hourly buffer for local viewing
						if (distance > PortPackets[ppc].DX[0].Distance)
						{	BOOL NewOne = strncmp(PortPackets[ppc].DX[0].Station, APRS->srcCall,
									sizeof(PortPackets[ppc].DX[0].Station));
							PortPackets[ppc].DX[0] = PortPackets[ppc].DXList[d];
							PortPackets[ppc].DX[0].Count = 1;
							TraceLogThread("DX", TRUE, "%s:%s Hourly DX from %s %.2lfmi at %ld degrees\n",
											PortPackets[ppc].Name,
											NewOne?"New":"Repeat",
											PortPackets[ppc].DX[0].Station, 
											(double) PortPackets[ppc].DX[0].Distance,
											(long) PortPackets[ppc].DX[0].Bearing);
						} else if (distance == PortPackets[ppc].DX[0].Distance)
						{	if (!strncmp(PortPackets[ppc].DX[0].Station, APRS->srcCall,
										sizeof(PortPackets[ppc].DX[0].Station)))
							{	unsigned short Count = ++PortPackets[ppc].DX[0].Count;
								PortPackets[ppc].DX[0] = PortPackets[ppc].DXList[d];
								PortPackets[ppc].DX[0].Count = Count;
								TraceLogThread("DX", TRUE, "%s:Tie[%ld] Hourly DX from %s %.2lfmi at %ld degrees\n",
												PortPackets[ppc].Name,
												(long) PortPackets[ppc].DX[0].Count,
												PortPackets[ppc].DX[0].Station, 
												(double) PortPackets[ppc].DX[0].Distance,
												(long) PortPackets[ppc].DX[0].Bearing);
							} else
							{	TraceLogThread("DX", TRUE, "%s:TIE Hourly DX from %s %.2lfmi at %ld degrees, Overwriting %s %.2lfmi @ %ld deg\n",
											PortPackets[ppc].Name,
											APRS->srcCall, 
											(double) distance, (long) bearing,
											PortPackets[ppc].DX[0].Station,
											(double) PortPackets[ppc].DX[0].Distance,
											(long) PortPackets[ppc].DX[0].Bearing);
								PortPackets[ppc].DX[0] = PortPackets[ppc].DXList[d];
								PortPackets[ppc].DX[0].Count = 1;
							}
						}
					}
/*
	Now check for a new MaxEver
*/
					if (CmpDist >= ActiveConfig.DX.MaxEver.Distance)
					{	if (CmpDist == ActiveConfig.DX.MaxEver.Distance
						&& !strncmp(ActiveConfig.DX.MaxEver.Station, APRS->srcCall,
								sizeof(ActiveConfig.DX.MaxEver.Station)))
							ActiveConfig.DX.MaxEver.Count++;
						else
						{	ActiveConfig.DX.MaxEver.Count = 1;
							GetSystemTime(&ActiveConfig.DX.MaxEver.stFirst);
							strncpy(ActiveConfig.DX.MaxEver.Station, APRS->srcCall,
									sizeof(ActiveConfig.DX.MaxEver.Station));
						}
						GetSystemTime(&ActiveConfig.DX.MaxEver.st);
						ActiveConfig.DX.MaxEver.lat = Station->pCoord->lat;
						ActiveConfig.DX.MaxEver.lon = Station->pCoord->lon;
						ActiveConfig.DX.MaxEver.Distance = distance;
						ActiveConfig.DX.MaxEver.Bearing = bearing;
					}
				}

pStart = DebugTimer("AprsLogPacket","p(UpStatPos)",pStart,&mspMax,&mspLast, hwnd, 1000);

					if (APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID)
					&& (!APRS->ObjectKilled	/* Only items or objects */
						|| Station->isCenter))	/* Force centered ones */
					{	CheckMultiLineObject(APRS, Station);

{	char Temp[80];
	StringCbPrintfA(Temp, sizeof(Temp), "p(ML(%s[%ld/%ld]))", Station->Station, Station->MultiLine?Station->MultiLine->Count:0, Station->MultiLine?Station->MultiLine->Segments:0);
	pStart = DebugTimer("AprsLogPacket",Temp,pStart,&mspMax,&mspLast, hwnd, 1000);
}

						if (APRS->Valid & APRS_ITEM_VALID	/* Item */
						&& APRS->Valid & APRS_MESSAGE_VALID	/* In Message */
						&& !_stricmp(APRS->msgCall, CALLSIGN))	/* to ME! */
						if (!NoPopups
						&& (NewOne || MsgNew)
						&& ActiveConfig.Messaging.MultiTrackItemInMessage)	/* Only new ones and enabled */
						{
#if MAX_TRACKERS > 1
							HWND hwndTracker = CreateTrackerWindow(Station->Station, Station->Owner, -1, "0");	/* View NONE */
							if (hwndTracker)
								PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);
							else
#endif
								SetCenterTracking(hwnd, Station);
						}

						if (Station->isNWS && !Station->isKilled)
						if (ActiveConfig.NWS.MultiTrack
							|| (NewOne && ActiveConfig.NWS.MultiTrackNew))
						if (Station->MultiLine	/* Has lines */
						|| !ActiveConfig.NWS.MultiTrackLinesOnly)	/* Or not restricting */
						if (GetNWSProduct(&ActiveConfig,Station->Owner+3,Station->Owner,*APRS->entryCall?APRS->entryCall:APRS->relayCall)->ActionEnabled)
						{	NWS_ENTRY_SERVER_S *Srv;
							if (*APRS->Path.Hops[APRS->Path.hopCount-2] == 'q')
							{	Srv = GetNWSServer(&ActiveConfig, APRS->Path.Hops[APRS->Path.hopCount-1], APRS->Path.Hops[APRS->Path.hopCount-2], APRS->srcCall, TRUE);
							} else Srv = NULL;
							if (!Srv || !Srv->Disabled)
							{	TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
								unsigned long i = LocateTimedStringEntry(pList, "*");
								if (i == -1 || pList->Entries[i].value)	/* Didn't * find or disabled */
								{	i = LocateTimedStringEntry(pList, Station->Owner, 3);
								}
								if (i != -1						/* Found it*/
								&& !pList->Entries[i].value)	/* Not disabled */
								{	BOOL DoPopup = FALSE;	/* Default to NOT doing the popup */
									STATION_INFO_S *oStation = NULL;	/* Pointer to the "other" object */

									if (!ActiveConfig.NWS.MultiTrackMoving	/* Doesn't have to move */
									&& !ActiveConfig.NWS.MultiTrackMe		/* Doesn't have to cover me */
									&& !ActiveConfig.NWS.MultiTrackRange)	/* Doesn't have to be in range */
										DoPopup = TRUE;		/* Then display it! */
									else if (ActiveConfig.NWS.MultiTrackMoving	/* Want to see ALL movers! */
									&& (Station->CSEParsed && Station->speed > 0))	/* and moving! */
										DoPopup = TRUE;		/* We definitely want this one */
									else if (ActiveConfig.NWS.MultiTrackMe
									&& MeInMultiLineRectangle(Station->MultiLine))
										DoPopup = TRUE;
									else if (ActiveConfig.NWS.MultiTrackRange
									&& MyRangeInMultiLineRectangle(Station->MultiLine))
										DoPopup = TRUE;

									if (DoPopup	/* Planning to pop up? */
									&& ActiveConfig.NWS.MultiTrackPreferML	/* Check for a MultiLine equivalent? */
									&& Station->sComment)				/* MUST have a comment */
									{	TCHAR *mySeq = wcschr(Station->pComment, TEXT('{'));
										if (mySeq)								/* Found a sequence */
										{	for (unsigned long s=1; s<CloseStationCount; s++)
											if (pCloseStations[s]->isNWS && pCloseStations[s]->sComment
											&& !strcmp(pCloseStations[s]->Owner, Station->Owner)
											&& pCloseStations[s] != Station)	/* NOT ME! */
											{	TCHAR *tSeq = wcschr(pCloseStations[s]->pComment, TEXT('{'));
												if (tSeq && !wcsncmp(mySeq, tSeq, 6))
												{	oStation = pCloseStations[s];
//TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s)(%S) Found Matching (%s)(%s)(%S)\n", Station->Station, Station->Owner, Station->pComment, oStation->Station, oStation->Owner, oStation->pComment);
													break;
												}
											}
										}
									}
									if (DoPopup	/* Planning to pop up? */
									&& oStation	/* Found a duplicate sequence */
									&& strlen(Station->Station) == 9		/* Long enough? */
									&& islower(Station->Station[6]&0xff))	/* One of mine? */
									{	DoPopup = FALSE;	/* Don't pop up the new area-based one */
//TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s)(%S) Suppressed For Preferred (%s)(%s)(%S)\n", Station->Station, Station->Owner, Station->pComment, oStation->Station, oStation->Owner, oStation->pComment);
									}

									if (!NoPopups && DoPopup)	/* still wanting to pop it up? */
#ifdef OLD_WAY
									if (!Station->Time.day	/* See also PurgeCloseStations */
									|| !(((Station->Time.day == stNow.wDay
									&& 	(Station->Time.hour < stNow.wHour
										|| (Station->Time.hour == stNow.wHour 
											&& Station->Time.minute <= stNow.wMinute)))
									|| (Station->Time.day < stNow.wDay && stNow.wDay-Station->Time.day <= 3)	/* A few days ago, but not next month */
									|| (Station->Time.day >= 27 && stNow.wDay <=3))))/* Month wrap */
#else
									if (/*Station->isNWSIssued && */!Station->isKilled)
#endif
									{	HWND hwndTracker;
/*
	If there's an area object and we're popping a multiline, close the area's MultiTrack
*/
		if (oStation
		&& strlen(oStation->Station) == 9
		&& islower(oStation->Station[6]&0xff))
		for (int tr=1; tr<MAX_TRACKERS; tr++)	/* Don't count ME[0]! */
		{	if (cInfos[tr].Active
			&& cInfos[tr].CenterStation == oStation)
			{	long dSeconds = (long) DeltaSeconds(&oStation->stLast, &Station->stLast);
//TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s)(%S) Forcing Close (%ld seconds) (%s)(%s)(%S)\n", Station->Station, Station->Owner, Station->pComment, (long) dSeconds, oStation->Station, oStation->Owner, oStation->pComment);
				if (abs(dSeconds) <= 30)
				{	SendMessage(cInfos[tr].hwnd, WM_CLOSE, 0, 0);
				}
			}
		}

										hwndTracker = CreateTrackerWindow(Station->Station, Station->Owner, -1, "NWS Objects");	/* View NWS Objects */
										if (hwndTracker)
											PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);
//										TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) %s MultiTracking%s (%S)\n", Station->Station, Station->Owner, NewOne?"NEW":"Always", hwndTracker?"...":" FAILED!", Station->Comment);
									}
//									else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Already Expired on %02ld %02ld:%02ldz (%S)\n", Station->Station, Station->Owner, Station->Time.day,Station->Time.hour, Station->Time.minute, Station->Comment);
//									else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Yielding To Preferred Specific (MultiLine) Object (%S)\n", Station->Station, Station->Owner, Station->Comment);
								}
//								else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Disabled by NWS-Station/CWA(%.3s) (%S)\n", Station->Station, Station->Owner, Station->Owner, Station->Comment);
							}
//							else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Disabled by Entry(%s) (%S)\n", Station->Station, Station->Owner, APRS->Path.Hops[APRS->Path.hopCount-1], Station->Comment);
						}
//						else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Product(%s) Disabling Popup(%S)\n", Station->Station, Station->Owner, Station->Owner+3, Station->Comment);
//						else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) Suppressing non-area Popup(%S)\n", Station->Station, Station->Owner, Station->Comment);
//						else TraceLog("NWS-MultiTrack", TRUE, hwnd, "Station(%s)(%s) %s MultiTracking Not Enabled(%S)...\n", Station->Station, Station->Owner, NewOne?"NEW":"Always", Station->Comment);
{	char Buffer[80];
	sprintf(Buffer,"p(NWS(%s[%ld]))",APRS->objCall,Station->MultiLine?Station->MultiLine->Count:0);	/* Was p(NWSTracker) */
pStart = DebugTimer("AprsLogPacket",Buffer,pStart,&mspMax,&mspLast, hwnd, 1000);
}
					}
				
					Station->latlonExtended = APRS->latlonExtended;
					Station->Ambiguity = max(APRS->latAmbiguity, APRS->lonAmbiguity);

pStart = DebugTimer("AprsLogPacket","p(LatLon)",pStart,&mspMax,&mspLast, hwnd, 1000);
				}
				else if (APRS->Valid & APRS_GRIDSQUARE_VALID)
				{	char gsAmbiguity = strlen(APRS->GridSquare);
					char GridAmbiguity;	/* Strictly for comparison purposes */
					switch (gsAmbiguity)
					{
					case 2:	GridAmbiguity = 4; break;
					case 4:	GridAmbiguity = 3; break;
					case 6:	GridAmbiguity = 2; break;
					case 8:	GridAmbiguity = 1; break;
					default:
						GridAmbiguity = 1;
					}
					if (Station->pCoord
					&& Station->pCoord->lat == 0 && Station->pCoord->lon == 0)
					{	double Lat, Lon;
						GridSquare2LatLon(APRS->GridSquare, &Lat, &Lon);
						TCHAR *LatLon1 = APRSLatLon(Lat, Lon, ' ', ' ', Station->latlonExtended);
						TraceLog("GridSquare", TRUE, hwnd, "%s @ %s (%Samb:%ld) from %s\n",
								APRS->srcCall, APRS->GridSquare, LatLon1, GridAmbiguity, safebuf);
						MovedOK = UpdateStationPosition(hwnd, Station, Lat, Lon, 0, FALSE, APRS->relayCall, &stSystem, (RfPort == RFPORT_INTERNAL), msNow, safebuf);
						if (MovedOK) StrSave(&Station->sLastPositPacket, &Station->pLastPositPacket, safebuf HERE);
						free(LatLon1);
						Station->Ambiguity = GridAmbiguity;
						Station->gsAmbiguity = gsAmbiguity;
					} else if (Station->pCoord)
					{	double Lat, Lon;
						GridSquare2LatLon(APRS->GridSquare, &Lat, &Lon);
						if (Lat != Station->pCoord->lat
						|| Lon != Station->pCoord->lon)
						{	TCHAR *LatLon1 = APRSLatLon(Lat, Lon, ' ', ' ', Station->latlonExtended);
							TCHAR *LatLon2 = APRSLatLon(Station->pCoord->lat, Station->pCoord->lon, ' ', ' ', Station->latlonExtended);
							double distance, bearing;
							AprsHaversineLatLon(Station->pCoord->lat,
											Station->pCoord->lon,
											Lat, Lon,
											&distance, &bearing);
							TraceLog("GridSquare", GridAmbiguity <= Station->Ambiguity, hwnd, "%s @ %s (%Samb:%ld) is %.3lfmi @ %ld away from %Samb:%ld(+%ld)%s\n",
									APRS->srcCall, APRS->GridSquare,
									LatLon1, GridAmbiguity,
									(double) distance, (long) bearing,
									LatLon2, Station->Ambiguity, Station->latlonExtended,
									GridAmbiguity<=Station->Ambiguity?" MOVING!":"");
							free(LatLon1); free(LatLon2);
							if (GridAmbiguity <= Station->Ambiguity)	/* Better or equal to what we have? */
							{	MovedOK = UpdateStationPosition(hwnd, Station, Lat, Lon, 0, FALSE, APRS->relayCall, &stSystem, (RfPort == RFPORT_INTERNAL), msNow, safebuf);
								if (MovedOK)
								{	Station->Ambiguity = GridAmbiguity;
									Station->gsAmbiguity = gsAmbiguity;
									StrSave(&Station->sLastPositPacket, &Station->pLastPositPacket, safebuf HERE);
								}
							}
						}
					}
				}

				if (APRS->Valid & APRS_FREQUENCY_VALID)
				{
					if (!Station->Frequency) Station->Frequency = (FREQUENCY_INFO_S *) calloc(1,sizeof(*Station->Frequency));
					*Station->Frequency = APRS->Frequency;

					size_t Remain = 256;
					char *Buffer = (char*)malloc(Remain);
					char *Next = Buffer;

					char *SymText = GetDisplayableSymbol(Station->isymbol);
					if (APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID))
					StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										"%s %s(%s)(%s) Frequency:%.3lf",
										SymText,
										APRS->srcCall, APRS->objCall,
										Station->pPlatform?Station->pPlatform:"*NULL*",
										(double) Station->Frequency->freq);
					else
					StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										"%s %s(%s) Monitoring %.3lf",
										SymText,
										APRS->srcCall,
										Station->pPlatform?Station->pPlatform:"*NULL*",
										(double) Station->Frequency->freq);
					free(SymText);

					if (Station->Frequency->altfreq)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" Input:%.3lf%s",
										(double) Station->Frequency->altfreq,
										Station->Frequency->altfreq == Station->Frequency->freq?"(BOGUS)":"");
					if (Station->Frequency->tonetype)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
											Station->Frequency->tone?" %c:%03ld":" %c:None",
											Station->Frequency->tonetype, (long) Station->Frequency->tone);
					if (Station->Frequency->offset)
						if (abs(Station->Frequency->offset) >= 100)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" offset:%.2lfMHz", (double) Station->Frequency->offset/100.0);
						else StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" offset:%ldKHz", Station->Frequency->offset*10);
					if (Station->Frequency->standardoffset)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" %coffset", Station->Frequency->standardoffset);
					if (Station->Frequency->range)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" range:%.1lfmi", Station->Frequency->range);
					if (Station->Frequency->Issues)
						StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
										" %s", Station->Frequency->Issues);
					if (!dFound)
					{	TraceLog((APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID))?"FreqSpec-Object":"FreqSpec-Station", Station->Frequency->altfreq==Station->Frequency->freq, hwnd, "%s Comment:%s\n", Buffer, APRS->CleanComment);
						if (Station->Frequency->Issues)
							TraceLog("FreqSpec-Issues", FALSE, hwnd, "%s Comment:%s\n", Buffer, APRS->CleanComment);
						if (Station->Frequency->altfreq)
							TraceLog(Station->Frequency->altfreq!=Station->Frequency->freq?"FreqSpec-rxFreq":"FreqSpec-DupeFreq", FALSE, hwnd, "%s Comment:%s\n", Buffer, APRS->CleanComment);
						if (IsTraceLogEnabled("FreqSpec-NonPrint")
						&& (APRS->tPlatform == PLATFORM_KENWOOD_D710
							|| APRS->tPlatform == PLATFORM_KENWOOD_D72
							|| APRS->tPlatform == PLATFORM_KENWOOD_D74))
						for (char *c=APRS->CleanComment; *c; c++)
						{	if (!isprint(*c&0xff))
							{	TraceLog("FreqSpec-NonPrint", FALSE, hwnd, "%s Comment:%s\n", Buffer, APRS->CleanComment);
								break;
							}
						}
					}
					free(Buffer);
				}

				if (Station->MessagePending)	/* We have an outbound pending */
				if (!(APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID)))	/* Real station */
				{	int m;
					for (m=0; m<PendingMsgCount; m++)
					if (!PendingMsgs[m].Subordinated)
					{	if (PendingMsgs[m].Retries >= MAX_MSG_RETRIES
						&& !PendingMsgs[m].Retriggered
						&& !_stricmp(Station->Station,PendingMsgs[m].MsgAckFrom))
						{	RetriggerPendingMessage(m,"Packet",TRUE);	/* Retrigger sending */
						}
#ifdef OBSOLETE
						else TraceLog("Messages", FALSE, hwnd, "MSG:MessagePending(%.*s) [%ld/%ld] not %.*s or %s or %ld vs %ld\n",
									STRING(Station->Station),
									(long) m, (long) PendingMsgCount,
									STRING(PendingMsgs[m].MsgAckFrom),
									PendingMsgs[m].Retriggered?"FINAL":"",
									(long) PendingMsgs[m].Retries,
									(long) MAX_MSG_RETRIES);
#endif
					}
					Station->MessagePending = FALSE;	/* Only trigger once */
pStart = DebugTimer("AprsLogPacket","p(MsgPend)",pStart,&mspMax,&mspLast, hwnd, 1000);
				}
				else TraceLog("Messages", FALSE, hwnd, "MessagePending:Station(%.*s) is Object or Item Datatype(%c) Valid(0x%lX) vs 0x%lX\n",
								STRING(Station->Station),
								APRS->datatype, (long) APRS->Valid, (long) ((APRS_OBJECT_VALID | APRS_ITEM_VALID)));


#ifdef SUPPORT_RFID
				if (ActiveConfig.RFIDs.Count	/* MUST do this to avoid nulls on RFIDs.RFID[0]. */
				&& APRS->Comment[0] && APRS->Valid & APRS_SYMBOL_VALID && APRS->symbol == SymbolInt('H','A'))
				{	char *freetext = APRS->Comment;

					if (strlen(freetext) >= 8
					&& freetext[0] == '>'
					&& (isdigit(freetext[1]&0xff) && isdigit(freetext[2]&0xff) && isdigit(freetext[3]&0xff))
					&& freetext[4] == '/'
					&& (isdigit(freetext[5]&0xff) && isdigit(freetext[6]&0xff) && isdigit(freetext[7]&0xff)))
					{	Station->RFID.Type = Station->RFID.CSESPD;

						Station->RFID.CseSpd.course = RFIDFromDecimal(&freetext[1],3);
						Station->RFID.CseSpd.speed = RFIDFromDecimal(&freetext[5],3);

						RememberRFIDReader(hwnd, &ActiveConfig, safebuf);

						TraceLog("RFID", ActiveConfig.RFIDs.RFID[0].AssocEnabled, hwnd, "RFID:Reader(%.*s)(%.*s) Comment(%.*S)(%.*s)(%.*s) Gives course(%ld) speed(%ld) @%.6lf %.6lf",
										STRING(Station->Owner), STRING(Station->Station),
										Station->sComment*sizeof(TCHAR), Station->pComment,
										STRING(APRS->Comment), STRING(APRS->CleanComment),
										(long) Station->RFID.CseSpd.course, (long) Station->RFID.CseSpd.speed,
										(double) Station->pCoord->lat, (double) Station->pCoord->lon);

						UTF8Save(&Station->sComment, &Station->pComment,
								APRS->Comment+10 HERE);

					}


		/* WB4APR-5>BEACON,WB4APR-3*,qAR,N3UJJ:;USNA-Lab *111111z3859.11NH07629.11WA+01-00+002 147.075 RFID HotSpot */
/* >ccc/sss   */
/* 0123456789 */
/* +A-G+II/NM */
					else if (strlen(freetext) >= 10
					&& (freetext[0] == '+' || freetext[0] == '-')
					&& isdigit(freetext[1]&0xff)
					&& (freetext[2] == '+' || freetext[2] == '-')
					&& isdigit(freetext[3]&0xff)
					&& (freetext[4] == '+' || freetext[4] == '-')
					&& (isdigit(freetext[5]&0xff) && isdigit(freetext[6]&0xff))
					&& freetext[7] == '/'
					&& (isdigit(freetext[8]&0xff) && isdigit(freetext[9]&0xff)))
					{	Station->RFID.Type = Station->RFID.GRID;

						Station->RFID.Grid.dlat = RFIDFromDecimal(&freetext[1],1);
						Station->RFID.Grid.dlon = RFIDFromDecimal(&freetext[3],1);
						Station->RFID.Grid.offset = RFIDFromDecimal(&freetext[5],2);
						Station->RFID.Grid.rows = RFIDFromDecimal(&freetext[8],1) * 3;
						Station->RFID.Grid.cols = RFIDFromDecimal(&freetext[9],1);
						if (freetext[0] == '-') Station->RFID.Grid.dlat = -Station->RFID.Grid.dlat;
						if (freetext[2] == '-') Station->RFID.Grid.dlon = -Station->RFID.Grid.dlon;
						if (freetext[4] == '-') Station->RFID.Grid.offset = -Station->RFID.Grid.offset;
						if (Station->RFID.Grid.rows == 0) Station->RFID.Grid.rows = 30;
						if (Station->RFID.Grid.cols == 0) Station->RFID.Grid.cols = 10;

						RememberRFIDReader(hwnd, &ActiveConfig, safebuf);

						TraceLog("RFID", ActiveConfig.RFIDs.RFID[0].AssocEnabled, hwnd, "RFID:Reader(%.*s)(%.*s) Comment(%.*S)(%.*s)(%.*s) Gives dlat(%ld) dlon(%ld) offset(%ld) rows(%ld) cols(%ld) @%.6lf %.6lf",
										STRING(Station->Owner), STRING(Station->Station),
										Station->sComment*sizeof(TCHAR), Station->pComment,
										STRING(APRS->Comment), STRING(APRS->CleanComment),
										(long) Station->RFID.Grid.dlat, (long) Station->RFID.Grid.dlon,
										(long) Station->RFID.Grid.offset,
										(long) Station->RFID.Grid.rows,  (long) Station->RFID.Grid.cols,
										(double) Station->pCoord->lat, (double) Station->pCoord->lon);

						UTF8Save(&Station->sComment, &Station->pComment,
									APRS->Comment+10 HERE);

		/*
			Build a track to show where IDs will go
		*/

						FreeTracks(Station, FALSE);	/* Dump the previous "track" */

						if (Station->RFID.Grid.dlat	/* if we've got a delta */
						|| Station->RFID.Grid.dlon
						|| Station->RFID.Grid.offset)	/* or an offset */
						{	int r, c;
							double llat, llon;
							double latoffset = (double)Station->RFID.Grid.offset/1000.0/60.0;
							double lonoffset = latoffset*6/cos(DegToRad(Station->pCoord->lat));

		/*
		Then it begins the next column which is offset in longitude 16
		times the latitude increment (divided by the local COS(lat)) so
		that the separation works at all latitudes.
		*/

							//if (Station->RFID.Grid.dlat < 0) latoffset = -latoffset;
							//if (Station->RFID.Grid.dlon < 0) lonoffset = -lonoffset;

							for (c=0, llon=Station->pCoord->lon+(double)Station->RFID.Grid.dlon/100.0/60.0; c<Station->RFID.Grid.cols; c++, llon+=lonoffset)
							{	for (r=0, llat=Station->pCoord->lat+(double)Station->RFID.Grid.dlat/100.0/60.0; r<Station->RFID.Grid.rows; r++, llat+=latoffset)
								{	int t = Station->TrackCount++;

									if (Station->TrackCount >= Station->TrackSize)
									{	Station->TrackSize += Station->RFID.Grid.rows * Station->RFID.Grid.cols + 8;
										Station->Tracks = (TRACK_INFO_S *) realloc(Station->Tracks, sizeof(*Station->Tracks)*Station->TrackSize);
									}

									Station->Tracks[t].pCoord = GetCoordIndex(llat, llon, "RFID", Station->Station, NULL);
									Station->Tracks[t].alt = 0;
									Station->Tracks[t].msec = msNow;
									Station->Tracks[t].Invalid = TRACK_OK;

									if (ActiveConfig.RFIDs.RFID[0].AssocEnabled)
									{	char *show = strstr(APRS->Comment,"SHOWME");
										char Buffer[128], *DAO=NULL;
										TCHAR *LatLon = APRSLatLon(llat, llon, '\\', 'A', 0, 2, &DAO);
										if (show)
										{	char Prefix[STATION_SIZE] = "SPOT";
											char *p1 = strchr(show,'(');
											if (p1)
											{	char *p2 = strchr(++p1,')');
												if (p2)
												{	if (p2-p1 > 4) p2 = p1+4;
													memset(Prefix, 0, sizeof(Prefix));
													strncpy(Prefix, p1, (int) (p2-p1));
												}
											}
											sprintf(Buffer,"%s>APRFID:)%s %1ld %2ld!%SXRFIDRFIDX@%.*s%.*S %s",
													APRS->srcCall, Prefix, (long) c, (long) r,
													LatLon, STRING(Station->Station),
													Station->sComment*sizeof(TCHAR), Station->pComment, DAO);
											TraceLog("RFID", TRUE, hwnd, "RFID:SPOT(%s)\n", Buffer);
											QueueToTransmit(OBJECT_PACKET, Buffer);
											AprsLogInternalPacket("RFID", hwnd, Buffer);	/* Process it on my display also! */
										}
										free(LatLon);
										if (DAO) free(DAO);
									}
									if (!latoffset) break;	/* No need to be redundant */
								}
								if (!lonoffset) break;	/* No need to be redundant */
							}
							{	int t = Station->TrackCount++;
								if (Station->TrackCount >= Station->TrackSize)
								{	Station->TrackSize += 8;
									Station->Tracks = (TRACK_INFO_S *) realloc(Station->Tracks, sizeof(*Station->Tracks)*Station->TrackSize);
								}
								Station->Tracks[t].pCoord = Station->pCoord;
								Station->Tracks[t].pCoord->References++;
								Station->Tracks[t].alt = 0;
								Station->Tracks[t].msec = msNow;
								Station->Tracks[t].Invalid = TRACK_OK;
							}
						}
					}
/*
	We don't understand what this one wants
*/
					else
					{	TraceLog("RFID", TRUE, hwnd, "RFID:Reader(%.*s)(%.*s) Comment(%.*S)(%.*s)(%.*s) Unrecognized (and ignored) Format @%.6lf %.6lf",
										STRING(Station->Owner), STRING(Station->Station),
										Station->sComment*sizeof(TCHAR), Station->pComment,
										STRING(APRS->Comment), STRING(APRS->CleanComment),
										(double) Station->pCoord->lat, (double) Station->pCoord->lon);
					}
pStart = DebugTimer("AprsLogPacket","p(Reader)",pStart,&mspMax,&mspLast, hwnd, 1000);
				}
#endif
			}
/*
	Now that Station has been fully populated...
*/
			if (APRS->thirdCall[0])	/* Third party transmissions come from the third party */
			{	//	STATION_INFO_S *SrcStat = FindStationCall(APRS->thirdCall);	/* But the path is wrong, so I can't do this yet */
				//	if (SrcStat) AccumulatePacketPath(SrcStat, APRS, safebuf, FromRF, RfPort);	/* Wrong path in APRS->Path */
			} else if (APRS->Valid & (APRS_OBJECT_VALID | APRS_ITEM_VALID))	/* Objects/Items come from source station */
			{	STATION_INFO_S *SrcStat = FindStationCall(APRS->srcCall);
				if (dFound) Station->Packets[0].Dupes++;
				if (SrcStat) AccumulatePacketPath(SrcStat, APRS, safebuf, FromRF, RfPort, msNow, Station);
			} else
			{	if (dFound) Station->Packets[0].Dupes++;
				AccumulatePacketPath(Station, APRS, safebuf, FromRF, RfPort, msNow);
			}
			UpdateStationScrollerPath(Station, st==-1?NULL:&Stations[st], APRS, FromRF, RfPort, msNow, pstSystem);

{	char Buffer[80];
	sprintf(Buffer,"p(Path(%ld))",(long)APRS->Path.hopCount);
pStart = DebugTimer("AprsLogPacket",Buffer,pStart,&mspMax,&mspLast, hwnd, 1000);
}
			UpdateStationVisibility(Station, MicEChanged?"MicEChanged":NewOne?"NewOne":((APRS->Valid&APRS_LATLON_VALID)?(MovedOK?"Moved":"Fixed"):"NoLatLon"), MovedOK, NewOne, MicEChanged);

#ifdef OLD_WAY
			if (NewOne)	/* Get the new ones on-screen if necessary */
			{	for (int tr=0; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active)
				{	if (Station->TInfo[tr].visible = IsStationVisible(&cInfos[tr], Station))
					{	cInfos[tr].Circle.StationsValid = FALSE;
						cInfos[tr].Circle.InvalidReason = "NewOne";
						//cInfos[tr].Circle.msLastPaint = 0;
						InvalidateCircle(hwndTracker[tr], FALSE, TRUE, 1000);
					}
				}
			}
#endif

/*
	Now get the popup open if it's new
	and process other things that needed to wait for location
*/
			if (Station)
			{	if (NewOne || Station->wasRecalled)	/* New station? */
				{	if (NoPopups) Station->wasRecalled = TRUE;	/* Not really new */
					else
					{	Station->wasRecalled = FALSE;	/* Really new now */
/*
	All "When New" processing goes here, it fires on the first packet AFTER Recalls
*/
						if (Station->Nickname && Station->Nickname->MultiTrackNew)
						{	RestoreOrCreateTrackerWindow(Station->Station, Station->Owner);
						}
					}
				}

				if (!NoPopups	/* Not during reload */
				&& Station->Nickname
				&& (Station->Nickname->MultiTrackActive
					|| Station->Nickname->MultiTrackAlways)
				&& !GetMultiTrackWindow(Station->Station, Station))
					RestoreOrCreateTrackerWindow(Station->Station, Station->Owner);

				if (!NoPopups
				&& ActiveConfig.FreqMon.Enabled
				&& Station->Frequency
				&& APRS->Valid & APRS_FREQUENCY_VALID
				&& (!*FreqMonFilter.FilterText
					|| FilterPacket(&FreqMonFilter, APRS)))
				{	if (!hwndFreq) CreateFrequencyWindow(hwndMain);
					if (hwndFreq) SendMessage(hwndFreq, WM_USER, 0, (LPARAM) Station);
				}

				if (!NoPopups)	/* Not during initial load */
				if (!Station->isKilled)	/* Ignore killed objects */
				if (Station->MicEIndex)
				{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
					if (MicEChanged)	/* Do the delta-checks in here */
					{	if (FirstMicE)	/* Only on the first Mic-E from station */
						{	/* Nothing here that I can think of... */
						}
						if (Action->Enabled)
						if (Action->MultiTrackNew)	/* New actually means new Mic-E state */
						if (ActiveConfig.Enables.MicENotification
						|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
						if (!CheckIgnoreString(hwnd, &Action->Ignores, Station->Station, TRUE))
						{	RestoreOrCreateTrackerWindow(Station->Station, Station->Owner);
						}
						if (Action->Enabled)
						if (Action->InternalMessage)
						if (ActiveConfig.Enables.MicENotification
						|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
						if (!CheckIgnoreString(hwnd, &Action->Ignores, Station->Station, TRUE))
						{	char *Buffer = (char*)malloc(80);
							StringCbPrintfA(Buffer, 80, "Mic-E:%s Transmitted Status(%s)", Station->Station, Action->Name);
//							QueueInternalMessage(Buffer, TRUE);
							QueueRememberMessage(Station->Station, CALLSIGN, Buffer, MESSAGE_INTERNAL);
							free(Buffer);
						}
					}
					/* And now the always checks */
					if (Action->Enabled)
					if (Action->MultiTrackActive
					&& !GetMultiTrackWindow(Station->Station, Station))
					if (ActiveConfig.Enables.MicENotification
					|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
					if (!CheckIgnoreString(hwnd, &Action->Ignores, Station->Station, TRUE))
						RestoreOrCreateTrackerWindow(Station->Station, Station->Owner);
				}
			}			
//for (int tr=0; tr<MAX_TRACKERS; tr++)
//if (cInfos[tr].Active)
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]AprsLogPacket(%s) %s %sVisible\n", (int) tr, NewOne?"NewOne":"Updated", Station->Station, Station->TInfo[tr].visible?"":"NOT ");
Start = DebugTimer("AprsLogPacket","Process",Start,&msMax,&msLast, hwnd);
		}
/*
	Now snapshot in the station's color so Invalids don't color all instances
*/
		if (st != -1)
		{	Stations[st].BackColor = GetSysColor(COLOR_WINDOW);	/* Default to Window Background (white) */
			if (Stations[st].CloseIndex != -1)	/* Known Station */
			{	unsigned int cIndex = Stations[st].CloseIndex;
				STATION_INFO_S *cStat = pCloseStations[cIndex];
				Stations[st].Lat = cStat->pCoord->lat;
				Stations[st].Lon = cStat->pCoord->lon;

				if (cStat->TrackCount	/* Recent entry is a duplicate */
				&& cStat->Tracks[cStat->TrackCount-1].Invalid)
				{	Stations[st].BackColor = GetInvalidColor(cStat->Tracks[cStat->TrackCount-1].Invalid);
				} else if (cStat->isClient)
				{	Stations[st].BackColor = RGB(255,255,128);
				}
			} else Stations[st].Lat = Stations[st].Lon = 0.0;
		}
/*
	Handle the QRU message group stuff
*/
		if (ActiveConfig.QRU.Enabled)
		if (APRS->Valid & APRS_MESSAGE_VALID	/* Message? */
		&& !_strnicmp(APRS->msgCall, "QRU", 3)		/* For QRU-Something for me? */
		&& (!APRS->msgCall[3] || IsSameBaseCallsign(&APRS->msgCall[3],CALLSIGN)))
		if ((!strncmp(APRS->Comment, "ack", 3)
		|| !strncmp(APRS->Comment, "rej", 3))
		&& APRS->Comment[5] == '}')	/* Is it my Reply-Ack? */
		{	SpaceCompress(-1, APRS->Comment);	/* We only want the purest essence (no trailing spaces, at least) */
			CheckAndHandlePendingAck(APRS->srcCall, APRS->Comment, &APRS->Comment[3]);
		} else //if (APRS->Comment[0] == '?')	/* Only queries */
		{	char *Groups = GetQRUGroups(&ActiveConfig, TRUE);
			STATION_INFO_S *Stat = FindStationCall(APRS->srcCall);	/* Can only talk to ones we know */

			if (Groups && *Groups)	/* Have any groups? */
			if (Stat && (Stat->pCoord->lat || Stat->pCoord->lon))
			{	int PrefixLen = 0;
				char *Body = NULL;
				char *Request = SkipWhite(APRS->Comment);

				SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, APRS->Comment);	/* strips off ack request */

				if (!_strnicmp(Request,"INFO",4)	/* Just the groups */
				|| !_strnicmp(Request,"?INFO",5))	/* Just the groups */
				{	unsigned long range = ActiveConfig.QRU.Range;
					char *group = _strdup(Request);
					char *r = strchr(group,' ');
					if (r)
					{	char *e;
						long newrange;
						*r++ = '\0';	/* Null term group */
						newrange = strtol(r,&e,10);
						if (!*e && newrange > 0)
						{	range = newrange;
						}
					}
					free(group);
					Body = GetQRUGroups(&ActiveConfig, TRUE, Stat->pCoord->lat, Stat->pCoord->lon, range, ActiveConfig.View.Metric.Distance);
					if (Body)
					{	char *NewBody = (char*)malloc(strlen(Body)+80);
						sprintf(NewBody,"de %s:%s Max %ld@%lu%s",
								CALLSIGN, Body,
								(long) ActiveConfig.QRU.MaxObjs,
								(long) range,
								ActiveConfig.View.Metric.Distance?"km":"mi");
						free(Body);
						Body = NewBody;
						PrefixLen = 3+strlen(CALLSIGN)+1;
					}
				} else
				{	unsigned long range = ActiveConfig.QRU.Range;
					unsigned long maxobjs = ActiveConfig.QRU.MaxObjs;
					char *group = _strdup(Request);
					char *r = strchr(group,' ');
					if (r)
					{	long value;
						*r++ = '\0';	/* Null term group */
						r = SkipWhite(r);
						if (*r == '#')
						{	value = strtol(r+1,&r,10);
							if (value > 0 && value < (long) maxobjs)
								maxobjs = value;
						}
						value = strtol(r,&r,10);
						if (value > 0)
						{	range = value;
						}
						r = SkipWhite(r);
						if (*r == '#')
						{	value = strtol(r+1,&r,10);
							if (value > 0 && value < (long) maxobjs)
								maxobjs = value;
						}
					}
					if (*group != '?')	/* Naked group? */
					{	char *newGroup = (char*)malloc(1+strlen(group)+1);
						strcat(strcpy(newGroup,"?"),group);
						free(group);
						group = newGroup;
					}
					unsigned long Count = TransmitClosestGroupObjects(hwnd, group, Stat, range, ActiveConfig.View.Metric.Distance, maxobjs);
					if (Count)
					{	Body = (char*)malloc(80);
						sprintf(Body,"Sent %ld %s Objects Max %ld@%lu%s de %s",
								(long) Count, group+1,	/* +1 drops the leading ? */
								(long) maxobjs,
								(long) range,
								ActiveConfig.View.Metric.Distance?"km":"mi",
								CALLSIGN);
					}
					free(group);
				}

				if (Body)	/* Did we get something? */
				{
//ShowTraceLog("QRU");
					int Len = strlen(Body)+1;
					TCHAR *Message = (TCHAR *) malloc(Len*sizeof(*Message));
					TCHAR *Next = Message;
					size_t Remaining = sizeof(*Message)*Len;
					*Message = *TEXT("");

					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("%S"), Body);

#define RESPOND_AS_QRU
#ifdef RESPOND_AS_QRU
					{	SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, PrefixLen, Message, FALSE,
											FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
						RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
						TraceLogThread("QRU", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
					}
#else
					{	SendAPRSMessageFrom(/*hwnd,*/ CALLSIGN, APRS->srcCall, PrefixLen, Message, FALSE,
											FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
						RememberMessage2(CALLSIGN, APRS->srcCall, Message, MESSAGE_ME);
						TraceLogThread("QRU", TRUE, "%s>%s %S\n", CALLSIGN, APRS->srcCall, Message);
					}
#endif
					free(Message);
					free(Body);
				}
			} else TraceLogThread("QRU", TRUE, "Station(%s) Not Found for %s\n", APRS->srcCall, APRS->Comment);
			else TraceLogThread("QRU", TRUE, "No QRU Groups For Station(%s) %s\n", APRS->srcCall, APRS->Comment);
			if (Groups) free(Groups);
		}
//		else TraceLogThread("QRU", TRUE, "NonQuery(%s) From Station(%s)\n", APRS->Comment, APRS->srcCall);
Start = DebugTimer("AprsLogPacket","QRU",Start,&msMax,&msLast, hwnd);

/*
	Handle the QRZ message group stuff
*/
		if (!_stricmp(CALLSIGN, "KJ4ERJ-15")
		&& APRS->Valid & APRS_MESSAGE_VALID	/* Message? */
		&& !_stricmp(APRS->msgCall, "QRZ"))		/* For QRZ-Something for me? */
		if ((!strncmp(APRS->Comment, "ack", 3)
		|| !strncmp(APRS->Comment, "rej", 3))
		&& APRS->Comment[5] == '}')	/* Is it my Reply-Ack? */
		{	SpaceCompress(-1, APRS->Comment);	/* We only want the purest essence (no trailing spaces, at least) */
			CheckAndHandlePendingAck(APRS->srcCall, APRS->Comment, &APRS->Comment[3]);
		} else //if (APRS->Comment[0] == '?')	/* Only queries */
		{	STATION_INFO_S *FromStat = FindStationCall(APRS->srcCall);	/* Can only talk to ones we know */
			if (FromStat)
			{	int PrefixLen = 0;
				char *Body = NULL;

				TraceLogThread(APRS->msgCall, TRUE, "%s>%s %s\n", APRS->srcCall, APRS->msgCall, APRS->Comment);
				RememberMessage(APRS->srcCall, APRS->msgCall, APRS->Comment, MESSAGE_ME);
				SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, APRS->Comment);	/* strips off ack request */

				char *Query = RtStrnTrim(-1,strdup(APRS->Comment));
				STATION_INFO_S *qStat = FindStationCall(Query);
				if (qStat && !qStat->HeardInternal)
				{	BOOL DidIt = TransmitStationTo(qStat, FromStat, APRS->msgCall);
					if (DidIt)
					{	char TempTime[32];
						Body = (char*)malloc(80);
						if (qStat->isObject)
							sprintf(Body,"Sent %s (%s) de %s",
									qStat->Station,
									FormatDeltaTime(SecondsSince(qStat->stPos.wYear?&qStat->stPos:&qStat->stLast),
													TempTime, sizeof(TempTime)),
									qStat->Owner);
						else
						{	char *Heard = FormatStationHeard(qStat);
							sprintf(Body,"Sent %s (%s) %s %s",
									qStat->Station,
									FormatDeltaTime(SecondsSince(qStat->stPos.wYear?&qStat->stPos:&qStat->stLast),
													TempTime, sizeof(TempTime)),
									Heard,
									qStat->pPlatform?qStat->pPlatform:"");
							free(Heard);
						}
					}
				} else
				{	unsigned long s;
					size_t qLen = strlen(Query);
					if (qLen <= 0)
					{	Body = (char*)malloc(80);
						sprintf(Body,"Please Specify StationID");
					} else if (qLen >= sizeof(qStat->Station))
					{	Body = (char*)malloc(80);
						sprintf(Body,"StationID Too Long, Max=%ld (Got %ld)", (long) sizeof(qStat->Station)-1, (long) qLen);
					} else
					{	int FoundCount = 0;
						Body = (char*)malloc(80);
						*Body = '\0';
						for (s=0; s<CloseStationCount; s++)
						if (!pCloseStations[s]->HeardInternal)
						{	size_t i;
							BOOL Match = TRUE;
							STATION_INFO_S *tStat = pCloseStations[s];
							for (i=0; i<qLen; i++)
							{	if (!tStat->Station[i])
								{	if (Query[i] != '*') Match = FALSE;	
									break;
								}
								if (toupper(tStat->Station[i]) != toupper(Query[i]))
								{	if (Query[i] == '*') break;	/* We have a match */
									if (Query[i] == '?') continue;	/* skip character */
									Match = FALSE;	/* No match here! */
									break;
								}
							}
							if (Query[i] != '*'
							&& i < sizeof(tStat->Station)
							&& tStat->Station[i]) Match = FALSE;
							if (Match)
							{	qStat = pCloseStations[s];
								if (!_strnicmp(qStat->Station, Query, qLen))	/* Exact? */
								{	FoundCount = 1;	/* Override */
									strcpy(Body, qStat->Station);	/* This one */
									break;			/* Transmit this one only */
								}
								FoundCount++;
								if (strlen(Body) < 67)
								{	if (*Body) strcat(Body, " ");
									strcat(Body, qStat->Station);
								}
							}
						}
						if (!*Body) sprintf(Body, "No Matches Found for %s", Query);
						else if (strlen(Body) >= 67)
							sprintf(Body, "%ld Matches, Respecify", (long) FoundCount);
						else if (FoundCount == 1 && qStat)
						{	BOOL DidIt = TransmitStationTo(qStat, FromStat, APRS->msgCall);
							if (DidIt)
							{	char TempTime[32];
								if (qStat->isObject)
									sprintf(Body,"Sent %s (%s) de %s",
											qStat->Station,
											FormatDeltaTime(SecondsSince(qStat->stPos.wYear?&qStat->stPos:&qStat->stLast),
															TempTime, sizeof(TempTime)),
											qStat->Owner);
								else
								{	char *Heard = FormatStationHeard(qStat);
									sprintf(Body,"Sent %s (%s) %s %s",
											qStat->Station,
											FormatDeltaTime(SecondsSince(qStat->stPos.wYear?&qStat->stPos:&qStat->stLast),
															TempTime, sizeof(TempTime)),
											Heard,
											qStat->pPlatform?qStat->pPlatform:"");
									free(Heard);
								}
							}
						}
					}
				}

				if (Body)	/* Did we get something? */
				{
//ShowTraceLog("QRZ");
					int Len = strlen(Body)+1;
					TCHAR *Message = (TCHAR *) malloc(Len*sizeof(*Message));
					TCHAR *Next = Message;
					size_t Remaining = sizeof(*Message)*Len;
					*Message = *TEXT("");

					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("%S"), Body);

					{	SendAPRSMessageOneShot(APRS->msgCall, APRS->srcCall, PrefixLen, Message);
						RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
						TraceLogThread(APRS->msgCall, TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
					}
					free(Message);
					free(Body);
				}
				free(Query);
			} else TraceLogThread(APRS->msgCall, TRUE, "Station(%s) Not Found for %s\n", APRS->srcCall, APRS->Comment);
		}
//		else TraceLogThread("QRZ", TRUE, "NonQuery(%s) From Station(%s)\n", APRS->Comment, APRS->srcCall);
Start = DebugTimer("AprsLogPacket","QRZ",Start,&msMax,&msLast, hwnd);

/*
	We've done everything else, now see if we need RFID intercept
*/
#ifdef SUPPORT_RFID
		if (ActiveConfig.RFIDs.Count	/* MUST to this to avoid NULLs on RFIDs.RFID[0]. */
		&& (ActiveConfig.RFIDs.RFID[0].AssocEnabled || ActiveConfig.RFIDs.RFID[0].ServerEnabled))
		{
/*
	First handle tag reads to monitors and position updates
*/
			if (ActiveConfig.RFIDs.RFID[0].AssocEnabled
			&& (APRS->datatype == 0x02	/* RFID? */
				|| APRS->datatype == 'x')	/* Lynn's HACK! */
			&& strlen(APRS->dstCall) >= 6	/* must be at least 6 */
			&& APRS->dstCall[0]=='A' && APRS->dstCall[1]=='P'
			&& !_strnicmp(&APRS->dstCall[2], ActiveConfig.RFIDs.RFID[0].ServerName, sizeof(APRS->dstCall)-2))	/* Correct App ID? */
			{	char x = APRS->dstCall[5];
				//int Len = sizeof(APRS->srcCall)+sizeof(APRS->dstCall)+sizeof(APRS->Comment)+80;
				//TCHAR *Message = (TCHAR *)malloc(Len*sizeof(TCHAR));
				char *oComment;
				char *Owner = RFIDGetIDCall(x, RtStrnuprTrim(STRING(APRS->Comment)), &oComment);
				STATION_INFO_S *Reader = RFIDFindReader(APRS->srcCall);
				char Buffer[256];

				int m;
		static	char * Monitors[] = { "KJ4ERJ-12" };

				for (m=0; m<ARRAYSIZE(Monitors); m++)
				{	sprintf(Buffer,"%s>APRFI%c::%-9s:%.*s (%.*s) Read (%.*s) Owner %s (Sent to %s)",
							CALLSIGN, x,
							Monitors[m],
							STRING(APRS->srcCall),
							sizeof(Reader->Station), !Reader?"*UNKNOWN*":Reader->Station,
							STRING(APRS->Comment), Owner?Owner:"*UNKNOWN*",
							Monitors[m]);
					QueueToTransmit(MESSAGE_PACKET, Buffer, FALSE, TRUE);	/* Only via -IS */
				}

				if (!Owner && !RFIDValidateID(x,APRS->Comment))
				{	sprintf(Buffer,"%s>APRFI%c::%-9s:%.*s Invalid and Unknown",
							CALLSIGN, x, APRS->srcCall, STRING(APRS->Comment));
					QueueToTransmit(MESSAGE_PACKET, Buffer);
					QueueToTransmit(MESSAGE_PACKET, Buffer, TRUE);	/* Double-pump RF */
				} else if (Reader)	/* Found a reader, let's do something with it */
				{	TCHAR *LatLon = NULL;
					char *DAO = NULL, CseSpd[8]={0};
					double lat = Reader->pCoord->lat;
					double lon = Reader->pCoord->lon;

					if (Reader->RFID.Type == Reader->RFID.GRID)
					{	double dlat=0, dlon=0, latoffset=0, lonoffset=0;
						int rows = 0, cols = 0;

/* WB4APR-5>BEACON,WB4APR-3*,qAR,N3UJJ:;USNA-Lab *111111z3859.11NH07629.11WA+01-00+002 147.075 RFID HotSpot */

						dlat = (double) Reader->RFID.Grid.dlat / 100.0 / 60.0;
						dlon = (double) Reader->RFID.Grid.dlon / 100.0 / 60.0;
						latoffset = (double) Reader->RFID.Grid.offset / 1000.0 / 60.0;
						lonoffset = latoffset*6/cos(DegToRad(Reader->pCoord->lat));
						rows = Reader->RFID.Grid.rows;
						cols = Reader->RFID.Grid.cols;

TraceLog("RFID", TRUE, hwnd,"RFID:Reader(%.*s)(%.*s) dlat:%ld dlon:%ld latoffset:%ld rows:%ld Comment(%.*S)\n",
				STRING(Reader->Owner), STRING(Reader->Station), 
				(long) Reader->RFID.Grid.dlat, (long) Reader->RFID.Grid.dlon, 
				(long) Reader->RFID.Grid.offset, (long) Reader->RFID.Grid.rows,
				Reader->sComment*sizeof(TCHAR), Reader->pComment);

						lat += dlat; lon += dlon;	/* Offset for the list */
						if (latoffset)	/* if no offset, they all just lump together */
						{	double minlat, minlon, maxlat, maxlon;
							unsigned int s;
							STATION_INFO_S *oStat;
							int SpotCount, row, col, p, leastp, oPos=-1;
							__int64 *msecs, leastmsec=0;

							if (Owner) oStat =FindStationCall(Owner);
							else oStat = FindStationCall(APRS->Comment+max(0,(int)strlen(APRS->Comment)-9),APRS->srcCall);	/* RFID Object */

							minlat = lat;
							minlon = lon;
							maxlat = minlat + latoffset * rows;
							maxlon = minlon + lonoffset * cols;

							//if (minlat > maxlat) { double t = minlat; minlat=maxlat; maxlat=t; }
							//if (minlon > maxlon) { double t = minlon; minlon=maxlon; maxlon=t; }
							//minlat -= abs(latoffset); maxlat += abs(latoffset);
							//minlon -= abs(lonoffset); maxlon += abs(lonoffset);

							SpotCount = rows * cols;
							TraceLog("RFID", TRUE, hwnd, "RFID:%.*s has %ld Spots over %ldx%ld lat %.5lf->%.5lf x %.5lf lon %.5lf->%.5lf x %.5lf\n",
										STRING(Reader->Station), (long) SpotCount, (long) rows, (long) cols,
										(double) minlat, (double) maxlat, (double) latoffset, (double) minlon, (double) maxlon, (double) lonoffset);

							msecs = (__int64 *) calloc(SpotCount, sizeof(*msecs));
							for (s=0; s<CloseStationCount; s++)
							{	double dRow = ((pCloseStations[s]->pCoord->lat - minlat) / latoffset)+0.5;
								double dCol = ((pCloseStations[s]->pCoord->lon - minlon) / lonoffset)+0.5;
								long Row, Col;

#ifdef VERBOSE
								TraceLog("RFID", TRUE, hwnd, "RFID:%.*s @ %.8lf %.8lf CHECKING %.8lf->%.8lf or %.8lf->%.8lf (%.2lf %.2lf) (%ld-%ld %ld-%ld)\n",
												STRING(CloseStations[s].Station), (double) CloseStations[s].lat, (double) CloseStations[s].lon,
												(double) minlat, (double) maxlat, (double) minlon, (double) maxlon,
												(double) dRow, (double) dCol,
												(long) (dRow-0.49), (long) (dRow+0.49), (long) (dCol-0.49), (long) (dCol+0.49));
#endif

								Row = (long) dRow; Col = (long) dCol;
								if (Row >= 0 && Row < rows
								&& Col >= 0 && Col < cols)
								{	int Pos = Col*rows + Row;
									if (Pos >= 0 && Pos < SpotCount)
									{	if (pCloseStations[s]==oStat) oPos = Pos;	/* We're already in the grid */
										if (pCloseStations[s]->Last.msec > msecs[Pos])
											if (msecs[Pos] || pCloseStations[s]!=oStat) msecs[Pos] = pCloseStations[s]->Last.msec;

										TraceLog("RFID", TRUE, hwnd, "RFID:%.*s Already At Row %ld Col %ld Pos %ld / %ld Since %.0lf (%.8lf %.8lf)\n",
												STRING(pCloseStations[s]->Station), (long) Row, (long) Col,
												(long) Pos, (long) SpotCount, (double) msecs[Pos],
												(double) pCloseStations[s]->pCoord->lat, (double) pCloseStations[s]->pCoord->lon);
									} else TraceLog("RFID", TRUE, hwnd, "RFID:%.*s Gives OUT OF RANGE Row %ld Col %ld Pos %ld / %ld\n",
													STRING(pCloseStations[s]->Station), (long) Row, (long) Col,
													(long) Pos, (long) SpotCount);
								} else if (abs(Row) < rows*3 && abs(Col) < cols*3)
									TraceLog("RFID", TRUE, hwnd, "RFID:%.*s Gives OUT OF RANGE Row %ld Col %ld\n",
													STRING(pCloseStations[s]->Station), (long) Row, (long) Col);
							}
#ifdef NOT_THIS_TIME
							else if (!strncmp(CloseStations[s].Station,"AI4PX",5)
								|| !strncmp(CloseStations[s].Station,"SPOT ",5))
							{	TraceLog("RFID", TRUE, hwnd, "RFID:%.*s @ %.8lf %.8lf Not within %.8lf->%.8lf or %.8lf->%.8lf (%lf %lf %lf %lf)\n",
												STRING(CloseStations[s].Station), (double) CloseStations[s].lat, (double) CloseStations[s].lon,
												(double) minlat, (double) maxlat, (double) minlon, (double) maxlon,
												(double) CloseStations[s].lat-minlat, (double) maxlat-CloseStations[s].lat,
												(double) CloseStations[s].lon-minlon, (double) maxlon-CloseStations[s].lon);
							}
#endif
							for (p=0; p<SpotCount; p++)
							{	if (!msecs[p]) break;
								else if (!leastmsec || msecs[p] < leastmsec)
								{	leastmsec = msecs[p];
									leastp = p;
								}
							}
							if (p>=SpotCount) p = oPos!=-1?oPos:leastp;	/* Keep me where I am if nothing better */
							row = p % rows;
							col = p / rows;
							TraceLog("RFID", TRUE, hwnd, "RFID:%.*s Putting %s At Row %ld/%ld Col %ld/%ld (o=%s oPos=%ld)\n",
									STRING(Reader->Station), Owner?Owner:APRS->Comment,
									(long) row, (long) rows, (long) col, (long) cols, oStat->Station, (long) oPos);

							lat += row * latoffset;
							lon += col * lonoffset;

							free(msecs);
						}
					}
					else if (Reader->RFID.Type == Reader->RFID.CSESPD)
					{	StringCbPrintfA(CseSpd, sizeof(CseSpd), "%03ld/%03ld",
										(long) Reader->RFID.CseSpd.course, (long) Reader->RFID.CseSpd.speed);
					}

					LatLon = APRSLatLon(lat, lon, 'R', 'A', 0, 2, &DAO);
					TraceLog("RFID", TRUE, hwnd, "RFID:Moving(%s) RFI%c(%.*s) To(%S)(%s) Via(%.*s)(%.*s)@%.6lf %.6lf\n",
								Owner?Owner:APRS->Comment, x, STRING(APRS->Comment),
								LatLon, DAO, STRING(Reader->Station), STRING(APRS->srcCall),
								(double) Reader->pCoord->lat, (double) Reader->pCoord->lon);

					if (Owner)
					{	size_t UseSize = 256;
						char *UseComment = (char*) calloc(sizeof(*UseComment),UseSize);
						if (*oComment == '!')	/* owner overrides all */
						{	strncpy(UseComment,oComment,UseSize);
						} else if (Reader->sComment && *Reader->pComment == *TEXT("="))
						{	WideCharToMultiByte(CP_UTF8, 0, Reader->pComment,
															Reader->sComment,
															UseComment, UseSize, NULL, NULL);
						} else if (*oComment == '+')
						{	strncpy(UseComment,oComment,UseSize);
						} else if (Reader->sComment && *Reader->pComment == *TEXT("."))
						{	WideCharToMultiByte(CP_UTF8, 0, Reader->pComment,
															Reader->sComment,
															UseComment, UseSize, NULL, NULL);
						} else if (*oComment && isprint(*oComment&0xff))
						{	strncpy(UseComment,oComment,UseSize);
						} else
						{	WideCharToMultiByte(CP_UTF8, 0, Reader->pComment,
															Reader->sComment,
															UseComment, UseSize, NULL, NULL);
						}
						sprintf(Buffer,"%s>APRFI%c,WIDE2-2:/%02ld%02ld%02ldh%S%s%.10s@%.*s%s %s",
								Owner, x, (long) stSystem.wHour, (long) stSystem.wMinute, (long) stSystem.wSecond,
								LatLon, CseSpd, APRS->Comment, STRING(Reader->Station),
								UseComment, DAO);
						free(UseComment);
					} else	sprintf(Buffer,"%s>APRFI%c:;%-9.9s*%02ld%02ld%02ldh%S%s%.10s@%.*s%.*S %s",
								APRS->srcCall, x,
								APRS->Comment+max(0,(int)strlen(APRS->Comment)-9), 
								(long) stSystem.wHour, (long) stSystem.wMinute, (long) stSystem.wSecond,
								LatLon, CseSpd, APRS->Comment, STRING(Reader->Station),
								Reader->sComment*sizeof(TCHAR), Reader->pComment, DAO);

					if (Reader->pCoord->lat == 0 && Reader->pCoord->lon == 0)
					{	TraceLog("RFID", TRUE, hwnd, "RFID:Reader@0,0, Skipping(%s)\n", Buffer);
					} else
					{	QueueToTransmit(BEACON_PACKET, Buffer);
						TraceLog("RFID", TRUE, hwnd, "RFID:Moved(%s)\n", Buffer);
					}

					AprsLogInternalPacket("RFID", hwnd, Buffer);	/* Process it on my display also! */
					RFIDMoves++;
					if (LatLon) free(LatLon);
					if (DAO) free(DAO);
				}
				if (Owner) free(Owner);
			}
/*
	Implement the ANSRVR here (as long as I'm KJ4ERJ-15!)
*/
			if (!_stricmp(CALLSIGN, "KJ4ERJ-15")
			&& APRS->Valid & APRS_MESSAGE_VALID	/* Message? */
			&& !_stricmp(APRS->msgCall, "ANSRVR"))	/* for ANSRVR? */
			if ((!strncmp(APRS->Comment, "ack", 3)
			|| !strncmp(APRS->Comment, "rej", 3))
			&& APRS->Comment[5] == '}')	/* Is it my Reply-Ack? */
			{	SpaceCompress(-1, APRS->Comment);	/* We only want the purest essence (no trailing spaces, at least) */
				CheckAndHandlePendingAck(APRS->srcCall, APRS->Comment, &APRS->Comment[3]);
			} else
			{	char *m, *g, *c = APRS->Comment;

				TraceLogThread("ANSRVR", TRUE, "%s>%s %s\n", APRS->srcCall, APRS->msgCall, APRS->Comment);
				RememberMessage(APRS->srcCall, APRS->msgCall, APRS->Comment, MESSAGE_ME);	/* BEFORE stripping off ack */
				SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, APRS->Comment);

				while (*c && isspace(*c&0xff)) c++;	/* Skip whitespace */

				g = c;
				while (*g && !isspace(*g&0xff)) g++;	/* Skip command */
				if (*g && g!=c) *g++='\0';
				while (*g && isspace(*g&0xff)) g++;	/* Skip whitespace */

				m = g;
				while (*m && !isspace(*m&0xff)) m++;	/* Skip group */
				if (*m && m!=g) *m++='\0';
				while (*m && isspace(*m&0xff)) m++;	/* Skip whitespace */

				size_t MsgSize = sizeof(TCHAR)*max(strlen(m)+128,(ActiveConfig.ANDefs.Count+1)*(sizeof(ActiveConfig.ANDefs.ANDef->Name)+sizeof(ActiveConfig.ANDefs.ANDef->Comment)+128));
				TCHAR *Message = (TCHAR*)malloc(MsgSize);
				size_t Remaining = MsgSize;
				TCHAR *Next = Message;
				int PrefixLen = 0;
				*Message = TEXT('\0');

				switch (toupper(*c & 0xff))
				{
				case '?':	/* List all groups or a specified group */
					if (*g)	/* Asking about a specific group? */
					{	ANSRVR_GROUP_DEFINITION_S *ANDef = GetOrCreateANDefinition(&ActiveConfig, g, FALSE);
						if (!ANDef)
						{	if (!IsValidANGroupName(g))
							{	StringCbPrintf(Message, MsgSize, TEXT("Invalid ANSRVR Group Name"));
							} else StringCbPrintf(Message, MsgSize, TEXT("%S Does Not Exist"), g);
						} else
						{	if (ANDef->Comment[0] || ANDef->Owner[0])
							{	StringCbPrintfEx(Message, MsgSize, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%S"), ANDef->Name);
								if (ANDef->Comment[0])
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														TEXT(" %S"), ANDef->Comment);
								if (ANDef->Owner[0])
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" Own:%S"), ANDef->Owner);
								SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
								RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
								TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
							}
							StringCbPrintf(Message, MsgSize, TEXT("%ld Members In %S"), ANDef->Members.Count, ANDef->Name);
						}
					} else if (ActiveConfig.ANDefs.Count == 0)
					{	StringCbPrintf(Message, MsgSize, TEXT("No Active Groups"));
					} else 
					{	StringCbPrintfEx(Message, MsgSize, &Next, &Remaining,
										STRSAFE_IGNORE_NULLS,
										TEXT("Active Groups:"));
						for (unsigned int p=0; p<ActiveConfig.ANDefs.Count; p++)
						{	BOOL Owner = ActiveConfig.ANDefs.ANDef[p].Owner[0]		/* Have an Owner? */
							&& IsSameBaseCallsign(APRS->srcCall, ActiveConfig.ANDefs.ANDef[p].Owner);	/* Me? */
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
										STRSAFE_IGNORE_NULLS,
										TEXT(" %S%S(%ld)"),
										Owner?"O:":"",
										ActiveConfig.ANDefs.ANDef[p].Name,
										ActiveConfig.ANDefs.ANDef[p].Members.Count);
						}
					}
					break;

				case 'L':	/* List my groups */
				{	int GroupCount = 0;
					StringCbPrintfEx(Message, MsgSize, &Next, &Remaining,
										STRSAFE_IGNORE_NULLS,
										TEXT("Member Of"));
					for (unsigned int p=0; p<ActiveConfig.ANDefs.Count; p++)
					if (FindANMemberIndex(&ActiveConfig.ANDefs.ANDef[p], APRS->srcCall) != -1)
					{	BOOL Owner = ActiveConfig.ANDefs.ANDef[p].Owner[0]		/* Have an Owner? */
						&& IsSameBaseCallsign(APRS->srcCall, ActiveConfig.ANDefs.ANDef[p].Owner);	/* Me? */
						GroupCount++;
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
										STRSAFE_IGNORE_NULLS,
										TEXT(" %S%S(%ld)"),
										Owner?"O:":"",
										ActiveConfig.ANDefs.ANDef[p].Name,
										ActiveConfig.ANDefs.ANDef[p].Members.Count);
					}
					if (!GroupCount)
						StringCbPrintf(Message, MsgSize, TEXT("No Memberships"));
					break;
				}
				case 'D':	/* Describe */
				{
					if (*g)	/* Asking about a specific group? */
					{	ANSRVR_GROUP_DEFINITION_S *ANDef = GetOrCreateANDefinition(&ActiveConfig, g, FALSE);
						if (!ANDef)
						{	if (!IsValidANGroupName(g))
							{	StringCbPrintf(Message, MsgSize, TEXT("Invalid ANSRVR Group Name"));
							} else StringCbPrintf(Message, MsgSize, TEXT("%S Does Not Exist"), g);
						} else if (!*m)
						{	BOOL isOwner = ANDef->Owner[0] && IsSameBaseCallsign(APRS->srcCall, ANDef->Owner);

							StringCbPrintfEx(Message, MsgSize, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%S(%ld)"), ANDef->Name, ANDef->Members.Count);
							if (ANDef->Comment[0] || ANDef->Owner[0])
							{	if (ANDef->Comment[0])
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														TEXT(" %S"), ANDef->Comment);
								else 	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
														TEXT(" <No Description>"));
								if (ANDef->Owner[0])
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" Own:%S"), ANDef->Owner);
							} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" <No Description Provided>"));
							SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, FALSE,
												FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
							RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
							TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);

							if (isOwner)
							{	StringCbPrintf(Message, MsgSize, TEXT("(Send D %S <Description> to change)"), ANDef->Name);
								SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
								RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
								TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
							}

							if (ANDef->Members.Count
							&& (ANDef->Members.Count < 16	/* Short enough to tell everybody */
							|| (ANDef->Owner[0] && IsSameBaseCallsign(APRS->srcCall, ANDef->Owner))))	/* Owners see all */
							{	size_t Size = sizeof(TCHAR)*(128+sizeof(ANDef->Comment)+ANDef->Members.Count+1)*(sizeof(ANDef->Owner)+12);
								TCHAR *Msg = (TCHAR*)malloc(Size);
								size_t Remain = Size;
								TCHAR *Nxt = Msg;

								StringCbPrintfEx(Msg, Size, &Nxt, &Remain, STRSAFE_IGNORE_NULLS,
													TEXT("Members[%S]:"), ANDef->Name);
								for (unsigned int m=0; m<ANDef->Members.Count; m++)
								{	StringCbPrintfEx(Nxt, Remain, &Nxt, &Remain, STRSAFE_IGNORE_NULLS,
												TEXT(" %S"), ANDef->Members.Entries[m].string);
								}
								SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Msg, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
								RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
								TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Msg);
								free(Msg);
							}
							StringCbPrintf(Message, MsgSize, TEXT("%ld Members In %S"), ANDef->Members.Count, ANDef->Name);
						} else if (!ANDef->Owner[0])
							StringCbPrintf(Message, MsgSize, TEXT("%S Has No Owner"), ANDef->Name);
						else if (!IsSameBaseCallsign(ANDef->Owner, APRS->srcCall))
							StringCbPrintf(Message, MsgSize, TEXT("%S Owned By %S"), ANDef->Name, ANDef->Owner);
						else
						{	AddANDefinitionMember(&ActiveConfig, g, APRS->srcCall, &ANDef);
							strncpy(ANDef->Comment, m, sizeof(ANDef->Comment));
							StringCbPrintf(Message, MsgSize, TEXT("Group(%S) Description(%S)"), 
											ANDef->Name, ANDef->Comment);
						}
					} else if (ActiveConfig.ANDefs.Count)
					{	size_t LineSize = sizeof(TCHAR)*max(strlen(m)+128,sizeof(ActiveConfig.ANDefs.ANDef->Name)+sizeof(ActiveConfig.ANDefs.ANDef->Comment)+128);
						TCHAR *Line = (TCHAR*)malloc(LineSize);
						size_t LineLeft = LineSize;
						TCHAR *LineNext = Line;
						BOOL HaveMessage = FALSE;

						StringCbPrintfEx(Message, MsgSize, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("Also:"));

						for (unsigned int p=0; p<ActiveConfig.ANDefs.Count; p++)
						{	ANSRVR_GROUP_DEFINITION_S *ANDef = &ActiveConfig.ANDefs.ANDef[p];

							if (!ANDef->Comment[0])
							{	BOOL Owner = ANDef->Owner[0]		/* Have an Owner? */
								&& IsSameBaseCallsign(APRS->srcCall, ANDef->Owner);	/* Me? */
								HaveMessage = TRUE;
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
												STRSAFE_IGNORE_NULLS,
												TEXT(" %S%S(%ld)"), Owner?"O:":"",
												ANDef->Name, ANDef->Members.Count);
							} else
							{	StringCbPrintfEx(Line, LineSize, &LineNext, &LineLeft, STRSAFE_IGNORE_NULLS,
													TEXT("%S(%ld)"), ANDef->Name, ANDef->Members.Count);
								if (ANDef->Comment[0] || ANDef->Owner[0])
								{	if (ANDef->Comment[0])
										StringCbPrintfEx(LineNext, LineLeft, &LineNext, &LineLeft, STRSAFE_IGNORE_NULLS,
															TEXT(" %S"), ANDef->Comment);
									else 	StringCbPrintfEx(LineNext, LineLeft, &LineNext, &LineLeft, STRSAFE_IGNORE_NULLS,
															TEXT(" <No Description>"));
									if (ANDef->Owner[0])
										StringCbPrintfEx(LineNext, LineLeft, &LineNext, &LineLeft, STRSAFE_IGNORE_NULLS,
													TEXT(" Own:%S"), ANDef->Owner);
								} else StringCbPrintfEx(LineNext, LineLeft, &LineNext, &LineLeft, STRSAFE_IGNORE_NULLS,
													TEXT(" <No Description Provided>"));
								SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Line, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
								TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Line);
							}
						}
						TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
						free(Line);
						if (!HaveMessage) *Message = TEXT('\0');	/* Nothing left to say here... */
						else PrefixLen = 5;	/* Also: */
					} else StringCbPrintf(Message, MsgSize, TEXT("No Active Groups"));

					break;
				}
				case 'C': case 'J':	/* CQ/Join */
				if (*g)	/* Specify a group? */
				{	ANSRVR_GROUP_DEFINITION_S *ANDef = GetOrCreateANDefinition(&ActiveConfig, g, FALSE);
					if (!ANDef)
					{	if (!IsValidANGroupName(g))
						{	StringCbPrintf(Message, MsgSize, TEXT("Invalid ANSRVR Group Name"));
						} else
						{	AddANDefinitionMember(&ActiveConfig, g, APRS->srcCall, &ANDef);
							strncpy(ANDef->Owner, APRS->srcCall, sizeof(ANDef->Owner));
							strncpy(ANDef->Comment, m, sizeof(ANDef->Comment));
							if (!*m)	/* New groups need a comment */
							{	StringCbPrintf(Message, MsgSize, TEXT("N:%S Send D %S <Description>"), ANDef->Name, ANDef->Name);
							} else
							{	StringCbPrintf(Message, MsgSize, TEXT("N:%S New Group Description(%S)"), 
												ANDef->Name, ANDef->Comment);
							}
						}
					} else
					{	BOOL NewMember = AddANDefinitionMember(&ActiveConfig, g, APRS->srcCall, &ANDef);
						if (*m)
						{	if (ANDef)	/* Group exists */
							{	TIMED_STRING_LIST_S *pList = &ANDef->Members;
								int SentCount = 0;
								for (unsigned int p=0; p<pList->Count; p++)
								if (_stricmp(pList->Entries[p].string, APRS->srcCall))	/* Not me! */
								{	SentCount++;
									StringCbPrintf(Message, MsgSize, TEXT("N:%S %S"), ANDef->Name, m);
									SendAPRSMessageFrom(/*hwnd,*/ APRS->srcCall, pList->Entries[p].string, 2+strlen(ANDef->Name)+1, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
									TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->srcCall, pList->Entries[p].string, Message);
								}
								StringCbPrintf(Message, MsgSize, TEXT("N:%S %ld Message%S Sent"), ANDef->Name, (long) SentCount, SentCount==1?"":"s");
							} else StringCbPrintf(Message, MsgSize, TEXT("N:%S Failed To Create Group"), g);
						} else if (NewMember)
						{	STATION_INFO_S *Station = FindStationCall(APRS->srcCall);
							if (Station && !Station->isANSRVR)
							{	Station->isANSRVR = TRUE;
								InvalidateCircle(NULL);
							}
							StringCbPrintf(Message, MsgSize, TEXT("N:%S Now Monitoring"), ANDef?ANDef->Name:g);
						}
						else
						{	StringCbPrintf(Message, MsgSize, TEXT("N:%S Still Monitoring"), ANDef?ANDef->Name:g);
							*Message = *TEXT("");	/* Suppress the "Still Monitoring" message */
						}
					}
				} else StringCbPrintf(Message, MsgSize, TEXT("Group Name Required"));
				break;

				case 'K':	/* Keep-Alive (Multi-Group) */
				if (*g)	/* Specify a group? */
				{	while (g && *g)	/* Loop all groups */
					{	ANSRVR_GROUP_DEFINITION_S *ANDef = GetOrCreateANDefinition(&ActiveConfig, g, TRUE);
						if (ANDef)
						{	BOOL NewMember = AddANDefinitionMember(&ActiveConfig, g, APRS->srcCall, &ANDef);
							if (NewMember)
							{	STATION_INFO_S *Station = FindStationCall(APRS->srcCall);
								if (Station && !Station->isANSRVR)
								{	Station->isANSRVR = TRUE;
									InvalidateCircle(NULL);
								}
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%S %S"),
											*Message?"":"Now Monitoring",
											ANDef?ANDef->Name:g);
								PrefixLen = 15;	/* "Now Monitoring " */
								TraceLog("ANSRVR", TRUE, hwnd, "KeepAlive %s NEW Member Of Group(%s)\n", APRS->srcCall, ANDef?ANDef->Name:g);
							} else TraceLog("ANSRVR", TRUE, hwnd, "KeepAlive %s Already Member Of Group(%s)\n", APRS->srcCall, ANDef?ANDef->Name:g);
//							else
//							{	StringCbPrintf(Message, MsgSize, TEXT("Still Monitoring %S"), ANDef?ANDef->Name:g);
//								*Message = *TEXT("");	/* Suppress the "Still Monitoring" message */
//							}
						} else TraceLog("ANSRVR", TRUE, hwnd, "KeepAlive Failed to Get Group(%s)\n", g);
						g = m;	/* Move to next group */
						while (*m && !isspace(*m&0xff)) m++;	/* Skip group */
						if (*m && m!=g) *m++='\0';	/* Null end of group */
						while (*m && isspace(*m&0xff)) m++;	/* Skip whitespace */
					}
				} else StringCbPrintf(Message, MsgSize, TEXT("Group Name(s) Required"));
				break;

				case 'U':	/* Unjoin */
				{	ANSRVR_GROUP_DEFINITION_S *ANDef = GetOrCreateANDefinition(&ActiveConfig, g, FALSE);
					if (!ANDef)
						StringCbPrintf(Message, MsgSize, TEXT("N:%S No Such Group"), g);
					else if (RemoveANDefinitionMember(&ActiveConfig, g, APRS->srcCall))
					{	ANDef = GetOrCreateANDefinition(&ActiveConfig, g, FALSE);
						if (ANDef && !strncmp(ANDef->Owner, APRS->srcCall, sizeof(ANDef->Owner)))
						{	memset(ANDef->Owner,0, sizeof(ANDef->Owner));
							StringCbPrintf(Message, MsgSize, TEXT("N:%S Removed From Group, Left OwnerLess!"), ANDef->Name);
						} else StringCbPrintf(Message, MsgSize, TEXT("N:%S Removed From Group"), ANDef?ANDef->Name:g);
					} else StringCbPrintf(Message, MsgSize, TEXT("N:%S Already Removed"), ANDef?ANDef->Name:g);
					break;
				}
				default:
					BOOL isOwner = FALSE;
					for (unsigned int p=0; p<ActiveConfig.ANDefs.Count; p++)
					{	BOOL Owner = ActiveConfig.ANDefs.ANDef[p].Owner[0]		/* Have an Owner? */
						&& IsSameBaseCallsign(APRS->srcCall, ActiveConfig.ANDefs.ANDef[p].Owner);	/* Me? */
						{	isOwner = TRUE;
							break;
						}
					}
					if (isOwner)
					{	StringCbPrintf(Message, MsgSize, TEXT("D GROUP Description (if Owner)"));
						SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
						RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
						TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
					}
					StringCbPrintf(Message, MsgSize, TEXT("L=My Groups, CQ/J=Join, U=Unjoin, D=Describe Groups, ?=All Groups, or ? GROUP"));
				}
				if (*Message != TEXT('\0'))
				{	SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, PrefixLen, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
					RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
					TraceLogThread("ANSRVR", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
				}
				free(Message);
			}
/*
	Implement SatTracking here (as long as I'm KJ4ERJ-15)
*/
#ifndef UNDER_CE
			if (!_stricmp(CALLSIGN, "KJ4ERJ-15")
			&& APRS->Valid & APRS_MESSAGE_VALID	/* Message? */
			&& IsSatelliteName(APRS->msgCall))	/* Satellite? */
			if ((!strncmp(APRS->Comment, "ack", 3)
			|| !strncmp(APRS->Comment, "rej", 3))
			&& APRS->Comment[5] == '}')	/* Is it my Reply-Ack? */
			{	SpaceCompress(-1, APRS->Comment);	/* We only want the purest essence (no trailing spaces, at least) */
				CheckAndHandlePendingAck(APRS->srcCall, APRS->Comment, &APRS->Comment[3]);
			} else
			{	int PrefixLen = 0;
				TCHAR *Message;
				STATION_INFO_S *Stat;

				TraceLogThread("SatRequest", TRUE, "%s>%s %s\n", APRS->srcCall, APRS->msgCall, APRS->Comment);
				RememberMessage(APRS->srcCall, APRS->msgCall, APRS->Comment, MESSAGE_ME);	/* BEFORE stripping off ack */
				SendAckIfRequested(APRS->srcCall, APRS->msgCall, APRS->msgAck, APRS->Comment);

				Stat = FindStationCall(APRS->Comment);	/* Asking for someone else? */
				if (!Stat)
				{	Stat = FindStationCall(APRS->srcCall);	/* Nope, forecast for requester */
				}
				if (Stat && (Stat->pCoord->lat || Stat->pCoord->lon))
				{	BOOL ForRequester = !_stricmp(Stat->Station, APRS->srcCall);
					char *aMessage = GetPassString(APRS->msgCall, APRS->srcCall,
												Stat->pCoord->lat, Stat->pCoord->lon,
												(long) Stat->alt);
					size_t MsgSize = sizeof(TCHAR)*(strlen(aMessage)+3+sizeof(Stat->Station)+1);
					Message = (TCHAR*)malloc(MsgSize);
					if (ForRequester)
						StringCbPrintf(Message, MsgSize, TEXT("%S"), aMessage);
					else StringCbPrintf(Message, MsgSize, TEXT("%S @ %S"), aMessage, Stat->Station);
					TraceLogThread("SatRequest", TRUE, "%s>%s(%s) %S\n", APRS->msgCall, APRS->srcCall, Stat->pPlatform?Stat->pPlatform:"*Unknown*", Message);
					free(aMessage);
				} else
				{	Message = TEXT("Please Beacon Position");
					TraceLogThread("SatRequest", TRUE, "%s>%s %S\n", APRS->msgCall, APRS->srcCall, Message);
				}

				if (*Message != *TEXT(""))
				{	SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, PrefixLen, Message, ActiveConfig.QRU.RetryMessages,
										FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
					RememberMessage2(APRS->msgCall, APRS->srcCall, Message, MESSAGE_ME);
				}
				//free(Message);
			}
#endif
/*
	Now handle translation DB messages to RFID
*/
			if (ActiveConfig.RFIDs.Count
			&& ActiveConfig.RFIDs.RFID[0].ServerEnabled
			&& APRS->Valid & APRS_MESSAGE_VALID	/* Message? */
			&& strlen(APRS->msgCall) == 4	/* Must be exactly 4 */
			&& !strncmp(APRS->msgCall, ActiveConfig.RFIDs.RFID[0].ServerName, sizeof(APRS->msgCall)))	/* And match the server I'm running */
			if ((!strncmp(APRS->Comment, "ack", 3)
			|| !strncmp(APRS->Comment, "rej", 3))
			&& APRS->Comment[5] == '}')	/* Is it my Reply-Ack? */
			{	SpaceCompress(-1, APRS->Comment);	/* We only want the purest essence (no trailing spaces, at least) */
				CheckAndHandlePendingAck(APRS->srcCall, APRS->Comment, &APRS->Comment[3]);
			} else
			{	char x = APRS->msgCall[3];
				char *original = _strdup(APRS->Comment);
				char *ack = strrchr(APRS->Comment, '{');	/* Do we need to ack it? */
				if (ack && strlen(ack) <= 6)
				{	char Buffer[80];
					sprintf(Buffer,"%s>APRFI%c::%-9s:ack%s", ActiveConfig.RFIDs.RFID[0].ServerName, x, APRS->srcCall, ack+1);
					QueueToTransmit(MESSAGE_ACK_PACKET, Buffer);
					QueueToTransmit(MESSAGE_ACK_PACKET, Buffer, TRUE);	/* RF-Only a second copy */
					*ack = '\0';	/* Null terminate message early */
				}

				RtStrnuprTrim(STRING(APRS->Comment));
				if (APRS->Comment[0] == '?' || !APRS->Comment[0])	/* '?' or empty query */
				{	STATION_INFO_S *Stat;
					char *ID, *idComment;
					int Len = 256;
					TCHAR *Message = (TCHAR *) malloc(Len*sizeof(*Message));

					if (!APRS->Comment[0] || !APRS->Comment[1])	/* Empty query? */
					{	TCHAR *Next = Message;
						size_t Remaining = sizeof(*Message)*Len;
						*Message = *TEXT("");	/* Initial null termination */

						if ((Stat = FindStationCall(APRS->srcCall)) != NULL)
						{	char *symName = GetDisplayableSymbol(Stat->isymbol);
							TCHAR *LatLon = APRSLatLon(Stat->pCoord->lat, Stat->pCoord->lon,
														' ', ' ', Stat->latlonExtended);
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%S at %s"),	/* LatLon ends in space */
											symName, LatLon);
							free(LatLon);
							free(symName);
						}
						if ((ID = RFIDGetCallIDs(x, APRS->srcCall)) != NULL)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("Own %S"), ID);
							free(ID);
						}
						if (*Message == *TEXT(""))
						{	RFIDLoadIDCalls(x);
							StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%ld RFID Tags in DB (%ld Type%S) (Moved %ld)"),
								(long) RFIDCount, (long) RFIDTypeCount, RFIDTypeCount==1?"":"s", (long) RFIDMoves);
						}
					} else if ((ID = RFIDGetIDCall(x, &APRS->Comment[1], &idComment)) != NULL)
					{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Owned By %S %S"),
									sizeof(APRS->Comment)-1,&APRS->Comment[1], ID, idComment);
						free(ID);
					} else if ((ID = RFIDGetCallIDs(x, &APRS->Comment[1])) != NULL)
					{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Owns %S"),
									sizeof(APRS->Comment)-1,&APRS->Comment[1], ID);
						free(ID);
					} else if ((Stat = FindStationCall(&APRS->Comment[1])) != NULL)
					{	char *symName = GetDisplayableSymbol(Stat->isymbol);
						TCHAR *LatLon = APRSLatLon(Stat->pCoord->lat, Stat->pCoord->lon,
													' ', ' ', Stat->latlonExtended);
						StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S is %S at %s"),
									sizeof(APRS->Comment)-1,&APRS->Comment[1],
									symName, LatLon);
						free(LatLon);
						free(symName);
					} else if (!_strnicmp(APRS->Comment, "?COUNT", sizeof(APRS->Comment))
					|| !_strnicmp(APRS->Comment, "?CNT", sizeof(APRS->Comment)))
					{	RFIDLoadIDCalls(x);
						StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%ld RFID Tags in DB (%ld Type%S) (Moved %ld)"),
								(long) RFIDCount, (long) RFIDTypeCount, RFIDTypeCount==1?"":"s", (long) RFIDMoves);
					} else if (!RFIDValidateID(x, &APRS->Comment[1]))
					{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Is NOT a Valid %S"),
									sizeof(APRS->Comment)-1, &APRS->Comment[1], APRS->msgCall);
					} else
					{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Is *UNKNOWN*"),
									sizeof(APRS->Comment)-1, &APRS->Comment[1]);
					}
					if (!SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, FALSE,
												FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE))
						TraceLog("RFID", TRUE, hwnd, "Send RFID (%S) Failed", Message);
					else TraceLog("RFID", TRUE, hwnd, "RFID: Sent(%S) To(%s)\n", Message, APRS->srcCall);
				} else
				{	int Len = sizeof(APRS->Comment)+sizeof(APRS->srcCall)+80;
					TCHAR *Message = (TCHAR *)malloc(Len*sizeof(TCHAR));
					int lenID = RFIDValidateID(x, APRS->Comment);

					if (lenID)	/* Valid? */
					{	char *c = original+lenID;
						while (*c && isspace(*c & 0xff)) c++;
						if (RFIDSetIDCall(x, APRS->Comment, APRS->srcCall, c) != -1)
						{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Now %.*S %S"),
										lenID, APRS->Comment,
										sizeof(APRS->srcCall), APRS->srcCall, c);
							if (!SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, "KJ4ERJ-12", 0, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE))
								TraceLog("RFID", TRUE, hwnd, "Send RFID (%S) Failed", Message);
						} else
						{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S FAILED!"),
									sizeof(APRS->Comment)-1, &APRS->Comment[1]);
						}
						if (!SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, TRUE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE))
							TraceLog("RFID", TRUE, hwnd, "Send RFID (%S) Failed", Message);
						else TraceLog("RFID", TRUE, hwnd, "RFID: Sent(%S) To(%s)\n", Message, APRS->srcCall);
					} else
					{	StringCbPrintf(Message, Len*sizeof(TCHAR), TEXT("%.*S Bad %S"),
									STRING(APRS->Comment), APRS->msgCall);
						if (!SendAPRSMessageFrom(/*hwnd,*/ APRS->msgCall, APRS->srcCall, 0, Message, TRUE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE))
							TraceLog("RFID", TRUE, hwnd, "Send RFID (%S) Failed", Message);
						else TraceLog("RFID", TRUE, hwnd, "RFID: Sent(%S) To(%s)\n", Message, APRS->srcCall);
					}
					free(Message);
				}
				free(original);
			}
Start = DebugTimer("AprsLogPacket","RFID",Start,&msMax,&msLast, hwnd);
		}	/* End of RFID processing */
/*
	And finally watch the position updates going by to glean RFID associations
	(This is outside so that KJ4ERJ can monitor RFID assignments)
*/
		if (ActiveConfig.RFIDs.Count
		&& (ActiveConfig.RFIDs.RFID[0].ServerEnabled || IsSameBaseCallsign(CALLSIGN, "KJ4ERJ"))
		&& !(APRS->Valid & APRS_OBJECT_VALID)	/* Cannot be an object */
		&& !(APRS->Valid & APRS_ITEM_VALID)	/* Cannot be an item either */
		&& APRS->Valid & APRS_LATLON_VALID	/* Valid Position? */
		&& APRS->Valid & APRS_SYMBOL_VALID	/* Valid Symbol? */
		&& APRS->symbol == SymbolInt('R', 'A')
		&& strlen(APRS->dstCall) >= 6	/* must be at least 6 */
		&& !_strnicmp(APRS->dstCall, "APRFI", 5))	/* Correct App ID? */
		{	char x = APRS->dstCall[5];
			char *At = strchr(APRS->Comment, '@');
			if (At)
			{	*At = '\0';
				TraceLog("RFID", TRUE, hwnd, "RFID:Gleaning RFI%c(%s) To(%s) Via(%s)\n",
								x, APRS->Comment, APRS->srcCall, At+1);
				char *FullID = RFIDFillOutID(x, APRS->Comment);
				if (FullID)
				{	if (RFIDSetIDCall(x, FullID, APRS->srcCall, NULL) == -1)
					{	TraceLog("RFID", TRUE, hwnd, "RFID:FAILED Definition RFI%c(%s) To(%s) Via(%s)\n",
								x, FullID, APRS->srcCall, At+1);
					}
				} else TraceLog("RFID", TRUE, hwnd, "RFID:Invalid RFI%c(%s) To(%s) Via(%s)\n",
							x, APRS->Comment, APRS->srcCall, At+1);
			} else TraceLog("RFID", TRUE, hwnd, "RFID:Unrecognized(%s) RFI%c Packet(%s) (Missing @)\n",
								APRS->srcCall, x, APRS->Comment);
		}
#endif
	}
	free(InBuf);
	free(APRS);
	if (st != -1)
	{	BOOL DidOne = FALSE;
		if (!PaintingStationsFrozen)
		{	if (PendingStationsCount)	/* Buffer any? */
			{	RecoverPendingStations(hwnd);
				DidOne = TRUE;
			} else if (Stations[st].DupeUseCount == PaintingStations[st].DupeUseCount)	/* Did we update one? */
			{	PaintingStations[st] = Stations[st];	/* Yep, copy it in */
				DidOne = TRUE;
			}
		} else	/* Frozen list, but we may be up in there somewhere */
		{	unsigned long ps;
			for (ps=0; ps<PacketScrollerSize; ps++)
			{	if (Stations[st].DupeUseCount == PaintingStations[ps].DupeUseCount)	/* Did we update one? */
				{	PaintingStations[ps] = Stations[st];
					DidOne = TRUE;
					break;	/* Only update ONE! */
				}
			}
		}
		if (DidOne) InvalidateStations(hwnd, TRUE);
	}
DebugTimer("AprsLogPacket","Overall",msStart,&msMax1,&msLast1, hwnd);

	InsideLogPacket--;	/* All done with this invocation */

	return Result;
}

static STATION_INFO_S *AprsLogInternalPacket(char *Why, HWND hwnd, char *Packet, BOOL FreeIt/*=FALSE*/, BOOL *ForcePost/*=FALSE*/)
{	STATION_INFO_S *Station = NULL;
	if (!hwnd) hwnd = hwndMain;
	if (InsideLogPacket || ForcePost)
	{	char *Dupe = FreeIt ? Packet : strdup(Packet);
//		if (!ForcePost) TraceLog("Recurse", TRUE, hwnd, "Avoiding AprsLogPacket recursion for %s(%s)\n", Why, Packet);
		if (!PostMessage(hwnd, WM_PORT_RECEIVED, RFPORT_INTERNAL, (LPARAM) Dupe))
			free(Dupe);
	} else
	{	CLIENT_INFO_S *Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (Info) Station = AprsLogPacket(Why, hwnd, Info, Packet, FALSE, RFPORT_INTERNAL);
		else TraceError(hwnd, "hwnd(%p) has NULL CLIENT_INFO_S *!\n", hwnd);
		if (FreeIt) free(Packet);
	}
	return Station;
}

static char *SpaceToWild(size_t Len, char *ID)
{	char *Result;
	if (Len == -1) Len = strlen(ID);
	Result = (char*)malloc(Len+1);
	strncpy(Result, ID, Len);
	Result[Len] = '\0';
	for (ID=Result; *ID; ID++)
	{	if (isspace(*ID))
		{	*ID++ = '*';
			*ID = '\0';
			break;
		}
	}
	return Result;
}

char * cdecl FormatFilter(void)
{	size_t Remaining = 4096;
	char *XmitBuffer = (char*)malloc(Remaining);
	char *Next = XmitBuffer;
	int tr;

	size_t oRemain=1024, bRemain=1024, pRemain=1024;
	char *oBuff=(char*)malloc(oRemain), *bBuff=(char*)malloc(bRemain), *pBuff=(char*)malloc(pRemain);
	char *oNext=oBuff, *bNext=bBuff, *pNext=pBuff;
	BOOL RangedMain = FALSE;

/* r/27.99673/-80.659072/8000  */

	*XmitBuffer = '\0';	/* Null terminate in case it's empty */

	if (RANGE > 0.0)
	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						" m/%ld r/%.5lf/%.5lf/%ld",
						(long) RANGE,
						(double) LastGoodPosition.dblLatitude,
						(double) LastGoodPosition.dblLongitude, (long) RANGE);

	if (ActiveConfig.Screen.FilterCircle
	&& cInfos[0].Scale > RANGE)
	{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						" r/%.5lf/%.5lf/%ld",
						(double) cInfos[0].LastCenterPosition.dblLatitude,
						(double) cInfos[0].LastCenterPosition.dblLongitude,
						(long) (cInfos[0].Scale*1.609344));
		RangedMain = TRUE;
	}

	for (tr=0; tr<MAX_TRACKERS; tr++)
	if (cInfos[tr].Active)
	{	if (cInfos[tr].CenterStation)
		{	if (cInfos[tr].CenterStation != MyStation
			&& !cInfos[tr].CenterStation->isNWS
			&& !cInfos[tr].CenterStation->HeardInternal)
			{	STATION_INFO_S *cStat = cInfos[tr].CenterStation;
				char *ID = SpaceToWild(STRING(cStat->Station));
				if (cStat->isObject)
					StringCbPrintfExA(oNext, oRemain, &oNext, &oRemain, STRSAFE_IGNORE_NULLS,
							"/%s%s", ID, strlen(cStat->Station)<9&&!strchr(ID,'*')?"*":"");
				else if (RANGE>0.0&&cInfos[tr].CenterRanging && !strchr(ID,'*'))
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" f/%s/%ld", ID, (long) RANGE);
				else StringCbPrintfExA(bNext, bRemain, &bNext, &bRemain, STRSAFE_IGNORE_NULLS,
							"/%s", ID);
				free(ID);
			}
		} else if (cInfos[tr].Awaiting)
		{	char *ID = SpaceToWild(STRING(cInfos[tr].CenterID));
			StringCbPrintfExA(bNext, bRemain, &bNext, &bRemain, STRSAFE_IGNORE_NULLS,
							"/%s", ID);
			StringCbPrintfExA(oNext, oRemain, &oNext, &oRemain, STRSAFE_IGNORE_NULLS,
							"/%s%s",
							ID,
							strlen(cInfos[tr].CenterID)<9&&!strchr(ID,'*')?"*":"");
			free(ID);
		}
	}

	if (RANGE > 0.0)
	for (int tr=0; tr<MAX_TRACKERS; tr++)
	if (cInfos[tr].Active)
	if (cInfos[tr].CenterRanging)
	if (tr!=0 || !RangedMain)	/* Don't range main's center twice */
	{	BOOL DoRange = TRUE;
		if (cInfos[tr].CenterStation)	/* Protect from NULLs */
		{	double lat = cInfos[tr].CenterStation->pCoord->lat;
			double lon = cInfos[tr].CenterStation->pCoord->lon;
			if (cInfos[tr].CenterStation == MyStation)
			{	lat = LastGoodPosition.dblLatitude;
				lon = LastGoodPosition.dblLongitude;
			}
			if (lat == cInfos[tr].LastCenterPosition.dblLatitude
			&& lon == cInfos[tr].LastCenterPosition.dblLongitude)
			{	DoRange = FALSE;
			} else
			{	double Distance, Bearing;
				AprsHaversineLatLon(cInfos[tr].LastCenterPosition.dblLatitude,
									cInfos[tr].LastCenterPosition.dblLongitude,
									lat, lon, &Distance, &Bearing);
				if (Distance < RANGE/2)
				{	DoRange = FALSE;
	TraceLogThread("Filter", FALSE, "[%ld] Suppressing Range(%s) %.2lf < %.2lf\n",
			 (long) tr, cInfos[tr].CenterStation->Station,
			 (double) Distance, (double) RANGE/2);
				}
			}
		}
		if (DoRange)
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" r/%.5lf/%.5lf/%ld",
							(double) cInfos[tr].LastCenterPosition.dblLatitude,
							(double) cInfos[tr].LastCenterPosition.dblLongitude,
							(long) RANGE);
		}
	}

#ifdef DOESNT_WORK
	if (ActiveConfig.Messaging.MyMessages)
	{	char *BaseCall = strdup(CALLSIGN);
		if (char *dash = strchr(BaseCall,'-'))
			*dash = '\0';
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						" b/%s", BaseCall);
	}
#endif

#ifdef FUTURE_MESSAGE_GROUP_FILTER
	if (ActiveConfig.Enables.MyMessages)	/* Promiscous needs a buddy filter on me */
	{	char *d = strchr(CALLSIGN,'-');
		if (!d) d = strchr(CALLSIGN,'\0');
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						" g/%.*s*", (int) (d-CALLSIGN), CALLSIGN);
	}
#endif

	if (ActiveConfig.RFIDs.Count
	&& (ActiveConfig.RFIDs.RFID[0].AssocEnabled || ActiveConfig.RFIDs.RFID[0].ServerEnabled))
	{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						" u/APRFI* s//A/H s//A/R t/m");
	}

	if (ActiveConfig.AltNet[0])
	{	char *ID = SpaceToWild(STRING(ActiveConfig.AltNet));
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" u/%s", ID);
		free(ID);
	}

	if (ActiveConfig.NWS.Offices.Count)
	{	TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
		for (unsigned long i=0; i<pList->Count; i++)
		if (!pList->Entries[i].value)	/* Not disabled */
		{	char *String = pList->Entries[i].string;
			if (*String == '*')
			{	BOOL First = TRUE;
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, " t/n");
				for (unsigned long s=0; s<ActiveConfig.NWSServers.Count; s++)
				if (!ActiveConfig.NWSServers.Srv[s].Disabled)
				{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%s/%s",
									First?" e":"", ActiveConfig.NWSServers.Srv[s].EntryCall);
					First = FALSE;
				}
			} else
			{	StringCbPrintfExA(pNext, pRemain, &pNext, &pRemain, STRSAFE_IGNORE_NULLS, "/%s", String);
			}
		}
	}

	if (*FILTER)
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" %s", FILTER);

	if (bNext != bBuff)
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" b%s", bBuff);
	if (pNext != pBuff)
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" p%s", pBuff);
	if (oNext != oBuff)
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							" o%s", oBuff);
	free(bBuff); free(pBuff); free(oBuff);

	if (!*XmitBuffer) strcpy(XmitBuffer," m/0");


	return XmitBuffer;
}

static BOOL TransmitFilter(BOOL SendToServer)
{	BOOL Result = FALSE;
	char *FilterBody = FormatFilter();
	size_t Remaining = 80+strlen(FilterBody);
	char *XmitBuffer = (char*)malloc(Remaining);
static	char *LastFilter = NULL;

/* r/27.99673/-80.659072/8000  */

	StringCbPrintfA(XmitBuffer, Remaining, "#filter%s", FilterBody);

	RefreshBuddyList(FilterBody);

	for (unsigned int p=0; p<ActiveConfig.RFPorts.Count; p++)
	{	PORT_CONFIG_INFO_S *pP = &ActiveConfig.RFPorts.Port[p];
		if (pP->RequiresFilter)	/* Does the port want a filter? */
		if (RFPortRunnable(pP))	/* Is it actually running/runnable? */
		{	TraceLogThread("Filter", TRUE, "Filtering(%s) With %s\n",
							pP->Name, XmitBuffer);
			if (PortTransmit(pP, p, XmitBuffer))
				IncrementXmitPackets(p, 1, pP->Name);	/* Yes, even count the filter */
		}
	}

	if (APRSEnabled && ActiveConfig.Enables.Internet)
	{	//settcpstatus("Filter", TRUE);

		if (SendToServer)
		{	size_t tSize = 80+strlen(XmitBuffer);
			char *Temp = (char*)malloc(tSize);
		static int AckID = 0;

			CHAT_INFO_S *newChat = DisplayChat(CALLSIGN, "SERVER");
			if (newChat)
			AddToChat(newChat, TRUE, MESSAGE_ME,
								XmitBuffer+1,
								NULL,
								COLOR_MESSAGE_SOURCE_DONE);
		
			StringCbPrintfA(Temp, tSize, "%s>%s::%-9s:%s{%04ld",
								CALLSIGN, DESTID, "SERVER",
								XmitBuffer+1, ++AckID);

			TransmitString(Temp);
			free(Temp);
		}

		if (!LastFilter || strcmp(LastFilter, XmitBuffer))
		{	//TraceLogThread("APRS-IS", TRUE, "Filter %s\n", XmitBuffer);
			TraceLogThread("Filter", TRUE, "%s\n", XmitBuffer);
			if (TransmitString(XmitBuffer))
			{	char *Temp = XmitBuffer;
				XmitBuffer = LastFilter;
				LastFilter = Temp;
				Result = TRUE;
			}
		} else
		{	TraceLogThread("Filter", TRUE, "Suppressed Redundant Filter %s\n", LastFilter);
			Result = TRUE;
		}

	} else Result = TRUE;

	if (XmitBuffer) free(XmitBuffer);
	if (FilterBody) free(FilterBody);

	return Result;
}

static void TriggerDXReport(BOOL Force)
{static	SYSTEMTIME stLastTrigger = {0};
	if (Force
	|| SecondsSince(&stLastTrigger) >= ActiveConfig.DX.MinInterval*60)
	{	GetSystemTime(&stLastTrigger);
		TransmitDXReport(TRUE);
		if (ActiveConfig.Status.DX)
			TransmitStatusReport(TRUE);
	} else TraceLogThread("DX", TRUE, "Suppressing DX Trigger, %ld < %ld seconds\n",
							(long) SecondsSince(&stLastTrigger),
							(long) ActiveConfig.DX.MinInterval*60);
}

static void TransmitDXReport(BOOL Force)
{	double MaxDist = 0;	// Trigger for DX formatting
	unsigned long MaxPPC = 0;	// Which PortPackets[] is MaxDist
	unsigned long ppc;
	PurgeDXList();	// Expire any old ones
	for (ppc=0; ppc<PortPacketCount; ppc++)
	if (PortPackets[ppc].DXCount)
	{	if (MaxDist < PortPackets[ppc].DXList[0].Distance)
		{	MaxDist = PortPackets[ppc].DXList[0].Distance;
			MaxPPC = ppc;
		}
	}
//http://www.aprs.org/TWP.html
// >261441zDX: VO1GT-1 47.32.04N 52.47.25W 57.3km 95 11:26
// >261440zDX: N2MH-15 40.47.56N 74.15.09W 34.7 miles 245 10:32
//DX de VE6SLP-10>144390.0  PIGEON       203 dg frm VE6SLP-10            74km
//      123456789>12345678901234567890123123456789012345678901234567890112345
//DX de YOURCALL.>11111111112222222222***33333333334444444444***********55555
//DX de  KJ4ERJ-1> 144390.0 WC4PEM-10    263 dg frm  KJ4ERJ-1   71mi    1238z
//DX de YOURCALL.>FIELD-ONE.ITEMNAME*****FIELD-TWO.FIELD-3333***********FORTH
//DX de     K2GXT>   2 mtr  VE3LSR-4     316 dg frm     K2GXT           140mi
//DX de  KJ4ERJ-1>APRS      KG4YZY-11    279 dg frm  KJ4ERJ-1           126mi
//DX de  KJ4ERJ-1>144390.0  K4LKL-10     273 dg frm  KJ4ERJ-1   79mi    1252z
	if (MaxDist)
	{	size_t Remaining = 128;
		char *Buffer = (char*)malloc(Remaining);
		char *Next = Buffer;

		StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
					STRSAFE_IGNORE_NULLS,
					"%s>DX%s%s:",
					CALLSIGN, *ActiveConfig.DXPath?",":"", ActiveConfig.DXPath);

		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"DX de %9.9s>%-9.9s %-10.10s   %3ld dg frm%10.10s %4ld%s    %02ld%02ldz",
								//    MYCALL>  FREQ   DXCALL ***           MYCALL ddddmi/km
								CALLSIGN,
								PortPackets[MaxPPC].Name,
								PortPackets[MaxPPC].DXList[0].Station,
								(long) PortPackets[MaxPPC].DXList[0].Bearing,
								CALLSIGN,
								(long) (PortPackets[MaxPPC].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
								ActiveConfig.View.Metric.Distance?"km":"mi",
								(long) PortPackets[MaxPPC].DXList[0].st.wHour,
								(long) PortPackets[MaxPPC].DXList[0].st.wMinute);
		TraceLogThread("DX", TRUE, "%s\n", Buffer);
		QueueToTransmit(DX_PACKET, Buffer, TRUE);

		if (ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)	/* Log the DX if Internet */
		{	SYSTEMTIME stSystem;
			GetSystemTime(&stSystem);
			char *Temp = (char *) malloc(strlen(Buffer)+80);
			int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld DXrprt:%s:[%ld]%s",
								(long) stSystem.wYear, 
								(long) stSystem.wMonth, 
								(long) stSystem.wDay, 
								(long) stSystem.wHour, 
								(long) stSystem.wMinute, 
								(long) stSystem.wSecond,
								CALLSIGN, (long) UDPSeq++,
								Buffer);
			if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
				TraceActivity(NULL, "UDPFailed %.*s\n", (int) Len, Temp);

			free(Temp);
		}




		free(Buffer);
	}// else TraceLogThread("DX", TRUE, "MaxDist = ZERO?\n");
//	ShowTraceLog("DX", FALSE);
}

static void TransmitStatusReport(BOOL Force)
{	HWND hwnd = hwndMain;
	CLIENT_INFO_S *cInfo = &cInfos[0];
	__int64 Now = llGetMsec();
	int DidOne = FALSE;

	if (!ActiveConfig.Status.Enabled) return;	/* Not enabled, no transmit */
	if (!ActiveConfig.Status.Interval) return;	/* No interval, no transmit */
	if (!ActiveConfig.Status.GridSquare	/* No grid square? */
	&& !ActiveConfig.Status.Timestamp	/* No timestamp? */
	&& !ActiveConfig.Status.DX			/* No DX? */
#ifdef MONITOR_PHONE
	&& !ActiveConfig.Status.Cellular	/* No cellular? */
#endif
	&& !ActiveConfig.Status.Text[0])	/* No text? */
		return;							/* No transmission! */

	if (Force	/* Somebody really wants to know */
	|| (IsSystemTimeout(&ActiveConfig.Status.LastSent, ActiveConfig.Status.Interval*60)))
	{	size_t Remaining = sizeof(ActiveConfig.Status.Text)+128;
		char *Buffer = (char*)malloc(Remaining);
		char *Next = Buffer;
		SYSTEMTIME stNow;
		GetSystemTime(&stNow);

		StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
					STRSAFE_IGNORE_NULLS,
					"%s>%s%s%s:>",
					CALLSIGN, DESTID, *PATH?",":"", PATH);

		if (ActiveConfig.Status.GridSquare)
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
					STRSAFE_IGNORE_NULLS,
					"%s%c%c", GridSquare(MyStation->pCoord->lat, MyStation->pCoord->lon, 3),
					SYMBOL);
			DidOne = TRUE;
		} else if (ActiveConfig.Status.Timestamp)
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, 
						STRSAFE_IGNORE_NULLS,
						"%02ld%02ld%02ldz",
						(long) stNow.wDay, 
						(long) stNow.wHour, 
						(long) stNow.wMinute);
		}

		double MaxDist = 0;	// Trigger for DX formatting
		unsigned long MaxPPC = 0;	// Which PortPackets[] is MaxDist
		if (ActiveConfig.Status.DX)
		{	unsigned long ppc;
			PurgeDXList();	// Expire any old ones
			for (ppc=0; ppc<PortPacketCount; ppc++)
			if (PortPackets[ppc].DXCount)
			{	if (MaxDist < PortPackets[ppc].DXList[0].Distance)
				{	MaxDist = PortPackets[ppc].DXList[0].Distance;
					MaxPPC = ppc;
				}
			}
		}
// >261441zDX: VO1GT-1 47.32.04N 52.47.25W 57.3km 95 11:26
// >261440zDX: N2MH-15 40.47.56N 74.15.09W 34.7 miles 245 10:32
		if (MaxDist)
		{	TCHAR *LatLon = APRSLatLon(PortPackets[MaxPPC].DXList[0].lat, PortPackets[MaxPPC].DXList[0].lon, ' ', ' ', 0);
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"DX: %.*s %.1lf%s %ld %02ld:%02ld %S",
								STRING(PortPackets[MaxPPC].DXList[0].Station),
								(double) (PortPackets[MaxPPC].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
								ActiveConfig.View.Metric.Distance?"km":"mi",
								(long) PortPackets[MaxPPC].DXList[0].Bearing,
								(long) PortPackets[MaxPPC].DXList[0].st.wHour,
								(long) PortPackets[MaxPPC].DXList[0].st.wMinute,
								LatLon);
			free(LatLon);
			DidOne = TRUE;
		} else if (ActiveConfig.Status.Text[0])
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, 
						STRSAFE_IGNORE_NULLS,
						"%s%s",
						ActiveConfig.Status.GridSquare?" ":"",
						ActiveConfig.Status.Text);
			DidOne = TRUE;
		}
#ifdef MONITOR_PHONE
		if (ActiveConfig.Status.Cellular)
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						"(%S %ld%%)", szOldOperatorName, (long) dwOldSignalStrength);
			DidOne = TRUE;
		}
#endif
		if (DidOne)
		{	QueueToTransmit(STATUS_PACKET, Buffer);
			ActiveConfig.Status.LastSent = stNow;
		}
		free(Buffer);
	}
}

static void TransmitIGate(BOOL Force)
{	HWND hwnd = hwndMain;
	CLIENT_INFO_S *cInfo = &cInfos[0];
	unsigned long DirectStationCount = 0, LocalStationCount = 0, RFStationCount = 0;
	__int64 Now = llGetMsec();
static BOOL WasEnabled = FALSE;

	GetStationCounts(&DirectStationCount, &LocalStationCount, &RFStationCount);
	if (Force	/* Somebody really wants to know */
	|| (LastIGateTransmitted
		&& (IGateEnabled || WasEnabled)	/* If disabled, not really gating */
		&& llMsecSince(LastIGateTransmitted, Now) >= 60*60*1000)	/* every 60 minutes */
	|| (!LastIGateTransmitted
		&& IGateEnabled	/* If disabled, not really gating */
		&& (MessagesGated || PacketsRGated || DirectStationCount
			|| LocalStationCount || RFStationCount)))
	{	char Buffer[256];
		size_t Remaining = sizeof(Buffer);
		char *Next = Buffer;

		if ((!IGateEnabled && SUCCEEDED(StringCbPrintfExA(Buffer, sizeof(Buffer), &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%s>%s%s%s:<IGATE,DISABLED\n",
								CALLSIGN, DESTID, *PATH?",":"", PATH)))
		|| SUCCEEDED(StringCbPrintfExA(Buffer, sizeof(Buffer), &Next, &Remaining, STRSAFE_IGNORE_NULLS, "%s>%s%s%s:<IGATE,MSG_CNT=%ld,LOC_CNT=%ld,DIR_CNT=%ld,RF_CNT=%ld",
					CALLSIGN, DESTID, *PATH?",":"", PATH,
					(long) MessagesGated,
					(long) LocalStationCount,
					(long) DirectStationCount,
					(long) RFStationCount)))
		{
			if (PacketsRGated)
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, ",PKT_CNT=%ld",
									(long) PacketsRGated);
			{	unsigned long ppc, MaxPPC = 0;
				double MaxDist = 0;
				for (ppc=0; ppc<PortPacketCount; ppc++)
				if (PortPackets[ppc].DXCount)
				{	if (MaxDist < PortPackets[ppc].DXList[0].Distance)
					{	MaxDist = PortPackets[ppc].DXList[0].Distance;
						MaxPPC = ppc;
					}
				}
				if (MaxDist)
				{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										",DX=%ld*%.*s(%.0lf%s@%ld)",
										(long) PortPackets[MaxPPC].DXList[0].Count,
										STRING(PortPackets[MaxPPC].DXList[0].Station),
										(double) (PortPackets[MaxPPC].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
										ActiveConfig.View.Metric.Distance?"km":"mi",
										(long) PortPackets[MaxPPC].DXList[0].Bearing);
				}
			}
			if (!ActiveConfig.RFPorts.Count)
				strcat(Buffer,",NoRFPorts?");
			else if (IGateReceiveOnly)
				strcat(Buffer,",R/O!");
			strcat(Buffer,"\n");
			QueueToTransmit(CAPABILITY_PACKET, Buffer, FALSE, ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet);
		} else TraceError(hwnd, "IGATE Format Failed!\n");
		if (!Force) LastIGateTransmitted = Now;	/* Don't set first if forced */
		WasEnabled = IGateEnabled;
	}

#ifdef SUPPORT_RFID
	if (ActiveConfig.RFIDs.Count
	&& (ActiveConfig.RFIDs.RFID[0].AssocEnabled || ActiveConfig.RFIDs.RFID[0].ServerEnabled))
	if (Force	/* Somebody really wants to know */
	|| (LastRFIDTransmitted && llMsecSince(LastRFIDTransmitted, Now) >= 60*60*1000)	/* every 60 minutes */
	|| (!LastRFIDTransmitted && (RFIDCount
					|| RFIDTypeCount
					|| RFIDMoves)))
	{	char Buffer[128];
		if (SUCCEEDED(StringCbPrintfA(Buffer, sizeof(Buffer), "%s>APRFID%s%s:<RFID,MOVES=%ld,COUNT=%ld,TYPES=%ld\n",
					CALLSIGN, *PATH?",":"", PATH,
					(long) RFIDMoves,
					(long) RFIDCount,
					(long) RFIDTypeCount)))
		{	QueueToTransmit(CAPABILITY_PACKET, Buffer);
		} else TraceError(hwnd, "RFID Format Failed!\n");
		if (!Force) LastRFIDTransmitted = Now;	/* Don't set first if forced */
	}
#endif
}

#ifndef UNDER_CE
#include <sys/stat.h>
static void FormatJT65Station
(	OBJECT_CONFIG_INFO_S *pObj,
	char *Who,
	char *Why,
	char *Where,
	char *How,
	double Freq,
	long Offset,
	SYSTEMTIME *stWhen
)
{	size_t Remain = 128;
	char *Buffer = (char*)malloc(Remain);
	char *Next = Buffer;
	char *Dash = pObj->Name?strchr(pObj->Name,'-'):NULL;
	if (!Dash) Dash = "-JT";

	StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
					"%s%s>APWWJT:>%s%c%c", Who, Dash, Where, pObj->Symbol.Table, pObj->Symbol.Symbol);
	if (Freq) StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								" %07.3lfMHz df%03ld", (double) Freq, (long) Offset);
	if (How && *How) StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								" %sdB", How);
	if (Why && *Why) StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								" %s", Why);
	StringCbPrintfExA(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
					" !JT65!");
	TraceLogThread("JT65", strcmp(Who,pObj->Name), "Xmit: %s\n", Buffer);
	if (IsWindow(hwndMain))
	{	CLIENT_INFO_S *Info = (CLIENT_INFO_S *) GetWindowLong(hwndMain, GWL_USERDATA);
		if (Info)
		{	__int64 Seconds = SecondsSince(stWhen);
			if (Seconds < ActiveConfig.Stations.MaxAge*60)
			{	__int64 msNow = llGetMsec() - Seconds*1000;
				AprsLogPacket(pObj->Name, hwndMain, Info, Buffer,
								FALSE, RFPORT_INTERNAL, msNow, stWhen);
			}
		}
		free(Buffer);
	}
	//AprsLogInternalPacket(pObj->Name, NULL, Buffer, TRUE);
}

static BOOL ParseJT65File(OBJECT_CONFIG_INFO_S *pObj, char *File, SYSTEMTIME *pst/*=NULL*/)
{	SYSTEMTIME st = {0}, stLast = {0};
	struct stat stBuf;
	struct tm tmBuf;

	if (stat(File, &stBuf))
	{	TraceLogThread("JT65", TRUE, "stat(%s) Failed errno=%ld\n", File, errno);
		return NULL;
	}
//	TraceLogThread("JT65", TRUE, "%s atime:0x%lX ctime:0x%lX mtime:0x%lX (Now:0x%lX) Size:%ld\n",
//					File, (long) stBuf.st_atime, (long) stBuf.st_ctime, (long) stBuf.st_mtime, (long) time(NULL),
//					(long) stBuf.st_size);
	tmBuf = *gmtime(&stBuf.st_mtime);
	st.wYear = tmBuf.tm_year+1900; st.wMonth = tmBuf.tm_mon+1; st.wDay = tmBuf.tm_mday;
	st.wHour = tmBuf.tm_hour; st.wMinute = tmBuf.tm_min; st.wSecond = tmBuf.tm_sec;
	if (pObj)
		if (pObj->Compressed)
			pObj->Compressed = FALSE;
		else stLast = pObj->LastWeather;

	__int64 dTime = DeltaSeconds(&stLast, &st);
//	TraceLogThread("JT65", dTime!=0, "%s Modified %04ld-%02ld-%02ld %02ld:%02ld:%02ld Last %04ld-%02ld-%02ld %02ld:%02ld:%02ld Delta: %ld seconds\n",
//					File,
//					st.wYear, st.wMonth, st.wDay,
//					st.wHour, st.wMinute, st.wSecond,
//					stLast.wYear, stLast.wMonth, stLast.wDay,
//					stLast.wHour, stLast.wMinute, stLast.wSecond,
//					(long) dTime);
	if (dTime)
	{	char *InBuf, *Packet = NULL;
		FILE *In;
		long Size, Read;
		int Lines = 0, NewLines = 0;
		BOOL AllOK = TRUE;

		In = fopen(File, "rt");
		if (!In)
		{	TraceLogThread("JT65", TRUE, "Failed To Open(%s)\n", File);
			return FALSE;
		}
		//TraceLogThread("JT65", TRUE, "Loading(%s)...\n", File);
		fseek(In, 0, SEEK_END);
		Size = (long) (ftell(In)*1.2);
		fseek(In, 0, SEEK_SET);
		if (!Size)
		{	fclose(In);
			TraceLogThread("JT65", TRUE, "ftell(%s) is ZERO!\n", File);
			return FALSE;
		}
		//TraceLogThread("JT65", TRUE, "ftell(%s)=%ld\n", File, (long) Size);
		Read = 0;
		InBuf = (char*)calloc(1,Size);
		//TraceLogThread("JT65", TRUE, "Reading(%s)...\n", File);
		while (fgets(&InBuf[Read], Size-Read, In))
		{	Read += strlen(&InBuf[Read]);
			InBuf[Read++] = '\n';	/* We need these later */
		}
		fclose(In);
		if (!Read)
		{	free(InBuf);
			TraceLogThread("JT65", TRUE, "Read(%s) is ZERO!\n", File);
			return FALSE;
		}
		//TraceLogThread("JT65", TRUE, "Reading(%s) gave %ld bytes\n", File, (long) Read);
		static char HeaderLn[] = "\"Date\",\"Time\",\"QRG\",\"Sync\",\"DB\",\"DT\",\"DF\",\"Decoder\",\"Exchange\"";
		if (strncmp(InBuf,HeaderLn,sizeof(HeaderLn)-1))
		{	TraceLogThread("JT65", TRUE, "%s has no (or wrong) header: %.80s\n", File, InBuf);
			free(InBuf);
			return FALSE;
		}
/*
"Date","Time","QRG","Sync","DB","DT","DF","Decoder","Exchange"
"2012-08-07","16:44","14076000","4","-12","-0.2","773","B","CQ AB1PF FN31","65A"
"2012-08-07","16:46","14076000","3","-12","-0.2","773","B","CQ AB1PF FN31","65A"
"2012-08-07","16:52","0","5","-18","0.1","428","K","MY REPORT PSE","65A"
*/
		for (char *Input=InBuf; *Input; Input++)
		{	char *p, *e, *eol = strchr(Input,'\n');
			char *Commas[10];	/* Hopefully not more than 10! */
			int CommaCount=0;
			BOOL OK = TRUE;
			SYSTEMTIME stLine = {0};

			if (!eol) break;	/* Need the \n */
			if (!strncmp(Input,HeaderLn,sizeof(HeaderLn)-1))	// ignore header
			{	Input = ++eol;
				Lines++;
				continue;
			}

			Commas[CommaCount++] = Input;	/* Get the first one loaded */
			for (p=Input; p<eol; p++)
			{	if (*p == ',')
				{	if (CommaCount < sizeof(Commas)/sizeof(Commas[0]))
						Commas[CommaCount++] = p+1;
					*p = '\0';	/* Null terminate previous string */
				}
			}
			*eol++ = '\0';	/* Null terminate last piece */
			Input = eol;
			Lines++;

/*
"Date","Time","QRG","Sync","DB","DT","DF","Decoder","Exchange"
"2012-08-07","16:44","14076000","4","-12","-0.2","773","B","CQ AB1PF FN31","65A"
"2012-08-07","16:46","14076000","3","-12","-0.2","773","B","CQ AB1PF FN31","65A"
"2012-08-07","16:52","0","5","-18","0.1","428","K","MY REPORT PSE","65A"
*/
			if (CommaCount>=1 && *Commas[0] == '"')
			{	stLine.wYear = (WORD) strtol(Commas[0]+1, &e, 10);
				if (*e == '-')
				{	stLine.wMonth = (WORD) strtol(e+1, &e, 10);
					if (*e == '-')
					{	stLine.wDay = (WORD) strtol(e+1, &e, 10);
						if (*e == '"') ;
						else OK = FALSE;
					} else OK = FALSE;
				} else OK = FALSE;
			} else OK = FALSE;
			if (CommaCount>=2 && *Commas[1] == '"')
			{	stLine.wHour = (WORD) strtol(Commas[1]+1, &e, 10);
				if (*e == ':')
				{	stLine.wMinute = (WORD) strtol(e+1, &e, 10);
					if (*e == '"') ;
					else OK = FALSE;
				} else OK = FALSE;
			} else OK = FALSE;
			for (int c=0; c<CommaCount; c++)
			{	if (*Commas[c] == '"')
				{	size_t l = strlen(Commas[c]);
					if (Commas[c][l-1] == '"')
					{	Commas[c][l-1] = '\0';
						Commas[c]++;
					} else OK = FALSE;
				} else OK = FALSE;
			}

			if (OK)
			{	__int64 newSeconds = DeltaSeconds(&stLast, &stLine);
				if (newSeconds > 0)
				if (CommaCount == 10)
				if (!strcmp(Commas[9],"65A"))
				{	NewLines++;
				TraceLogThread("JT65",FALSE,"Processing:%s %s %s\n", Commas[0], Commas[1], Commas[8]);
				if (pObj)	// Only if generating objects
				{	double Freq = 0;
					long Offset = 0;
					if (*Commas[2] && *Commas[6])
					{	Freq = strtod(Commas[2],&e)/1000.0/1000.0;
						if (*e)
						{	TraceLogThread("JT65",newSeconds>0,"Invalid Freq(%s)\n", Commas[2]);
							Freq = 0;
						} else
						{	if (Freq < 1.0) Freq = Freq * 1000.0;	/* New JT65 version! */
							Offset = strtol(Commas[6],&e,10);
							if (*e)
							{	TraceLogThread("JT65",newSeconds>0,"Invalid Offset(%s)\n", Commas[6]);
								Offset = 0;
							}
						}
					}
				if (!strncmp(Commas[8],"CQ ",3))
				{	char *call = strchr(Commas[8],' ');
					char *gridsq = strchr(++call,' ');
					if (gridsq)
					{	*gridsq++ = '\0';
						if (IsInternationalCall(call))
						if (strlen(gridsq)==4
						&& isalpha(gridsq[0]&0xff) && isalpha(gridsq[1]&0xff) 
						&& isdigit(gridsq[2]&0xff) && isdigit(gridsq[3]&0xff))
						{	TraceLogThread("JT65",FALSE,"CQ %s from %s\n", call, gridsq);
							if (newSeconds>0) FormatJT65Station(pObj, call, "CQ", gridsq, Commas[4], Freq, Offset, &stLine);
						} else TraceLogThread("JT65",newSeconds>0,"Non-Grid(%s) CQ from %s\n", gridsq, call);
						else TraceLogThread("JT65",newSeconds>0,"Non-Call(%s) CQ\n", call);
					} else TraceLogThread("JT65",newSeconds>0,"2-Piece CQ from %s", call);
				} else
				{	char *to = Commas[8];
					char *from = strchr(to,' ');
					if (from)
					{	*from++ = '\0';
						char *gridsq = strchr(from,' ');
						if (gridsq)
						{	*gridsq++ = '\0';
							if (IsInternationalCall(to))
							if (IsInternationalCall(from))
							if (strlen(gridsq)==4
							&& isalpha(gridsq[0]&0xff) && isalpha(gridsq[1]&0xff) 
							&& isdigit(gridsq[2]&0xff) && isdigit(gridsq[3]&0xff))
							{	TraceLogThread("JT65",FALSE,"Ans %s from %s at %s\n", to, from, gridsq);
								if (newSeconds>0) FormatJT65Station(pObj, from, to, gridsq, Commas[4], Freq, Offset, &stLine);
							} else
							{	if (!strcmp(gridsq,"RRR") || !strcmp(gridsq,"73"))
									TraceLogThread("JT65",FALSE,"%s to %s from %s\n", gridsq, to, from);
								else
								{	strtol(*gridsq=='R'?gridsq+1:gridsq,&e,10);
									if (!*e) TraceLogThread("JT65",FALSE,"Report %s to %s from %s\n", gridsq, to, from);
									else TraceLogThread("JT65",newSeconds>0,"Non-Grid(%s) to %s from %s\n", gridsq, to, from);
								}
							}
							else TraceLogThread("JT65",newSeconds>0,"Non-fromCall(%s) to %s grid %s\n", from, to, gridsq);
							else TraceLogThread("JT65",newSeconds>0,"Non-toCall(%s) from %s grid %s\n", to, from, gridsq);
						} else TraceLogThread("JT65",newSeconds>0,"2 parts: %s %s\n", to, from);
					} else TraceLogThread("JT65",newSeconds>0,"1 part: %s", to);
				}	// if (CQ) else
				}	// if (pObj)
				} else
				{	OK = FALSE;
					TraceLogThread("JT65", TRUE, "Non-JT65 in %s\n", Commas[9]);
				}
				else if (Lines > 1 && (CommaCount !=8 || strcmp(Commas[6],"T")))
				{	OK = FALSE;
					TraceLogThread("JT65", TRUE, "Expected 10 Commas, got %ld\n", CommaCount);
				}
					// if (newSeconds)
			}	// if (OK)

//TraceLogThread("JT65",FALSE,"Got %ld Commas in %.*s\n", CommaCount, (int) (eol-Input), Input);
			if (!OK) AllOK = FALSE;
		}
		free(InBuf);
		if (pObj)
		{	char *Where = GridSquare(MyStation->pCoord->lat, MyStation->pCoord->lon, 3);
			FormatJT65Station(pObj, pObj->Name, NULL, Where, NULL, 0, 0, &st);
		}
		TraceLogThread("JT65", TRUE, "%sDone Parsing %ld/%ld Lines (%ld Bytes) from %s\n",
						AllOK?"":"SOME BAD!  ", (long) NewLines, (long) Lines, (long) Read, File);
		if (pObj) pObj->LastWeather = st;
	}
	return TRUE;
}
#endif


static STATION_INFO_S *TransmitObject(OBJECT_CONFIG_INFO_S *Obj, BOOL LocalOnly/*=FALSE*/, BOOL ISOnly/*=FALSE*/)
{	SYSTEMTIME stObj;

#ifndef UNDER_CE
	if (Obj->JT65)
	{	ParseJT65File(Obj, Obj->WeatherPath, &stObj);
//#error need to finish this code
//		return AprsLogInternalPacket("Object", NULL, Buffer, TRUE);	/* Process it on my display also! */
		return NULL;
	}
#endif

	if (Obj->Weather)
	{	char *Packet = ParseWeatherFile(Obj->Name, Obj->WeatherPath, &stObj);
		if (!Packet)
		{	TraceLogThread(Obj->Name, TRUE, "Weather Object(%s) Format Failed, Retrying NOW!\n", Obj->Name);
			Packet = ParseWeatherFile(Obj->Name, Obj->WeatherPath, &stObj);
			if (Packet)
			{	char *Buffer = (char*)malloc(256);
				TraceLogThread(Obj->Name, TRUE, "Weather Object(%s) Format Instant Retry WORKED!\n", Obj->Name);
				StringCbPrintfA(Buffer, 256, "Weather Object(%s) Format Instant Retry WORKED!", Obj->Name);
				QueueInternalMessage(Buffer,TRUE);
//			static char dBuffer[256];
//				StringCbPrintfA(dBuffer,sizeof(dBuffer), "%s>DEBUG::%-9s:Instant Retry Weather(%s) WORKED!",
//								CALLSIGN, "KJ4ERJ-DB", Obj->Name);
//				QueueDebugMessage(llGetMsec(), dBuffer);
			}
		}
		if (!Packet)
		{	char *Buffer = (char*)malloc(256);
			if (++Obj->WeatherRetries > 3)
			{	TraceLogThread(Obj->Name, TRUE, "Disabling Weather Object(%s)\n", Obj->Name);
				StringCbPrintfA(Buffer, 256, "Disabled Weather Object(%s)", Obj->Name);
				Obj->Enabled = FALSE;
				Obj->WeatherRetries = 0;	/* For next time */
			} else
			{	OffsetSystemTime(&Obj->LastTransmit, Obj->Interval/4);	/* Wait 1/4 of Interval before retry */
				TraceLogThread(Obj->Name, TRUE, "Weather Object(%s) Format Failed, Retrying in %ld Seconds (%04ld-%02ld-%02ld %02ld:%02ld:%02ld)...\n",
								Obj->Name,
								Obj->Interval / 4,
								Obj->LastTransmit.wYear,
								Obj->LastTransmit.wMonth,
								Obj->LastTransmit.wDay,
								Obj->LastTransmit.wHour,
								Obj->LastTransmit.wMinute,
								Obj->LastTransmit.wSecond);
				StringCbPrintfA(Buffer, 256, "Weather Object(%s) Format Failed, Retrying in %ld Seconds (%04ld-%02ld-%02ld %02ld:%02ld:%02ld)...",
								Obj->Name,
								Obj->Interval / 4,
								Obj->LastTransmit.wYear,
								Obj->LastTransmit.wMonth,
								Obj->LastTransmit.wDay,
								Obj->LastTransmit.wHour,
								Obj->LastTransmit.wMinute,
								Obj->LastTransmit.wSecond);
			}
			QueueInternalMessage(Buffer,TRUE);
			// ShowTraceLog(Obj->Name);
			return NULL;
		} else
		{	Obj->WeatherRetries = 0;	/* Looks good now! */
			if (!memcmp(&stObj, &Obj->LastWeather, sizeof(stObj)))
			{	TraceLogThread(Obj->Name, FALSE, "No New Weather Data, Last %04ld-%02ld-%02ld %02ld:%02ld:%02ld from %s\n",
						stObj.wYear, stObj.wMonth, stObj.wDay,
						stObj.wHour, stObj.wMinute, stObj.wSecond,
						Obj->WeatherPath);
				return NULL;
			}
			Obj->LastWeather = stObj;
			strncpy(Obj->Comment, Packet, sizeof(Obj->Comment));
		}
	}

	size_t Remaining = 256 + sizeof(Obj->Comment);
	char *DAO=NULL, *Buffer = (char*)malloc(Remaining);
	TCHAR *LatLon = Obj->Compressed /*&& !isdigit(Obj->Symbol.Table)*/
					?	APRSCompressLatLon(Obj->Latitude, Obj->Longitude,
										Obj->Symbol.Table, Obj->Symbol.Symbol,
										FALSE, 0, 0, FALSE, 0)
					:	APRSLatLon(Obj->Latitude, Obj->Longitude,
										Obj->Symbol.Table, Obj->Symbol.Symbol,
										0, Obj->Precision, &DAO);
	char *Next = Buffer;

	if (!LatLon) return NULL;	/* Formatting failed! */

	if (!LocalOnly)
		GetSystemTime(&Obj->LastTransmit);	/* Remember time transmitted */
	stObj = Obj->Weather?Obj->LastWeather:Obj->LastTransmit;

	if (Obj->Item && !Obj->Weather)	/* Weather Items are Posits */
	{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%s>%s%s%s:)%.9s%c",	/* Item format */
					CALLSIGN, DESTID,
					*Obj->RFPath?",":"", Obj->RFPath,
					Obj->Name, Obj->Kill?'_':'!');
//					Obj->Name, (Obj->Kill&&!LocalOnly)?'_':'!');
	} else
	{	if (Obj->Item)	/* Weather Items are Posits */
		{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%s>%s", Obj->Name, DESTID);
			if (!IsSameBaseCallsign(Obj->Name, CALLSIGN))
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					",%s*", CALLSIGN);
			if (*Obj->RFPath)
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					",%s",Obj->RFPath);
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					":/");	/* Pos, Timestamp, No msg */
		} else 
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%s>%s%s%s:;%-9.9s%c",	/* Object format */
					CALLSIGN, DESTID,
					*Obj->RFPath?",":"", Obj->RFPath,
					Obj->Name, Obj->Kill?'_':'*');
//					Obj->Name, (Obj->Kill&&!LocalOnly)?'_':'*');

		/* Now add the timestamp */

		if (Obj->Permanent)
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"111111z");
		else if (Obj->HHMMSS)
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld%02ld%02ldh",
					(long) stObj.wHour, 
					(long) stObj.wMinute, 
					(long) stObj.wSecond);
		else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld%02ld%02ldz",
					(long) stObj.wDay, 
					(long) stObj.wHour, 
					(long) stObj.wMinute);
	}

	/* And finally the payload */
	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			"%S%s%s", LatLon, Obj->Comment,
			Obj->Compressed?"":(DAO?DAO:""));

	TraceLogThread(Obj->Weather?Obj->Name:"Objects", TRUE, "%s", Buffer);

	if (Obj->Kill)
	{	unsigned long Max = ActiveConfig.Aging.MaxObjectKillXmits;
		if ((!Obj->ISEnabled && !Obj->RFEnabled) || !Obj->Interval)
			Max = 1;/* Local gets 1 */
		if (++Obj->KillXmitCount >= Max)
		{	Obj->Enabled = FALSE;	/* Disable the killed object */
			char *Buffer = (char *) malloc(256);
			StringCbPrintfA(Buffer, 256, "Killed Object %s%s%s Disabled After %ld Transmission%s",
						Obj->Group, Obj->Group[0]?"/":"",
						Obj->Name, (long) Obj->KillXmitCount,
						Obj->KillXmitCount==1?"":"s");
			TraceLogThread(Obj->Weather?Obj->Name:"Objects", TRUE, "%s", Buffer);
			QueueInternalMessage(Buffer, TRUE);
		}
	}
	if (!LocalOnly)
	{	if (ISOnly)
			QueueToTransmit(OBJECT_PACKET, Buffer, FALSE, TRUE);
		else QueueToTransmit(OBJECT_PACKET, Buffer, !Obj->ISEnabled, !Obj->RFEnabled);
	}
	free(LatLon);
	if (DAO) free(DAO);
	return AprsLogInternalPacket("Object", NULL, Buffer, TRUE);	/* Process it on my display also! */
}

BOOL TransmitObject2(OBJECT_CONFIG_INFO_S *Obj, BOOL LocalOnly=FALSE)
{	return TransmitObject(Obj, LocalOnly) != NULL;
}

static void TransmitWeather(BOOL Force /*= FALSE*/)
{	unsigned long o;
	for (o=0; o<ActiveConfig.Objects.Count; o++)
	{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[o];
		if (Obj->Weather && Obj->Enabled)
		{	if (Force)
			{	memset(&Obj->LastWeather, 0, sizeof(Obj->LastWeather));
			}
			TransmitObject(Obj, FALSE);
		}
	}
}

static unsigned long TransmitObjects(HWND hwnd, BOOL OnTimer/*FALSE*/, BOOL AllIntervaled/*FALSE*/, char *Group/*=NULL*/)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	unsigned long o, Count=0;
	__int64 Now = llGetMsec();
static	BOOL First = TRUE;	/* First time force all LocalOnlys */

	for (o=0; o<ActiveConfig.Objects.Count; o++)
	{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[o];
		BOOL LocalOnly = (!Obj->ISEnabled && !Obj->RFEnabled);
//TraceLogThread("Objects", FALSE, "Obj(%s) %s %s %s %s %04ld-%02ld-%02ld %02ld:%02ld:%02ld\n", Obj->Name, Obj->ISEnabled?"IS":"", Obj->RFEnabled?"RF":"", LocalOnly?"LOCAL":"", First?"FIRST":"", Obj->LastTransmit.wYear, Obj->LastTransmit.wMonth, Obj->LastTransmit.wDay, Obj->LastTransmit.wHour, Obj->LastTransmit.wMinute, Obj->LastTransmit.wSecond);
		if (LocalOnly && First)
			memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
		if (Obj->Enabled
		&& (Obj->Interval	/* Have an interval? */
			|| LocalOnly))				/* Or Internal only? */
		{	unsigned long Interval = Obj->Interval;
			if (!Interval && LocalOnly)
				Interval = ActiveConfig.Stations.MinAge;
			if ((AllIntervaled&&!Obj->Weather&&!Obj->JT65)
			|| IsSystemTimeout(&Obj->LastTransmit, Interval*60))
			if ((!Group /*&& Obj->Group[0] != '?'*/)	/* ?group only explicitly */
			|| (Group && !_stricmp(Group,Obj->Group)))	/* Explicitly */
			{	TransmitObject(Obj, (!Obj->ISEnabled && !Obj->RFEnabled));
				// Assume it worked in case of asynch posting of objs w/o Station
				{	if (LocalOnly)
						GetSystemTime(&Obj->LastTransmit);	/* Remember time transmitted */
					else Count++;	/* Only count really transmitted ones */
					
//TraceLogThread("Objects", FALSE, "Obj(%s) Transmitted %s\n", Obj->Name, LocalOnly?"LOCAL":"");
					if (OnTimer && Obj->RFEnabled) break;	/* Only one allowed RF per interval */
				}
//else TraceLogThread("Objects", FALSE, "Obj(%s) FAILED!\n", Obj->Name);
			}
//else TraceLogThread("Objects", FALSE, "NOT Obj(%s)Group(%s) Requested %s\n", Obj->Name, Obj->Group, Group?Group:"*NULL*");
//else TraceLogThread("Objects", FALSE, "NOT Obj(%s) %s %s Int:%ld %s %04ld-%02ld-%02ld %02ld:%02ld:%02ld\n", Obj->Name, Obj->Enabled?"Enabled":"DISABLED", OnDemand?"OnDemand":"", Interval*60, LocalOnly?"LOCAL":"", Obj->LastTransmit.wYear, Obj->LastTransmit.wMonth, Obj->LastTransmit.wDay, Obj->LastTransmit.wHour, Obj->LastTransmit.wMinute, Obj->LastTransmit.wSecond);
		}
//else TraceLogThread("Objects", FALSE, "NOT Obj(%s) %s %s Int:%ld %s %04ld-%02ld-%02ld %02ld:%02ld:%02ld\n", Obj->Name, Obj->Enabled?"Enabled":"DISABLED", OnDemand?"OnDemand":"", Obj->Interval, LocalOnly?"LOCAL":"", Obj->LastTransmit.wYear, Obj->LastTransmit.wMonth, Obj->LastTransmit.wDay, Obj->LastTransmit.wHour, Obj->LastTransmit.wMinute, Obj->LastTransmit.wSecond);
	}
	First = FALSE;

	if (ActiveConfig.QRU.Enabled
	&& ActiveConfig.QRU.Interval
	&& IsSystemTimeout(&ActiveConfig.QRU.LastTransmit, ActiveConfig.QRU.Interval*60))
	{	char *Groups = GetQRUGroups(&ActiveConfig, TRUE);
		if (Groups)
		{	SYSTEMTIME *pst = &ActiveConfig.QRU.LastTransmit;
			size_t Remaining = 256 + strlen(Groups);
			char *DAO=NULL, *Buffer = (char*)malloc(Remaining);
			TCHAR *LatLon = APRSLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon, '\\', '?', 0, ActiveConfig.Beacon.Precision, &DAO);
			char *Next = Buffer;
			GetSystemTime(pst);
			char *Dash = strchr(CALLSIGN,'-');
			if (!Dash) Dash = strchr(CALLSIGN,'\0');
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%s>%s%s%s:;QRU%-6.*s*",	/* Object format */
					CALLSIGN, DESTID,
					*PATH?",":"", PATH,
					(int) (Dash-CALLSIGN), CALLSIGN);
		/* Now add the timestamp */
#ifdef BREAKS_D710s
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld%02ld%02ldh",
					(long) pst->wHour, 
					(long) pst->wMinute, 
					(long) pst->wSecond);
#else
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%02ld%02ld%02ldz",
					(long) pst->wDay, 
					(long) pst->wHour, 
					(long) pst->wMinute);
#endif
			/* And finally the payload */
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					"%SRNG%04ld%s%s", LatLon,
					(long) (ActiveConfig.QRU.Range/(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
					Groups, DAO);
			TraceLog("QRU", TRUE, hwnd, "%s", Buffer);
			QueueToTransmit(OBJECT_PACKET, Buffer);
			AprsLogInternalPacket("Object", NULL, Buffer, TRUE);	/* Process it on my display also! */
			free(Groups);
			free(LatLon);
			if (DAO) free(DAO);
		}
	}

	return Count;
}

static void TransmitBulletins(HWND hwnd, BOOL OnTimer=FALSE)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	unsigned long o;
	__int64 Now = llGetMsec();

	for (o=0; o<ActiveConfig.Bulletins.Count; o++)
	if (ActiveConfig.Bulletins.Bull[o].Enabled	/* Enabled? */
	&& ActiveConfig.Bulletins.Bull[o].Interval)	/* Have an interval? */
	{	BULLETIN_CONFIG_INFO_S *Bull = &ActiveConfig.Bulletins.Bull[o];
		if (Bull->ISEnabled || Bull->RFEnabled)
		if (IsSystemTimeout(&Bull->LastTransmit, Bull->Interval*60))
		{	size_t Remaining = 256 + strlen(Bull->Comment);
			char *Buffer = (char*)malloc(Remaining);
			char *Next = Buffer;

			GetSystemTime(&Bull->LastTransmit);	/* Remember time transmitted */

			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s>%s%s%s::%-9.9s:%s",
							CALLSIGN, DESTID,
							*Bull->RFPath?",":"", Bull->RFPath,
							Bull->Name, Bull->Comment);

//			TraceLog("Bulletins", FALSE, hwnd, "Sent: %s", Buffer);
			QueueToTransmit(BULLETIN_PACKET, Buffer, !Bull->ISEnabled, !Bull->RFEnabled);
			AprsLogInternalPacket("Bulletin", hwnd, Buffer, TRUE);
			InvalidateBulletin(FALSE);
			if (OnTimer && Bull->RFEnabled) break;	/* Only one allowed RF per interval */
		}
	}
}

static void TransmitCQGroups(HWND hwnd, BOOL Force=FALSE)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	unsigned long i, o;
	__int64 Now = llGetMsec();
	BOOL ISOnlys[] = { FALSE, TRUE };
/*
	Scan for unjoins and deletes before anything else
*/
for (o=0; o<ActiveConfig.CQGroups.Count; o++)
{	CQSRVR_GROUP_INFO_S *CQGroup = &ActiveConfig.CQGroups.CQGroup[o];
	if (CQGroup->UnJoin || CQGroup->PendingDelete)
	{	size_t Remaining = DEFAULT_WRAP_WIDTH*sizeof(TCHAR);
		TCHAR *Buffer = (TCHAR*)malloc(Remaining);
		TCHAR *Next = Buffer;
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("U %S"),
						CQGroup->Name);
		SendAPRSMessage(CQGroup->ViaCQSRVR?"CQSRVR":"ANSRVR", 1+1, Buffer, TRUE, FALSE, CQGroup->ISOnly);
		free(Buffer);
		if (CQGroup->PendingDelete)
		{	if (o < --ActiveConfig.CQGroups.Count)
				memmove(&ActiveConfig.CQGroups.CQGroup[o], &ActiveConfig.CQGroups.CQGroup[o+1],
						sizeof(ActiveConfig.CQGroups.CQGroup[0])*(ActiveConfig.CQGroups.Count-o));
			o--;	/* Do this entry over again */
		} else
		{	CQGroup->UnJoin = FALSE;	/* Only once */
			GetSystemTime(&CQGroup->LastTransmit);	/* Remember time transmitted */
		}
	}
}
/*
	First coalesce the Quiet ANSRVR KeepAlives
*/
for (i=0; i<sizeof(ISOnlys)/sizeof(ISOnlys[0]); i++)/* Note + on wrap breaks group names! */
{	size_t Remaining = DEFAULT_WRAP_WIDTH*sizeof(TCHAR);	/* Also below */
	TCHAR *Buffer = (TCHAR*)malloc(Remaining);
	TCHAR *Next = Buffer;
	*Next = TEXT('\0');
	for (o=0; o<ActiveConfig.CQGroups.Count; o++)
	{	CQSRVR_GROUP_INFO_S *CQGroup = &ActiveConfig.CQGroups.CQGroup[o];
		if (!CQGroup->ViaCQSRVR	/* Only ANSRVR groups */
		&& CQGroup->QuietMonitor	/* And quiet ones */
		&& CQGroup->KeepAlive	/* Enabled? */
		&& CQGroup->Interval	/* Have an interval? */
		&& CQGroup->ISOnly == ISOnlys[i]	/* Only compatible vias */
		&& CQGroup->LastTransmit.wYear	/* Only refreshes, not news */
		&& IsSystemTimeout(&CQGroup->LastTransmit, CQGroup->Interval*60*60))
		{	if (Remaining < (strlen(CQGroup->Name)+2)*sizeof(TCHAR))
			{	SendAPRSMessage("ANSRVR", 1+1, Buffer, TRUE, FALSE, ISOnlys[i]);/* Also below */
				Remaining = DEFAULT_WRAP_WIDTH*sizeof(TCHAR);	/* Also above */
				Next = Buffer;
				*Next = TEXT('\0');
			}
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S %S"),
							*Buffer?"":"K",	/* Put the command in first */
							CQGroup->Name);
			GetSystemTime(&CQGroup->LastTransmit);	/* Remember time transmitted */
		}
	}
	if (*Buffer)
	{	SendAPRSMessage("ANSRVR", 1+1, Buffer, TRUE, FALSE, ISOnlys[i]);/* Also above */
	}
	free(Buffer);
}
/*
	Now do the non-quiet or CQSRVR groups
*/
	for (o=0; o<ActiveConfig.CQGroups.Count; o++)
	if (ActiveConfig.CQGroups.CQGroup[o].OneShot	/* OneShot? */
	|| (ActiveConfig.CQGroups.CQGroup[o].KeepAlive	/* Enabled? */
	&& ActiveConfig.CQGroups.CQGroup[o].Interval))	/* Have an interval? */
	{	CQSRVR_GROUP_INFO_S *CQGroup = &ActiveConfig.CQGroups.CQGroup[o];
		if (CQGroup->OneShot
		|| ((!CQGroup->IfPresent || isOperatorPresent())
			&& IsSystemTimeout(&CQGroup->LastTransmit, CQGroup->Interval*60*60)))
		{	size_t Remaining = (256 + strlen(CQGroup->Name)+strlen(CQGroup->Comment))*sizeof(TCHAR);
			TCHAR *Buffer = (TCHAR*)malloc(Remaining);
			TCHAR *Next = Buffer;
#ifdef PETE_BROKE_THIS
			if (ActiveConfig.CQGroups.CQGroup[o].QuietMonitor)
			{	size_t Remaining = (256 + strlen(CQGroup->Name))*sizeof(TCHAR);
				TCHAR *Buffer = (TCHAR*)malloc(Remaining);
				TCHAR *Next = Buffer;
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("U %S"),
							CQGroup->Name);
				SendAPRSMessage(hwnd, "ANSRVR", Buffer, TRUE, FALSE,
							ActiveConfig.CQGroups.CQGroup[o].ISOnly);
				free(Buffer);
			}
#endif
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("CQ %S"),
							CQGroup->Name);
			if (ActiveConfig.CQGroups.CQGroup[o].OneShot
			|| ActiveConfig.CQGroups.CQGroup[o].ViaCQSRVR
			|| !ActiveConfig.CQGroups.CQGroup[o].QuietMonitor)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %S"), CQGroup->Comment);

			SendAPRSMessage(/*hwnd,*/
				ActiveConfig.CQGroups.CQGroup[o].ViaCQSRVR?"CQSRVR":"ANSRVR",
							3+strlen(CQGroup->Name)+1, Buffer, TRUE, FALSE,
							ActiveConfig.CQGroups.CQGroup[o].ISOnly);
			free(Buffer);

			ActiveConfig.CQGroups.CQGroup[o].OneShot = FALSE;
			GetSystemTime(&CQGroup->LastTransmit);	/* Remember time transmitted */
		}
	}

	if (ActiveConfig.ANDefs.Count)	/* Am I running announcements? */
	{static SYSTEMTIME LastTransmit = {0};
		if (IsSystemTimeout(&LastTransmit, 30*60))	/* Every 30 minutes */
		{	size_t Remaining = 128;
			char *Buffer = (char*)malloc(Remaining);
			char *Next = Buffer;
			SYSTEMTIME stNow;
			GetSystemTime(&stNow);

			StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						"%s>%s,%s*%s%s:>",
						"ANSRVR", DESTID, CALLSIGN, *PATH?",":"", PATH);

			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, 
						STRSAFE_IGNORE_NULLS,
						"%02ld%02ld%02ldz",
						(long) stNow.wDay, 
						(long) stNow.wHour, 
						(long) stNow.wMinute);
			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, 
						STRSAFE_IGNORE_NULLS,
						"%ld Active Announcement Groups",
						(long) ActiveConfig.ANDefs.Count);

			TraceLogThread("ANSRVR", TRUE, "%s", Buffer);
			QueueToTransmit(CAPABILITY_PACKET, Buffer, FALSE, TRUE);
			GetSystemTime(&LastTransmit);
			free(Buffer);
		} else
		{	BOOL MembershipChanged = FALSE;
			for (o=0; o<ActiveConfig.ANDefs.Count; o++)
			{	unsigned int PreCount = ActiveConfig.ANDefs.Count;
				unsigned int Count = ActiveConfig.ANDefs.ANDef[o].Members.Count;
				unsigned long Timeout = ActiveConfig.ANDefs.ANDef[o].IdleTimeoutHours;

				if (!Timeout) Timeout = 12;	/* Default 12 hours */
				for (unsigned int m=0; m<Count; m++)
				if (strncmp(ActiveConfig.ANDefs.ANDef[o].Owner, ActiveConfig.ANDefs.ANDef[o].Members.Entries[m].string,
							sizeof(ActiveConfig.ANDefs.ANDef[o].Owner)))
				{	char *Who = _strdup(ActiveConfig.ANDefs.ANDef[o].Members.Entries[m].string);
					STATION_INFO_S *Station = FindStationCall(Who);
					BOOL isMember = TRUE;
					unsigned __int64 Seconds = SecondsSince(&ActiveConfig.ANDefs.ANDef[o].Members.Entries[m].time);
					if (Seconds/60/60 >= Timeout)
					{	char *From = _strdup(ActiveConfig.ANDefs.ANDef[o].Name);
						if (RemoveANDefinitionMember(&ActiveConfig, From, Who))
						{	size_t MsgSize = 256*sizeof(TCHAR);
							TCHAR *Message = (TCHAR*)malloc(MsgSize);
							StringCbPrintf(Message, MsgSize, TEXT("N:%S Removed From Group"), From);
							SendAPRSMessageFrom(/*hwnd,*/ "ANSRVR", Who, 0, Message, FALSE,
													FALSE, FALSE, FALSE, DEFAULT_WRAP_WIDTH, TRUE);
							TraceLogThread("ANSRVR", TRUE, "%s Timeout (%ld seconds) %S\n",
											Who, (long) Seconds, Message);
							free(Message);
							isMember = FALSE;
						} else TraceLogThread("ANSRVR", TRUE, "Failed To Remove %s From %s\n",
											Who, From);
						free(Who); free(From);
					}
					if (Station && Station->isANSRVR != isMember)
					{	Station->isANSRVR = isMember;
						MembershipChanged = TRUE;
					}
				}
				if (ActiveConfig.ANDefs.Count != PreCount) o--;	/* Do over */
			}
			if (MembershipChanged) InvalidateCircle(NULL);
		}
	}
}

BOOL OnTcpReaderTimer(HWND hwnd)
{	CLIENT_INFO_S *Info;

	Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	if (Info)
	{static char InBuf[1024];

		if (!CloseStationCount) DefineME(hwnd);

#ifdef UNDER_CE
#ifdef USING_COMM_MGR
		GetConnMgrConnected(hwnd);
#endif
#endif

	}	// Info
	return TRUE;
}

COLORREF GetScaledRGColor(double Current, double RedValue, double GreenValue)
{	COLORREF color;
	double Percent = (Current - RedValue) / (GreenValue - RedValue) * 100.0;

	if (Percent <= 50.0)
	{	if (Percent < 0.0) Percent = 0.0;
		color = RGB(255,255*Percent/50,0);
	} else
	{	if (Percent > 100.0) Percent = 100.0;
		color = RGB(255*(100.0-Percent)/50,255,0);
	}
	return color;
}
		
static COLORREF GetScaledRGColorText(double Current, double RedValue, double GreenValue)
{	COLORREF color;
	double Percent = (Current - RedValue) / (GreenValue - RedValue) * 100.0;
#define BRIGHTNESS 0xA0
	if (Percent <= 50.0)
	{	if (Percent < 0.0) Percent = 0.0;
		color = RGB(BRIGHTNESS,BRIGHTNESS*Percent/50,0);
	} else
	{	if (Percent > 100.0) Percent = 100.0;
		color = RGB(BRIGHTNESS*(100.0-Percent)/50,BRIGHTNESS,0);
	}
	return color;
}
		
static void DrawRGRectangle(HDC hdc, RECT *prc, BOOL Outline, double Current, double RedValue, double GreenValue, BOOL RedIsFull)
{	double Percent = (Current - RedValue) / (GreenValue - RedValue) * 100.0;

	if (RedIsFull) Percent = 100.0 - Percent;

	if (Percent > 0.0)
	{	RECT rc = *prc;

		if (Percent > 100.0) Percent = 100.0;

		if (rc.right-rc.left < rc.bottom-rc.top)	/* Vertical bar? */
			rc.top = (long) (rc.top + (100.0-Percent) * (rc.bottom - rc.top) / 100.0);	/* (B->T) */
		else	rc.right = (long) (rc.left + Percent * (rc.right - rc.left) / 100.0);	/* Horizontal bar (L->R) */

		if (!IsRectEmpty(&rc))
		{	COLORREF color = GetScaledRGColor(Current, RedValue, GreenValue);
			HBRUSH hbr = CreateSolidBrush(color);
			if (Outline)
			{	HGDIOBJ oldBrush = SelectObject(hdc, hbr), hTemp;
				Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
				if ((hTemp=SelectObject(hdc, oldBrush)) != hbr)
					TraceError(NULL, "DrawRGRectangle SelectObject(0x%lX) return 0x%lX not 0x%lX Error %ld\n", (long) oldBrush, (long) hTemp, (long) hbr, GetLastError());
			} else	FillRect(hdc, &rc, hbr);
			if (!DeleteObject(hbr))
				TraceError(NULL,"DrawRGRectangle(%s) DeleteObject(hbr) Failed, Last Error = %ld\n", Outline?"Outline":"", GetLastError());
		}
	}
}

static COLORREF ScaleSatelliteColor(DWORD SNR)
{	return GetScaledRGColor((double) SNR, MIN_SNR, MAX_SNR);
}

static COLORREF GetSatelliteColor(int PRN, GPS_POSITION *gpsPos)
{
	if (gpsPos->dwValidFields & GPS_VALID_SATELLITES_IN_VIEW)
	if (gpsPos->dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_SIGNAL_TO_NOISE_RATIO)
	{	DWORD s;
		for (s=0; s<(DWORD)gpsPos->dwSatellitesInView; s++)
		{	if (PRN == (int) gpsPos->rgdwSatellitesInViewPRNs[s])
			{	return ScaleSatelliteColor(gpsPos->rgdwSatellitesInViewSignalToNoiseRatio[s]);
			}
		}
	}
	static char Buffer[256];
	Buffer[0] = 0;
	{	DWORD s;
		for (s=0; s<(DWORD)gpsPos->dwSatellitesInView; s++)
			sprintf(strchr(Buffer,'\0'),"%ld ",(long) gpsPos->rgdwSatellitesInViewPRNs[s]);
	}
	TraceLogThread("NMEA", gpsPos->dwSatellitesInView>0, "Failed To Find PRN %ld in %ld in view (%s)\n",
					(long) PRN, (long) gpsPos->dwSatellitesInView, Buffer);
	return 0;
}

void BltSymbol(HDC hdc, int x, int y, int Mult, int Div, int Page, int Index, int Percentage, RECT *prc)
{
	HBITMAP     hBitmap, hOldBitmap;
	BITMAP      bm;
	HDC         hMemDC;
	
	// Load the correct image and get its label
	hBitmap = LoadPaintImage(Page&0xff);
	if (hBitmap != NULL)
	{		// Calculate the height of our display image and text
			GetObject(hBitmap, sizeof(bm), &bm);
			// Draw the image
			hMemDC = CreateCompatibleDC(hdc);
			if (hMemDC != NULL)
			{	int w16 = bm.bmWidth/16;	/* 337 => 21 */
				int h6 = bm.bmHeight/6;		/* 127 => 21 */
				int dw = Mult*w16/Div;
				int dh = Mult*h6/Div;

				prc->left = x - dw/2 + 2*Mult/Div; prc->top = y - dh/2 + 2*Mult/Div;
				prc->right = dw - 4*Mult/Div; prc->bottom = dh - 4*Mult/Div;

#ifdef EXTREME
				TraceActivity(0, "bltSymbol %ld %ld (%ldx%ld) to %ld x %ld\n",
						  (long) (Index%16)*w16+2, (long) (Index/16)*h6+2, (long) w16-4, (long) h6-4,
						  (long) (prc->right), (long) (prc->bottom));
#endif

				hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
				if (Percentage > 90)
				{	TransparentBlt(hdc, prc->left, prc->top, prc->right, prc->bottom,
						hMemDC, (Index%16)*w16+2, (Index/16)*h6+2, w16-4, h6-4, RGB(255,255,255));
				} else
				{	BLENDFUNCTION bf = {0};
					bf.BlendOp = AC_SRC_OVER;
					bf.SourceConstantAlpha = (Percentage*255)/100;
#ifndef NO_ALPHABLEND
					AlphaBlend(hdc, prc->left, prc->top, prc->right, prc->bottom,
						hMemDC, (Index%16)*w16+2, (Index/16)*h6+2, w16-4, h6-4, bf);
#endif
				}

				Page = Page >> 8;	/* Overlay character? */
				if (prc->right > 8 && Page && isprint(Page&0xFF))	/* right is width, too small isn't worth drawing! */
				{	COLORREF overColor;
					int prevBkMode = SetBkMode(hdc, TRANSPARENT);
					RECT rcO = *prc;
					HFONT hOld = (HFONT) 0, hFont = LoadPaintFont(TEXT(""), (rcO.bottom*6)/8, FALSE);	/* bottom is height */
					TCHAR Buffer[2];
					StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.1S"), &Page);

					if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);

#define HIGHLIGHT_OVERLAY
#ifdef HIGHLIGHT_OVERLAY
					overColor = RGB(0,0,0);
					COLORREF backColor = RGB(255-GetRValue(overColor),255-GetGValue(overColor),255-GetBValue(overColor));
					if (backColor == RGB(255,255,255))
						backColor = RGB(254,254,254);	/* NOT transparent */
					COLORREF prevColor = SetTextColor(hdc, backColor);

					rcO = *prc;
					if (rcO.left&1) rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					OffsetRect(&rcO,-1,-1);
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

					rcO = *prc;
					if (rcO.left&1) rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					OffsetRect(&rcO,-1,1);
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

					rcO = *prc;
					if (rcO.left&1) rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					OffsetRect(&rcO,1,-1);
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

					rcO = *prc;
					if (rcO.left&1) rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					OffsetRect(&rcO,1,1);
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

					/* TraceActivity(NULL, "Overlay:%c @ %ld %ld (%ld x %ld)\n", Page&0xff, rcO.left, rcO.top, rcO.right, rcO.bottom); */
					SetTextColor(hdc, overColor);
					rcO = *prc;
					if (rcO.left&1) rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#else
#define WHITE RGB(255,255,255)
#define RED RGB(255,0,255)
static char WhiteOverlay[] = "#&";	/* Digi, HF Gateway */
static char RedOverlay[] = "AW_cs";	/* Aid Stn, WX Service, WX Station, ICP, Power Boat */

					if (strchr(WhiteOverlay,Page))
						overColor = RGB(255,255,255);
					else if (strchr(RedOverlay,Page))
						overColor = RGB(255,0,255);
					else overColor = RGB(0,0,0);

					COLORREF prevColor = SetTextColor(hdc, overColor);

					/* TraceActivity(NULL, "Overlay:%c @ %ld %ld (%ld x %ld)\n", Page&0xff, rcO.left, rcO.top, rcO.right, rcO.bottom); */
					rcO.left += 1;	/* Shift it over a bit */
					rcO.right += rcO.left; rcO.bottom += rcO.top;
					DrawText(hdc, Buffer, -1, &rcO, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#endif

					if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
					SetBkMode(hdc, prevBkMode);
					SetTextColor(hdc, prevColor);
				}

				SelectObject(hMemDC, hOldBitmap);
				DeleteDC(hMemDC);
			}
			else DrawText(hdc, TEXT("No hMemDC"), -1, prc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
	}
	else
	{
#ifdef UNDER_CE
		DrawText(hdc, TEXT("No hBitmap"), -1, prc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#else
	bm.bmWidth = 337;
	bm.bmHeight = 127;
	int w16 = bm.bmWidth/16;
	int h6 = bm.bmHeight/6;
	int dw = Mult*w16/Div;
	int dh = Mult*h6/Div;

	prc->left = x - dw/2 + 2*Mult/Div; prc->top = y - dh/2 + 2*Mult/Div;
	prc->right = dw - 4*Mult/Div; prc->bottom = dh - 4*Mult/Div;

	COLORREF color = GetScaledRGColor(50, 0, 100);
	HBRUSH hbr = CreateSolidBrush(color);

	prc->right += prc->left;
	prc->bottom += prc->top;

	FillRect(hdc, prc, hbr);
	prc->right -= prc->left;
	prc->bottom -= prc->top;
	DeleteObject(hbr);
#endif
	}
}

typedef struct SYMBOL_BITMAP_S
{	int Symbol;
	int xSize, ySize;
	HICON hIcon;
	HBITMAP hbm;
	RECT rc;	/* Rectangle within hbm */
} SYMBOL_BITMAP_S;

typedef struct BITMAP_SIZE_S
{	int xSize, ySize;
	HBITMAP hbm;	/* hbm of LARGE composite bitmap */
	int Next;		/* next index into hbm */
	int Count;
	int SymbolBitmapCount;
	int SymbolBitmapSize;
	SYMBOL_BITMAP_S *SymbolBitmaps;
} BITMAP_SIZE_S;

int BitmapSizeCount = 0;
int BitmapSizeSize = 0;
BITMAP_SIZE_S *BitmapSizes = NULL;

#ifdef NOT_USED_YET
static void GetSymbolSize(int Page, int *pWidth, int *pHeight)
{	HBITMAP     hBitmap = LoadPaintImage(Page?1:0);

	if (hBitmap != NULL)
	{	BITMAP	bm;
		// Calculate the height of our display image and text
		if (GetObject(hBitmap, sizeof(bm), &bm))
		{	*pWidth = bm.bmWidth / 16;	/* 337 => 21 */
			*pHeight = bm.bmHeight / 6;	/* 127 => 21 */
		}
	}

}
#endif

static int CompareSymbolBitmaps(const void *One, const void *Two)
{	SYMBOL_BITMAP_S *Left = (SYMBOL_BITMAP_S *)One;
	SYMBOL_BITMAP_S *Right = (SYMBOL_BITMAP_S *)Two;

	if (Left->Symbol != Right->Symbol) return Left->Symbol - Right->Symbol;
	if (Left->xSize != Right->xSize) return Left->xSize - Right->xSize;
	if (Left->ySize != Right->ySize) return Left->ySize - Right->ySize;
	return 0;
}

BITMAP_SIZE_S *FindBitmapSize(int xSize, int ySize)
{	int b1;

	for (b1=0; b1<BitmapSizeCount; b1++)
		if (BitmapSizes[b1].xSize == xSize
		&& BitmapSizes[b1].ySize == ySize)
			break;
	if (b1 >= BitmapSizeCount)
	{	b1 = BitmapSizeCount++;
		if (BitmapSizeCount > BitmapSizeSize)
		if (BitmapSizeCount > BitmapSizeSize)
		{	BitmapSizeSize += 16;
			BitmapSizes = (BITMAP_SIZE_S*)realloc(BitmapSizes, sizeof(*BitmapSizes)*BitmapSizeSize);
		}
		memset(&BitmapSizes[b1], 0, sizeof(BitmapSizes[b1]));
		BitmapSizes[b1].xSize = xSize;
		BitmapSizes[b1].ySize = ySize;
		BitmapSizes[b1].Count = 0;
	}
	BitmapSizes[b1].Count++;
	return &BitmapSizes[b1];
}

SYMBOL_BITMAP_S *FindSymbolBitmap(int symbol, int xSize, int ySize)
{	SYMBOL_BITMAP_S bFind;
	BITMAP_SIZE_S *pSize = FindBitmapSize(xSize, ySize);

	bFind.Symbol = symbol;
	bFind.xSize = xSize;
	bFind.ySize = ySize;
	SYMBOL_BITMAP_S *Find = &bFind;
	SYMBOL_BITMAP_S *Found;
	Found = (SYMBOL_BITMAP_S *)bsearch(&bFind, pSize->SymbolBitmaps, pSize->SymbolBitmapCount, sizeof(*pSize->SymbolBitmaps), CompareSymbolBitmaps);
	if (Found) return Found;
	return NULL;
}

void RememberSymbolBitmap(int symbol, int xSize, int ySize, HICON hIcon, HBITMAP hbm, RECT *prc)
{	SYMBOL_BITMAP_S *pBitmap = FindSymbolBitmap(symbol, xSize, ySize);

	if (!pBitmap)
	{	BITMAP_SIZE_S *pSize = FindBitmapSize(xSize, ySize);
		int b = pSize->SymbolBitmapCount++;

		if (pSize->SymbolBitmapCount > pSize->SymbolBitmapSize)
		{	pSize->SymbolBitmapSize += 16;
			pSize->SymbolBitmaps = (SYMBOL_BITMAP_S*)realloc(pSize->SymbolBitmaps, sizeof(*pSize->SymbolBitmaps)*pSize->SymbolBitmapSize);
		}
		pSize->SymbolBitmaps[b].Symbol = symbol;
		pSize->SymbolBitmaps[b].xSize = xSize;
		pSize->SymbolBitmaps[b].ySize = ySize;
		pSize->SymbolBitmaps[b].hIcon = hIcon;
		pSize->SymbolBitmaps[b].hbm = hbm;
		if (prc) pSize->SymbolBitmaps[b].rc = *prc;
		qsort(pSize->SymbolBitmaps, pSize->SymbolBitmapCount,
				sizeof(*pSize->SymbolBitmaps), CompareSymbolBitmaps);

if (xSize != ySize) TraceError(NULL, "RememberSymbolBitmap:Non-Square Bitmap %ld x %ld\n", xSize, ySize);

	} else
	{	if (hIcon) pBitmap->hIcon = hIcon;
		if (hbm) pBitmap->hbm = hbm;
		if (prc) pBitmap->rc = *prc;
	}
}

HBITMAP GetCachedSymbolBitmap(HWND hwnd, int Symbol, int xSize, int ySize, COLORREF SysColor, RECT *prc)
{	HBITMAP hResult = NULL;
	SYMBOL_BITMAP_S *pBitmap = FindSymbolBitmap(Symbol, xSize, ySize);

	if (pBitmap && pBitmap->hbm)
	{	hResult = pBitmap->hbm;
		*prc = pBitmap->rc;
	} else
	{	BITMAP_SIZE_S *pSize = FindBitmapSize(xSize, ySize);
		HDC hdcWin = GetDC(hwnd);
		HDC hdcBitmap = CreateCompatibleDC(hdcWin);
		HGDIOBJ hOrgMap = 0;
		RECT rcTarget;
		int Page = Symbol >> 8;
		int Index = (Symbol & 0xFF) - '!';

		if (!pSize->hbm || pSize->Next >= 8*8)
		{	pSize->hbm = CreateCompatibleBitmap(hdcWin, xSize*8, ySize*8);
			if (!pSize->hbm) TraceError(NULL, "Failed To Build %ld x %ld Bitmap Cache\n", xSize*8, ySize*8);
//else TraceLog("Bitmap", TRUE, hwnd, "Created New bitmap[%ld x %ld]\n", xSize, ySize);
			pSize->Next = 0;
		}

		hResult = pSize->hbm;
		prc->left = (pSize->Next%8)*xSize;
		prc->top = (pSize->Next/8)*ySize;
		prc->right = prc->left + xSize;
		prc->bottom = prc->top + ySize;

		hOrgMap = SelectObject(hdcBitmap, hResult);
		FillRect(hdcBitmap, prc, GetSysColorBrush(SysColor));
		BltSymbol(hdcBitmap, prc->left+xSize/2, prc->top+ySize/2, xSize, 17, Page, Index, 100, &rcTarget);
		SelectObject(hdcBitmap, hOrgMap);

		DeleteDC(hdcBitmap);
		ReleaseDC(hwnd, hdcWin);

		if (hResult)
		{
//TraceLog("Bitmap", TRUE, hwnd, "Next[%ld] Symbol %ld %ldx%ld at %ld %ld\n",pSize->Next, Symbol, xSize, ySize, prc->left, prc->top);
			pSize->Next++;
			RememberSymbolBitmap(Symbol, xSize, ySize, NULL, hResult, prc);
		}
	}

	return hResult;
}

HBITMAP MakeSymbolBitmap(HWND hwnd, int Symbol, int xSize, int ySize, COLORREF SysColor)
{	HBITMAP hResult = NULL;
	RECT rc;
	HBITMAP hSrcBmp = GetCachedSymbolBitmap(hwnd, Symbol, xSize, ySize, SysColor, &rc);
	if (hSrcBmp)
	{	HDC hdcWin = GetDC(hwnd);
		HDC hdcSrc = CreateCompatibleDC(hdcWin);
		HDC hdcDest = CreateCompatibleDC(hdcWin);
		HGDIOBJ hOrgDestMap=0, hOrgSrcMap=0;
		RECT rcSymbol;

		hResult = CreateCompatibleBitmap(hdcWin, xSize, ySize);

		SetRect(&rcSymbol, 0, 0, xSize, ySize);

		hOrgSrcMap = SelectObject(hdcSrc, hSrcBmp);

		hOrgDestMap = SelectObject(hdcDest, hResult);
		FillRect(hdcDest, &rcSymbol, GetSysColorBrush(SysColor));

		BitBlt(hdcDest, 0, 0, xSize, ySize, hdcSrc, rc.left, rc.top, SRCCOPY);

		SelectObject(hdcDest, hOrgDestMap);
		SelectObject(hdcSrc, hOrgSrcMap);
		DeleteDC(hdcDest);
		DeleteDC(hdcSrc);
		ReleaseDC(hwnd, hdcWin);
	}

	return hResult;
}

void BltSymbolBitmap(HWND hwnd, HDC hdc, HDC hMemDC, int x, int y, int Mult, int Div, int Symbol, int Percentage, COLORREF SysColor, RECT *prc)
{
//#define OLD_WAY
#ifdef OLD_WAY
#undef OLD_WAY
	int w16 = 337/16;	/* 337 => 21 */
	int h6 = 127/6;		/* 127 => 21 */
	HBITMAP hBitmap = MakeSymbolBitmap(hwnd, Symbol, w16-4, h6-4, SysColor);
	HBITMAP hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
	int dw = Mult*w16/Div;
	int dh = Mult*h6/Div;

	prc->left = x - dw/2 + 2*Mult/Div;
	prc->top = y - dh/2 + 2*Mult/Div;
	prc->right = dw - 4*Mult/Div;
	prc->bottom = dh - 4*Mult/Div;

		{	int b1;
			for (b1=0; b1<BitmapSizeCount; b1++)
				if (BitmapSizes[b1].xSize == prc->right
				&& BitmapSizes[b1].ySize == prc->bottom)
					break;
			if (b1 >= BitmapSizeCount)
			{	b1 = BitmapSizeCount++;
				if (BitmapSizeCount > BitmapSizeSize)
				if (BitmapSizeCount > BitmapSizeSize)
				{	BitmapSizeSize += 16;
					BitmapSizes = (BITMAP_SIZE_S*)realloc(BitmapSizes, sizeof(*BitmapSizes)*BitmapSizeSize);
				}
				memset(&BitmapSizes[b1],0,sizeof(BitmapSizes[b1]));
				BitmapSizes[b1].xSize = prc->right;
				BitmapSizes[b1].ySize = prc->bottom;
				BitmapSizes[b1].Count = 0;
			}
		}

	if (Percentage > 90)
	{	TransparentBlt(hdc, prc->left, prc->top,
						prc->right, prc->bottom,
						hMemDC, 0, 0, w16-4, h6-4,
						RGB(255,255,255));
	} else
	{	BLENDFUNCTION bf = {0};
		bf.BlendOp = AC_SRC_OVER;
		bf.SourceConstantAlpha = (Percentage*255)/100;
		//bf.SourceConstantAlpha = (75*255)/100;
		//bf.AlphaFormat = AC_SRC_ALPHA;   // use source alpha  
		AlphaBlend(hdc, prc->left, prc->top, prc->right, prc->bottom,
					hMemDC, 0, 0, w16-4, h6-4, bf);
	}
	SelectObject(hMemDC, hOldBitmap);
#else
	int w16 = 337/16;	/* 337 => 21 */
	int h6 = 127/6;		/* 127 => 21 */
	int dw = Mult*w16/Div;
	int dh = Mult*h6/Div;

	prc->left = x - dw/2 + 2*Mult/Div;
	prc->top = y - dh/2 + 2*Mult/Div;
	prc->right = dw - 4*Mult/Div;
	prc->bottom = dh - 4*Mult/Div;

	RECT rc;
	HBITMAP hBitmap = GetCachedSymbolBitmap(hwnd, Symbol, prc->right, prc->bottom, SysColor, &rc);
	HBITMAP hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);

	if (Percentage > 90)
	{	TransparentBlt(hdc, prc->left, prc->top,
						prc->right, prc->bottom,
						hMemDC, rc.left, rc.top, prc->right, prc->bottom,
						RGB(255,255,255));
	} else
	{	BLENDFUNCTION bf = {0};
		bf.BlendOp = AC_SRC_OVER;
		bf.SourceConstantAlpha = (Percentage*255)/100;
		//bf.SourceConstantAlpha = (75*255)/100;
		//bf.AlphaFormat = AC_SRC_ALPHA;   // use source alpha  
#ifndef NO_ALPHABLEND
		AlphaBlend(hdc, prc->left, prc->top, prc->right, prc->bottom,
					hMemDC, rc.left, rc.top, prc->right, prc->bottom, bf);
#endif
	}
	SelectObject(hMemDC, hOldBitmap);
#endif
#ifdef FUTURE
	{static BOOL Once = TRUE;
		if (Once)
		{	BITMAP bm;
			GetObject(hBitmap, sizeof(bm), &bm);
			TraceLog("BitMap", TRUE, hwnd, "Bits:%ld %ld/Pixel %ld x %ld (%ld bytes wide) Planes:%ld Type:%ld\n",
						bm.bmBits, bm.bmBitsPixel,
						bm.bmWidth, bm.bmHeight, bm.bmWidthBytes,
						bm.bmPlanes, bm.bmType);
			Once = FALSE;
		}
	}

	{	UCHAR ubAlpha = (UCHAR)(((Percentage)*255)/100);
		ubAlpha = (UCHAR)(((75)*255)/100);
		float fAlphaFactor = (float)ubAlpha / (float)0xff; 
		for (int x=0; x<w16-4; x++)
		{	for (int y=0; y<h6-4; y++)
			{	COLORREF pixel = GetPixel(hMemDC, x, y);

	            pixel = (ubAlpha << 24) |                       //0xaa000000 
                 ((UCHAR)(GetRValue(pixel) * fAlphaFactor) << 16) |  //0x00rr0000 
                 ((UCHAR)(GetGValue(pixel) * fAlphaFactor) << 8) | //0x0000gg00 
                 ((UCHAR)(GetBValue(pixel)   * fAlphaFactor));      //0x000000bb 

				SetPixel(hMemDC, x, y, pixel);
			}
		}
	}
#endif

}

#define ICON_X_SIZE 16
#define ICON_Y_SIZE 16

HICON MakeSymbolIcon(HWND hwnd, int Symbol)
{	HICON hResult = NULL;
	SYMBOL_BITMAP_S *pBitmap = FindSymbolBitmap(Symbol, ICON_X_SIZE, ICON_Y_SIZE);

	if (pBitmap && pBitmap->hIcon)
		hResult = pBitmap->hIcon;
	else
	{	HDC hdcWin = GetDC(hwnd);
		HDC hdcBitmap = CreateCompatibleDC(hdcWin);
		HGDIOBJ hOrgMap = 0;
		RECT rcSymbol;
		HBRUSH hbrBlack = CreateSolidBrush(RGB(0,0,0));
		HBRUSH hbrWhite = CreateSolidBrush(RGB(255,255,255));

		int Page = Symbol >> 8;
		int Index = (Symbol & 0xFF) - '!';

		ICONINFO ii = {0};
		ii.fIcon = TRUE;
		ii.xHotspot = ICON_X_SIZE/2;
		ii.yHotspot = ICON_Y_SIZE/2;
		ii.hbmMask = CreateCompatibleBitmap(hdcWin, ICON_X_SIZE, ICON_Y_SIZE);
		ii.hbmColor = CreateCompatibleBitmap(hdcWin, ICON_X_SIZE, ICON_Y_SIZE);

		SetRect(&rcSymbol, 0, 0, ICON_X_SIZE, ICON_Y_SIZE);

		hOrgMap = SelectObject(hdcBitmap, ii.hbmMask);
//		FillRect(hdcBitmap, &rcSymbol, hbrBlack);
		FillRect(hdcBitmap, &rcSymbol, hbrWhite);
		BltSymbol(hdcBitmap, ICON_X_SIZE/2, ICON_Y_SIZE/2, 1, 1, Page, Index, 100, &rcSymbol);
		for (int x=0; x<ICON_X_SIZE/2; x++)
		{	for (int y=0; y<ICON_Y_SIZE/2; y++)
			{	if (GetPixel(hdcBitmap, x, y) != RGB(255,255,255))
				{	SetPixel(hdcBitmap, x, y, RGB(0,0,0));
				}
			}
		}
		SelectObject(hdcBitmap, hOrgMap);

		hOrgMap = SelectObject(hdcBitmap, ii.hbmColor);
		//FillRect(hdcBitmap, &rcSymbol, GetSysColorBrush(COLOR_WINDOW));
		FillRect(hdcBitmap, &rcSymbol, GetSysColorBrush(COLOR_ACTIVECAPTION));
		BltSymbol(hdcBitmap, ICON_X_SIZE/2, ICON_Y_SIZE/2, 1, 1, Page, Index, 100, &rcSymbol);
		SelectObject(hdcBitmap, hOrgMap);

		hResult = CreateIconIndirect(&ii);
		if (!hResult) TraceLog("Icons", TRUE, hwnd, "CreateIconIndirect(0x%lX 0x%lX) Failed, Error=%ld\n", (long) ii.hbmMask, (long) ii.hbmColor, GetLastError());

		DeleteObject(ii.hbmMask);
		DeleteObject(ii.hbmColor);

		DeleteDC(hdcBitmap);
		ReleaseDC(hwnd, hdcWin);		
		DeleteObject(hbrBlack);
		DeleteObject(hbrWhite);

		if (hResult) RememberSymbolBitmap(Symbol, ICON_X_SIZE, ICON_Y_SIZE, hResult, NULL, NULL);
	}
	return hResult;
}

HICON MakeMySymbolIcon(void)
{
	if (MyStation)
		return MakeSymbolIcon(hwndMain, GetStationSymbol(MyStation));
	return NULL;
}

static int CompareDWords(const void *One, const void *Two)
{	DWORD *Left = (DWORD *) One;
	DWORD *Right = (DWORD *) Two;

	if (*Left < *Right) return -1;
	else if (*Left > *Right) return 1;
	else return 0;
}

double CalcTransmitPressure(CLIENT_INFO_S *Info, GENIUS_INFO_S *Genius, GPS_POSITION *Pos, __int64 Now, char *Why)
{	double Pressure = 0.0, newPressure;

	strcpy(Why,"Unknown");
	if (Genius->LastAPRSUpdate == 0.0)
	{	Pressure = 100.0;
		strcpy(Why,"FIRST");
		if ((Pos->dwValidFields & (GPS_VALID_SATELLITE_COUNT | GPS_VALID_SATELLITES_IN_VIEW)) == (GPS_VALID_SATELLITE_COUNT | GPS_VALID_SATELLITES_IN_VIEW))
		{	sprintf(Why, "FIRST %ld/%ld", (long) Pos->dwSatelliteCount, (long) Pos->dwSatellitesInView);
		}
	} else if (ForceTransmit)
	{	Pressure = 100.0;
		strcpy(Why,"FORCE");
	} else if (ConnectionTransitionTransmit)
	{	Pressure = 100.0;
		strcpy(Why,"Connect");
	} else if (GPSTransitionTransmit)
	{	Pressure = 100.0;
		if (HadGPSFix)
		{	if ((Pos->dwValidFields & (GPS_VALID_SATELLITE_COUNT | GPS_VALID_SATELLITES_IN_VIEW)) == (GPS_VALID_SATELLITE_COUNT | GPS_VALID_SATELLITES_IN_VIEW))
			{	sprintf(Why, "GotFix %ld/%ld", (long) Pos->dwSatelliteCount, (long) Pos->dwSatellitesInView);
			} else strcpy(Why, "GotFix");
		} else strcpy(Why,"LostFix");
	} else if (GPSEnabled
	&& !Genius->TimeOnly
	&& Genius->StartStop
	&& Genius->coordinatesMoved
	&& Pos->flSpeed > MOVING_SPEED
	&& Genius->LastAPRSPosition.flSpeed == 0.0)
	{	Pressure = 100.0;
		strcpy(Why,"START");
	} else if (GPSEnabled
	&& !Genius->TimeOnly
	&& Genius->StartStop
	&& Genius->coordinatesMoved
	&& Pos->flSpeed == 0.0
	&& Genius->LastAPRSPosition.flSpeed > MOVING_SPEED)
	{	Pressure = 100.0;
		strcpy(Why,"STOP");
	} else
	{	if (GPSEnabled && !Genius->TimeOnly)
		{	newPressure = (double) Genius->deltaDistance / (double) Genius->MaxDistance * 100.0;
			if (newPressure > Pressure) { sprintf(Why,"Dist %ld%%",(long) newPressure); Pressure = newPressure; };
			newPressure = (double) Genius->forecastDistance / (double) Genius->MaxDistance * 100.0;
			if (newPressure > Pressure) { sprintf(Why,"Fore %ld%%",(long) newPressure); Pressure = newPressure; };
			newPressure = (double) Genius->projDistance / (double) Genius->ForecastError * 100.0;
			if (newPressure > Pressure) { sprintf(Why,"Proj %ld%%",(long) newPressure); Pressure = newPressure; };
			if (Genius->coordinatesMoved && Genius->deltaHeading > 0	/* Must have one */
			&& Genius->BearingChange)	/* Skip it if zero (disabled) */
			{	newPressure = (double) Genius->deltaHeading / (double) Genius->BearingChange * 100.0;
				if (newPressure > Pressure) { sprintf(Why,"Head %ld%%",(long) newPressure); Pressure = newPressure; };
			}
		}

		newPressure = (Now-Genius->LastAPRSUpdate) / (double) MAXIMUM_APRS_DELTA * 100.0;
		if (newPressure > Pressure)
		{	long sec = max(0,(long) ((MAXIMUM_APRS_DELTA-(Now-Genius->LastAPRSUpdate))/1000.0));
			long Seconds = sec % 60;
			long Minutes = (sec / 60) % 60;
			long Hours = sec / 3600;
			sprintf(Why,"Time %ld:%02ld:%02ld",(long) Hours, (long) Minutes, (long) Seconds);
			Pressure = newPressure;
		}
	}
	TraceLogThread("Pressure",FALSE,"%ld%% %s\n", (long) Pressure, Why);
	return Pressure;
}

void SaveToTrackCSV(CLIENT_INFO_S *cInfo, HWND hwnd, GPS_POSITION *Pos)
{	if (CSVTrackFile)
		fprintf(CSVTrackFile,"%4d-%02d-%02dT%02d:%02d:%02d,%.5lf,%.5lf,%ld\n",
				(int) Pos->stUTCTime.wYear,
				(int) Pos->stUTCTime.wMonth,
				(int) Pos->stUTCTime.wDay,
				(int) Pos->stUTCTime.wHour,
				(int) Pos->stUTCTime.wMinute,
				(int) Pos->stUTCTime.wSecond,
				(double) Pos->dblLatitude,
				(double) Pos->dblLongitude,
				(long) (Pos->flAltitudeWRTSeaLevel*FeetPerMeter));
}

BOOL TransmitAPRS(HWND hwnd, CLIENT_INFO_S *Info, GENIUS_INFO_S *Genius, GPS_POSITION *Pos, BOOL NewPos)
{	BOOL Xmitted = FALSE;
	__int64 Now = llGetMsec();
static char Why[80];

	if (Genius->MinTime < 10) Genius->MinTime = 10;
	if (Genius->MaxTime < 1) Genius->MaxTime = 1;

	if (CalcTransmitPressure(Info, Genius, Pos, Now, Why) >= 100.0)
	{	if (Genius->LastAPRSUpdate+MINIMUM_APRS_DELTA <= Now	// It is time
		|| ForceTransmit)								// Or we are under force
	{	size_t Remaining = 256 + strlen(COMMENT);
			char *DAO=NULL, *Buffer = (char*)malloc(Remaining);
			TCHAR *LatLon = APRSLatLon(Pos->dblLatitude, Pos->dblLongitude, SYMBOL, 0, ActiveConfig.Beacon.Precision, &DAO);
			char *cLatLon, *Next = Buffer;
			BOOL DoComment = ActiveConfig.Beacon.Comment
				&& ActiveConfig.Comment[0]
				&& (ForceTransmit
					|| llMsecSince(Genius->msLastComment,Now)/1000
									>= ActiveConfig.CommentInterval*60);

			StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s>%s%s%s:", CALLSIGN, DESTID, *PATH?",":"", PATH);
			if (ActiveConfig.Beacon.Timestamp)
			{	if (ActiveConfig.Beacon.HHMMSS)
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%c%02ld%02ld%02ldh",
							POS_TIMESTAMPED_WITH_MESSAGING,
							(long) Pos->stUTCTime.wHour, 
							(long) Pos->stUTCTime.wMinute, 
							(long) Pos->stUTCTime.wSecond);
				else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%c%02ld%02ld%02ldz",
							POS_TIMESTAMPED_WITH_MESSAGING,
							(long) Pos->stUTCTime.wDay, 
							(long) Pos->stUTCTime.wHour, 
							(long) Pos->stUTCTime.wMinute);
			} else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%c", POS_NO_TIME_WITH_MESSAGING);

			if (ActiveConfig.Beacon.Compressed
			&& (cLatLon = APRSCompressed(Pos, NewPos, SYMBOL,
										ActiveConfig.Beacon.CourseSpeed,
										ActiveConfig.Beacon.Altitude)) != NULL)
			{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%s", cLatLon);
				if (DAO) free(DAO);
				DAO = NULL;	/* Don't put out the extra digits! */
				free(cLatLon);
			} else
			{
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%S", LatLon);

				if (ActiveConfig.Beacon.CourseSpeed)
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%S", APRSHeadSpeed((Pos->dwValidFields & (GPS_VALID_HEADING | GPS_VALID_SPEED))
																				== (GPS_VALID_HEADING | GPS_VALID_SPEED),
														Pos->flHeading, Pos->flSpeed));

				if (ActiveConfig.Beacon.Altitude)
				{	char cNext;
					if (ActiveConfig.Beacon.Why) cNext = *Why;
					else if (DoComment) cNext = *COMMENT;
					else if (ActiveConfig.Beacon.MicETag[0]) cNext = ActiveConfig.Beacon.MicETag[0];
					else if (ActiveConfig.Beacon.Precision > 0) cNext = DAO?*DAO:'\0';
					else cNext = '\0';
					StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
										STRSAFE_IGNORE_NULLS,
										"%S",
										APRSAltitude(Pos->dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL,
													Pos->flAltitudeWRTSeaLevel, cNext));
				}
			}

			if (ActiveConfig.Beacon.Why)
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"(%s)", Why);

#ifdef MONITOR_PHONE
			if (ActiveConfig.Beacon.Cellular)
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"(%S %ld%%)", szOldOperatorName, (long) dwOldSignalStrength);
#endif
			if (ActiveConfig.Beacon.MicETag[0])
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s", ActiveConfig.Beacon.MicETag);
			if (DoComment)
			{	Genius->msLastComment = Now;
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s", COMMENT);
			}

			if (ActiveConfig.Beacon.Precision > 0 && DAO && *DAO)
				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s", DAO);

#ifdef SUPPORT_APRSTRACE
			if (APRSTraceFile) fprintf(APRSTraceFile, "%s\n", Buffer);
#endif

			if (BeaconEnabled)
			{	if (!QueueToTransmit(BEACON_PACKET, Buffer))
				{	TraceLog("Transmit", TRUE, hwnd, "QueueToTransmit FAILED %s (%.3lfmi @ %ld = %.2lf)(%s)\n",
								Buffer, (double)Genius->deltaDistance, (long) Genius->deltaBearing,
								(double) Pos->flSpeed * MilePerNM, Why);
				}

			}// else
			{
//				TraceActivity(hwnd, "Sent %s (%.3lfmi @ %ld = %.2lf)(%s)\n",
//							Buffer, (double)Info->deltaDistance, (long) Info->deltaBearing,
//							(double) Pos->flSpeed * MilePerNM, Why);
#ifdef NO_LONGER_NECESSARY	/* Debugging has completed on this change */
				if (ConnectionTransitionTransmit && LastAPRSUpdate)
				{	char *Buffer = (char *) malloc(256);
					StringCbPrintfA(Buffer, 256, "Connection Transition Beacon Cleared");
					QueueInternalMessage(Buffer, TRUE);
				}
#endif
				ConnectionTransitionTransmit = FALSE;
				GPSTransitionTransmit = FALSE;
				ForceTransmit = FALSE;
				GetSystemTime(&Genius->stLastAPRS);
				Genius->LastAPRSUpdate = Now;
				Genius->LastAPRSPosition = *Pos;
				Odometer += Genius->deltaDistance;
				if (Genius->deltaDistance)
				{	InvalidateOdometer(FALSE);
					if (UpdateStationPosition(hwnd, MyStation,
											Pos->dblLatitude, Pos->dblLongitude,
											Pos->flAltitudeWRTSeaLevel, Pos->dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL,
											"*Local*", &Pos->stUTCTime, TRUE, Now))
						SaveToTrackCSV(Info, hwnd, &gpsPosition);
				}
				Xmitted = TRUE;
			}
			AprsLogInternalPacket("TransmitAPRS", hwnd, Buffer, TRUE);
			//free(Buffer);
			free(LatLon);
			if (DAO) free(DAO);
		}// else settcpstatus(Why, FALSE);
	}
	return Xmitted;
}

BOOL TransmitOdometer(HWND hwnd, CLIENT_INFO_S *Info, char *Why)
{static	char Buffer[256];

	if (!Odometer) return TRUE;
	if (!ActiveConfig.Enables.APRSIS) return TRUE;
	if (!ActiveConfig.APRSIS.XmitEnabled) return TRUE;
	if (!ActiveConfig.APRSIS.BeaconingEnabled) return TRUE;

	TCHAR *LatLon = APRSLatLon(LastGoodPosition.dblLatitude, LastGoodPosition.dblLongitude, SYMBOL, 0);

	if (ActiveConfig.View.Metric.Distance)
		StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s:%c%02ld%02ld%02ldz%S(%s)Odometer=%.2lfkm",
					CALLSIGN, DESTID, *PATH?",":"", PATH,
					POS_TIMESTAMPED_WITH_MESSAGING,
					(long) LastGoodPosition.stUTCTime.wDay, 
					(long) LastGoodPosition.stUTCTime.wHour, 
					(long) LastGoodPosition.stUTCTime.wMinute,
					LatLon, Why, (double) Odometer*KmPerMile);
	else StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s:%c%02ld%02ld%02ldz%S(%s)Odometer=%.2lfmi",
					CALLSIGN, DESTID, *PATH?",":"", PATH,
					POS_TIMESTAMPED_WITH_MESSAGING,
					(long) LastGoodPosition.stUTCTime.wDay, 
					(long) LastGoodPosition.stUTCTime.wHour, 
					(long) LastGoodPosition.stUTCTime.wMinute,
					LatLon, Why, (double) Odometer);
	free(LatLon);

	if (TransmitString(Buffer))
		return TRUE;

	TraceLog("Transmit", TRUE, hwnd, "TransmitOdometer FAILED %s\n", Buffer);
	return FALSE;
}

static void FormatSendTelemetry(HWND hwnd, BYTE BatteryLifePercent, BOOL AC, BOOL Charging, BOOL GPSenabled, DWORD dwSignalStrength, DWORD Current)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
static char Buffer[256];

	if (cInfo)	/* Somehow this is null during startup */
	{
		long GPSs = 2;
		BYTE ChargeAC = 2;				/* Start at 2 */
		if (AC) ChargeAC += 46;			/* Take it to 48 */
		if (Charging) ChargeAC += 47;	/* Take it to 95 */
		if (GPSenabled)
		{	GPSs += 46;					/* Take it to 48 */
			GPSs += GPSSatInUse*5;		/* Add 5 per satellite */
			if (GPSs > 95) GPSs = 95;	/* upper limit */
		}

		Current += 500;	/* Normalize to 000..999 */
		if (Current < 0) Current = 0;
		if (Current > 999) Current = 999;

		if (SUCCEEDED(StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s:T#%03ld,%03ld,%03ld,%03ld,%03ld,%03ld,%c%c%c00000",
					CALLSIGN, DESTID, *PATH?",":"", PATH,
					(long) ActiveConfig.Telemetry.Index++,
					(long) BatteryLifePercent,
					(long) ChargeAC,
					(long) GPSs,
					(long) Current,
					(long) dwSignalStrength,
					AC?'1':'0',
					Charging?'1':'0',
					GPSenabled?'1':'0')))
		{	if (TelemetryEnabled) QueueToTransmit(TELEMETRY_PACKET, Buffer, FALSE, ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet);
			AprsLogInternalPacket("Telemetry", hwnd, Buffer);
		} else TraceError(hwnd, "Telemetry Format Failed!\n");
		ActiveConfig.Telemetry.Index = ActiveConfig.Telemetry.Index % 1000;
		if (!ActiveConfig.Telemetry.Index) ActiveConfig.Telemetry.Index = 1;
	}
}

static void TransmitTelemetry(HWND hwnd, BYTE BatteryLifePercent, BOOL AC, BOOL Charging, BOOL GPSenabled, DWORD dwSignalStrength, DWORD Current)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	__int64 Now = llGetMsec();
static BYTE lastPercent;
static __int64 lastTime = 0;
static BOOL lastAC, lastCharging, lastGPS, lastTelemetryEnabled;
static DWORD lastSignalStrength;
static char Buffer[256];
#ifdef MONITOR_PHONE
#ifdef MONITOR_CURRENT	/* Non-compliant values */
static DWORD lastCurrent;
#define TELEMETRY_VERSION 4
static char *Params[] = { "PARM.Battery,Charging/AC,GPS+Sat,Current,Phone Signal,A/C,Charging,GPS,B4,B5,B6,B7,B8",	/* Channel names */
							"UNIT.Percent,Charge/On/Off,Sats/On/Off,mA,Percent,On,Yes,On,N/A,N/A,N/A,N/A,N/A",/* Units */
							"EQNS.0,1,0,0,1,0,0,1,0,0,1,-500,0,1,0",	/* (a*v^2 + b*v + c) 5 times! */
							"BITS.11111111,Battery State Tracking" };	/* Bit sense and project name */
#else
#define TELEMETRY_VERSION 3
static char *Params[] = { "PARM.Battery,Charging/AC,GPS+Sat,A4,Phone Signal,A/C,Charging,GPS,B4,B5,B6,B7,B8",	/* Channel names */
							"UNIT.Percent,Charge/On/Off,Sats/On/Off,N/A,Percent,On,Yes,On,N/A,N/A,N/A,N/A,N/A",/* Units */
							"EQNS.0,1,0,0,1,0,0,1,0,0,1,0,0,1,0",	/* (a*v^2 + b*v + c) 5 times! */
							"BITS.11111111,Battery State Tracking" };	/* Bit sense and project name */
#endif
#else
#define TELEMETRY_VERSION 2
static char *Params[] = { "PARM.Battery,Charging/AC,GPS+Sat,A4,A5,A/C,Charging,GPS,B4,B5,B6,B7,B8",	/* Channel names */
							"UNIT.Percent,Charge/On/Off,Sats/On/Off,N/A,N/A,On,Yes,On,N/A,N/A,N/A,N/A,N/A",/* Units */
							"EQNS.0,1,0,0,1,0,0,1,0,0,1,0,0,1,0",	/* (a*v^2 + b*v + c) 5 times! */
							"BITS.11111111,Battery State Tracking" };	/* Bit sense and project name */
#endif

	if (cInfo)
	{static __int64 firstTelemetry = 0;
		if (!firstTelemetry)
		{	firstTelemetry = Now;	/* Time from now */
		} else if (llMsecSince(firstTelemetry, Now) >= 1*60*1000	/* Wait at least this long */
		&& llMsecSince(lastTime, Now) > ActiveConfig.Telemetry.MinTime*1000
		&& (lastPercent != BatteryLifePercent
		|| lastAC != AC || lastCharging != Charging
		|| lastGPS != GPSenabled
		|| lastSignalStrength != dwSignalStrength
#ifdef MONITOR_CURRENT
		|| lastCurrent != Current
#endif
		|| (lastTelemetryEnabled != TelemetryEnabled && TelemetryEnabled)	/* Turned on */
		|| !lastTime
		|| llMsecSince(lastTime, Now) >= ActiveConfig.Telemetry.Interval*60*1000))
		{static __int64 lastDefCheck = 0;
			if (!lastDefCheck) lastDefCheck = Now;
			else if (llMsecSince(lastDefCheck, Now) >= 5*60*1000)	/* Wait 5 minutes after startup */
			{	SYSTEMTIME stNow;
				FILETIME ftNow, ftCheck;
				unsigned __int64 ullNow, Elapsed;

				lastDefCheck = Now;		/* And only recheck every 60 seconds */

				GetSystemTime(&stNow);

#ifdef UNDER_CE
				GetCurrentFT(&ftNow);
#else
				GetSystemTimeAsFileTime(&ftNow);
#endif
				ullNow = ((unsigned __int64) ftNow.dwHighDateTime)<<32 | ftNow.dwLowDateTime;

				SystemTimeToFileTime(&ActiveConfig.Telemetry.Defined, &ftCheck);

				Elapsed = ((unsigned __int64) ftCheck.dwHighDateTime)<<32 | ftCheck.dwLowDateTime;
				Elapsed = ullNow - Elapsed;	/* Delta time before now */
				Elapsed /= 10;	/* 1000 nanosec = microsec */
				Elapsed /= 1000;	/* 1000 microsec = millisec */
				Elapsed /= 1000;	/* 1000 millisec = seconds */

				if (Elapsed >= ((unsigned __int64)ActiveConfig.Telemetry.DefHours)*60L*60L
				|| ActiveConfig.Telemetry.Version != TELEMETRY_VERSION)
				{	int p;
					for (p=0; p<ARRAYSIZE(Params); p++)
					{	if (SUCCEEDED(StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s::%-9s:%s",
											CALLSIGN, DESTID, *PATH?",":"", PATH, CALLSIGN, Params[p])))
						{	if (TelemetryEnabled)
								QueueToTransmit(TELEMETRY_PACKET, Buffer, FALSE, ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet);
							AprsLogInternalPacket("Telemetry", hwnd, Buffer);
						} else TraceError(hwnd, "Telemetry Parameterization Format Failed!\n");
					}
					ActiveConfig.Telemetry.Defined = stNow;
					ActiveConfig.Telemetry.Version = TELEMETRY_VERSION;
				}
			}

			if (lastAC != AC || lastCharging != Charging || lastGPS != GPSenabled)
				if (lastTime && llMsecSince(lastTime,Now) >= 60*1000)
#ifdef MONITOR_CURRENT
					FormatSendTelemetry(hwnd, lastPercent, lastAC, lastCharging, lastGPS, lastSignalStrength, lastCurrent);
#else
					FormatSendTelemetry(hwnd, lastPercent, lastAC, lastCharging, lastGPS, lastSignalStrength, 0);
#endif

#ifdef MONITOR_CURRENT
			FormatSendTelemetry(hwnd, BatteryLifePercent, AC, Charging, GPSenabled, dwSignalStrength, Current);
			lastCurrent = Current;
#else
			FormatSendTelemetry(hwnd, BatteryLifePercent, AC, Charging, GPSenabled, dwSignalStrength, 0);
#endif

			lastPercent = BatteryLifePercent;
			lastAC = AC;
			lastCharging = Charging;
			lastGPS = GPSenabled;
			lastSignalStrength = dwSignalStrength;
			lastTelemetryEnabled = TelemetryEnabled;
			lastTime = Now;
		}
	}
}

static void TriggerTelemetry(HWND hwnd)
{	__int64 msNow = llGetMsec();
static __int64 msLast=0, msMax=0;

//#ifdef UNDER_CE
//#ifdef CE50
//	memset(&sps,0,sizeof(sps));
//#else
//	if (GetSystemPowerStatusEx(&sps, TRUE))
//#endif
//#else
//	if (GetSystemPowerStatus(&sps))
//#endif
#ifdef UNDER_CE
	if (GetSystemPowerStatusEx2(&sps2, sizeof(sps2), FALSE))
	{
msNow = DebugTimer("TriggerTelemetry","GetSystemPowerStatusEx2",msNow,&msMax,&msLast,hwnd);
		InvalidatePower(TRUE);
#ifdef MONITOR_CURRENT
		TransmitTelemetry(hwnd, sps2.BatteryLifePercent==255?100:sps2.BatteryLifePercent, sps2.ACLineStatus==AC_LINE_ONLINE, sps2.BatteryFlag&BATTERY_FLAG_CHARGING, GPSEnabled, dwOldSignalStrength, sps2.BatteryCurrent?sps2.BatteryCurrent:sps2.BatteryAverageCurrent);
#else
		TransmitTelemetry(hwnd, sps2.BatteryLifePercent==255?100:sps2.BatteryLifePercent, sps2.ACLineStatus==AC_LINE_ONLINE, sps2.BatteryFlag&BATTERY_FLAG_CHARGING, GPSEnabled, dwOldSignalStrength, 0);
#endif
		msNow = DebugTimer("TriggerTelemetry","GetSystemPowerStatus",msNow,&msMax,&msLast,hwnd);
	}
//else msNow = DebugTimer("TriggerTelemetry","Failed",msNow,&msMax,&msLast,hwnd);
#else
	if (GetSystemPowerStatus(&sps))
	{
msNow = DebugTimer("TriggerTelemetry","GetSystemPowerStatusEx2",msNow,&msMax,&msLast,hwnd);
		InvalidatePower(TRUE);
		TransmitTelemetry(hwnd, sps2.BatteryLifePercent==255?100:sps2.BatteryLifePercent, sps2.ACLineStatus==AC_LINE_ONLINE, sps2.BatteryFlag&BATTERY_FLAG_CHARGING, GPSEnabled, dwOldSignalStrength, 0);
msNow = DebugTimer("TriggerTelemetry","GetSystemPowerStatus",msNow,&msMax,&msLast,hwnd);
	}
//else msNow = DebugTimer("TriggerTelemetry","Failed",msNow,&msMax,&msLast,hwnd);
#endif
}

static void CalculateGenius(GENIUS_INFO_S *Genius, GPS_POSITION *newPosition)
{	//BOOL hadPos = (gpsPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL newPos = (newPosition->dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL lastPos = (Genius->LastAPRSPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL newSpeed = (newPosition->dwValidFields & GPS_VALID_SPEED) == GPS_VALID_SPEED;
	BOOL lastSpeed = (Genius->LastAPRSPosition.dwValidFields & GPS_VALID_SPEED) == GPS_VALID_SPEED;
	BOOL newHeading = (newPosition->dwValidFields & GPS_VALID_HEADING) == GPS_VALID_HEADING;
	BOOL lastHeading = (Genius->LastAPRSPosition.dwValidFields & GPS_VALID_HEADING) == GPS_VALID_HEADING;
	BOOL newTime = (newPosition->dwValidFields & GPS_VALID_UTC_TIME) == GPS_VALID_UTC_TIME;
	BOOL lastTime = (Genius->LastAPRSPosition.dwValidFields & GPS_VALID_UTC_TIME) == GPS_VALID_UTC_TIME;
	BOOL newAlt = (newPosition->dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL) == GPS_VALID_ALTITUDE_WRT_SEA_LEVEL;

	Genius->coordinatesMoved = FALSE;
	Genius->deltaDistance = Genius->deltaBearing = 0;
	if (newPos & lastPos)
	{	Genius->coordinatesMoved = !AreCoordinatesEquivalent(Genius->LastAPRSPosition.dblLatitude, Genius->LastAPRSPosition.dblLongitude,
														newPosition->dblLatitude, newPosition->dblLongitude,
														ActiveConfig.Beacon.Precision);
		AprsHaversinePos(&Genius->LastAPRSPosition, newPosition, &Genius->deltaDistance, &Genius->deltaBearing);
	}

	if (newTime & lastTime)
	{	FILETIME ft1, ft2;
		ULARGE_INTEGER tmLast, tmNow, MilliSecond;
		MilliSecond.HighPart = 0; MilliSecond.LowPart = 10000;
		SystemTimeToFileTime(&Genius->LastAPRSPosition.stUTCTime, &ft1);
		SystemTimeToFileTime(&newPosition->stUTCTime, &ft2);
		tmLast.LowPart = ft1.dwLowDateTime; tmLast.HighPart = ft1.dwHighDateTime;
		tmNow.LowPart = ft2.dwLowDateTime; tmNow.HighPart = ft2.dwHighDateTime;
		if (tmNow.QuadPart > tmLast.QuadPart)
		{	ULARGE_INTEGER deltaT;
			deltaT.QuadPart = (tmNow.QuadPart - tmLast.QuadPart) / MilliSecond.QuadPart;
			if (lastSpeed && Genius->LastAPRSPosition.flSpeed > MOVING_SPEED && lastHeading)
			{	Genius->forecastDistance = ((double)(__int64)deltaT.QuadPart)*(Genius->LastAPRSPosition.flSpeed*MilePerNM)/60.0/60.0/1000.0;
				AprsProjectWaypoint(&Genius->LastAPRSPosition, Genius->forecastDistance, Genius->LastAPRSPosition.flHeading, &Genius->ProjectedPosition);
				AprsHaversinePos(newPosition, &Genius->ProjectedPosition, &Genius->projDistance, &Genius->projBearing);
			} else Genius->forecastDistance = Genius->projDistance = Genius->projBearing = 0.0;
		}
	} else Genius->forecastDistance = Genius->projDistance = Genius->projBearing = 0.0;

	if (newHeading & lastHeading)
	{	if (newSpeed && newPosition->flSpeed	/* Need to be moving to trust heading */
		&& lastSpeed && Genius->LastAPRSPosition.flSpeed)	/* Need to have been moving to trust heading */
		{	Genius->deltaHeading = fabs(newPosition->flHeading - Genius->LastAPRSPosition.flHeading);
			if (Genius->deltaHeading > 180) Genius->deltaHeading = 360-Genius->deltaHeading;
		} else Genius->deltaHeading = -1;
	} else Genius->deltaHeading = -1;
}

static void SetMyPosition(HWND hwnd, CLIENT_INFO_S *Info, GPS_POSITION *newPosition)
{	GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
	BOOL hadPos = (gpsPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL newPos = (newPosition->dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL lastPos = (Genius->LastAPRSPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL newSpeed = (newPosition->dwValidFields & GPS_VALID_SPEED) == GPS_VALID_SPEED;
	BOOL lastSpeed = (Genius->LastAPRSPosition.dwValidFields & GPS_VALID_SPEED) == GPS_VALID_SPEED;
	BOOL newHeading = (newPosition->dwValidFields & GPS_VALID_HEADING) == GPS_VALID_HEADING;
	BOOL lastHeading = (Genius->LastAPRSPosition.dwValidFields & GPS_VALID_HEADING) == GPS_VALID_HEADING;
	BOOL newTime = (newPosition->dwValidFields & GPS_VALID_UTC_TIME) == GPS_VALID_UTC_TIME;
	BOOL lastTime = (newPosition->dwValidFields & GPS_VALID_UTC_TIME) == GPS_VALID_UTC_TIME;
	BOOL newAlt = (newPosition->dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL) == GPS_VALID_ALTITUDE_WRT_SEA_LEVEL;

#ifdef PIXEL_MOTION
	double moved, heading;
	AprsHaversinePos(&Info->gpsPosition, newPosition, &moved, &heading);
#endif

//#define SHOW_DELTAS
#ifdef SHOW_DELTAS
//	if (newPos && hadPos
//	&& (Info->gpsPosition.dblLatitude != newPosition->dblLatitude
//			|| Info->gpsPosition.dblLongitude != newPosition->dblLongitude))
	{	double distance, bearing;
		AprsHaversinePos(&Info->gpsPosition, newPosition, &distance, &bearing);
		TraceActivity(hwnd, "GPS %s 0x%lX != 0x%lX or %s %.8lf != %.8lf or %s %.8lf != %.8lf (Moved %ld feet @ %ld degrees) (%ld Inches)\n",
										Info->gpsPosition.dwValidFields!=newPosition->dwValidFields?"CHANGED":"",
										(long) Info->gpsPosition.dwValidFields, (long) newPosition->dwValidFields,
										Info->gpsPosition.dblLatitude!=newPosition->dblLatitude?"CHANGED":"",
										(double) Info->gpsPosition.dblLatitude, (double) newPosition->dblLatitude,
										Info->gpsPosition.dblLongitude!=newPosition->dblLongitude?"CHANGED":"",
										(double) Info->gpsPosition.dblLongitude, (double) newPosition->dblLongitude,
										(long) (distance*5280.0), (long) bearing, (long) (distance*5280.0*12.0));
	}
#endif

	gpsPosition = *newPosition;
static double LastSpeed = 99;
static BOOL LastValid = TRUE;
	if (newSpeed)
	{	double dSpeed = newPosition->flSpeed * MilePerNM + 0.5;
		if (ActiveConfig.View.Metric.Distance)
			dSpeed *= (double) KmPerMile;
		if (dSpeed > MaxSpeed && dSpeed <= 999)	/* Let's be reasonable! */
		{	HDC hdc = GetDC(hwnd);
			TCHAR TempID[sizeof(MaxSpeedText)+1];
			RECT rc;
//TraceLogThread("Speed", FALSE, "New MaxSpeed(%.2lf) Old(%.2lf)\n", dSpeed, MaxSpeed);
			GetWindowRect(hwnd, &rc);
			StringCbPrintf(TempID, sizeof(TempID), TEXT("%ld"), (long) dSpeed);
			if (DrawText(hdc, TempID, -1, &rc, DT_NOPREFIX | DT_CALCRECT))
			{	int speedwidth = rc.right - rc.left + 2;
				if (speedwidth > MaxSpeedWidth)
				{	TraceError(hwnd, "New MaxSpeed(%S)=%ld Was(%S)=%ld\n",
										TempID, (long) speedwidth,
										MaxSpeedText, (long) MaxSpeedWidth);
						StringCbPrintf(MaxSpeedText, sizeof(MaxSpeedText), TEXT("%ld"), (long) dSpeed);
						MaxSpeed = dSpeed;
						MaxSpeedWidth = speedwidth;
						ShuffleScreenElements(hwnd);
				}
			} else TraceError(hwnd, "DrawText(%S) Failed Last Error=%ld\n", TempID, (long) GetLastError());
			ReleaseDC(hwnd, hdc);
		}
//else if (dSpeed != LastSpeed) TraceLogThread("Speed", FALSE, "Speed(%.2lf) Last(%.2lf) MAX(%.2lf)\n", dSpeed, LastSpeed, MaxSpeed);
		LastValid = TRUE;
		LastSpeed = dSpeed;
	}
	else
	{	//if (LastValid) TraceLogThread("Speed", FALSE, "No Valid(0x%lX) Speed(0x%lX) Last(%.2lf)\n", newPosition->dwValidFields, GPS_VALID_SPEED, LastSpeed);
		LastSpeed = -1;
		LastValid = FALSE;
	}

	if (newSpeed && newHeading)
	{	MyStation->course = (int) (newPosition->flHeading+0.5);
		MyStation->speed = (int) (newPosition->flSpeed+0.5);
		MyStation->CSEParsed = TRUE;
	} else MyStation->CSEParsed = FALSE;	/* Clear if none in packet */

	if (newAlt)
	{	MyStation->alt = newPosition->flAltitudeWRTSeaLevel;
		MyStation->hadAltitude = TRUE;
	}

	if (newPos)
	{	if (MyStation)
		{	MyStation->lastMsec = llGetMsec();
//			MyStation->lat = Info->gpsPosition.dblLatitude;
//			MyStation->lon = Info->gpsPosition.dblLongitude;
			MyStation->pCoord = GetCoordIndex(gpsPosition.dblLatitude, gpsPosition.dblLongitude, "MyStation", MyStation->Station, MyStation->pCoord);
//			MyStation->tileX = long2tilex(MyStation->lon, MAX_OSM_ZOOM);
//			MyStation->tileY = lat2tiley(MyStation->lat, MAX_OSM_ZOOM);
//			MyStation->tileZ = MAX_OSM_ZOOM;
			if (MyStation->isFriend) SetFriendCoordinates(MyStation->Station, MyStation->pCoord->lat, MyStation->pCoord->lon);
		}
		LastGoodPosition = gpsPosition;
		for (int tr=0; tr<MAX_TRACKERS; tr++)
		if (cInfos[tr].Active)
		if (cInfos[tr].CenterStation == MyStation
		&& cInfos[tr].CenterTracking)
		if (cInfos[tr].Dragging
		|| cInfos[tr].msDragComplete > llGetMsec()-5000)	/* 5 second drag freeze */
		{	/* Need a timer or something? */
		} else
		{	cInfos[tr].LastCenterPosition = LastGoodPosition;
//			InvalidateStationPoints(tr,"SetMyPosition",TRUE);
			InvalidateCenter(hwndTracker[tr], FALSE);
//		} else if (!tr)
//		{	InvalidateStationPoints(tr,"SetMyPosition",TRUE);
//			InvalidateCenter(hwnd, FALSE);
		}
		UpdateStationVisibility(MyStation, "Moved", TRUE, FALSE);	/* ME Moved */
		SoundGps(hwnd, TRUE);
	} else
	{	SoundGps(hwnd, FALSE);
	}

	if (newAlt)
		if (MyStation)
			MyStation->alt = gpsPosition.flAltitudeWRTSeaLevel;

	if (gpsPosition.dwValidFields & GPS_VALID_SATELLITE_COUNT)
	{	GPSSatInUse = gpsPosition.dwSatelliteCount;
		if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_USED_PRNS)
			qsort(gpsPosition.rgdwSatellitesUsedPRNs, gpsPosition.dwSatelliteCount,
					sizeof(gpsPosition.rgdwSatellitesUsedPRNs[0]), CompareDWords);
	} else GPSSatInUse = 0;
	if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW)
	{	if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_PRNS)
		{	DWORD s;
			for (s=0; s<gpsPosition.dwSatellitesInView; s++)
				SatellitesInViewPRNs[s] = gpsPosition.rgdwSatellitesInViewPRNs[s];
			qsort(SatellitesInViewPRNs, gpsPosition.dwSatellitesInView,
					sizeof(SatellitesInViewPRNs[0]), CompareDWords);
		}
	}

	CalculateGenius(Genius, newPosition);

	if (newPos && newTime)
		TransmitAPRS(hwnd, Info, Genius, &gpsPosition, TRUE);
	else if (GPSTransitionTransmit && !HadGPSFix	/* Need to transmit a LostFix! */
	&& (LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
		TransmitAPRS(hwnd, Info, Genius, &LastGoodPosition, FALSE);

#ifdef PIXEL_MOTION
	RECT rc = rcCircle(0);
	int width = rc.right-rc.left;
	int height = rc.bottom-rc.top;
	if (!Info->Scale || !width || !height
	|| moved > Info->Scale/min(width,height)/2)	/* Moved more than 1/2 pixel? */
	{
	TraceActivity(hwnd, "Moved %lf or %.2lf pixels\n", (double) moved, (double) moved/(Info->Scale/min(width,height)));
#endif
#ifdef PIXEL_MOTION
	} else TraceActivity(hwnd, "Didn't MOVE %lf/%lf or %.4lf pixels\n", (double) moved, (double) Info->Scale, (double) moved/(Info->Scale/min(width,height)));
#endif
	InvalidateGPS(TRUE);
}

static BOOL TransmitCompanions(void)
{	BOOL Xmitted = FALSE;
	GPS_POSITION *Pos = &gpsPosition;
	BOOL hasPos = (Pos->dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
	BOOL hasTime = (Pos->dwValidFields & GPS_VALID_UTC_TIME) == GPS_VALID_UTC_TIME;

	if (hasPos && hasTime && ActiveConfig.CompanionsEnabled && ActiveConfig.Companions.Count)
	{	__int64 Now = llGetMsec();
	static char Why[80];
		for (unsigned long c=0; c<ActiveConfig.Companions.Count; c++)
		if (ActiveConfig.Companions.Companion[c].Enabled
		&& ActiveConfig.Companions.Companion[c].Posit)
		{	COMPANION_INFO_S *Obj = &ActiveConfig.Companions.Companion[c];
			GENIUS_INFO_S *Genius = &Obj->Genius;

			if (Genius->MinTime < 10) Genius->MinTime = 10;
			if (Genius->MaxTime < 1) Genius->MaxTime = 1;

			CalculateGenius(Genius, Pos);	// Update the genius fields for the (hopefully new) position

			double Pressure = CalcTransmitPressure(NULL, Genius, Pos, Now, Why);
			TraceLogThread("Companions", FALSE, "Companion(%s) %s %.0lf%%\n", Obj->Name, Why, (double) Pressure);
			if (Pressure >= 100.0)
			{	if (Genius->LastAPRSUpdate+MINIMUM_APRS_DELTA <= Now)	// It is time
				{	size_t Remaining = 256 + strlen(Obj->Comment);
					char *DAO=NULL, *Buffer = (char*)malloc(Remaining);
					TCHAR *LatLon = APRSLatLon(Pos->dblLatitude, Pos->dblLongitude, Obj->Symbol.Table, Obj->Symbol.Symbol, 0, ActiveConfig.Beacon.Precision, &DAO);
					char *cLatLon, *Next = Buffer;
					BOOL DoComment = ActiveConfig.Beacon.Comment
						&& Obj->Comment[0]
						&& (llMsecSince(Genius->msLastComment,Now)/1000
											>= ActiveConfig.CommentInterval*60);

					if (Obj->Object)
					{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								"%s>%s%s%s:;%-9.9s*",	/* Object format */
								CALLSIGN, DESTID,
								*Obj->RFPath?",":"", Obj->RFPath,
								Obj->Name);

						/* Objects always have time */
						if (ActiveConfig.Beacon.HHMMSS)
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%02ld%02ld%02ldh",
									(long) Pos->stUTCTime.wHour, 
									(long) Pos->stUTCTime.wMinute, 
									(long) Pos->stUTCTime.wSecond);
						else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%02ld%02ld%02ldz",
									(long) Pos->stUTCTime.wDay, 
									(long) Pos->stUTCTime.wHour, 
									(long) Pos->stUTCTime.wMinute);
					} else
					{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s>%s%s%s:", Obj->Name, DESTID, *Obj->RFPath?",":"", Obj->RFPath);
						if (ActiveConfig.Beacon.Timestamp)
						{	if (ActiveConfig.Beacon.HHMMSS)
								StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%c%02ld%02ld%02ldh",
										Obj->Messaging?POS_TIMESTAMPED_WITH_MESSAGING:POS_TIMESTAMPED_NO_MESSAGING,
										(long) Pos->stUTCTime.wHour, 
										(long) Pos->stUTCTime.wMinute, 
										(long) Pos->stUTCTime.wSecond);
							else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%c%02ld%02ld%02ldz",
										Obj->Messaging?POS_TIMESTAMPED_WITH_MESSAGING:POS_TIMESTAMPED_NO_MESSAGING,
										(long) Pos->stUTCTime.wDay, 
										(long) Pos->stUTCTime.wHour, 
										(long) Pos->stUTCTime.wMinute);
						} else StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%c", Obj->Messaging?POS_NO_TIME_WITH_MESSAGING:POS_NO_TIME_NO_MESSAGING);
					}

					/* Now the common part of the packet */
					if (ActiveConfig.Beacon.Compressed
					&& (cLatLon = APRSCompressed(Pos, hasPos, Obj->Symbol.Table, Obj->Symbol.Symbol,
												ActiveConfig.Beacon.CourseSpeed,
												ActiveConfig.Beacon.Altitude)) != NULL)
					{	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s", cLatLon);
						if (DAO) free(DAO);
						DAO = NULL;	/* Don't put out the extra digits! */
						free(cLatLon);
					} else
					{
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%S", LatLon);

						if (ActiveConfig.Beacon.CourseSpeed)
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%S", APRSHeadSpeed((Pos->dwValidFields & (GPS_VALID_HEADING | GPS_VALID_SPEED))
																						== (GPS_VALID_HEADING | GPS_VALID_SPEED),
																Pos->flHeading, Pos->flSpeed));

						if (ActiveConfig.Beacon.Altitude)
						{	char cNext;
							if (ActiveConfig.Beacon.Why) cNext = *Why;
							else if (DoComment) cNext = *Obj->Comment;
							//else if (ActiveConfig.Beacon.MicETag[0]) cNext = ActiveConfig.Beacon.MicETag[0];
							else if (ActiveConfig.Beacon.Precision > 0) cNext = DAO?*DAO:'\0';
							else cNext = '\0';
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining,
												STRSAFE_IGNORE_NULLS,
												"%S",
												APRSAltitude(Pos->dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL,
															Pos->flAltitudeWRTSeaLevel, cNext));
						}
					}

					if (ActiveConfig.Beacon.Why)
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"(%s)", Why);

		//			if (ActiveConfig.Beacon.MicETag[0])
		//				StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
		//							"%s", ActiveConfig.Beacon.MicETag);
					if (DoComment)
					{	Genius->msLastComment = Now;
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%s", Obj->Comment);
						if (!Obj->Object)	/* Objects have me as the owner */
							StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										"%s%s", *Obj->Comment?" de ":"", CALLSIGN);
					}

					if (ActiveConfig.Beacon.Precision > 0 && DAO && *DAO)
						StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									"%s", DAO);

					TraceLogThread("Companions", TRUE, "Companion(%s) %s %.0lf%% Transmit:%s\n",
									Obj->Name, Why, (double) Pressure, Buffer);

					if (Obj->ISEnabled || Obj->RFEnabled)
					{	if (!QueueToTransmit(Obj->Object?OBJECT_PACKET:BEACON_PACKET,
												Buffer, !Obj->ISEnabled, !Obj->RFEnabled))
						{	TraceLogThread("Transmit", TRUE, "QueueCompanionToTransmit FAILED %s (%.3lfmi @ %ld = %.2lf)(%s)\n",
										Buffer, (double)Genius->deltaDistance, (long) Genius->deltaBearing,
										(double) Pos->flSpeed * MilePerNM, Why);
						}

					}
					GetSystemTime(&Genius->stLastAPRS);
					Genius->LastAPRSUpdate = Now;
					Genius->LastAPRSPosition = *Pos;
					Xmitted = TRUE;
					AprsLogInternalPacket("TransmitCompanion", NULL, Buffer, TRUE);
					free(LatLon);
					if (DAO) free(DAO);
				}
			}
		}
	}
	return Xmitted;
}

BOOL OnGpsReaderTimer(HWND hwnd)
{	CLIENT_INFO_S *Info = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (Info)
	{	GPS_POSITION newPosition;
		newPosition.dwVersion = GPS_VERSION_1;
		newPosition.dwSize = sizeof(newPosition);
		if (GPSEnabled)
		{
#ifdef UNDER_CE
			DWORD Status = ~ERROR_SUCCESS;
			if (ActiveConfig.GPSPort[0])
				Status = MyGPSGetPosition(NULL, &newPosition, 15000, 0);
#ifdef USING_GPSAPI
			else Status = GPSGetPosition(hGPS, &newPosition, 15000, 0);
#else
			else Status = MyGPSGetPosition(NULL, &newPosition, 15000, 0);
#endif
			if (Status != ERROR_SUCCESS)
#else
			if (GPSGetPosition(hGPS, &newPosition, 15000, 0) != ERROR_SUCCESS)
#endif
			{	SoundGps(hwnd, FALSE);
				TraceActivity(hwnd, "GPSGetPosition Failed with %ld\n", (long) GetLastError());
			} else
			{	SetMyPosition(hwnd, Info, &newPosition);
			}
		}
		else	/* GPS Is disabled */
		{	InvalidateTime(FALSE);
			if (!BeaconSuspended	/* Holding for transmit? */
			&& (LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
			{	GetSystemTime(&LastGoodPosition.stUTCTime);
				LastGoodPosition.dwValidFields = GPS_VALID_UTC_TIME | GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE;	/* Only these */
				TransmitAPRS(hwnd, Info, &ActiveConfig.MyGenius, &LastGoodPosition, FALSE);
				gpsPosition = LastGoodPosition;
			}
		}

		if (PendingMsgCount)
		{	int m;
			__int64 msNow = llGetMsec();
			for (m=0; m<PendingMsgCount; m++)
			if (!PendingMsgs[m].Subordinated)
			{	if (PendingMsgs[m].Ack	/* There shouldn't be any here that don't need ack, but... */
				&& PendingMsgs[m].Retries < MAX_MSG_RETRIES	/* See definition for total time required */
				&& msNow > PendingMsgs[m].msNextSend)
				{	RetryPendingMessage(m);
				}
			}
		}

		if (MessageCount && PendingAutoReply)
		{	if (ActiveConfig.Messaging.AutoAnswer.Delay != LONG_MAX	/* And configured delay */
			&& IsSystemTimeout(&stLastActivity, ActiveConfig.Messaging.AutoAnswer.Delay*60)) /* and time */
			{	BOOL NonePending = TRUE;
				SYSTEMTIME lclNow;
				GetLocalTime(&lclNow);
				for (int m=0; m<MessageCount; m++)
				{	if (Messages[m].PendingAutoReply)
					{	NonePending = FALSE;
						if (DeltaSeconds(&Messages[m].stLocal, &lclNow) >= 30) /* Wait 30 seconds for multi-line to arrive */
						{	if (SendAutoReply(hwnd, Messages[m].From))
							{	Messages[m].PendingAutoReply = FALSE;
TraceLog("AutoAnswer", FALSE, hwnd, "Clearing after AA to %s(%s)\n", Messages[m].From, Messages[m].Text);
								for (int n=0; n<MessageCount; n++)
								{	if (Messages[n].PendingAutoReply
									&& !_stricmp(Messages[m].From, Messages[n].From))
									{	Messages[n].PendingAutoReply = FALSE;
									}
								}
							} else
							{	Messages[m].PendingAutoReply = FALSE;
TraceLog("AutoAnswer", FALSE, hwnd, "Aborting AA (too soon?) to %s(%s)\n", Messages[m].From, Messages[m].Text);
							}
						} else TraceLog("AutoAnswer", FALSE, hwnd, "Not time(%ld/30) for AutoAnswer to %s(%s)\n", (long) DeltaSeconds(&Messages[m].stLocal, &lclNow), Messages[m].From, Messages[m].Text);
					}
				}
if (NonePending) TraceLog("AutoAnswer", FALSE, hwnd, "NonePending!  Stopping Poller\n");
				if (NonePending) PendingAutoReply = FALSE;	/* No more need to check */
			}
			InvalidateMessage(!PendingAutoReply);
		}
	}
	return TRUE;
}
#ifdef DEBUGGING_STUFF
BOOL OnGpsReaderTimer(HWND hwnd)
{	GPS_DEVICE gpsDevice;
static FILETIME lastData = {0};
static GPS_POSITION lastPos = {0};

		gpsDevice.dwVersion = GPS_VERSION_1;
		gpsDevice.dwSize = sizeof(gpsDevice);
		if (GPSGetDeviceState(&gpsDevice) == ERROR_SUCCESS)
		{	if(gpsDevice.ftLastDataReceived.dwLowDateTime != lastData.dwLowDateTime
			|| gpsDevice.ftLastDataReceived.dwHighDateTime != lastData.dwHighDateTime)
			{	FILETIME localFileTime;
				FileTimeToLocalFileTime(&gpsDevice.ftLastDataReceived, &localFileTime);
				SYSTEMTIME st;
				FileTimeToSystemTime(&localFileTime, &st);
				TraceActivityBegin(hwndMain, "GPSdev4 dwServiceState: 0x%lX dwDeviceState: 0x%lX\n",
							(long) gpsDevice.dwServiceState, (long) gpsDevice.dwDeviceState);
				TraceActivity(hwndMain, "GPSdev4 LastDataReceived: %04ld-%02ld-%02ldT%02ld:%02ld:%02ld ",
								(long) st.wYear, (long) st.wMonth, (long) st.wDay, 
								(long) st.wHour, (long) st.wMinute, (long) st.wSecond);
				TraceActivityEnd(hwndMain, "GPSdev4 DriverPrefix: %S MultiplexPrefix: %S FriendlyName: %S\n",
							gpsDevice.szGPSDriverPrefix, gpsDevice.szGPSMultiplexPrefix, gpsDevice.szGPSFriendlyName);
				lastData = gpsDevice.ftLastDataReceived;
			}
		} else
		{	TraceActivity(hwndMain, "GPSGetDeviceState Failed With %ld\n", (long) GetLastError());
		}

		
	{	GPS_POSITION newPosition;
		newPosition.dwVersion = GPS_VERSION_1;
		newPosition.dwSize = sizeof(newPosition);
		if (GPSGetPosition(hGPS, &newPosition, 10000, 0) == ERROR_SUCCESS)
		{
			if (lastPos.dblLatitude != newPosition.dblLatitude || lastPos.dblLongitude != newPosition.dblLongitude)
			{	TraceActivityBegin(hwndMain, "GPS4 Valid: 0x%lX Flags: 0x%lX\n",
								(long) newPosition.dwValidFields, (long) newPosition.dwFlags);
				TraceActivity(hwndMain, "GPS4 stUTCTime: %04ld-%02ld-%02ldT%02ld:%02ld:%02ld ",
								(long) newPosition.stUTCTime.wYear, (long) newPosition.stUTCTime.wMonth, (long) newPosition.stUTCTime.wDay, 
								(long) newPosition.stUTCTime.wHour, (long) newPosition.stUTCTime.wMinute, (long) newPosition.stUTCTime.wSecond);
				TraceActivity(hwndMain, "GPS4 Lat: %.5lf Lon: %.5lf Speed: %.2lf Heading: %.2lf Variation: %.5lf\n",
								(double) newPosition.dblLatitude, (double) newPosition.dblLongitude,
								(double) newPosition.flSpeed, (double) newPosition.flHeading,
								(double) newPosition.dblMagneticVariation);
				TraceActivity(hwndMain, "GPS4 WRTSeaLevel: %.2lf WRTEllipsoid: %.3lf\n",
								(double) newPosition.flAltitudeWRTSeaLevel, (double) newPosition.flAltitudeWRTEllipsoid);
				TraceActivity(hwndMain, "GPS4 FixQual: 0x%lX FixType: 0x%lX Selection: 0x%lX\n",
								(long) newPosition.FixQuality, (long) newPosition.FixType, (long) newPosition.SelectionType);
				TraceActivity(hwndMain, "GPS4 PDOP: %.2lf HDOP: %.3lf VDOP: %.3lf\n",
								(double) newPosition.flPositionDilutionOfPrecision,
								(double) newPosition.flHorizontalDilutionOfPrecision,
								(double) newPosition.flVerticalDilutionOfPrecision);
				TraceActivityEnd(hwndMain, "GPS4 SatCount: %ld SatInView: %ld\n",
								(long) newPosition.dwSatelliteCount, (long) newPosition.dwSatellitesInView);
				{	double distance, bearing;
					AprsHaversinePos(&lastPos, &newPosition, &distance, &bearing);
					TraceActivity(hwnd, "GPS %s 0x%lX != 0x%lX or %s %.8lf != %.8lf or %s %.8lf != %.8lf (Moved %ld feet @ %ld degrees) (%ld Inches)\n",
													lastPos.dwValidFields!=newPosition.dwValidFields?"CHANGED":"",
													(long) lastPos.dwValidFields, (long) newPosition.dwValidFields,
													lastPos.dblLatitude!=newPosition.dblLatitude?"CHANGED":"",
													(double) lastPos.dblLatitude, (double) newPosition.dblLatitude,
													lastPos.dblLongitude!=newPosition.dblLongitude?"CHANGED":"",
													(double) lastPos.dblLongitude, (double) newPosition.dblLongitude,
													(long) (distance*5280.0), (long) bearing, (long) (distance*5280.0*12.0));
				}
				lastPos = newPosition;
			} else TraceActivity(hwndMain, "GPS4 lat/long didn't change\n");
		} else
		{	TraceActivity(hwndMain, "GPSGetPosition Failed With %ld\n", (long) GetLastError());
		}
	}
		
return TRUE;
}
#endif

BOOL OnSharedTimer(HWND hwnd, WORD idTimer)
{
	switch (idTimer)
	{
	case INVALID_TIMER:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo) ActualInvalidateRects(cInfo->Index, FALSE);
		break;
	}
	case CROSSHAIR_TIMER:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo)
		{	cInfo->CrossHairs = FALSE;
			InvalidateCircle(hwnd, TRUE, TRUE);
		}
		KillTimer(hwnd, CROSSHAIR_TIMER);
		break;
	}
	case DRIVE_TIMER:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo && cInfo->DriveCount)
		{	int ItemsQueued = OSMGetQueueStats(NULL, NULL);
			if (!ItemsQueued && --cInfo->DriveDelay <= 0)	/* Time to move? */
			{	int i = cInfo->DrivePoint;
				if (cInfo->LastCenterPosition.dblLatitude == cInfo->DrivePoints[i].lat
				&& cInfo->LastCenterPosition.dblLongitude == cInfo->DrivePoints[i].lon)
				{	i = ++cInfo->DrivePoint;	/* Next point */
					TraceLog("Driver", TRUE, hwnd, "Moving To [%ld/%ld]\n",
							(long) cInfo->DrivePoint, 
							(long) cInfo->DriveCount);
				}
				if (cInfo->DrivePoint >= cInfo->DriveCount)
				{	__int64 Elapsed = SecondsSince(&cInfo->stDriveStart);
					long EndTilesFetched;
					char Temp[32];
				static TCHAR Buffer[256];

					FormatDeltaTime(Elapsed, Temp, sizeof(Temp));
					OSMGetTileServerTotals(NULL, NULL, NULL, NULL,
											&EndTilesFetched, 
											NULL, NULL, NULL);
					EndTilesFetched -= cInfo->StartTilesFetched;
					TraceLog("Driver", TRUE, hwnd, "Done Driving %ld points, %ld Tiles Fetched in %s across %.2lf Miles\n",
							cInfo->DriveCount,
							EndTilesFetched, Temp, cInfo->DistanceDriven);
					cInfo->Driving = FALSE;
					KillTimer(hwnd, DRIVE_TIMER);

					StringCbPrintf(Buffer, sizeof(Buffer),
						TEXT("Done Driving %ld Points\nDrove: %.1lfmi in %S\nFetched: %ld Tiles\n"),
						cInfo->DriveCount, 
						cInfo->DistanceDriven, Temp,
						EndTilesFetched);
					MessageBox(hwnd, Buffer, TEXT("Drive Complete"), MB_ICONINFORMATION | MB_OK); 
					if (!cInfo->Index)	/* Main window */
					{	Odometer = 0;
						memset(&MyDestination, 0, sizeof(MyDestination));
						ShuffleScreenElements(hwnd);
					}
				} else
				{	double Lat = cInfo->DrivePoints[i].lat;
					double Lon = cInfo->DrivePoints[i].lon;
					double range, bearing;

					MyDestination.lat = Lat;
					MyDestination.lon = Lon;
					InvalidateDestination(TRUE);

					AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
									cInfo->LastCenterPosition.dblLongitude,
									Lat, Lon, &range, &bearing);
					if (range > cInfo->Scale)	/* Too far, move a bit */
					{	TraceLog("Driver", TRUE, hwnd, "[%ld/%ld] %.2lf > %.2lf, Advancing %ld Degrees\n",
							(long) cInfo->DrivePoint,
							(long) cInfo->DriveCount,
							range, cInfo->Scale, (long) bearing);
						AprsProjectLatLon(cInfo->LastCenterPosition.dblLatitude,
									cInfo->LastCenterPosition.dblLongitude,
									cInfo->Scale, bearing, &Lat, &Lon);
						cInfo->DistanceDriven += cInfo->Scale;
						if (!cInfo->Index) Odometer += cInfo->Scale;
						cInfo->DriveDelay = 16;	/* Maximum delay before moving */
					} else
					{	TraceLog("Driver", TRUE, hwnd, "[%ld/%ld] %.2lf < %.2lf, Arriving\n",
							(long) cInfo->DrivePoint,
							(long) cInfo->DriveCount,
							range, cInfo->Scale);
						cInfo->DistanceDriven += range;
						if (!cInfo->Index) Odometer += range;
						cInfo->DriveDelay = (int) (16*(range / cInfo->Scale));	/* Scale the delay */
					}
					if (!cInfo->Index) InvalidateOdometer(TRUE);
					SetCenterLatLon(hwnd, Lat, Lon);
				}
			} else
			{	if (ItemsQueued != cInfo->LastQueued)
					TraceLog("Driver", TRUE, hwnd, "[%ld/%ld] %ld Items Still Queued\n",
													(long) cInfo->DrivePoint,
													(long) cInfo->DriveCount,
													(long) ItemsQueued);
			}
			cInfo->LastQueued = ItemsQueued;
		} else
		{	TraceLog("Driver", TRUE, hwnd, "Driver Timer Running without Points!\n");
			KillTimer(hwnd, DRIVE_TIMER);
		}
		break;
	}
	}
	return FALSE;
}


BOOL OnMainWindowTimer(HWND hwnd, WORD idTimer)
{
	switch (idTimer)
	{
	case TCP_TIMER:
#ifdef TRACE_MESSAGES
if (StopTraceMessages)
{	if (!--StopTraceMessages)
	{	TraceLogThread("WinMsg", TRUE, "TcpTimer:Stopping TraceMessages...\n");
		StopTraceMessages = TraceMessages = FALSE;
	} else TraceLogThread("WinMsg", TRUE, "TcpTimer:%ld before Stopping TraceMessages\n", (long) StopTraceMessages);
}
#endif
	return OnTcpReaderTimer(hwnd);
	case GPS_TIMER: return OnGpsReaderTimer(hwnd);
	case POWER_TIMER: TriggerTelemetry(hwnd); break;
	case PURGE_TIMER:
	{	__int64 Start = llGetMsec();
	static __int64 msMax=0, msLast=0;
		PurgeCloseStations(hwnd);
{	char Buffer[80];
	StringCbPrintfA(Buffer,80,"Stations(%ld)",CloseStationCount);
Start = DebugTimer("PurgeTimer",Buffer,Start,&msMax,&msLast,hwnd);
}
		if (szSaveConfigWhy)	/* Save pending? */
		{	if (SecondsSince(&stSaveConfig) > ulSaveConfigTimeout)
			{	RealSaveConfiguration(hwnd, &ActiveConfig, szSaveConfigWhy);
				szSaveConfigWhy = NULL;
				ulSaveConfigTimeout = 0;	/* Remember first timer */
			}
Start = DebugTimer("PurgeTimer","SaveConfig",Start,&msMax,NULL,hwnd);
		}
		TransmitIGate();	/* Kick this one for good measure */
Start = DebugTimer("PurgeTimer","IGate",Start,&msMax,NULL,hwnd);
		TransmitStatusReport(FALSE);	/* Keep our status out there */
Start = DebugTimer("PurgeTimer","StatusReport",Start,&msMax,NULL,hwnd);
		TransmitObjects(hwnd, TRUE);	/* Get our objects out the door */
Start = DebugTimer("PurgeTimer","Objects",Start,&msMax,NULL,hwnd);
		TransmitCompanions();	/* Get our companions updated */
Start = DebugTimer("PurgeTimer","Companions",Start,&msMax,NULL,hwnd);
		TransmitBulletins(hwnd, TRUE);	/* Get our bulletins out the door */
Start = DebugTimer("PurgeTimer","Bulletins",Start,&msMax,NULL,hwnd);
		TransmitCQGroups(hwnd);	/* Keep up with CQGroups out the door */
Start = DebugTimer("PurgeTimer","CQGroups",Start,&msMax,NULL,hwnd);
		Check4Updates(hwnd);	/* Kick this one also */
Start = DebugTimer("PurgeTimer","Updates",Start,&msMax,NULL,hwnd);
		CheckNotifyUsage();		/* And check-in with usage tracking */
Start = DebugTimer("PurgeTimer","Usage",Start,&msMax,NULL,hwnd);
		PurgeTraceLogs();		/* And all of the traces */
Start = DebugTimer("PurgeTimer","PurgeTrace",Start,&msMax,NULL,hwnd);
		PurgeBulletins();		/* Clean off our Bulletin Board */
Start = DebugTimer("PurgeTimer","PurgeBulletins",Start,&msMax,NULL,hwnd);
		PurgeTelemetry();		/* Clean up the telemetry definitions */
Start = DebugTimer("PurgeTimer","PurgeTelemetry",Start,&msMax,NULL,hwnd);
		PurgeRcvdWeather();		/* Clean off our Weather memory */
Start = DebugTimer("PurgeTimer","PurgeWeather",Start,&msMax,NULL,hwnd);
		FlushLog(hwnd);			/* Close the output file every 30 seconds if open */
Start = DebugTimer("PurgeTimer","FlushLog",Start,&msMax,NULL,hwnd);
		OSMFlushTileCache(10*60);	/* Keep 10 minutes of cache */
Start = DebugTimer("PurgeTimer","OSMFlush",Start,&msMax,NULL,hwnd);

		break;
	}
	default:
	{	return OnSharedTimer(hwnd, idTimer);
	}
	}
	return FALSE;
}


#ifdef UNDER_CE
int FrameRect(HDC hdc, CONST RECT *prc, HBRUSH hbr)
{	int Result;
	POINT pt[5];
	HBRUSH hbrOld = (HBRUSH) SelectObject(hdc, hbr);
	pt[0].x = prc->left; pt[0].y = prc->top;
	pt[1].x = prc->right; pt[1].y = prc->top;
	pt[2].x = prc->right; pt[2].y = prc->bottom;
	pt[3].x = prc->left; pt[3].y = prc->bottom;
	pt[4].x = prc->left; pt[4].y = prc->top;
	Result = Polyline(hdc, pt, 5);
	SelectObject(hdc, hbrOld);
	return Result;
}
#endif

static BOOL SplitPolyline(HDC hdc, POINT *p, int c, long maxlen)
{	int s, e;
	if (!maxlen) return Polyline(hdc, p, c);
	for (s=0, e=1; e<c; e++)
	{	if (abs(p[e].x-p[e-1].x) > maxlen
		|| abs(p[e].y-p[e-1].y) > maxlen)
		{	if (e-s > 1) Polyline(hdc, &p[s], e-s);
			s = e;
		}
	}
	if (c-s > 1) Polyline(hdc, &p[s], c-s);
	return TRUE;
}

typedef struct ADDRESS_LOOKUP_INFO_S
{	HWND hwnd;
	STATION_INFO_S Station;
} ADDRESS_LOOKUP_INFO_S;	

#ifdef UNDER_CE
DWORD AddressLookupThread(LPVOID pvParam)
#else
DWORD WINAPI AddressLookupThread(LPVOID pvParam)
#endif
{	ADDRESS_LOOKUP_INFO_S *Info = (ADDRESS_LOOKUP_INFO_S *)pvParam;

	SetTraceThreadName("AddressLookup");

	TCHAR *Address = FindNearbyAddress(Info->hwnd, Info->Station.pCoord->lat, Info->Station.pCoord->lon);
	TCHAR *Title=(TCHAR*)malloc(sizeof(*Title)*80);

	if (Info->Station.IGate[0])
		StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S via %S"),
						Info->Station.Station, Info->Station.IGate);
	else	StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S%S"),
						Info->Station.Station,
						!strcmp(Info->Station.Station,CALLSIGN)?"":" - ME!");
	if (Address)
	{	if ((Info->Station.sComment && *Info->Station.pComment) || HasNickComment(&Info->Station))
		{	size_t MsgLen = sizeof(TCHAR)*(Info->Station.sComment+80+wcslen(Address)+sizeof(Info->Station.Nickname->Comment));
			TCHAR *Message = (TCHAR*)malloc(MsgLen);
			if (HasNickComment(&Info->Station))
			{	if (Info->Station.sComment && *Info->Station.pComment)
					StringCbPrintf(Message, MsgLen, TEXT("%S\n(%s)\n\n%s"),
							Info->Station.Nickname->Comment,
							Info->Station.pComment, Address);
				else StringCbPrintf(Message, MsgLen, TEXT("%S\n\n%s"),
							Info->Station.Nickname->Comment, Address);
			} else StringCbPrintf(Message, MsgLen, TEXT("%s\n\n%s"),
							Info->Station.pComment, Address);
			PostMessage(Info->hwnd, WM_ASYNC_MSG_BOX, (WPARAM) Title, (LPARAM) Message);
		} else PostMessage(Info->hwnd, WM_ASYNC_MSG_BOX, (WPARAM) Title, (LPARAM) Address);
	} else
	{static	char Error[] = "Address Not Available\n\nextendedFindNearby Failed";
		size_t MsgLen = sizeof(TCHAR)*sizeof(Error);
		TCHAR *Message = (TCHAR*)malloc(MsgLen);
		StringCbPrintf(Message, MsgLen, TEXT("%S"), Error);
		PostMessage(Info->hwnd, WM_ASYNC_MSG_BOX, (WPARAM) Title, (LPARAM) Message);
	}
	return 0;
}

static void FreeWordWrap(char **Wraps)
{	char **f;
	for (f=Wraps; *f; f++)
		free(*f);
	free(Wraps);
}

static char **WordWrap(char *aMsg, size_t MaxWidth, size_t PreLen)
{
	if (MaxWidth <= 0) MaxWidth = strlen(aMsg)+16;	/* For good measure */

	int p=0, n=strlen(aMsg)/(MaxWidth/2-PreLen)+1;
	char **r = (char**)calloc(n+1,sizeof(*r));
	char *Next, *Last;

	if (strlen(aMsg) <= PreLen) PreLen = 0;

	for (Next=aMsg+PreLen; p<n && *Next; Next=Last)
	{
		while (*Next && isspace(*Next & 0xff)) Next++;	/* No leading spaces allowed */

		r[p] = (char*)calloc(1,MaxWidth+1);

		if (PreLen) strncpy(r[p], aMsg, PreLen);

		if (strlen(Next) > MaxWidth-PreLen)
		{	Last = Next + MaxWidth-PreLen-1;
/* Need to watch for next line starting with ? tripping up remote queries */
			while (!isspace(*Last & 0xff) && Last>Next+MaxWidth/2)
				Last--;
			if (isspace(*Last & 0xff))
			{	while (Last>Next && isspace(Last[-1] & 0xff)) Last--;
			}
			else Last = Next + MaxWidth-PreLen-1;
		} else Last = Next + strlen(Next);

		strncat(r[p], Next, (Last-Next));

		{	char *Check4More = Last;
			while (*Check4More && isspace(*Check4More & 0xff)) Check4More++;	/* No leading spaces allowed */
			if (*Check4More)	/* There's more, add a + to the end */
			{	strcat(r[p], "+");
			}
		}

		if (strlen(r[p]) > PreLen) p++;
	}
	return r;
}

static BOOL SendAPRSMessageFrom(/*HWND hwnd,*/ char *From, char *To, int PrefixLen, TCHAR *wMsg,
								BOOL Ack, BOOL RFOnly, BOOL ISOnly, BOOL SuppressChat, size_t WrapWidth,
								BOOL OneShot)
{//	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
static int MsgAckID;
	BOOL Success = FALSE;
	int m;
//#define ACK_BASE '!'
//#define ACK_RANGE 91
#define ACK_BASE 'A'
#define ACK_RANGE 26
//#define ACK_BASE '0'
//#define ACK_RANGE 10
#define MAX_ACK (ACK_RANGE*ACK_RANGE)
	char *aMsg = NULL;
	int Size8 = 0;

	if (WrapWidth)	/* Only if we're allowed to reformat */
		RtStrnTrim(-1,To);	/* Trim off any leading or trailing spaces */

	{	int Len16 = wcslen(wMsg)+1;
		Size8 = WideCharToMultiByte(CP_UTF8, 0, wMsg, Len16, NULL, 0, NULL, NULL);
		if (Size8)
		{	aMsg = (char*)malloc(sizeof(*aMsg)*Size8);
			int Result = WideCharToMultiByte(CP_UTF8, 0, wMsg, Len16, aMsg, Size8, NULL, NULL);
			if (!Result)
			{	TraceError(NULL, "WideCharToMultiByte(%ld)(%S) Failed with %ld\n", (long) Len16, wMsg, (long) GetLastError());
				TraceError(NULL, "WideCharToMultiByte Failed with %ld\n", (long) GetLastError());
				free(aMsg);
				aMsg = NULL;
			} else TraceActivity(NULL, "WideCharToMultiByte(%S) Moved %ld->%ld(%ld) Giving (%s)\n",
								wMsg, (long) Len16, (long) Size8, (long) Result, aMsg);
		} else TraceError(NULL, "WideCharToMultiByte(Len)(%S) Failed with %ld\n", wMsg, (long) GetLastError());
	}

	if (!aMsg)
	{	int Len16 = wcslen(wMsg)+1;
		aMsg = (char*)malloc(Len16);
		if (!SUCCEEDED(StringCbPrintfA(aMsg, Len16, "%S", wMsg)))
		{	TraceLogThread("Messages", TRUE, "SendAPRSMessage:Failed To Convert Text(%S)\n", wMsg);
			strncpy(aMsg, "Failed", Len16);
			aMsg[Len16-1] = '\0';
		}
	}

	TraceLogThread("Messages", TRUE, "To(%s) Msg(%s) %s\n", To, aMsg, Ack?"ACK":"NoAck");
/*
	Blank messages don't get sent, they just appear to succeed
*/
	{	char *p;
		for (p=aMsg; *p; p++)
			if (!isspace(*p & 0xff))
				break;
		if (!*p)
		{	free(aMsg);
			return TRUE;
		}
	}

	if (!MsgAckID)
	{	SYSTEMTIME st; GetSystemTime(&st);
		MsgAckID = (st.wMinute*60+st.wSecond)%MAX_ACK;
		if (!MsgAckID) MsgAckID = 1;
	}
/*
	If this is to ME, disable Ack
*/
	if (Ack && !strcmp(To,CALLSIGN))
	{	TraceLogThread("Messages", TRUE, "To(%s) Is ME(%s), Disabling Ack\n", To, CALLSIGN);
		Ack = FALSE;
	}
/*
	If this is one of our group messages, disable Ack
*/
	if (Ack)
	{	STATION_INFO_S *Stat = FindStationCall(To);
TraceLogThread("Messages", TRUE, "To(%s) %s Messaging\n", To, Stat&&Stat->hasMessaging?"HAS":"NO");
		if (!Stat || !Stat->hasMessaging)
		{	unsigned long i;
			for (i=0; i<ARRAYSIZE(SpecMessageGroups); i++)
			{	if (!_stricmp(To, SpecMessageGroups[i]))
				{	TraceLogThread("Messages", TRUE, "To(%s) Is SpecMessageGroups[%ld](%s), Disabling Ack\n", To, (long) i, SpecMessageGroups[i]);
					Ack = FALSE;
					break;
				}
			}
			if (LocateSimpleStringEntry(&ActiveConfig.MessageGroups, To) != -1)
			{	TraceLogThread("Messages", TRUE, "To(%s) Is A MessageGroups, Disabling Ack\n", To);
				Ack = FALSE;
			}
		}
	}

	if (!PrefixLen && *aMsg=='%') PrefixLen = 1;

	char **ww = WordWrap(aMsg, WrapWidth, PrefixLen);
	for (char **f=ww; *f; f++)
	{	char *Next = *f;
		if (*Next)	/* Still have something to send? */
		{
			m = PendingMsgCount++;
			if (PendingMsgCount > PendingMsgSize)
			{	PendingMsgSize += 8;
				PendingMsgs = (PENDING_MESSAGE_S *) realloc(PendingMsgs, PendingMsgSize*sizeof(*PendingMsgs));
			}

			memset(&PendingMsgs[m], 0, sizeof(PendingMsgs[m]));
			PendingMsgs[m].Ack = Ack;
			PendingMsgs[m].OneShot = OneShot;
			PendingMsgs[m].RFOnly = RFOnly;
			PendingMsgs[m].ISOnly = ISOnly;
			PendingMsgs[m].SuppressChat = SuppressChat;
			PendingMsgs[m].Retries = 0;
			PendingMsgs[m].Retriggered = FALSE;
			PendingMsgs[m].Subordinated = FALSE;
			strncpy(PendingMsgs[m].aTo, To, sizeof(PendingMsgs[m].aTo));
			strncpy(PendingMsgs[m].aFrom, From, sizeof(PendingMsgs[m].aFrom));
			GetLocalTime(&PendingMsgs[m].stQueued);

			size_t Remain;
			char *More, *Body;

			if (strcmp(From, CALLSIGN))
				Success = SUCCEEDED(StringCbPrintfExA(PendingMsgs[m].Message, sizeof(PendingMsgs[m].Message), &More, &Remain, STRSAFE_IGNORE_NULLS,
							"%s>%s,%s*%s%s::%-9s:",
							From, DESTID, CALLSIGN, *PATH?",":"", PATH, To));
			else Success = SUCCEEDED(StringCbPrintfExA(PendingMsgs[m].Message, sizeof(PendingMsgs[m].Message), &More, &Remain, STRSAFE_IGNORE_NULLS,
							"%s>%s%s%s::%-9s:",
							From, DESTID, *PATH?",":"", PATH, To));
			Body = More;
			Success = SUCCEEDED(StringCbPrintfExA(More, Remain, &More, &Remain, STRSAFE_IGNORE_NULLS, "%s", Next)) && Success;
			if (Ack)
			{
//				Success = SUCCEEDED(StringCbPrintfA(PendingMsgs[m].MsgAckID, sizeof(PendingMsgs[m].MsgAckID), "%ld", (long) MsgAckID++)) && Success;

				PendingMsgs[m].MsgAckID[0] = ((MsgAckID/ACK_RANGE)%ACK_RANGE)+ACK_BASE;
				PendingMsgs[m].MsgAckID[1] = (MsgAckID%ACK_RANGE)+ACK_BASE;
				PendingMsgs[m].MsgAckID[2] = '}';	/* for Reply-Ack */
				PendingMsgs[m].MsgAckID[3] = '\0';	/* Null terminate string */
				MsgAckID++;	/* Increment for next time */

				Success = SUCCEEDED(StringCbPrintfExA(More, Remain, &More, &Remain, STRSAFE_IGNORE_NULLS, "{%s", PendingMsgs[m].MsgAckID)) && Success;
				Success = SUCCEEDED(StringCbPrintf(PendingMsgs[m].uTo, sizeof(PendingMsgs[m].uTo), TEXT("%S"), To)) && Success;
//				Success = SUCCEEDED(StringCbPrintf(PendingMsgs[m].Msg, sizeof(PendingMsgs[m].Msg), TEXT("%S"), Next)) && Success;

				int m1;
				for (m1=0; m1<m; m1++)
				{	if (!strcmp(PendingMsgs[m1].aTo, PendingMsgs[m].aTo))
					{	PendingMsgs[m].Subordinated = TRUE;
						break;
					}
				}
			}
			Success = SUCCEEDED(StringCbPrintfA(PendingMsgs[m].MessageBody, sizeof(PendingMsgs[m].MessageBody), "%s", Body));

			if (Success)
			{	strncpy(PendingMsgs[m].MsgAckFrom, To, sizeof(PendingMsgs[m].MsgAckFrom));
				if (MsgAckID > MAX_ACK) MsgAckID = 1;

#ifdef USING_CHAT
				if (!SuppressChat)
				{	BOOL Reply = FALSE;
					CHAT_INFO_S *Chat = FindChat(From, PendingMsgs[m].aTo, &Reply);
					if (Chat)
					{	AddToChat(Chat, Reply, MESSAGE_ME, PendingMsgs[m].MessageBody, &PendingMsgs[m].stQueued,
								COLOR_MESSAGE_SOURCE_QUEUED, TRUE);	// Assume subordinated
					}
				}
#endif

				if (!PendingMsgs[m].Subordinated)	/* This one's clear for transmission */
				{	RetriggerPendingMessage(m, "New", FALSE);	// This resets color
					if (!Ack) PendingMsgCount--;	/* Don't keep in the pending list */
					if (PendingMsgCount)
					{	InvalidateMessage(TRUE);
					}
				}
			} else PendingMsgCount--;	/* Didn't send it, don't queue it! */
		}
	}

	FreeWordWrap(ww);

	free(aMsg);	/* Let's not leak this piece */

	return Success;
}

static BOOL SendAPRSMessage(/*HWND hwnd,*/ char *To, int PrefixLen, TCHAR *wMsg, BOOL Ack, BOOL RFOnly, BOOL ISOnly, BOOL SuppressChat)
{	return SendAPRSMessageFrom(/*hwnd,*/ CALLSIGN, To, PrefixLen, wMsg, Ack, RFOnly, ISOnly, SuppressChat);
}

static BOOL SendAPRSMessageOneShot(char *From, char *To, int PrefixLen, TCHAR *wMsg)
{
	return SendAPRSMessageFrom(From, To, PrefixLen, wMsg, TRUE, FALSE, FALSE, FALSE, 0, TRUE);
}

BOOL CALLBACK SendEMailDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{static	BOOL EntryChanged;
static	TCHAR EnterText[] = TEXT("Enter Message Text Here");

	switch (msg)
	{
	case WM_INITDIALOG:
	{	TCHAR *Buffer = (TCHAR*)malloc(sizeof(*Buffer)*256);

		if (HWND hwndList = GetDlgItem(hdlg, IDL_EMAIL))
		{	SendMessage(hwndList, CB_LIMITTEXT, 79, 0);
			for (unsigned long i=0; i<ActiveConfig.EMails.Count; i++)
			{
#ifdef USE_TIMED_STRINGS
				StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("%S"), ActiveConfig.EMails.Entries[i].string);
#else
				StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("%S"), ActiveConfig.EMails.Strings[i]);
#endif
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) Buffer);	/* First entry in the list */
			}
			SendMessage(hwndList, CB_SETCURSEL, 0, 0);	/* Select first entry in the list */
		}
		else MessageBox(hdlg, TEXT("IDL_EMAIL Not Found!"), TEXT("SendEMailDlgProc"), MB_OK | MB_ICONERROR);

		SendDlgItemMessage(hdlg, IDE_TEXT, EM_LIMITTEXT, DEFAULT_WRAP_WIDTH, 0);
		SetDlgItemText(hdlg, IDE_TEXT, EnterText);
		SetFocus(GetDlgItem(hdlg, IDE_TEXT));
		SendDlgItemMessage(hdlg, IDE_TEXT, EM_SETSEL, 0, -1);
#ifdef USING_SIP
		SipShowIM(SIPF_ON);	/* Bring up the keyboard for message typing */
#endif
		EntryChanged = FALSE;
		free(Buffer);
		CenterWindow(hdlg);
		return FALSE;	/* I already set focus */
	}
	case WM_COMMAND:
		if (!MakeFocusControlVisible(hdlg, wp, lp))
		switch (LOWORD(wp))
		{
		case IDB_CANCEL:
			EndDialog(hdlg, IDCANCEL);
			return TRUE;
		case IDB_SEND:
		{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*128), *EMail = (TCHAR*)malloc(sizeof(*EMail)*80);
			if (EntryChanged)
			if (GetDlgItemText(hdlg, IDE_TEXT, Text, 128))
			if (GetDlgItemText(hdlg, IDL_EMAIL, EMail, 80))
			{	char *aEMail = (char*)malloc(80);
				TCHAR *wText = (TCHAR*)malloc(sizeof(*wText)*80*2);
				if (SUCCEEDED(StringCbPrintfA(aEMail, 80, "%S", EMail))
				&& SUCCEEDED(StringCbPrintf(wText, sizeof(*wText)*80*2, TEXT("%s %s"), EMail, Text)))
				{	RememberEMail(hdlg, &ActiveConfig, aEMail);
					SaveConfiguration(hdlg, &ActiveConfig, "EMail");
					if (SendAPRSMessage(/*GetParent(hdlg),*/ ActiveConfig.EMailServer, strlen(aEMail)+1, wText, TRUE))
						EndDialog(hdlg, IDOK);
					else MessageBox(hdlg, TEXT("SendAPRSMessage Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
				} else MessageBox(hdlg, TEXT("EMail Format Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
				free(aEMail); free(wText);
			}
//			else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);
//			else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDE_TEXT"), MB_OK | MB_ICONERROR);
//			else MessageBox(hdlg, TEXT("No Change In Message Text"), TEXT("EntryChanged"), MB_OK | MB_ICONERROR);
			free(Text); free(EMail);
			return TRUE;
		}
		case IDE_TEXT:
		{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*80);
			switch (HIWORD(wp))
			{
			case EN_CHANGE:
				EntryChanged = GetDlgItemText(hdlg, IDE_TEXT, Text, 80) > 0;
				break;
			case EN_KILLFOCUS:
				if (GetDlgItemText(hdlg, IDE_TEXT, Text, 80))
					if (!memcmp(Text, EnterText, sizeof(EnterText)))
						SetDlgItemText(hdlg, IDE_TEXT, TEXT(""));
			}
			free(Text);
			return TRUE;
		}
		}
		break;
	}
	return FALSE;
}

BOOL CALLBACK FindStationDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_INITDIALOG:	/* Note: IDB_FIND re-invokes this */
	{
#if MAX_TRACKERS <= 1
		DestroyWindow(GetDlgItem(hdlg,IDB_MULTITRACK));
#endif
		SetWindowLong(hdlg, DWL_USER, lp);

		if (!GetFreeTrackerCount())
			EnableWindow(GetDlgItem(hdlg, IDB_MULTITRACK),FALSE);

		SendMessage(hdlg, WM_USER+1, 0, 0);

		SetFocus(GetDlgItem(hdlg, IDL_TO_CALL));
#ifdef USING_SIP
		SipShowIM(SIPF_ON);	/* Bring up the keyboard for callsign typing */
#endif
		CenterWindow(hdlg);
		return FALSE;	/* I already set focus */
	}
	case WM_USER+1:	/* Note: IDB_FIND re-invokes this */
	{	TCHAR *tBuffer = (TCHAR*)malloc(sizeof(*tBuffer)*80);

		if (HWND hwndList = GetDlgItem(hdlg, IDL_TO_CALL))
		{	unsigned long s;
			SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
			SendMessage(hwndList, CB_LIMITTEXT, 9, 0);
			for (s=0; s<CloseStationCount; s++)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%.*S"), STRING(pCloseStations[s]->Station));
				SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tBuffer);	/* Sort entry or Last entry in the list (Added) */
			}

			for (s=1; s<CloseStationCount; s++)
			if (HasNickLabelNonBlank(pCloseStations[s]))
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%.*S"), STRING(pCloseStations[s]->Nickname->Label));
				SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tBuffer);	/* Sort entry or Last entry in the list (Added) */
			}

			SendMessage(hwndList, CB_SETCURSEL, 0, 0);	/* Select first entry in the list */
			SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
		}
		else MessageBoxW(hdlg, TEXT("GetDlgItem"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);

		StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("Found %ld Stations"), (long) CloseStationCount);
		SetDlgItemText(hdlg, IDT_TEXT, tBuffer);
		free(tBuffer);
		return TRUE;
	}

	case WM_COMMAND:
		if (!MakeFocusControlVisible(hdlg, wp, lp))
		switch (LOWORD(wp))
		{
		case IDB_CANCEL:
			EndDialog(hdlg, -1);
			return TRUE;
		case IDB_FIND:
		case IDB_MULTITRACK:
		{	TCHAR ToCall[80];
			HWND hwndList = GetDlgItem(hdlg, IDL_TO_CALL);
			if (GetDlgItemText(hdlg, IDL_TO_CALL, ToCall, ARRAYSIZE(ToCall)))
			{	char aToCall[16];
				if (SUCCEEDED(StringCbPrintfA(aToCall, sizeof(aToCall), "%S", ToCall)))
				{	if (!_stricmp(aToCall, "ME"))
						EndDialog(hdlg, 0);
					else
					{	size_t l = strlen(aToCall);
						BOOL isWild;
						unsigned long s, sFound=-1, sExact=-1;
						//ZeroSSID(aToCall);

						for (s=0; s<CloseStationCount; s++)
						if (HasNickLabelNonBlank(pCloseStations[s])
						&& !_stricmp(pCloseStations[s]->Nickname->Label, aToCall))
						{	strncpy(aToCall, pCloseStations[s]->Nickname->Station, sizeof(aToCall));
						}

						if (!IsDlgButtonChecked(hdlg, IDC_LOWER))
							_strupr(aToCall);

						if (aToCall[l-1] == '*')
						{	isWild = TRUE;
							aToCall[--l] = '\0';	/* Null out * */
						} else isWild = FALSE;
#ifndef UNDER_CE
						SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
#endif
						SendMessage(hwndList, CB_RESETCONTENT, 0, 0);
						for (s=0; s<CloseStationCount; s++)
						{	if ((isWild && !_strnicmp(aToCall, pCloseStations[s]->Station, l))
							|| (!_stricmp(aToCall, pCloseStations[s]->Station)))
							{	StringCbPrintf(ToCall, sizeof(ToCall), TEXT("%.*S"), STRING(pCloseStations[s]->Station));
								SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) ToCall);	/* Sort entry or Last entry in the list (Added) */
								sFound = s;
								if (!_stricmp(aToCall, pCloseStations[s]->Station))
									sExact = s;
							}
						}
						SendMessage(hwndList, CB_SETCURSEL, 0, 0);	/* Select first entry in the list */
#ifndef UNDER_CE
						SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
						RedrawWindow(hwndList, NULL, NULL,
									RDW_ERASE | RDW_FRAME
									| RDW_INVALIDATE | RDW_ALLCHILDREN);
#endif
						size_t Count = SendMessage(hwndList, CB_GETCOUNT, 0, 0);
						if (Count == 1)
						{
#if MAX_TRACKERS > 1
							if (LOWORD(wp) == IDB_MULTITRACK)
							{	if (CreateTrackerWindow(pCloseStations[sFound]->Station, pCloseStations[sFound]->Owner))
									EndDialog(hdlg, -1);
							} else
#endif
								EndDialog(hdlg, sFound);
						} else if (Count == 0)
						{	if (!isWild)
							{	StringCbPrintf(ToCall, sizeof(ToCall), TEXT("Station %S Not Found, Wait For It?"), aToCall);

								BUTTONS_S *Buttons = CreateButtons(-1);
								AddButton(Buttons, "Yes", IDYES);
#if MAX_TRACKERS > 1
								BOOL IsActive = FALSE;
								STATION_INFO_S *Which = FindStationCall(aToCall);
								if (GetFreeTrackerCount(Which, &IsActive)
								|| IsActive)
									AddButton(Buttons, "MultiTrack" /*"MultiTrack"*/, IDRETRY);
#endif
								AddButton(Buttons, "No", IDNO);
								int Action;
#if MAX_TRACKERS > 1
								if (LOWORD(wp) == IDB_MULTITRACK)
									Action = IDRETRY;
								else
									Action = LwdMessageBox2(hdlg, ToCall, TEXT("Find Station"), MB_YESNO | MB_ICONQUESTION, Buttons);
#else
									Action = MessageBoxW(hdlg, ToCall, TEXT("Find Station"), MB_YESNO | MB_ICONQUESTION);
#endif
								switch (Action)
								{
								case IDYES:
								{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hdlg, DWL_USER);
									cInfo->Awaiting = TRUE;
									strncpy(cInfo->CenterID, aToCall, sizeof(cInfo->CenterID));
									InvalidateStationPoints(cInfo->Index,"FindStation", TRUE);
									InvalidateCenter(cInfo->hwnd, TRUE);
									TransmitFilter();
									if (cInfo->Awaiting)
									{	SendAPRSMessage(cInfo->CenterID, 0, TEXT("?APRSP"), FALSE, FALSE, FALSE, TRUE);
									}
									EndDialog(hdlg, -1);
									break;
								}
#if MAX_TRACKERS > 1
								case IDRETRY:
									if (CreateTrackerWindow(aToCall,NULL))
										EndDialog(hdlg, -1);
									break;
#endif
								default:
									SendMessage(hdlg, WM_USER+1, 0, 0);
								}
							} else
							{	StringCbPrintf(ToCall, sizeof(ToCall), TEXT("No Stations Found Matching %S*, Try Again?"), aToCall);
								if (MessageBoxW(hdlg, ToCall, TEXT("Find Station"), MB_YESNO | MB_ICONQUESTION) == IDYES)
									SendMessage(hdlg, WM_USER+1, 0, 0);
								else EndDialog(hdlg, -1);
							}
						} else if (!isWild && sExact != -1)
						{
#if MAX_TRACKERS > 1
							if (LOWORD(wp) == IDB_MULTITRACK)
							{	if (CreateTrackerWindow(aToCall,NULL))
									EndDialog(hdlg, -1);
							} else
#endif
								EndDialog(hdlg, sExact);
						} else
						{	StringCbPrintf(ToCall, sizeof(ToCall), TEXT("Found %ld Stations"), (long) Count);
							SetDlgItemText(hdlg, IDT_TEXT, ToCall);
						}
					}
				} else MessageBoxW(hdlg, TEXT("Callsign Format Failed"), TEXT("IDB_FIND"), MB_OK | MB_ICONERROR);
			}
			return TRUE;
		}
		}
		break;
	}
	return FALSE;
}

#ifdef USING_CHAT
BOOL CALLBACK SendMessageDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_INITDIALOG:
	{	char *CallSign = (char*)lp;
		TCHAR *tBuffer = (TCHAR*)malloc(sizeof(*tBuffer)*80);

		if (HWND hwndList = GetDlgItem(hdlg, IDL_TO_CALL))
		{	unsigned long i, s;
			SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
			SendMessage(hwndList, CB_LIMITTEXT, 9, 0);
			for (s=1; s<CloseStationCount; s++)
			if (pCloseStations[s]->hasMessaging)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%.*S"), STRING(pCloseStations[s]->Station));
				SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tBuffer);	/* Sort entry or Last entry in the list (Added) */
			}
			for (i=0; i<ARRAYSIZE(SpecMessageGroups); i++)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), SpecMessageGroups[i]);
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}
			for (i=0; i<ActiveConfig.MessageGroups.Count; i++)
			{
#ifdef USE_TIMED_STRINGS
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageGroups.Entries[i].string);
#else
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageGroups.Strings[i]);
#endif
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}

			for (s=1; s<CloseStationCount; s++)
			if (HasNickLabelNonBlank(pCloseStations[s])
			&& pCloseStations[s]->hasMessaging)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%.*S"), STRING(pCloseStations[s]->Nickname->Label));
				SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tBuffer);	/* Sort entry or Last entry in the list (Added) */
			}

			for (i=0; i<ActiveConfig.MessageCalls.Count; i++)
			{
#ifdef USE_TIMED_STRINGS
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageCalls.Entries[i].string);
#else
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageCalls.Strings[i]);
#endif
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}
//			SendMessage(hwndList, CB_INSERTSTRING, -1, (LPARAM) TEXT("EMAIL-2"));	/* Last entry in the list */
//			SendMessage(hwndList, CB_INSERTSTRING, -1, (LPARAM) TEXT("EMAIL"));	/* Last entry in the list */
			if (strcmp(CallSign, CALLSIGN))
			{	long Index;
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), CallSign);
				Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index == CB_ERR
				|| SendMessage(hwndList, CB_SETCURSEL, Index, 0) == CB_ERR)
				{	Index = SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
					SendMessage(hwndList, CB_SETCURSEL, Index, 0);
				}
			} else SendMessage(hwndList, CB_SETCURSEL, 0, 0);	/* Select first entry in the list */

			SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
//			RedrawWindow(hwndList, NULL, NULL,
//					RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
		}
		else MessageBox(hdlg, TEXT("GetDlgItem"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);

#ifdef USING_SIP
		SipShowIM(SIPF_ON);	/* Bring up the keyboard for message typing */
#endif

		SetFocus(GetDlgItem(hdlg, IDL_TO_CALL));
		free(tBuffer);
		CenterWindow(hdlg);
		return FALSE;	/* I already set focus */
	}
	case WM_CLOSE:
		EndDialog(hdlg, IDCANCEL);
		return TRUE;

	case WM_COMMAND:
		if (!MakeFocusControlVisible(hdlg, wp, lp))
		switch (LOWORD(wp))
		{
		case IDB_CANCEL:
			EndDialog(hdlg, IDCANCEL);
			return TRUE;
		case IDB_SEND:
		{	HWND hwndEntry = GetDlgItem(hdlg, IDE_TEXT);
			{	TCHAR ToCall[16];
				if (GetDlgItemText(hdlg, IDL_TO_CALL, ToCall, ARRAYSIZE(ToCall)))
				{	char aToCall[16];
					if (SUCCEEDED(StringCbPrintfA(aToCall, sizeof(aToCall), "%S", ToCall)))
					{	ZeroSSID(aToCall);
						for (unsigned long s=0; s<CloseStationCount; s++)
						if (HasNickLabelNonBlank(pCloseStations[s])
						&& !_stricmp(pCloseStations[s]->Nickname->Label, aToCall))
						{	strncpy(aToCall, pCloseStations[s]->Nickname->Station, sizeof(aToCall));
						}
						if (!IsDlgButtonChecked(hdlg, IDC_LOWER))
							_strupr(aToCall);
						if (!CheckMessageCall(hdlg, &ActiveConfig, aToCall) 
						&& !FindStationCall(aToCall))
						{	BOOL hasLower = FALSE;
							for (int i=0; i<sizeof(aToCall); i++)
							{	if (!aToCall[i]) break;
								else if (islower(aToCall[i]&0xff))
									hasLower = TRUE;
							}
							if (hasLower)
							{	char upCall[16];
								_strupr(strcpy(upCall, aToCall));
								if (FindStationCall(upCall))
								{	strcpy(aToCall, upCall);
								} else
								{
									TCHAR Buffer[80];
									StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Some APRS Clients are Case Sensitive, Continue with %S?"), aToCall);
									if (MessageBox(hdlg, Buffer, TEXT("Confirm LowerCase"), MB_YESNO | MB_ICONQUESTION) != IDYES)
										return TRUE;
								}
							}
						}
						RememberMessageCall(hdlg, &ActiveConfig, aToCall);
						SaveConfiguration(hdlg, &ActiveConfig, "MessageCall");
						DisplayChat(CALLSIGN, aToCall);
						EndDialog(hdlg, IDOK);
					} else MessageBox(hdlg, TEXT("Message Format Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
				}
//				else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);
			}
			return TRUE;
		}
		}
		break;
	}
	return FALSE;
}
#else
BOOL CALLBACK SendMessageDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{static	BOOL EntryChanged;
static	TCHAR EnterText[] = TEXT("Enter Message Text Here");

	switch (msg)
	{
	case WM_INITDIALOG:
	{	char *CallSign = (char*)lp;
		TCHAR *tBuffer = (TCHAR*)malloc(sizeof(*tBuffer)*80);

		if (HWND hwndList = GetDlgItem(hdlg, IDL_TO_CALL))
		{	SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
			SendMessage(hwndList, CB_LIMITTEXT, 9, 0);
			for (unsigned long s=1; s<CloseStationCount; s++)
			if (pCloseStations[s]->hasMessaging)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%.*S"), STRING(pCloseStations[s]->Station));
				SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tBuffer);	/* Sort entry or Last entry in the list (Added) */
			}
			for (unsigned long i=0; i<ARRAYSIZE(SpecMessageGroups); i++)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), SpecMessageGroups[i]);
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}
			for (unsigned long i=0; i<ActiveConfig.MessageGroups.Count; i++)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageGroups.Strings[i]);
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}

			for (unsigned long i=0; i<ActiveConfig.MessageCalls.Count; i++)
			{	StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), ActiveConfig.MessageCalls.Strings[i]);
				long Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index != CB_ERR)
				{	SendMessage(hwndList, CB_DELETESTRING, Index, 0);
				}
				SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
			}
//			SendMessage(hwndList, CB_INSERTSTRING, -1, (LPARAM) TEXT("EMAIL-2"));	/* Last entry in the list */
//			SendMessage(hwndList, CB_INSERTSTRING, -1, (LPARAM) TEXT("EMAIL"));	/* Last entry in the list */
			if (strcmp(CallSign, CALLSIGN))
			{	long Index;
				StringCbPrintf(tBuffer, sizeof(*tBuffer)*80, TEXT("%S"), CallSign);
				Index = SendMessage(hwndList, CB_FINDSTRINGEXACT, 0, (LPARAM) tBuffer);
				if (Index == CB_ERR
				|| SendMessage(hwndList, CB_SETCURSEL, Index, 0) == CB_ERR)
				{	Index = SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) tBuffer);	/* First entry in the list */
					SendMessage(hwndList, CB_SETCURSEL, Index, 0);
				}
			} else SendMessage(hwndList, CB_SETCURSEL, 0, 0);	/* Select first entry in the list */

			SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
//			RedrawWindow(hwndList, NULL, NULL,
//					RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
		}
		else MessageBox(hdlg, TEXT("GetDlgItem"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);

		SendDlgItemMessage(hdlg, IDE_TEXT, EM_LIMITTEXT, DEFAULT_WRAP_WIDTH*5, 0);
		SetDlgItemText(hdlg, IDE_TEXT, EnterText);
		SetFocus(GetDlgItem(hdlg, IDE_TEXT));
		SendDlgItemMessage(hdlg, IDE_TEXT, EM_SETSEL, 0, -1);
		SendDlgItemMessage(hdlg, IDE_TEXT, EM_FMTLINES, 0, 0);	/* No soft breaks */

#ifdef USING_SIP
		SipShowIM(SIPF_ON);	/* Bring up the keyboard for message typing */
#endif

		CheckDlgButton(hdlg, IDC_ACK, TRUE);

		EntryChanged = FALSE;
		free(tBuffer);
		CenterWindow(hdlg);
		return FALSE;	/* I already set focus */
	}
	case WM_COMMAND:
		if (!MakeFocusControlVisible(hdlg, wp, lp))
		switch (LOWORD(wp))
		{
		case IDB_CANCEL:
			EndDialog(hdlg, IDCANCEL);
			return TRUE;
		case IDB_SEND:
		{	HWND hwndEntry = GetDlgItem(hdlg, IDE_TEXT);
			int TextLen = GetWindowTextLength(hwndEntry);
			if (EntryChanged)
			if (TextLen)
			{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*(TextLen+1)), ToCall[16];
				if (GetDlgItemText(hdlg, IDE_TEXT, Text, TextLen+1))
				if (GetDlgItemText(hdlg, IDL_TO_CALL, ToCall, ARRAYSIZE(ToCall)))
				{	char aToCall[16];
					if (SUCCEEDED(StringCbPrintfA(aToCall, sizeof(aToCall), "%S", ToCall)))
					{	ZeroSSID(aToCall);
						RememberMessageCall(hdlg, &ActiveConfig, aToCall);
#ifdef USING_CHAT
						DisplayChat(CALLSIGN, aToCall);
#endif
						if (SendAPRSMessage(GetParent(hdlg), aToCall, Text, *Text!=*TEXT("?") && IsDlgButtonChecked(hdlg, IDC_ACK)))
							EndDialog(hdlg, IDOK);
						else MessageBox(hdlg, TEXT("SendAPRSMessage Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
					} else MessageBox(hdlg, TEXT("Message Format Failed"), TEXT("IDB_SEND"), MB_OK | MB_ICONERROR);
				}
//				else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDL_TO_CALL"), MB_OK | MB_ICONERROR);
//				else MessageBox(hdlg, TEXT("GetDlgItemText Failed"), TEXT("IDE_TEXT"), MB_OK | MB_ICONERROR);
				free(Text);
			}
//			else MessageBox(hdlg, TEXT("TextLen is ZERO"), TEXT("TextLen"), MB_OK | MB_ICONERROR);
//			else MessageBox(hdlg, TEXT("No Change In Message Text"), TEXT("EntryChanged"), MB_OK | MB_ICONERROR);
			return TRUE;
		}
		case IDE_TEXT:
		{	TCHAR *Text = (TCHAR*)malloc(sizeof(*Text)*80);
			switch (HIWORD(wp))
			{
			case EN_CHANGE:
				EntryChanged = GetDlgItemText(hdlg, IDE_TEXT, Text, 80) > 0;
				break;
			case EN_KILLFOCUS:
				if (GetDlgItemText(hdlg, IDE_TEXT, Text, 80))
					if (!memcmp(Text, EnterText, sizeof(EnterText)))
						SetDlgItemText(hdlg, IDE_TEXT, TEXT(""));
			}
			free(Text);
			return TRUE;
		}
		}
		break;
	}
	return FALSE;
}
#endif

static void PopupTestShape(HWND hwnd, char *Code)
{	char ObjName[16];
	SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
	if (Obj)
	{	TCHAR *LatLon = APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2);
		TraceLogThread("ShapeFile", TRUE, "PopupTestShape:Code(%s)%S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
				Obj->Code,
				LatLon,
				(double) Obj->Lat, (double) Obj->Lon,
				STRING(Obj->ID), STRING(Obj->State),
				STRING(Obj->FIPS), STRING(Obj->Zone),
				STRING(Obj->Office), STRING(Obj->County),
				STRING(Obj->ShortName), STRING(Obj->Name));
		free(LatLon);

	if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
	{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
		Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//		GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
	}
#ifdef OLD_WAY
	size_t Remaining = 2048;
	char *Packet = (char*)malloc(Remaining), *DAO;
	char *Next = Packet;

	TCHAR *LatLon = APRSLatLon(Obj->Lat, Obj->Lon, '\\', 'L', 0, 2, &DAO);	/* Lighthouse */
	SYSTEMTIME stNow;
	GetSystemTime(&stNow);

	stNow.wMinute++;	/* Valid for one minute */
	if (stNow.wMinute >= 60)
	{	stNow.wMinute -= 60;
		if (++stNow.wHour >= 24)
		{	stNow.wHour -= 24;
			stNow.wDay++;
		}
	}

	// Note that we extract the code out of ObjName elsewhere */
	sprintf(ObjName,"TST%-6.6s", Obj->Code);
	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			"ZZZZZZ>%s:;%-9.9s*%02ld%02ld%02ldz%S",
			DESTID, ObjName,
			(long) stNow.wDay, (long) stNow.wHour, (long) stNow.wMinute,
			LatLon);

	if (*Obj->Office)
		StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							"%s-", Obj->Office);

	StringCbPrintfExA(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			"%s %s%s{00000",
			Obj->Code, 
			*Obj->County?Obj->County:(*Obj->ShortName?Obj->ShortName:Obj->Name),
			DAO);

	TraceLogThread("ShapeFile", TRUE, "Test(%s) %s\n", Obj->Code, Packet);
	AprsLogInternalPacket("ZoneTest", hwnd, Packet, TRUE);
#else
	SYSTEMTIME stNow;
	GetSystemTime(&stNow);
	__int64 msNow = llGetMsec();

	sprintf(ObjName,"TST%-6.6s", Obj->Code);

	BOOL New = FALSE;
	STATION_INFO_S *Station = GetOrCreateStationID(hwnd, ObjName, CALLSIGN, msNow, &New);

	Station->isymbol = SymbolInt('\\','L');	 /* Lighthouse */

	UpdateStationPosition(hwnd, Station, Obj->Lat, Obj->Lon, 0, FALSE, CALLSIGN, &stNow, TRUE, msNow);

	stNow.wMinute++;	/* Valid for one minute */
	if (stNow.wMinute >= 60)
	{	stNow.wMinute -= 60;
		if (++stNow.wHour >= 24)
		{	stNow.wHour -= 24;
			stNow.wDay++;
		}
	}

	Station->Time.day = (char) stNow.wDay;
	Station->Time.hour = (char) stNow.wHour;
	Station->Time.minute = (char) stNow.wMinute;

	if (Station->pComment) free(Station->pComment);
	Station->sComment = 128;
	Station->pComment = (TCHAR*)malloc(Station->sComment*sizeof(Station->pComment));

	StringCbPrintf(Station->pComment, Station->sComment*sizeof(TCHAR),
			TEXT("%S%S%S %S{00000"),
			Obj->Office?Obj->Office:"",
			Obj->Office?"-":"",
			Obj->Code, 
			*Obj->County?Obj->County:(*Obj->ShortName?Obj->ShortName:Obj->Name));
	Station->sComment = wcslen(Station->pComment);
	Station->MultiLine = ShapeToML(Obj, Station->MultiLine, 'l');

	TraceLog("ShapeFile", TRUE, hwnd, "PopupTestShape:Created(%s) Comment(%S)\n",
			Station->Station, Station->pComment);

	Station->isNWS = TRUE;
	Station->isNWSIssued = TRUE;
	Station->isObject = TRUE;
	Station->isMyObject = TRUE;
	Station->isKilled = FALSE;
	Station->HeardInternal = TRUE;

	strncpy(Station->IGate, CALLSIGN, sizeof(Station->IGate));
	GetSystemTime(&Station->stLast);
	Station->lastMsec = msNow;	/* Mark the time */

	Station->pPlatform = _strdup(PROGNAME);
	Station->tPlatform = PLATFORM_APRSIS32;

	InvalidateCircle(hwnd, TRUE);

	UpdateStationVisibility(Station, "TestObject", FALSE, TRUE);

#endif
	HWND hwndTracker = CreateTrackerWindow(ObjName, CALLSIGN, 0, "0");
	if (hwndTracker)
		PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);

		FreeShapeObject("PopupTestShape", Obj);
	}
}

static STATION_INFO_S *MakeOfficeObject(HWND hwnd, char *ObjName, char *Comment)
{	STATION_INFO_S *Object;
	__int64 msNow = llGetMsec();

	BOOL New = FALSE;
	Object = GetOrCreateStationID(hwnd, ObjName, CALLSIGN, msNow, &New);

	Object->isymbol = SymbolInt('\\','L');	 /* Lighthouse */

	if (Object->pComment) free(Object->pComment);
	Object->sComment = 128;
	Object->pComment = (TCHAR*)malloc(Object->sComment*sizeof(Object->pComment));

	StringCbPrintf(Object->pComment, Object->sComment*sizeof(TCHAR),
					TEXT("%S"), Comment);
	Object->sComment = wcslen(Object->pComment);

TraceLog("CWAZones", TRUE, hwnd, "PopupEnabledCWAs:Created(%s) Comment(%S)\n",
		Object->Station, Object->pComment);

	{	SYSTEMTIME stNow;
		GetSystemTime(&stNow);
		if (++stNow.wHour >= 24)
		{	stNow.wHour -= 24;
			stNow.wDay++;
		}
		Object->Time.day = (char) stNow.wDay;
		Object->Time.hour = (char) stNow.wHour;
		Object->Time.minute = (char) stNow.wMinute;
	}

	Object->isNWS = TRUE;
	Object->isNWSIssued = TRUE;
	Object->isObject = TRUE;
	Object->isMyObject = TRUE;
	Object->isKilled = FALSE;
	Object->HeardInternal = TRUE;

	strncpy(Object->IGate, CALLSIGN, sizeof(Object->IGate));
	GetLocalTime(&Object->stLast);
	Object->lastMsec = msNow;	/* Mark the time */

	Object->pPlatform = _strdup(PROGNAME);
	Object->tPlatform = PLATFORM_APRSIS32;

	return Object;
}

static void PopupEnabledCWAs(HWND hwnd, BOOL ShowIndividual)
{	STATION_INFO_S *AllOffices = NULL;
	int TotalCount = 0;
	TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
	size_t ErrRemain = (pList->Count*10+80)*sizeof(TCHAR);
	TCHAR *ErrBuff = (TCHAR*)malloc(ErrRemain);
	TCHAR *ErrNext = ErrBuff;
	unsigned long w;

	for (w=0; w<pList->Count; w++)
	if (*pList->Entries[w].string != '*'	/* Not *ALL* */
	&& !pList->Entries[w].value)		/* And not disabled */
		TotalCount++;

	if (!TotalCount)
	{	MessageBox(hwnd, TEXT("No (non-*ALL*) Enabled NWS Offices to Display"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
		return;
	}

	TotalCount = 0;
	for (w=0; w<pList->Count; w++)
	if (*pList->Entries[w].string != '*'	/* Not *ALL* */
	&& !pList->Entries[w].value)		/* And not disabled */
	{	SHAPEFILE_OBJECT_S **Objs = GetCWAZones(pList->Entries[w].string);
		int ThisCount = 0;

		STATION_INFO_S *Office = NULL;
		int OfficeCount = 0;

		if (Objs)
		{	for (int i=0; Objs[i]; i++)
			{	if (strlen(Objs[i]->Code) == 6)
				{
					//SpinMessages(hwnd);
	SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Objs[i]->Code);
	if (Obj)
	{
	TotalCount++;
	ThisCount++;

#ifdef VERBOSE
	TraceLogThread("CWAZones", TRUE, "PopupEnabledCWAs:Code(%s)%S @ %.5lf %.5lf ID(%.*s) State(%.*s) FIPS(%.*s) Zone(%.*s) Office(%.*s) County(%.*s) ShortName(%.*s) Name(%.*s)\n",
				Obj->Code,
				APRSLatLon(Obj->Lat, Obj->Lon, ' ', ' ', 2),
				(double) Obj->Lat, (double) Obj->Lon,
				STRING(Obj->ID), STRING(Obj->State),
				STRING(Obj->FIPS), STRING(Obj->Zone),
				STRING(Obj->Office), STRING(Obj->County),
				STRING(Obj->ShortName), STRING(Obj->Name));
#endif

	if (Obj->Lat == 0.0 && Obj->Lon == 0.0)
	{	Obj->Lat = (Obj->minLat + Obj->maxLat) / 2.0;
		Obj->Lon = (Obj->minLon + Obj->maxLon) / 2.0;
//		GetCoordIndex(Obj->Lat, Obj->Lon, "ObjAvg");
	}

	if (!ShowIndividual)
	{
		if (!AllOffices)	 /* Need to start the Station */
		{	AllOffices = MakeOfficeObject(hwnd, "Off(***)", "NWS Offices{00000");
//			TraceLog("CWAZones", TRUE, hwnd, "PopupEnabledCWAs:Initial Zone(%s)\n", Obj->Code);
			AllOffices->MultiLine = ShapeToML(Obj, AllOffices->MultiLine, 'l');
		} else
		{
//			TraceLog("CWAZones", TRUE, hwnd, "PopupEnabledCWAs:Adding Zone(%s)\n", Obj->Code);
			AddShapeToML(Obj, AllOffices->MultiLine);
		}
		double lat = (AllOffices->pCoord->lat*(TotalCount-1) + Obj->Lat) / TotalCount;
		double lon = (AllOffices->pCoord->lon*(TotalCount-1) + Obj->Lon) / TotalCount;
		AllOffices->pCoord = GetCoordIndex(lat, lon, "AllOffices", AllOffices->Station, AllOffices->pCoord);
	}

	if (ShowIndividual)
	{
		if (!Office)	 /* Need to start the Station */
		{	char OfficeName[16];
			sprintf(OfficeName,"Off(%s)",pList->Entries[w].string);
			char OfficeDesc[80];
			sprintf(OfficeDesc,"NWS Office(%s){%05ld",pList->Entries[w].string, w);
			Office = MakeOfficeObject(hwnd, OfficeName, OfficeDesc);
			Office->MultiLine = ShapeToML(Obj, Office->MultiLine, 'l');
		} else
		{	AddShapeToML(Obj, Office->MultiLine);
		}
		OfficeCount++;
		double lat = (Office->pCoord->lat*(OfficeCount-1) + Obj->Lat) / OfficeCount;
		double lon = (Office->pCoord->lon*(OfficeCount-1) + Obj->Lon) / OfficeCount;
		Office->pCoord = GetCoordIndex(lat, lon, "Office", Office->Station, Office->pCoord);
	}

		FreeShapeObject("PopupEnabledCWAs", Obj);

	} else TraceLog("CWAZones", TRUE, hwnd, "PopupEnabledCWAs:Failed To Build(%s)\n", Objs[i]->Code);
		} else TraceLog("CWAZones", TRUE, hwnd, "PopupEnabledCWAs:Invalid Code(%s)\n", Objs[i]->Code);
			}
			FreeCWAZones(Objs);

	if (Office)
	{	SYSTEMTIME stNow;
		GetSystemTime(&stNow);

		UpdateStationPosition(hwnd, Office, Office->pCoord->lat, Office->pCoord->lon, 0, FALSE, CALLSIGN, &stNow, TRUE, llGetMsec());

		stNow.wMinute++;	/* Valid for one minute */
		if (stNow.wMinute >= 60)
		{	stNow.wMinute -= 60;
			if (++stNow.wHour >= 24)
			{	stNow.wHour -= 24;
				stNow.wDay++;
			}
		}
		Office->Time.day = (char) stNow.wDay;
		Office->Time.hour = (char) stNow.wHour;
		Office->Time.minute = (char) stNow.wMinute;

		InvalidateCircle(hwnd, TRUE);

		UpdateStationVisibility(Office, "NWSOffice", FALSE, TRUE);

		HWND hwndTracker = CreateTrackerWindow(Office->Station, CALLSIGN, 0, "0");
		if (hwndTracker)
			PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);
	}

		} else TraceLogThread("CWAZones", TRUE, "PopupEnabledCWAs(%s):No Zones Found\n", pList->Entries[w].string);
		if (!ThisCount)
		{	StringCbPrintfEx(ErrNext, ErrRemain, &ErrNext, &ErrRemain,
							STRSAFE_IGNORE_NULLS,
							TEXT("%S%S"),
							ErrNext==ErrBuff?"No Zones Found For:\n\n":", ",
							pList->Entries[w].string);
		}
	} else TraceLogThread("CWAZones", TRUE, "PopupEnabledCWAs(%s) Disabled\n", pList->Entries[w].string);

	if (!TotalCount)
		MessageBox(hwnd, TEXT("Failed To Locate Shapes for Enabled NWS Offices"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
	else if (AllOffices)
	{	SYSTEMTIME stNow;
		GetSystemTime(&stNow);
		UpdateStationPosition(hwnd, AllOffices, AllOffices->pCoord->lat, AllOffices->pCoord->lon, 0, FALSE, CALLSIGN, &stNow, TRUE, llGetMsec());

		stNow.wMinute++;	/* Valid for one minute */
		if (stNow.wMinute >= 60)
		{	stNow.wMinute -= 60;
			if (++stNow.wHour >= 24)
			{	stNow.wHour -= 24;
				stNow.wDay++;
			}
		}
		AllOffices->Time.day = (char) stNow.wDay;
		AllOffices->Time.hour = (char) stNow.wHour;
		AllOffices->Time.minute = (char) stNow.wMinute;

		InvalidateCircle(hwnd, TRUE);

		UpdateStationVisibility(AllOffices, "AllOffices", FALSE, TRUE);

		HWND hwndTracker = CreateTrackerWindow(AllOffices->Station, CALLSIGN, 0, "0");
		if (hwndTracker)
			PostMessage(hwndTracker, WM_AUTO_ZOOM, 0, 0);
	}
	if (ErrNext != ErrBuff)
		MessageBox(hwnd, ErrBuff, TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
	free(ErrBuff);
}

void StationPopup(HWND hwnd, CLIENT_INFO_S *cInfo, STATION_INFO_S *Station)
{	char TempTime[32];
	size_t Remaining = sizeof(TCHAR)*2048;
	TCHAR *Buffer=(TCHAR*)malloc(Remaining), *Title=(TCHAR*)malloc(sizeof(*Title)*80);
	TCHAR *Next = Buffer;
	char *symName = GetDisplayableSymbol(Station->isymbol);

	*Buffer = *TEXT("");	/* Initial null termination */

#ifdef EXTREME_DEBUG
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("G+I+R:%ld+%ld+%ld"), (long) Station->Packets[0].IGate, (long) Station->Packets[0].IS, (long) Station->Packets[0].RF);
#endif

	if (Station->isMyObject)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("*** MY OBJECT! ***\n"));
	if (Station->isKilled)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("*** KILLED OBJECT! ***\n"));

	if (ActiveConfig.View.Nicknames
	&& Station->Nickname)
	{	NICKNAME_INFO_S *pNick = Station->Nickname;
		if (!pNick->Enabled)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT("** Disabled Nickname **\n"));
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT("Label: %S\n"),
						*pNick->Label?pNick->Label:"*BLANK*");
		if (pNick->OverrideSymbol)
		{	char *symName2 = GetDisplayableSymbol(SymbolInt(pNick->Symbol.Table, pNick->Symbol.Symbol));
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT("Sym: %S"),
						symName2);
			if (isprint(pNick->Symbol.Table&0xff)
			&& isprint(pNick->Symbol.Symbol&0xff))
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT(" (%c%c)\n"),
						(TCHAR) pNick->Symbol.Table,
						(TCHAR) pNick->Symbol.Symbol);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT(" (0x%ld 0x%ld)\n"),
						(long) pNick->Symbol.Table,
						(long) pNick->Symbol.Symbol);
			free(symName2);
		}
		if (*pNick->Comment)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("Cmnt: %S\n"), pNick->Comment);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT("\n"));
	}
	
/*	See if it has an NWS comment */
	{	int iday, ihour, iminute;
		TCHAR *c = GetNWSIssued(Station, &iday, &ihour, &iminute);
		if (!c && Station->sComment) c = wcsrchr(Station->pComment,TEXT('{'));
		TCHAR *oc = c, *o = NULL;
		if (!c)
		{	c = Station->sComment?Station->pComment+Station->sComment-1:NULL;
			iday = ihour = iminute = 0;
		} else
		{	o = wcschr(Station->pComment,TEXT('}'));	/* Any multiline? */
			if (o && o < c) c = o; else o = NULL;
		}

		if (Station->sComment && *Station->pComment)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%.*s\n"), (int) (c-Station->pComment), Station->pComment);

		if (Station->sStatusReport && *Station->pStatusReport)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%s\n"), Station->pStatusReport);

		if (Station->ShriekMask)
		{	unsigned long i;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("Shrieks:"));
			for (i=0; i<ShriekCount; i++)
				if (Station->ShriekMask & Shrieks[i].Mask)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT(" %S"), Shrieks[i].Name);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n"));
		}

		if (Station->MultiLine)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("Multi: %ld/%ld Points %ld Parts\n"),
					(long) Station->MultiLine->Tracker[cInfo->Index].ptEnds
					? Station->MultiLine->Tracker[cInfo->Index].ptEnds[Station->MultiLine->Segments-1]
					: 0,
					(long) Station->MultiLine->Count,
					(long) Station->MultiLine->Segments);
			if (Station->MultiLine->SourceString)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("Source: %S%S\n"),
					Station->MultiLine->SourceString,
					Station->MultiLine->Errors?" (ERROR)":"");
			if (oc && o && o < oc)	/* Got a multiline to show? */
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("ML: %s\n"), o);
//								TEXT("ML: %.*s\n"), (oc-o)-1, o+1);
		}

		if (Station->isNWS && Station->pNWSTimes)
		{	char Temp[80];
			SYSTEMTIME stNow;
			NWS_TIMES_S *pTime = Station->pNWSTimes;
			GetSystemTime(&stNow);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("%S: %02ld %02ld:%02ldz\n"),
							Station->isNWSIssued?"Issued":"Forecast",
							(long) pTime->stIssued.wDay, 
							(long) pTime->stIssued.wHour, 
							(long) pTime->stIssued.wMinute);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("Expire: %02ld %02ld:%02ldz (%S)\n"),
							(long) pTime->stExpires.wDay, 
							(long) pTime->stExpires.wHour, 
							(long) pTime->stExpires.wMinute,
							FormatDeltaTime(DeltaSeconds(&stNow,&pTime->stExpires),
											Temp, sizeof(Temp)));
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("Duration: %S\n"),
							FormatDeltaTime(DeltaSeconds(&pTime->stIssued,&pTime->stExpires),
											Temp, sizeof(Temp)));
		}
	}

	if (*Buffer) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));

	if (Station->Frequency)
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("Freq: %.3lfMHz"),
							(double) Station->Frequency->freq);
		if (Station->Frequency->altfreq)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("/%.3lfrx%S"),
							(double) Station->Frequency->altfreq,
							Station->Frequency->altfreq == Station->Frequency->freq?"(BOGUS)":"");
		if (Station->Frequency->tonetype)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								Station->Frequency->tone?TEXT(" %c:%03ld"):TEXT(" %c:None"),
								Station->Frequency->tonetype, (long) Station->Frequency->tone);
		if (Station->Frequency->offset)
			if (abs(Station->Frequency->offset) >= 100)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %S%.2lfMHz"),
							Station->Frequency->offset>0?"+":"",
							(double) Station->Frequency->offset/100.0);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %S%ldKHz"),
							Station->Frequency->offset>0?"+":"",
							Station->Frequency->offset*10);
		if (Station->Frequency->standardoffset)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %coffset"),
							Station->Frequency->standardoffset);
		if (Station->Frequency->range)
		{	if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" %ldkm"),
					(long) (Station->Frequency->range*KmPerMile));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" %ldmi"),
					(long) Station->Frequency->range);
		}
		if (Station->Frequency->Issues)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %S"), Station->Frequency->Issues);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
	}

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("Sym: %S"), symName);
	{	char Overlay = (Station->isymbol>>8), Symbol = Station->isymbol&0xff;
		if (Station->isymbol&0xff0000) Overlay = (Station->isymbol>>16)&0xff;
		else Overlay = Overlay?'\\':'/';
		if (isprint(Overlay&0xff) && isprint(Symbol&0xff))
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT(" (%c%c)"), Overlay, Symbol);
		}
	}

	if (Station->WeatherParsed && Station->Weather)
	{	if (Station->Weather->Valid & VALID_WX_TEMPERATURE)
		{	if (ActiveConfig.View.Metric.Temperature)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nTemp: %ldC"),
							(long) (5.0/9.0*(Station->Weather->temperature-32)));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nTemp: %ldF"),
							(long) Station->Weather->temperature);
		}

		if (Station->Weather->Valid & VALID_WX_LUMINOSITY)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nLuminosity: %ldwatt/m"),
							(long) Station->Weather->luminosity);
		}

		if (Station->Weather->Valid & VALID_WX_RADIATION)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nRadiation: %.2lfuSv/h"),
							(double) Station->Weather->radiation/1000.0);
		}

		if (Station->Weather->Valid & VALID_WX_WATER_HEIGHT)
		{	if (ActiveConfig.View.Metric.Altitude)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nWaterHeight: %.1lfm"),
								(double) Station->Weather->water_height/FeetPerMeter);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nWaterHeight: %.1lfft"),
								(double) Station->Weather->water_height);
		}

		if (Station->Weather->Valid & VALID_WX_BATTERY_VOLTS)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nBattery: %.1lfv"),
							(double) Station->Weather->battery_volts);
		}

		if (Station->Weather->Valid & (VALID_WX_WINDSPEED|VALID_WX_GUST))
		{	if (Station->Weather->Valid & VALID_WX_WINDSPEED)
			{	if (ActiveConfig.View.Metric.Windspeed)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldkn %s"),
							(long) (Station->Weather->windspeed), GetCompassPoint(Station->Weather->direction));
				else if (ActiveConfig.View.Metric.Distance)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldkm/h %s"),
							(long) (Station->Weather->windspeed * MilePerNM *KmPerMile + 0.5), GetCompassPoint(Station->Weather->direction));
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldmph %s"),
							(long) (Station->Weather->windspeed * MilePerNM + 0.5), GetCompassPoint(Station->Weather->direction));
			} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind:"));
			if (Station->Weather->Valid & VALID_WX_GUST)
			{	if (ActiveConfig.View.Metric.Windspeed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (Gust:%ld)"),
						(long) (Station->Weather->gust));
				else if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" (Gust:%ld)"),
						(long) (Station->Weather->gust * MilePerNM *KmPerMile + 0.5));
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" (Gust:%ld)"),
						(long) (Station->Weather->gust * MilePerNM + 0.5));
			}
		}

		if (Station->Weather->Valid & (VALID_WX_RAIN_HOUR
									| VALID_WX_RAIN_24HOUR
									| VALID_WX_RAIN_MIDNIGHT))
		{	double rainHour = Station->Weather->rainHour/100.0;
			double rain24Hour = Station->Weather->rain24Hour/100.0;
			double rainDay = Station->Weather->rainMidnight/100.0;
			char *Units = "in";
			if (ActiveConfig.View.Metric.Rainfall)
			{	rainHour *= MmPerInch;
				rain24Hour *= MmPerInch;
				rainDay *= MmPerInch;
				Units = "mm";
			}
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nRain(%S):"), Units);
			if (Station->Weather->Valid & VALID_WX_RAIN_HOUR)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %.2lf/hr"), (double) rainHour);
			if (Station->Weather->Valid & VALID_WX_RAIN_24HOUR)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %.2lf/24h"), (double) rain24Hour);
			if (Station->Weather->Valid & VALID_WX_RAIN_MIDNIGHT)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %.2lf(today)"), (double) rainDay);
		}

		if (Station->Weather->Valid & (VALID_WX_BAROMETER | VALID_WX_HUMIDITY))
		{	if (Station->Weather->Valid & VALID_WX_BAROMETER)
			{	if (ActiveConfig.View.Metric.Pressure)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nBar: %.1lfmb"), (double) Station->Weather->barometer/10.0);
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nBar: %.2lfin"), (double) Station->Weather->barometer/10.0*InHgPerMb);
			}

			if (Station->Weather->Valid & VALID_WX_HUMIDITY)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%SHum: %ld%%"),
							(Station->Weather->Valid & VALID_WX_BAROMETER)?" ":"\n",
							Station->Weather->humidity);
		}

		if (Station->Weather->Valid & VALID_WX_PLATFORM)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nSoft: %S"), Station->Weather->Platform);
		if (Station->Weather->Valid & VALID_WX_UNIT)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nUnit: %S"), Station->Weather->Unit);

		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n"));
	}

	if (Station->Storm)
	{	STORM_INFO_S *Storm = Station->Storm;
		if (Storm->valid & VALID_STORM_TYPE)
		{	if (!strncmp(Storm->type, "TS", 2))
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nTropical Storm"));
			else if (!strncmp(Storm->type, "HC", 2))
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nHurricane"));
			else if (!strncmp(Storm->type, "TD", 2))
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nTropical Depression"));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nType: %.*S"),
							STRING(Storm->type));
		}

		if (Storm->valid & (VALID_STORM_WINDSPEED|VALID_STORM_GUST))
		{	if (Storm->valid & VALID_STORM_WINDSPEED)
			{	if (ActiveConfig.View.Metric.Windspeed)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldkn"),
							(long) (Storm->windspeed));
				else if (ActiveConfig.View.Metric.Distance)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldkm/h"),
							(long) (Storm->windspeed * MilePerNM *KmPerMile + 0.5));
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind: %ldmph"),
							(long) (Storm->windspeed * MilePerNM + 0.5));
			} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nWind:"));
			if (Storm->valid & VALID_STORM_GUST)
			{	if (ActiveConfig.View.Metric.Windspeed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (Gust:%ld)"),
						(long) (Storm->gust));
				else if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" (Gust:%ld)"),
						(long) (Storm->gust * MilePerNM *KmPerMile + 0.5));
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" (Gust:%ld)"),
						(long) (Storm->gust * MilePerNM + 0.5));
			}
		}

		if (Storm->valid & VALID_STORM_PRESSURE)
		{	if (ActiveConfig.View.Metric.Pressure)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nPress: %.0lfmb"), (double) Storm->pressure);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nPress: %.2lfin"), (double) Storm->pressure*InHgPerMb);
		}

		if (Storm->valid & (VALID_STORM_RADIUS_HURR
									| VALID_STORM_RADIUS_TS
									| VALID_STORM_RADIUS_GALE))
		{	double radHurr = Storm->radius.hurricane*MilePerNM;
			double radTS = Storm->radius.tropical_storm*MilePerNM;
			double radGale = Storm->radius.gale*MilePerNM;
			char *Units = "mi";
			if (ActiveConfig.View.Metric.Distance)
			{	radHurr *= KmPerMile;
				radTS *= KmPerMile;
				radGale *= KmPerMile;
				Units = "km";
			}

			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nRadius(%S):"), Units);
			if (Storm->valid & VALID_STORM_RADIUS_HURR)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" HC:%.0lf"), (double) radHurr);
			if (Storm->valid & VALID_STORM_RADIUS_TS)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" TS:%.0lf"), (double) radTS);
			if (Storm->valid & VALID_STORM_RADIUS_GALE)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" GL:%.0lf"), (double) radGale);
		}
	}

	if (Station->RFID.Type == Station->RFID.GRID
	&& (Station->RFID.Grid.dlat	/* if we've got a delta */
	|| Station->RFID.Grid.dlon
	|| Station->RFID.Grid.offset))	/* or an offset */
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nRFID: %ld %ld %ld %ldx%ld"),
						(long) Station->RFID.Grid.dlat,
						(long) Station->RFID.Grid.dlon,
						(long) Station->RFID.Grid.offset,
						(long) Station->RFID.Grid.rows,
						(long) Station->RFID.Grid.cols);
	}

	if (Station->RFID.Type == Station->RFID.CSESPD
	&& (Station->RFID.CseSpd.course	/* if we've got a course */
	|| Station->RFID.CseSpd.speed))	/* or a speed */
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nRFID: %ld knots @ %ld deg"),
						(long) Station->RFID.CseSpd.speed,
						(long) Station->RFID.CseSpd.course);
	}

	if (Station->MicEIndex)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("\nMic-E: %S%S"), Action->Name, Station->isEmergencySymbol?" (Symbol)":"");
	}
	if (Station->ReplyAck[0])
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("\nReplyAck: %.*S"), sizeof(Station->ReplyAck), Station->ReplyAck);

	if (Station->pPlatform)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("\nApp: %S"), Station->pPlatform);

#ifndef UNDER_CE
	if (Station->sCapabilities && *Station->pCapabilities)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("\nCap: %s"), Station->pCapabilities);
#endif

/*	power 49W, antenna HAAT 40 ft, gain 6 dBi omni, */
	if (Station->pPHG)
	{	if (Station->PHGParsed && Station->pPHG->power)
		{	if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nPHG: %ldw %ld%S %lddBi %s (%.0lfkm)"),
							(long) Station->pPHG->power,
							ActiveConfig.View.Metric.Altitude?(long)(Station->pPHG->height/FeetPerMeter+0.5):Station->pPHG->height,
							ActiveConfig.View.Metric.Altitude?"m":"ft",
							(long) Station->pPHG->gain,
							Station->pPHG->dir?GetCompassPoint(Station->pPHG->dir):TEXT("Omni"),
							Station->pPHG->range*KmPerMile);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nPHG: %ldw %ld%S %lddBi %s (%.0lfmi)"),
							(long) Station->pPHG->power,
							ActiveConfig.View.Metric.Altitude?(long)(Station->pPHG->height/FeetPerMeter+0.5):Station->pPHG->height,
							ActiveConfig.View.Metric.Altitude?"m":"ft",
							(long) Station->pPHG->gain,
							Station->pPHG->dir?GetCompassPoint(Station->pPHG->dir):TEXT("Omni"),
							Station->pPHG->range);
			if (Station->pPHG->rate)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" (%ld/hr)"),
							(long) Station->pPHG->rate);
		} else if (Station->DFSParsed)
		{	if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nDFS: s:%ld %ld%S %lddBi %s (%.1lfkm)"),
							(long) Station->pPHG->sunits,
							ActiveConfig.View.Metric.Altitude?(long)(Station->pPHG->height/FeetPerMeter+0.5):Station->pPHG->height,
							ActiveConfig.View.Metric.Altitude?"m":"ft",
							(long) Station->pPHG->gain,
							Station->pPHG->dir?GetCompassPoint(Station->pPHG->dir):TEXT("Omni"),
							Station->pPHG->range*KmPerMile);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nDFS: s:%ld %ld%S %lddBi %s (%.1lfmi)"),
							(long) Station->pPHG->sunits,
							ActiveConfig.View.Metric.Altitude?(long)(Station->pPHG->height/FeetPerMeter+0.5):Station->pPHG->height,
							ActiveConfig.View.Metric.Altitude?"m":"ft",
							(long) Station->pPHG->gain,
							Station->pPHG->dir?GetCompassPoint(Station->pPHG->dir):TEXT("Omni"),
							Station->pPHG->range);
		} else if (Station->pPHG->range)	/* Compressed packet or RNGnnnn */
		{	if (Station->PHGParsed)	/* Packet specified? */
			{	if (ActiveConfig.View.Metric.Distance)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nRange: %.0lfkm"),
								Station->pPHG->range*KmPerMile);
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nRange: %.0lfmi"),
								Station->pPHG->range);
			} else if (Station->hadAltitude
			&& Station->alt*FeetPerMeter >= ActiveConfig.View.Footprint.MinAltitude
			&& Station->alt*FeetPerMeter <= ActiveConfig.View.Footprint.MaxAltitude)
			{	if (ActiveConfig.View.Metric.Distance)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nFootprint: %.0lfkm"),
								Station->pPHG->range*KmPerMile);
				else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nFootprint: %.0lfmi"),
								Station->pPHG->range);
			}
		}
	}
	if (Station->pBRGNRQ)
	{	if (ActiveConfig.View.Metric.Distance)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nDF: %s (%ld) N:%ld R:%.0lfkm Q:%ld"),
						GetCompassPoint(Station->pBRGNRQ->bearing),
						(long) Station->pBRGNRQ->bearing,
						(long) Station->pBRGNRQ->number,
						(double) Station->pBRGNRQ->range*KmPerMile,
						(long) Station->pBRGNRQ->quality);
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nDF: %s (%ld) N:%ld R:%.0lfmi Q:%ld"),
						GetCompassPoint(Station->pBRGNRQ->bearing),
						(long) Station->pBRGNRQ->bearing,
						(long) Station->pBRGNRQ->number,
						(double) Station->pBRGNRQ->range,
						(long) Station->pBRGNRQ->quality);
	}

#ifndef NO_PATH_TRACKING
	if (Station->PathSize)
	{	unsigned long Hearing = 0, SeenBy = 0;
		char *Hearings = (char*)calloc(SeenStationCount, sizeof(Hearings));
		char *SeenBys = (char*)calloc(SeenStationCount, sizeof(Hearings));
		__int64 msOldest = (cInfo->Paths.MaxAge==-1 || cInfo->Paths.MaxAge==0) ? 0 : (llGetMsec() - cInfo->Paths.MaxAge*1000);
		char dTemp[80];
		unsigned long p;
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%ld/%ld Paths (%ldKb)"),
						(long) Station->PathCount,
						(long) Station->PathSize,
						(long) (sizeof(*Station->Paths)*Station->PathSize+1023)/1024);
		for (p=0; p<(unsigned long) Station->PathCount; p++)
		if (Station->Paths[p].msec >= msOldest)
		{	if (Station->Paths[p].from.SeenIndex == Station->SeenIndex)
			{	SeenBy++;
				SeenBys[Station->Paths[p].to.SeenIndex] = TRUE;
			}
			if (Station->Paths[p].to.SeenIndex == Station->SeenIndex)
			{	Hearing++;
				Hearings[Station->Paths[p].from.SeenIndex] = TRUE;
			}
		}
		if (SeenBy)
		{	if (msOldest)	/* Restricted? */
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nHeardBy(%S):"), FormatDeltaTime(cInfo->Paths.MaxAge,dTemp,sizeof(dTemp)));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nHeardBy:"));
			for (p=0; p<SeenStationCount; p++)
			if (SeenBys[p])
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %.*S"), STRING(SeenStations[p].Station));
			}
		}
		if (Hearing)
		{	if (msOldest)	/* Restricted? */
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nHearing(%S):"), FormatDeltaTime(cInfo->Paths.MaxAge,dTemp,sizeof(dTemp)));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nHearing:"));
			for (p=0; p<SeenStationCount; p++)
			if (Hearings[p])
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %.*S"), STRING(SeenStations[p].Station));
			}
		}
		free(Hearings); free(SeenBys);
	}
	if (Station->PacketPath)
	{	PACKET_PATH_S *PktPath = Station->PacketPath;
		BOOL NeedUnits = PktPath->HopCount <= 2;
		BOOL PlusMore = FALSE;
		double TotalDist = 0;
		char dTemp[80];
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nPacket(%S):"), FormatDeltaTime((llGetMsec()-PktPath->msec)/1000,dTemp,sizeof(dTemp)));
		for (int h=0; h<PktPath->HopCount; h++)
		{
#ifdef UNDER_CE
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S%.*S"), h?" ":"", STRING(SeenStations[PktPath->Hops[h].SeenIndex].Station));
#else
			if (h)
			{	if (PktPath->Hops[h-1].pCoord && PktPath->Hops[h].pCoord)
				{	double distance, bearing;
					AprsHaversineLatLon(PktPath->Hops[h-1].pCoord->lat,
									PktPath->Hops[h-1].pCoord->lon,
									PktPath->Hops[h].pCoord->lat,
									PktPath->Hops[h].pCoord->lon,
									&distance, &bearing);
					TotalDist += distance;
					if (distance > 0)
					{	if (ActiveConfig.View.Metric.Distance)
						{	distance *= KmPerMile;
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT(" %s %.*lf%S"),
										GetCompassPoint((int)bearing),
										(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
										NeedUnits?"km":"");
						} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT(" %s %.*lf%S"),
										GetCompassPoint((int)bearing),
										(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
										NeedUnits?"mi":"");
						NeedUnits = FALSE;
					} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT(" -"));
				} else
				{	PlusMore = TRUE;
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT(" ->"));
				}
			}
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%S%.*S"), h?" ":"",
						STRING(SeenStations[PktPath->Hops[h].SeenIndex].Station));
#endif
		}
#ifndef UNDER_CE
		if (PktPath->HopCount > 2 && TotalDist > 0.0)
		{	if (ActiveConfig.View.Metric.Distance)
			{	TotalDist *= KmPerMile;
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" Total:%.*lfkm%S"),
							(int) min(2,max(0,((int)(2-floor(log10(TotalDist)))))), (double) TotalDist,
							PlusMore?"+":"");
			} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" Total:%.*lfmi%S"),
							(int) min(2,max(0,((int)(2-floor(log10(TotalDist)))))), (double) TotalDist,
							PlusMore?"+":"");
		}
#endif
	}
#endif

	if (Station->TrackSize)
	{	int t, Invalids = 0;
		COLORREF aColor = Station->TrackColorLocked
							? Station->TrackColor
							: (HasNickColor(Station)
								? Station->Nickname->RGB
								: Station->TrackColor);
		for (t=0; t<Station->TrackCount; t++)
		{	if (Station->Tracks[t].Invalid)
				Invalids++;
		}
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%ld/%ld %S Tracks (%ldKb)"),
						(long) Station->TrackCount,
						(long) Station->TrackSize,
						GetRGBColorName(&ActiveConfig, aColor),
						(long) (sizeof(*Station->Tracks)*Station->TrackSize+1023)/1024);
		if (Invalids)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %ld Bad!"), (long) Invalids);
	}

#ifdef SUPPORT_HOURLY_PACKET_COUNT
	{	char *Hourly = BuildHourlyStationString(Station, "\n");
		if (Hourly)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S"), Hourly);
			free(Hourly);
		}
	}
#endif

	if (Station->Ambiguity)
	{static char *Ambiguity[] = { "unknown", "0.1", "1", "10", "60" };	/* Nautical Miles */
		if (Station->Ambiguity < ARRAYSIZE(Ambiguity))
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
				TEXT("\nAmbiguity: %S nm"),
				Ambiguity[Station->Ambiguity]);
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
				TEXT("\nAmbiguity: %S nm"),
				Ambiguity[0]);
		if (Station->gsAmbiguity)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" GS:%d"), (int) Station->gsAmbiguity);
	}
#ifdef UNDER_CE
	else
#endif
	if ((cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (cInfo->LastCenterPosition.dblLatitude != Station->pCoord->lat || cInfo->LastCenterPosition.dblLongitude != Station->pCoord->lon)
	&& (LastGoodPosition.dblLatitude != cInfo->LastCenterPosition.dblLatitude || LastGoodPosition.dblLongitude != cInfo->LastCenterPosition.dblLongitude))
	{	double distance, bearing;
		AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
							cInfo->LastCenterPosition.dblLongitude,
							Station->pCoord->lat, Station->pCoord->lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromCtr: %.*lfkm %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromCtr: %.*lfmi %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
	}
#ifdef UNDER_CE
	else
#else	/* Only on Win32 */
	if (cInfo->CenterStation && !cInfo->CenterTracking	/* Panned away from center? */
	&& cInfo->CenterStation->pCoord		/* Has coordinates? */
	&& cInfo->CenterStation != MyStation)	/* And not ME? */
	{	double distance, bearing;
		AprsHaversineLatLon(Station->pCoord->lat, Station->pCoord->lon,
							cInfo->CenterStation->pCoord->lat,
							cInfo->CenterStation->pCoord->lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nTo:%S: %.*lfkm %s"),
						cInfo->CenterStation->Station,
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nTo:%S: %.*lfmi %s"),
						cInfo->CenterStation->Station,
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
	}
#endif
	if ((LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (LastGoodPosition.dblLatitude != Station->pCoord->lat || LastGoodPosition.dblLongitude != Station->pCoord->lon))
	{	double distance, bearing;
		AprsHaversineLatLon(LastGoodPosition.dblLatitude,
							LastGoodPosition.dblLongitude,
							Station->pCoord->lat, Station->pCoord->lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromME: %.*lfkm %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromME: %.*lfmi %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
#ifndef UNDER_CE
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (%ld)"),
						(long) bearing);
#endif
	}

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\nGridSquare: %S"),
					GridSquare(Station->pCoord->lat, Station->pCoord->lon,
								max(Station->gsAmbiguity,3+Station->latlonExtended)));
	if (Station->gsAmbiguity) 
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" Rcvd:%d"), (int) Station->gsAmbiguity);

	if (Station->alt > 0)	/* Got an altitude? */
	{	if (ActiveConfig.View.Metric.Altitude)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" +%ldm"), (long) (Station->alt));
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" +%ldft"), (long) (Station->alt*FeetPerMeter));
	}

#ifdef UNDER_CE
	TCHAR *LatLon = APRSLatLon(Station->pCoord->lat, Station->pCoord->lon, ' ', ' ', Station->latlonExtended?1:0);
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\n%s"),
					LatLon);
	if (Station->latlonExtended > 1)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("+"),
						(long) Station->latlonExtended);
#else
	TCHAR *LatLon = APRSLatLon(Station->pCoord->lat, Station->pCoord->lon, ' ', ' ', Station->latlonExtended);
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\n%S%s"), Station==MyStation?"Now:":"",
					LatLon);
#endif
	free(LatLon);
	if (Station==MyStation)
	{	GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
	if ((Genius->LastAPRSPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (Genius->LastAPRSPosition.dblLatitude != Station->pCoord->lat
		|| Genius->LastAPRSPosition.dblLongitude != Station->pCoord->lon))
	{
#ifdef UNDER_CE
		TCHAR *LatLon = APRSLatLon(Genius->LastAPRSPosition.dblLatitude, Genius->LastAPRSPosition.dblLongitude, ' ', ' ', ActiveConfig.Beacon.Precision>0?1:0);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%s"),
						LatLon);
		if (ActiveConfig.Beacon.Precision > 1)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("+"),
							(long) Station->latlonExtended);
#else
		TCHAR *LatLon = APRSLatLon(Genius->LastAPRSPosition.dblLatitude, Genius->LastAPRSPosition.dblLongitude, ' ', ' ', ActiveConfig.Beacon.Precision);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nLast:%s"),
						LatLon);
#endif
		free(LatLon);
	}
	}

	if (Station == MyStation)
	{	double zHoursRise, zHoursSet;
		SYSTEMTIME stLocal, stUTC;
		GetLocalTime(&stLocal);	/* Current day */
		GetSystemTime(&stUTC);	/* And UTC */
		if (SunRiseSet(Station->pCoord->lat, Station->pCoord->lon,
						stLocal.wYear, stLocal.wMonth, stLocal.wDay,
						&zHoursRise, &zHoursSet))
		{	__int64 UTCOffset = DeltaSeconds(&stLocal, &stUTC);
			zHoursRise -= UTCOffset/60.0/60.0;
			zHoursSet -= UTCOffset/60.0/60.0;
			while (zHoursRise < 0.0) zHoursRise += 24.0;
			while (zHoursRise > 24.0) zHoursRise -= 24.0;
			while (zHoursSet < 0.0) zHoursSet += 24.0;
			while (zHoursSet > 24.0) zHoursSet -= 24.0;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\nSun Rise: %02ld:%02ld Set: %02ld:%02ld"),
								(long) zHoursRise,
								(long) ((zHoursRise-(long)zHoursRise)*60),
								(long) zHoursSet,
								(long) ((zHoursSet-(long)zHoursSet)*60));
		}
	}

	if (Station->CSEParsed)
	{	if (ActiveConfig.View.Metric.Distance)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nSpd: %ldkm/h %s"),
						(long) (Station->speed * MilePerNM *KmPerMile + 0.5), GetCompassPoint(Station->course));
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nSpd: %ldmph %s"),
						(long) (Station->speed * MilePerNM + 0.5), GetCompassPoint(Station->course));
	}

	if (Station->speedAverage > 1)
	{	if (ActiveConfig.View.Metric.Distance)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nCalc: %ldkm/h Avg: %ldkm/h"),
						(long) (Station->speedCalculated*KmPerMile+0.5),
						(long) (Station->speedAverage*KmPerMile+0.5));
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nCalc: %ldmph Avg: %ldmph"),
						(long) (Station->speedCalculated+0.5),
						(long) (Station->speedAverage+0.5));
	}

	if (Station == MyStation)
	{	FILETIME FileTime, LocalFileTime;
		SYSTEMTIME stLocal;
		GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;

		if (Genius->LastAPRSUpdate)
		{	SystemTimeToFileTime(&Genius->stLastAPRS,&FileTime);
			FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
			FileTimeToSystemTime(&LocalFileTime, &stLocal);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nBea:%04ld-%02ld-%02ld %02ld:%02ld:%02ld (%S)"),
							(long) stLocal.wYear, 
							(long) stLocal.wMonth, 
							(long) stLocal.wDay, 
							(long) stLocal.wHour, 
							(long) stLocal.wMinute, 
							(long) stLocal.wSecond,
							FormatDeltaTime(SecondsSince(&Genius->stLastAPRS),
											TempTime, sizeof(TempTime)));
		}
		SystemTimeToFileTime(&Station->stLast,&FileTime);
		FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
		FileTimeToSystemTime(&LocalFileTime, &stLocal);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nUp:%04ld-%02ld-%02ld %02ld:%02ld:%02ld (%S)"),
						(long) stLocal.wYear, 
						(long) stLocal.wMonth, 
						(long) stLocal.wDay, 
						(long) stLocal.wHour, 
						(long) stLocal.wMinute,
						(long) stLocal.wSecond,
						FormatDeltaTime(SecondsSince(&Station->stLast),
											TempTime, sizeof(TempTime)));
	} else
	{	if (!Station->isNWS)	/* This came out above */
		if (Station->Time.day || Station->Time.hour
		|| Station->Time.minute || Station->Time.second)
		{	if (Station->Time.day == 11
			&& Station->Time.hour == 11
			&& Station->Time.minute == 11
			&& Station->Time.type == 'z')
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\nTime: FIXED (%02ld%02ld%02ld%1S)"),
						(long) Station->Time.day, 
						(long) Station->Time.hour, 
						(long) Station->Time.minute, 
						&Station->Time.type);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\nTime: %02ld-%02ld %02ld:%02ld:%02ld%1S"),
						(long) Station->Time.month, 
						(long) Station->Time.day, 
						(long) Station->Time.hour, 
						(long) Station->Time.minute, 
						(long) Station->Time.second,
						&Station->Time.type);

		}
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%04ld-%02ld-%02ld %02ld:%02ld:%02ld (%S)"),
						(long) Station->stLast.wYear, 
						(long) Station->stLast.wMonth, 
						(long) Station->stLast.wDay, 
						(long) Station->stLast.wHour, 
						(long) Station->stLast.wMinute, 
						(long) Station->stLast.wSecond,
						FormatDeltaTime(SecondsSince(&Station->stLast),
											TempTime, sizeof(TempTime)));

	}
	if (IsValidAltNet(Station->dstCall))
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
		TEXT("\nAltNet: %.*S"), STRING(Station->dstCall));

	if (Station->sPath && *Station->pPath)
	if (Station != MyStation
	|| !APRSIS_Actual
	|| strcmp(Station->pPath, APRSIS_Actual))
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
						STRSAFE_IGNORE_NULLS,
						TEXT("\n%s%S"),
						(Station->sRFpath && *Station->pRFpath)?TEXT("IS: "):TEXT(""),
						Station->pPath);
	}

	if (Station==MyStation && APRSIS_Actual) /* Me gets the currently (last?) connected APRS-IS server */
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, 
						STRSAFE_IGNORE_NULLS,
						TEXT("\n%s%S (%S)"),
						(Station->sRFpath && *Station->pRFpath)?TEXT("Act: "):TEXT(""),
						APRSIS_Actual,
						FormatDeltaTime(llMsecSince(APRSIS_MSec,llGetMsec())/1000,
										TempTime, sizeof(TempTime)));
	}

	if (Station->sRFpath && *Station->pRFpath)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%s%S"),
						(Station->sPath && *Station->pPath)?TEXT("RF: "):TEXT(""),
						Station->pRFpath);

	{	char *Heard = FormatStationHeard(Station);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n%S"), Heard);
		free(Heard);
	}

#ifdef OBSOLETE	/* Now using "Chat" button */
	if (DoesStationMessage(Station))
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n\nSend Message?"));
#endif

	free(symName);

	if (Station->IGate[0])
		StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S via %S%s"),
						Station->Station, Station->IGate,
						Station->Dupes?TEXT("+"):TEXT(""));
	else if (Station->HeardOnRF == 1)
		StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S DIRECT%s"),
						Station->Station,
						Station->RFDupes?TEXT("+"):TEXT(""));
	else if (Station->HeardOnRF)
		StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S via %ld Hops%s"),
						Station->Station, Station->HeardOnRF-1,
						Station->RFDupes?TEXT("+"):TEXT(""));
	else	StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S%S"),
						Station->Station, Station!=MyStation?"":" - ME!");

	if (!DoesStationMessage(Station))
		LwdMessageBox(hwnd, Buffer, Title, MB_OK | MB_ICONINFORMATION, MakeSymbolIcon(hwnd,GetStationSymbol(Station)));
	else if (LwdMessageBox1(hwnd, Buffer, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2, "Chat", FALSE, MakeSymbolIcon(hwnd,GetStationSymbol(Station))))	/* True if button pressed */
	{
#ifdef USING_CHAT
		DisplayChat(CALLSIGN, Station->Station);
#else
		if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Station->Station) == -1)
			MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("ID_SEND_MESSAGE"), MB_OK | MB_ICONERROR);
#endif
#ifdef USING_SIP
		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
	}
	free(Buffer); free(Title);
}

void TelemetryPopup(HWND hwnd, CLIENT_INFO_S *cInfo, STATION_INFO_S *Station)
{	unsigned long t = FindTelemetryCall(Station->Station, TRUE);
	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*512), *Title=(TCHAR*)malloc(sizeof(*Title)*80);
	TCHAR *Next = Buffer;
	size_t Remaining = sizeof(*Buffer)*1024;
	char *symName = GetDisplayableSymbol(Station->isymbol);

	char *Parms[13] = { 0 };
	int ParmCount = 0;
	char *Units[13] = { 0 };
	int UnitCount = 0;
	struct
	{	double a;
		double b;
		double c;
		int Decimal;
	} Eqnss[5] = { { 0, 1, 0, FALSE }, { 0, 1, 0, FALSE }, { 0, 1, 0, FALSE }, { 0, 1, 0, FALSE }, { 0, 1, 0, FALSE } };
	unsigned char BitSense = 0;	/* Default is bits go straight */
	char *Project = "";

	if (!Telemetry[t].PARM) Telemetry[t].PARM = RecallTelemetryDefinition(hwnd, &ActiveConfig, Telemetry[t].Station, "PARM.");

	if (Telemetry[t].PARM)
	{	char *p, *eol;
		p = Parms[ParmCount++] = _strdup(Telemetry[t].PARM+5);	/* Make copy for nulling */

		eol = p+strlen(p)-1;
		while (eol >= p && (*eol=='\n' || *eol=='\r'))
			*eol-- = '\0';

		for (p=Parms[0]; *p; p++)
		{	if (*p == ',')
			{	*p = '\0';	/* Null-terminate previous string */
				if (ParmCount >= ARRAYSIZE(Parms)) break;
				p = Parms[ParmCount++] = _strdup(p+1);
				if (*p==',') p--;	/* Back up to see ,, properly */
			}
		}
	}
	if (ParmCount < ARRAYSIZE(Parms))
	{	while (ParmCount < 5)
		{	char *p = Parms[ParmCount++] = (char*)malloc(5+33+1);
			StringCbPrintfA(p, 5+33+1,
							"Chan %ld", (long) ParmCount);
		}
		while (ParmCount < 13)
		{	char *p = Parms[ParmCount++] = (char*)malloc(5+33+1);
			StringCbPrintfA(p, 5+33+1,
							"Bit %ld", (long) ParmCount-5);
		}
	}

	if (!Telemetry[t].UNIT) Telemetry[t].UNIT = RecallTelemetryDefinition(hwnd, &ActiveConfig, Telemetry[t].Station, "UNIT.");

	if (Telemetry[t].UNIT)
	{	char *p, *eol;
		p = Units[UnitCount++] = _strdup(Telemetry[t].UNIT+5);	/* Make copy for nulling */

		eol = p+strlen(p)-1;
		while (eol >= p && (*eol=='\n' || *eol=='\r'))
			*eol-- = '\0';

		for (p=Units[0]; *p; p++)
		{	if (*p == ',')
			{	*p = '\0';	/* Null-terminate previous string */
				if (UnitCount >= ARRAYSIZE(Units)) break;
				p = Units[UnitCount++] = _strdup(p+1);
				if (*p==',') p--;	/* Back up to see ,, properly */
			}
		}
	}
	if (UnitCount < ARRAYSIZE(Units))
	{	while (UnitCount < 5)
		{	char *p = Units[UnitCount++] = (char*)malloc(33+1);
			StringCbPrintfA(p, 33+1,
							"", (long) UnitCount);
		}
		while (UnitCount < 13)
		{	char *p = Units[UnitCount++] = (char*)malloc(3+33+1);
			StringCbPrintfA(p,3+33+1,
							"off", (long) UnitCount-5);
		}
	}

	if (!Telemetry[t].EQNS) Telemetry[t].EQNS = RecallTelemetryDefinition(hwnd, &ActiveConfig, Telemetry[t].Station, "EQNS.");

	if (Telemetry[t].EQNS)
	{	char *p, *eol;
		char *te[15];
		int tc = 0;

		te[tc++] = _strdup(Telemetry[t].EQNS+5);	/* Make copy for nulling */

		eol = te[0]+strlen(te[0])-1;
		while (eol >= te[0] && (*eol=='\n' || *eol=='\r'))
			*eol-- = '\0';

		for (p=te[0]; *p; p++)
		{	if (*p == ',')
			{	*p = '\0';	/* Null terminate previous string */
				if (tc >= ARRAYSIZE(te)) break;
				te[tc++] = p+1;
			}
		}
		if (tc)
		{	int i;
			char *e;
			for (i=0; i<tc/3; i++)
			{	Eqnss[i].a = strtol(te[i*3+0],&e,10);
				if (*e=='.')
				{	Eqnss[i].Decimal = max(Eqnss[i].Decimal,(int)strlen(e+1));
					Eqnss[i].a = strtod(te[i*3+0],&e);
				}
				Eqnss[i].b = strtol(te[i*3+1],&e,10);
				if (*e=='.')
				{	Eqnss[i].Decimal = max(Eqnss[i].Decimal,(int)strlen(e+1));
					Eqnss[i].b = strtod(te[i*3+1],&e);
				}
				Eqnss[i].c = strtol(te[i*3+2],&e,10);
				if (*e=='.')
				{	Eqnss[i].Decimal = max(Eqnss[i].Decimal,(int)strlen(e+1));
					Eqnss[i].c = strtod(te[i*3+2],&e);
				}
			}
		}
		free(te[0]);
	}

	if (!Telemetry[t].BITS) Telemetry[t].BITS = RecallTelemetryDefinition(hwnd, &ActiveConfig, Telemetry[t].Station, "BITS.");

	if (Telemetry[t].BITS)
	{	char *eol = Telemetry[t].BITS+strlen(Telemetry[t].BITS)-1;
		while (eol >= Telemetry[t].BITS && (*eol=='\n' || *eol=='\r'))
			*eol-- = '\0';
		BitSense = (unsigned char) strtol(Telemetry[t].BITS+5, &Project, 2);
		if (*Project == ',') Project++;
	}

	*Buffer = *TEXT("");	/* Initial null termination */
	if ((Station->sComment && *Station->pComment) || HasNickComment(Station))
	{	if (HasNickComment(Station))
		{	if (Station->sComment && *Station->pComment)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%S\n(%s)\n"),
						Station->Nickname->Comment,
						Station->pComment);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%S\n"),
						Station->Nickname->Comment);
		} else	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%s\n"), Station->pComment);
	}
	if (Station->sStatusReport && *Station->pStatusReport)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%s\n"), Station->pStatusReport);
	if (Station->pPlatform)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("App: %S\n"), Station->pPlatform);

	if (Project && *Project)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("Proj: %S\n"), Project);

	if (!strcmp(Telemetry[t].Station, CALLSIGN))
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
			TEXT("Interval: %ld Min (v%ld)\n"),
			ActiveConfig.Telemetry.Interval,
			(long) ActiveConfig.Telemetry.Version);

	if (*Buffer) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));

	if (Telemetry[t].stLast.wYear)
	{	int i;
		unsigned char Digital = Telemetry[t].Telemetry.Digital;

		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("%04ld-%02ld-%02ld %02ld:%02ld:%02ld"),
					(long) Telemetry[t].stLast.wYear, 
					(long) Telemetry[t].stLast.wMonth, 
					(long) Telemetry[t].stLast.wDay, 
					(long) Telemetry[t].stLast.wHour, 
					(long) Telemetry[t].stLast.wMinute, 
					(long) Telemetry[t].stLast.wSecond);
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nSeq: %ld"), Telemetry[t].Telemetry.Sequence);
		for (i=0; i<ARRAYSIZE(Telemetry[t].Telemetry.Analog); i++)
		{	double Value = Telemetry[t].Telemetry.Analog[i];
			Value = (Eqnss[i].a * Value + Eqnss[i].b) * Value + Eqnss[i].c;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n%S: %.*lf %S"), Parms[i], (int) Eqnss[i].Decimal, Value, Units[i]);
		}
		for (i=0; i<8; i++)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S%S: %S"), i&1?"\t":"\n", Parms[i+5],
							((Digital&0x80)==(BitSense&0x80))?Units[i+5]:(BitSense&0x80)?"off":"on");
			Digital = Digital<<1;
			BitSense = BitSense<<1;
		}
	}

	StringCbPrintf(Title, sizeof(*Title)*80, TEXT("%S (%S)"),
					Telemetry[t].Station, symName);

	MessageBox(hwnd, Buffer, Title, MB_OK | MB_ICONINFORMATION);

	free(Parms[0]); free(Units[0]);
	free(Buffer); free(Title);
	free(symName);
}

static char * SaveTrackToGPX(HWND hwnd, STATION_INFO_S *Station)
{	char *GPXFile;
	FILE *Out;
	int t;

	if (Station->TrackCount < 3) return "No Track To Save";

	GPXFile = GetGPXFileName(hwnd, Station->Station, &Station->Tracks[0].st);
	if (!GPXFile) return "Failed To Get GPX File";

	Out = fopen(GPXFile,"w");
	if (!Out) return "Failed To Create GPX File";

#ifdef FUTURE_SAVE_TRACK
	<gpx version="1.1" creator="APRSISCE/32 2010/06/10 hh:MM">
#endif
	fprintf(Out, "<gpx version=\"1.1\" creator=\"%s %s\">\n", PROGNAME, Timestamp);

#ifdef FUTURE_SAVE_TRACK
		<metadata>
			<name>GPX File Name</name>
			<desc>Content description</desc>
			<author><name>callsign</name></author>
			<link href="http://aprs.fi/callsign"><text>callsign at APRS.FI</text></link>
			<time>creation time in xml timestamp</time>
			<bounds minlat="dec.degrees" minlon="" maxlat="" maxlon="" />
		</metadata>
#endif
	fprintf(Out, "<metadata>\n");
	fprintf(Out, "<name>%s</name>\n", GPXFile);
	fprintf(Out, "<desc>APRS Track For %s</desc>\n", Station->Station);
	fprintf(Out, "<author><name>%s</name></author>\n", Station->Station);
	fprintf(Out, "<link href=\"http://aprs.fi/%s\"><text>%s at APRS.FI</text></link>\n", Station->Station, Station->Station);
	fprintf(Out, "<time>%04ld-%02ld-%02ldT%02ld:%02ld:%02ldZ</time>\n",
			(long) Station->Tracks[0].st.wYear, 
			(long) Station->Tracks[0].st.wMonth, 
			(long) Station->Tracks[0].st.wDay, 
			(long) Station->Tracks[0].st.wHour, 
			(long) Station->Tracks[0].st.wMinute, 
			(long) Station->Tracks[0].st.wSecond);
#ifdef FUTURE
	fprintf(Out, "<bound minlat=\"%.6lf\" minlon=\"%.6lf\" maxlat=\"%.6lf\" maxlon=\"%.6lf\" />\n",
#endif
	fprintf(Out, "</metadata>\n");

#ifdef FUTURE_SAVE_TRACK
		<trk>
			<name>Name of track</name>
			<cmt>Comment for track</cmt>
			<desc>Description of track</desc>
			<number>Track Number</number>
			<trkseg>
#endif
	fprintf(Out, "<trk>\n");
	fprintf(Out, "<trkseg>\n");

#ifdef FUTURE_SAVE_TRACK
				<trkpt lat="" lon=""><ele>Altitude in m</ele><time>UTC xml time</time></trkpt>
				<trkpt>...</trkpt>
				<trkpt>...</trkpt>
#endif
	for (t=0; t<Station->TrackCount; t++)
	if (Station->Tracks[t].st.wYear)	/* Year needs to be non-zero */
	if (Station->Tracks[t].Invalid == TRACK_OK)	/* Only the good ones */
	{
		fprintf(Out,"<trkpt lat=\"%.6lf\" lon=\"%.6lf\">",
				(double) Station->Tracks[t].pCoord->lat,
				(double) Station->Tracks[t].pCoord->lon); 
		if (Station->Tracks[t].alt > 0)
			fprintf(Out,"<ele>%ld</ele>",
					(long) (Station->Tracks[t].alt/FeetPerMeter));
		fprintf(Out,"<time>%04ld-%02ld-%02ldT%02ld:%02ld:%02ldZ</time><name>%02ld:%02ld:%02ld</name></trkpt>\n",
				(long) Station->Tracks[t].st.wYear, 
				(long) Station->Tracks[t].st.wMonth, 
				(long) Station->Tracks[t].st.wDay, 
				(long) Station->Tracks[t].st.wHour, 
				(long) Station->Tracks[t].st.wMinute, 
				(long) Station->Tracks[t].st.wSecond,
				(long) Station->Tracks[t].st.wHour, 
				(long) Station->Tracks[t].st.wMinute, 
				(long) Station->Tracks[t].st.wSecond);
	}
#ifdef FUTURE_SAVE_TRACK
			</trkseg>
			<trkseg>
			<!-- Another on/off GPS set -->
			</trkseg>
		</trk>
	</gpx>
#endif
	fprintf(Out,"</trkseg>\n");
	fprintf(Out,"</trk>\n");
	fprintf(Out,"</gpx>\n");
	fclose(Out);
	return NULL;
}

#ifdef FUTURE_SAVE_TRACK
From: http://www.topografix.com/GPX/1/1/  (Handy popup descriptions there)

Element: gpx
Name 	gpx
Type 	gpxType
Documentation 	GPX is the root element in the XML file.
XML Instance Representation
<gpx
version="1.1 [1] ?"
creator="xsd:string [1] ?">
<metadata> metadataType </metadata> [0..1] ?
<wpt> wptType </wpt> [0..*] ?
<rte> rteType </rte> [0..*] ?
<trk> trkType </trk> [0..*] ?
<extensions> extensionsType </extensions> [0..1] ?
</gpx>

Complex Type: gpxType
Name 	gpxType
Documentation 	GPX documents contain a metadata header, followed by waypoints, routes, and tracks. You can add your own elements to the extensions section of the GPX document.
XML Instance Representation
<...
version="1.1 [1] ?"
creator="xsd:string [1] ?">
<metadata> metadataType </metadata> [0..1] ?
<wpt> wptType </wpt> [0..*] ?
<rte> rteType </rte> [0..*] ?
<trk> trkType </trk> [0..*] ?
<extensions> extensionsType </extensions> [0..1] ?
</...>

Complex Type: metadataType
Name 	metadataType
Documentation 	Information about the GPX file, author, and copyright restrictions goes in the metadata section. Providing rich, meaningful information about your GPX files allows others to search for and use your GPS data.
XML Instance Representation
<...>
<name> xsd:string </name> [0..1] ?
<desc> xsd:string </desc> [0..1] ?
<author> personType </author> [0..1] ?
<copyright> copyrightType </copyright> [0..1] ?
<link> linkType </link> [0..*] ?
<time> xsd:dateTime </time> [0..1] ?
<keywords> xsd:string </keywords> [0..1] ?
<bounds> boundsType </bounds> [0..1] ?
<extensions> extensionsType </extensions> [0..1] ?
</...>

Complex Type: boundsType
Name 	boundsType
Documentation 	Two lat/lon pairs defining the extent of an element.
XML Instance Representation
<...
minlat="latitudeType [1] ?"
minlon="longitudeType [1] ?"
maxlat="latitudeType [1] ?"
maxlon="longitudeType [1] ?"/>

Complex Type: trkType
Name 	trkType
Documentation 	trk represents a track - an ordered list of points describing a path.
XML Instance Representation
<...>
<name> xsd:string </name> [0..1] ?
<cmt> xsd:string </cmt> [0..1] ?
<desc> xsd:string </desc> [0..1] ?
<src> xsd:string </src> [0..1] ?
<link> linkType </link> [0..*] ?
<number> xsd:nonNegativeInteger </number> [0..1] ?
<type> xsd:string </type> [0..1] ?
<extensions> extensionsType </extensions> [0..1] ?
<trkseg> trksegType </trkseg> [0..*] ?
</...>

Complex Type: trksegType
Name 	trksegType
Documentation 	A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
XML Instance Representation
<...>
<trkpt> wptType </trkpt> [0..*] ?
<extensions> extensionsType </extensions> [0..1] ?
</...>
	
Complex Type: wptType
Name 	wptType
Documentation 	wpt represents a waypoint, point of interest, or named feature on a map.
XML Instance Representation
<...
lat="latitudeType [1] ?"
lon="longitudeType [1] ?">
<ele> xsd:decimal </ele> [0..1] ?
<time> xsd:dateTime </time> [0..1] ?
<magvar> degreesType </magvar> [0..1] ?
<geoidheight> xsd:decimal </geoidheight> [0..1] ?
<name> xsd:string </name> [0..1] ?
<cmt> xsd:string </cmt> [0..1] ?
<desc> xsd:string </desc> [0..1] ?
<src> xsd:string </src> [0..1] ?
<link> linkType </link> [0..*] ?
<sym> xsd:string </sym> [0..1] ?
<type> xsd:string </type> [0..1] ?
<fix> fixType </fix> [0..1] ?
<sat> xsd:nonNegativeInteger </sat> [0..1] ?
<hdop> xsd:decimal </hdop> [0..1] ?
<vdop> xsd:decimal </vdop> [0..1] ?
<pdop> xsd:decimal </pdop> [0..1] ?
<ageofdgpsdata> xsd:decimal </ageofdgpsdata> [0..1] ?
<dgpsid> dgpsStationType </dgpsid> [0..1] ?
<extensions> extensionsType </extensions> [0..1] ?
</...>

#endif

static void ExtendMenuItem(HMENU hmenu, UINT ID, char *Parenthetical)
{	MENUITEMINFO mi = {0};
	mi.cbSize = sizeof(mi);
	mi.fMask = MIIM_DATA | MIIM_TYPE;
	if (GetMenuItemInfo(hmenu, ID, MF_BYCOMMAND, &mi)
	&& mi.fType == MFT_STRING)	/* This is what we're looking for */
	{	mi.dwTypeData = (TCHAR*)malloc(sizeof(TCHAR)*++mi.cch);
		if (GetMenuItemInfo(hmenu, ID, MF_BYCOMMAND, &mi))
		{	TCHAR *paren = wcschr(mi.dwTypeData, TEXT('('));
			if (paren)
			{	if (paren != mi.dwTypeData && paren[-1] == TEXT(' '))
					paren[-1] = *TEXT("");
				else *paren = *TEXT("");
			}
			size_t NewSize = sizeof(TCHAR)*(mi.cch+2+strlen(Parenthetical)+1+1);
			TCHAR *New = (TCHAR*)malloc(NewSize);
			StringCbPrintf(New, NewSize, TEXT("%s (%S)"), mi.dwTypeData, Parenthetical);
			free(mi.dwTypeData);
			mi.dwTypeData = New;
			mi.cch = NewSize;
			if (!SetMenuItemInfo(hmenu, ID, MF_BYCOMMAND, &mi))
			{	TraceError(NULL, "SetMenuItemInfo(%ld) to %S FAILED!  LastError=%ld\n", ID, mi.dwTypeData, GetLastError());
			}
		}
		free(mi.dwTypeData);
	}
// else TraceError(NULL, "GetMenuItemInfo(%ld) Failed, LastError=%ld\n", ID, GetLastError());
}

static void NumberMenuItem(HMENU hmenu, UINT ID, long Count, char *Units=NULL)
{	char Buffer[33];
	sprintf(Buffer,"%ld%s",Count,Units?Units:"");
	ExtendMenuItem(hmenu, ID, Buffer);
}

static void NumberOfMenuItem(HMENU hmenu, UINT ID, long Count, long Total, char *Units=NULL)
{	char Buffer[66];
	sprintf(Buffer,"%ld/%ld%s",Count,Total,Units?Units:"");
	ExtendMenuItem(hmenu, ID, Buffer);
}

static void DeltaTimeMenuItem(HMENU hmenu, UINT ID, __int64 DeltaSeconds)
{	char Buffer[66];
	FormatDeltaTime(DeltaSeconds, Buffer, sizeof(Buffer));
	ExtendMenuItem(hmenu, ID, Buffer);
}

static void CheckEnableNumberMenuItem(HMENU hmenu, UINT ID, long Count)
{	//CheckMenuItem (hmenu, ID, Count?MF_CHECKED:MF_UNCHECKED);
	EnableMenuItem(hmenu, ID, Count?MF_ENABLED:MF_GRAYED);
	NumberMenuItem(hmenu, ID, Count);
}

static void StartDriving(CLIENT_INFO_S *cInfo)
{	HWND hwnd = cInfo->hwnd;

	if (cInfo->DriveCount > 1)	/* Any to drive? */
	if (cInfo->zoom < 15
	|| MessageBox(hwnd, TEXT("Really Drive At Tight (15+) Zoom?"), TEXT("Drive MultiLine"), MB_ICONQUESTION | MB_YESNO) == IDYES)
	{
		cInfo->Locked = FALSE;	/* Don't want to be yanked */
		cInfo->Driving = TRUE;
		cInfo->DrivePoint = 0;
		cInfo->DistanceDriven = 0;
		cInfo->LastQueued = 0;
		OSMGetTileServerTotals(NULL, NULL, NULL, NULL,
								&cInfo->StartTilesFetched, 
								NULL, NULL, NULL);
		GetSystemTime(&cInfo->stDriveStart);
		cInfo->DriveDelay = 0;	/* Start with a valid move */
		SetTimer(hwnd, DRIVE_TIMER, DriveRate, NULL);
		TraceLog("Driver", TRUE, hwnd, "Started Driving At %.4lf %.4lf\n",
				cInfo->DrivePoints[0].lat, cInfo->DrivePoints[0].lon);

		SetCenterLatLon(hwnd, cInfo->DrivePoints[0].lat, cInfo->DrivePoints[0].lon);
		if (!cInfo->Index)	/* Main window destinates */
		{	memset(&MyDestination,0,sizeof(MyDestination));
			MyDestination.lat = cInfo->DrivePoints[1].lat;
			MyDestination.lon = cInfo->DrivePoints[1].lat;
			Odometer = 1./5280.;
			ShuffleScreenElements(cInfo->hwnd);
		}
	}
}

static void AddDrivingPoint(CLIENT_INFO_S *cInfo, double lat, double lon)
{	int i = cInfo->DriveCount++;
	if (cInfo->DriveCount > cInfo->DriveSize)
	{	cInfo->DriveSize += 16;	/* Chunk it up */
		cInfo->DrivePoints = (LAT_LON_S*)realloc(cInfo->DrivePoints,sizeof(*cInfo->DrivePoints)*cInfo->DriveSize);
	}
	cInfo->DrivePoints[i].lat = lat;
	cInfo->DrivePoints[i].lon = lon;
}


//#define SELECT_BITS 5	/* Allows for up to 32 (0..31) options */
//#define SELECT_SHIFT (32-SELECT_BITS)
//#define SELECT_MASK ((UINT)-1<<SELECT_SHIFT)
//#define SELECTED(s) (s & SELECT_MASK)
//#define STATION(s) (s & ~SELECT_MASK)

#ifdef FUTURE
#define SELECT_CENTER		((UINT)1<<SELECT_SHIFT)
#define SELECT_INFO			((UINT)2<<SELECT_SHIFT)
#define SELECT_CQLOOKUP		((UINT)3<<SELECT_SHIFT)
#define SELECT_MESSAGE		((UINT)4<<SELECT_SHIFT)
#define SELECT_ADDRESS		((UINT)5<<SELECT_SHIFT)
#define SELECT_TELEMETRY	((UINT)6<<SELECT_SHIFT)
#define SELECT_SAVE_GPX		((UINT)7<<SELECT_SHIFT)
#define SELECT_CLEAR_TRACK	((UINT)8<<SELECT_SHIFT)
#define SELECT_COLOR_TRACK	((UINT)9<<SELECT_SHIFT)
#define SELECT_SHRINK_TRACK	((UINT)10<<SELECT_SHIFT)
#define SELECT_NEW_WINDOW	((UINT)11<<SELECT_SHIFT)
#define SELECT_RANGE		((UINT)12<<SELECT_SHIFT)
#define SELECT_AVRS			((UINT)13<<SELECT_SHIFT)
#define SELECT_NWS_FINGER	((UINT)14<<SELECT_SHIFT)
#define SELECT_NICKNAME		((UINT)15<<SELECT_SHIFT)
#define SELECT_OBJ_EDIT		((UINT)16<<SELECT_SHIFT)
#define SELECT_OBJ_ENABLE	((UINT)17<<SELECT_SHIFT)
#define SELECT_OBJ_VIAIS	((UINT)18<<SELECT_SHIFT)
#define SELECT_OBJ_VIARF	((UINT)19<<SELECT_SHIFT)
#define SELECT_OBJ_KILL		((UINT)20<<SELECT_SHIFT)
#define SELECT_OBJ_ADOPT	((UINT)21<<SELECT_SHIFT)
#define SELECT_OBJ_SEND		((UINT)22<<SELECT_SHIFT)
#define SELECT_OBJ_DRIVE	((UINT)23<<SELECT_SHIFT)
#define SELECT_TRACK_2_AREA	((UINT)24<<SELECT_SHIFT)
#define SELECT_TRACK_2_LINE	((UINT)25<<SELECT_SHIFT)
#define SELECT_DESTINATION	((UINT)26<<SELECT_SHIFT)
#endif
/* Note: Check SELECT_BITS above for max value, currently 31 */

static void MenuOverlayObject(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	unsigned long o = LOWORD(index);
	int p = HIWORD(index);
	if (o>=0 && o<ActiveConfig.Overlays.Count)
	if (ActiveConfig.Overlays.Overlay[o].Enabled)	/* Visible? */
	{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
		if (p>=0 && p<pOver->Runtime.ObjectCount)
		{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[p];

{	size_t Remaining = sizeof(TCHAR)*2048;
	TCHAR *Buffer=(TCHAR*)malloc(Remaining), *Title=(TCHAR*)malloc(sizeof(*Title)*80);
	TCHAR *Next = Buffer;
	char *symName = GetDisplayableSymbol(Obj->isymbol);

	*Buffer = *TEXT("");	/* Initial null termination */
	
	if (Obj->sComment && *Obj->pComment)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%.*s\n"), (int) (Obj->pComment), Obj->pComment);
	if (Obj->sStatusReport && *Obj->pStatusReport)
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%s\n"), Obj->pStatusReport);

	if (*Buffer) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));

	if (Obj->isymbol)
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("Sym: %S"), symName);
		if (((Obj->isymbol>>8)&0xff) <= 1)
		{	char Overlay = (Obj->isymbol>>8), Symbol = Obj->isymbol&0xff;
			if (Obj->isymbol&0xff0000) Overlay = (Obj->isymbol>>16)&0xff;
			else Overlay = Overlay?'\\':'/';
			if (isprint(Overlay&0xff) && isprint(Symbol&0xff))
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT(" (%c%c)"), Overlay, Symbol);
			}
		}
	}

	if (Obj->TrackSize)
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\n%ld/%ld Tracks (%ldKb)"),
						(long) Obj->TrackCount,
						(long) Obj->TrackSize,
						(long) (sizeof(*Obj->Tracks)*Obj->TrackSize+1023)/1024);
	}

	if ((cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (cInfo->LastCenterPosition.dblLatitude != Obj->pCoord->lat || cInfo->LastCenterPosition.dblLongitude != Obj->pCoord->lon)
	&& (LastGoodPosition.dblLatitude != cInfo->LastCenterPosition.dblLatitude || LastGoodPosition.dblLongitude != cInfo->LastCenterPosition.dblLongitude))
	{	double distance, bearing;
		AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
							cInfo->LastCenterPosition.dblLongitude,
							Obj->pCoord->lat, Obj->pCoord->lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromCtr: %.*lfkm %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromCtr: %.*lfmi %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
	}

	if ((LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (LastGoodPosition.dblLatitude != Obj->pCoord->lat || LastGoodPosition.dblLongitude != Obj->pCoord->lon))
	{	double distance, bearing;
		AprsHaversineLatLon(LastGoodPosition.dblLatitude,
							LastGoodPosition.dblLongitude,
							Obj->pCoord->lat, Obj->pCoord->lon,
							&distance, &bearing);
		if (ActiveConfig.View.Metric.Distance)
		{	distance *= KmPerMile;
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromME: %.*lfkm %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
		} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nFromME: %.*lfmi %s"),
						(int) min(2,max(0,((int)(2-floor(log10(distance)))))), (double) distance,
						GetCompassPoint((int)bearing));
#ifndef UNDER_CE
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (%ld)"),
						(long) bearing);
#endif
	}

	if (Obj->alt > 0)	/* Got an altitude? */
	{	if (ActiveConfig.View.Metric.Altitude)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" +%ldm"), (long) (Obj->alt));
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" +%ldft"), (long) (Obj->alt*FeetPerMeter));
	}

#ifdef UNDER_CE
	TCHAR *LatLon = APRSLatLon(Obj->pCoord->lat, Obj->pCoord->lon, ' ', ' ', 1);
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\n%s"),
					LatLon);
#else
	TCHAR *LatLon = APRSLatLon(Obj->pCoord->lat, Obj->pCoord->lon, ' ', ' ', 2);
	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\n%s"),
					LatLon);
#endif
	free(LatLon);

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT("\n%S"),
					pOver->FileName);

	free(symName);

	StringCbPrintExUTF8(Title, sizeof(*Title)*80, NULL, NULL, -1, Obj->ID, NULL);

	LwdMessageBox(hwnd, Buffer, Title, MB_OK | MB_ICONINFORMATION, MakeSymbolIcon(hwnd,Obj->isymbol));
	free(Buffer); free(Title);
}
		}
	}
}

static void MenuOverlayConfig(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	unsigned long o = LOWORD(index);
	int p = HIWORD(index);
	if (o>=0 && o<ActiveConfig.Overlays.Count)
	if (ActiveConfig.Overlays.Overlay[o].Enabled)	/* Visible? */
	{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
		if (p>=0 && p<pOver->Runtime.ObjectCount)
		{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[p];
			PromptOverlayConfig(cInfo->hwnd, WM_REFRESH_CIRCLE, pOver, FALSE);
		}
	}
}

static void MenuOverlayObjectDrive(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	unsigned long o = LOWORD(index);
	int p = HIWORD(index);
	if (o>=0 && o<ActiveConfig.Overlays.Count)
	if (ActiveConfig.Overlays.Overlay[o].Enabled)	/* Visible? */
	{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
		if (p>=0 && p<pOver->Runtime.ObjectCount)
		{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[p];
			if (Obj->TrackCount > 1)
			{	int t;
				cInfo->DriveCount = 0;	/* None to start with */
				for (t=0; t<Obj->TrackCount; t++)
					AddDrivingPoint(cInfo, Obj->Tracks[t].pCoord->lat, Obj->Tracks[t].pCoord->lon);
				StartDriving(cInfo);
			}
		}
	}
}

static void MenuOverlayObjectAdopt(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	unsigned long o = LOWORD(index);
	int p = HIWORD(index);
	if (o>=0 && o<ActiveConfig.Overlays.Count)
	if (ActiveConfig.Overlays.Overlay[o].Enabled)	/* Visible? */
	{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
		if (p>=0 && p<pOver->Runtime.ObjectCount)
		{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[p];
			if (!Obj->TrackCount
			|| MessageBox(hwnd, TEXT("Tracks Will Not Adopt (Yet), Continue?"), TEXT("Make Object"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			if (strlen(Obj->ID) <= 9)
	if (!FindConfigObject(&ActiveConfig, Obj->ID))
	{	char *Comment;
		if (Obj->sComment)
		{	size_t wideLen = wcslen(Obj->pComment)+1;
			size_t multiLen = wideLen*2;
			Comment = (char*)malloc(multiLen);
			WideCharToMultiByte(CP_UTF8, 0,
						Obj->pComment, wideLen, 
						Comment, multiLen, NULL, NULL);
		} else if (Obj->sStatusReport)
		{	size_t wideLen = wcslen(Obj->pStatusReport)+1;
			size_t multiLen = wideLen*2;
			Comment = (char*)malloc(multiLen);
			WideCharToMultiByte(CP_UTF8, 0,
						Obj->pStatusReport, wideLen, 
						Comment, multiLen, NULL, NULL);
		} else Comment = _strdup("");
		char Sym = Obj->isymbol & 0xFF;
		char Tab = Obj->isymbol >> 8;
		if (Obj->isymbol&0xff0000)
			Tab = (Obj->isymbol>>16)&0xff;
		else Tab = Tab?'\\':'/';
		if (!Obj->isymbol
		|| ((Obj->isymbol>>8)&0xff) > 1)
		{	Sym = '.'; Tab = '\\';	/* Circle ? */
		}
		OBJECT_CONFIG_INFO_S *Obj2 = PromptNewObject(hwnd, &ActiveConfig,
						Obj->pCoord->lat, Obj->pCoord->lon,
						Tab, Sym, Comment,
						"Overlays", Obj->ID);
		if (Obj2 && Obj2->Enabled)
		{	TransmitObject(Obj2);
			InvalidateCircle(NULL, TRUE, TRUE);
		}
		free(Comment);
	} else MessageBox(hwnd, TEXT("Object ID Already Defined"), TEXT("Adopt EchoLink"), MB_ICONERROR | MB_OK);
			else MessageBox(hwnd, TEXT("Object ID Too Long"), TEXT("Adopt Waypoint"), MB_ICONERROR | MB_OK);
		}
	}
}

static void MenuSelectGeocache(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	unsigned long g = index;
	HWND hwnd = cInfo->hwnd;
	if (g >= 0 && g < GeocacheCount)
	{	int Len = sizeof(TCHAR)*(strlen(Geocaches[g].Desc)+strlen(Geocaches[g].ShortDesc)+strlen(Geocaches[g].LongDesc)+80);
		TCHAR *Buffer = (TCHAR*)malloc(Len);
		TCHAR ID[32];
		double Lat = Geocaches[g].lat;
		double Lon = Geocaches[g].lon;
		char NS = (Lat<0)?'S':'N';
		char EW = (Lon<0)?'W':'E';
//				GetCoordIndex(Lat, Lon, "GeoCache");
		if (Lat < 0) Lat = -Lat;
		if (Lon < 0) Lon = -Lon;

		StringCbPrintf(Buffer, Len, TEXT("%S: %S %S %.1lf/%.1lf\n%c%02ld %6.3lf %c%02ld %6.3lf\n%S\n\n%S%S%S"),
			Geocaches[g].ID,
			Geocaches[g].Type, Geocaches[g].Container,
			(double)(Geocaches[g].difficulty)/2.0,
			(double)(Geocaches[g].terrain)/2.0,
			NS, (long) floor(Lat), (double) (Lat - floor(Lat))*60.0,
			EW, (long) floor(Lon), (double) (Lon - floor(Lon))*60.0,
			Geocaches[g].Desc, Geocaches[g].ShortDesc,
			Geocaches[g].ShortDesc&&*Geocaches[g].ShortDesc?"\n\n":"",
			Geocaches[g].LongDesc);
		StringCbPrintf(ID, sizeof(ID), TEXT("%.*S"),
			sizeof(Geocaches[g].ID), Geocaches[g].ID);

		for (;;)	/* Loop until break */
		{	int Pushed;
			BUTTONS_S *Buttons = CreateButtons(-1);
			AddButton(Buttons, "Destination", IDYES);
			if (Geocaches[g].Hint && *Geocaches[g].Hint)
				AddButton(Buttons, "Hint", IDRETRY);
			AddButton(Buttons, "Done", IDNO);

			Pushed = LwdMessageBox2(hwnd, Buffer, ID, MB_ICONINFORMATION, Buttons);
			if (Pushed == IDRETRY)	/* Hint */
			{	int Len = sizeof(TCHAR)*(strlen(Geocaches[g].Hint)+strlen(Geocaches[g].Desc)+80);
				TCHAR *Buffer = (TCHAR*)malloc(Len);
				StringCbPrintf(Buffer, Len, TEXT("%S\n\nHint: %S"),
								Geocaches[g].Desc, Geocaches[g].Hint);
				MessageBox(hwnd, Buffer, ID, MB_OK);
				free(Buffer);
			} else if (Pushed == IDYES)
			{	MyDestination.lat = Geocaches[g].lat;
				MyDestination.lon = Geocaches[g].lon;
				strncpy(MyDestination.Owner, "GeoCaches", sizeof(MyDestination.Owner));
				strncpy(MyDestination.Station, Geocaches[g].ID, sizeof(MyDestination.Station));
				ShuffleScreenElements(hwnd);
				break;
			} else if (Pushed == IDNO || Pushed == 0)/* 0=closed */
			{	break;
			} else TraceError(hwnd, "Geocache got %ld\n", (long) Pushed);
		}
		free(Buffer);
	}
}

static void MenuObjectEdit(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	unsigned long id = Obj-ActiveConfig.Objects.Obj;
		char OldName[sizeof(Obj->Name)];
		strncpy(OldName, Obj->Name, sizeof(OldName));
		Obj = PromptConfigObject(hwnd, &ActiveConfig, id);
		if (!Obj || strncmp(Obj->Name, OldName, sizeof(OldName)))
		{	OBJECT_CONFIG_INFO_S *OldObj = FindConfigObject(&ActiveConfig, OldName);
			if (!OldObj || !OldObj->Enabled)	/* Gone or disabled */
			{	STATION_INFO_S *Station = FindStationCall(OldName,CALLSIGN);
				if (Station) Station->isKilled = TRUE;
			}
		} else if (Obj->Enabled)
		{	TransmitObject(Obj);
		} else Station->isKilled = TRUE;
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuObjectEnable(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	Obj->Enabled = !Obj->Enabled;
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		} else Station->isKilled = TRUE;
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuObjectViaIS(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	Obj->ISEnabled = !Obj->ISEnabled;
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		}
	}
}

static void MenuObjectViaRF(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	Obj->RFEnabled = !Obj->RFEnabled;
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		}
	}
}

static void MenuObjectKill(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	Obj->KillXmitCount = 0;
		Obj->Kill = !Obj->Kill;
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		} else Station->isKilled = TRUE;
	} else Station->isKilled = TRUE;
	InvalidateCircle(NULL, TRUE, TRUE);
}

static void MenuObjectShrinkTrack(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;

	if (Station->TrackCount >= 2)
	{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
		int t = Station->TrackCount-2;
		double lat = Station->Tracks[t].pCoord->lat;
		double lon = Station->Tracks[t].pCoord->lon;
		SYSTEMTIME stWhen = Station->Tracks[t].st;
		Station->TrackCount -= 2;
		if (!Station->TrackCount)
			FreeTracks(Station, FALSE);
		UpdateStationPosition(hwnd, Station, lat, lon, 0, FALSE,
							CALLSIGN, &stWhen, TRUE, llGetMsec());
		if (Obj)
		{	Obj->Latitude = lat;
			Obj->Longitude = lon;
			TransmitObject(Obj, TRUE);
		}
		InvalidateStatUsage(FALSE);
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}
	
static void MenuObjectTrack2Line(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	size_t MaxLen = sizeof(Obj->Comment)-4-1;
		char *String = Obj->Compressed
			? TrackToVariableMultiLine(Station, MaxLen)
			: ScaleTrackToMultiLine(Station, MaxLen);
		if (String)
		{	StringCbPrintfA(Obj->Comment, sizeof(Obj->Comment), " }j1%s", String);	/* Trailing {seq included in String */
			Obj->Precision = 2;	/* Force !DAO! as seq */
			free(String);
		} else MessageBox(hwnd, TEXT("MultiLine Format Failed, Track Too Long?"), TEXT("Track To Line"), MB_ICONERROR | MB_OK);
		/* }d0]LPPPSJSJOJNJNLMLLP{I1YAA */
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		}
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuObjectTrack2Area(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (Obj)
	{	size_t MaxLen = sizeof(Obj->Comment)-4-1;
		char *String = Obj->Compressed
			? TrackToVariableMultiLine(Station, MaxLen, TRUE)
			: ScaleTrackToMultiLine(Station, MaxLen, TRUE);
		if (String)
		{	StringCbPrintfA(Obj->Comment, sizeof(Obj->Comment), " }j0%s", String);	/* Trailing {seq included in String */
			Obj->Precision = 2;	/* Force !DAO! as seq */
			free(String);
		} else MessageBox(hwnd, TEXT("MultiLine Format Failed, Track Too Long?"), TEXT("Track To Area"), MB_ICONERROR | MB_OK);
		/* }d0]LPPPSJSJOJNJNLMLLP{I1YAA */
		if (Obj->Enabled)
		{	TransmitObject(Obj);
		}
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuObjectAdopt(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	STATION_INFO_S *Station = (STATION_INFO_S*)pointer;
	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
	if (!Obj)
	{	char *Comment;
		if (Station->sComment)
		{	size_t wideLen = wcslen(Station->pComment)+1;
			size_t multiLen = wideLen*2;
			Comment = (char*)malloc(multiLen);
			WideCharToMultiByte(CP_UTF8, 0,
						Station->pComment, wideLen, 
						Comment, multiLen, NULL, NULL);
		} else Comment = _strdup("");
		char Sym = Station->isymbol & 0xFF;
		char Tab = Station->isymbol >> 8;
		if (Station->isymbol&0xff0000)
			Tab = (Station->isymbol>>16)&0xff;
		else Tab = Tab?'\\':'/';
		Obj = PromptNewObject(hwnd, &ActiveConfig,
						Station->pCoord->lat, Station->pCoord->lon,
						Tab, Sym, Comment,
						"EchoLinks", Station->Station);
		if (Obj && Obj->Enabled)
		{	TransmitObject(Obj);
			InvalidateCircle(NULL, TRUE, TRUE);
		}
		free(Comment);
	} else MessageBox(hwnd, TEXT("Object Name Already Defined"), TEXT("Adopt EchoLink"), MB_ICONERROR | MB_OK);
}
			
static void MenuStationMessage(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
#ifdef USING_CHAT
	DisplayChat(CALLSIGN, Station->Station);
	RememberMessageCall(cInfo->hwnd, &ActiveConfig, Station->Station);
#else
	if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Station->Station) == -1)
		MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("ID_SEND_MESSAGE"), MB_OK | MB_ICONERROR);
#endif
#ifdef USING_SIP
	SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
}
			
static void MenuStationSend(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	STATION_INFO_S *Stat = FindStationCall(LastChatStation);
	if (Stat)
	{	TransmitStationTo(Station, Stat, CALLSIGN);
	} else MessageBox(cInfo->hwnd, TEXT("Chat Station Not Found"), TEXT("Send To"), MB_ICONERROR | MB_OK);
}

static void MenuStationSaveGPX(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	if (Station->AutoSaveGPX)
	{	MessageBox(hwnd, TEXT("No Longer Auto-Saving GPX Tracks"), TEXT("Save GPX Track"), MB_ICONINFORMATION);
		Station->AutoSaveGPX = FALSE;
	} else 
	{	char *Error = SaveTrackToGPX(cInfo->hwnd, Station);
		if (Error) TraceError(hwnd, "SaveTrackToGPX Error %s\n", Error);
		else if (MessageBox(hwnd, TEXT("Auto-Save Future Track Changes?"), TEXT("Save GPX Track"), MB_ICONQUESTION | MB_YESNO) == IDYES)
		{	Station->AutoSaveGPX = TRUE;
		}
	}
}

static void MenuStationColorTrack(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	char *NewColor = ColorPrompt(cInfo->hwnd, "Track Color",
			GetRGBColorName(&ActiveConfig, Station->TrackColor),
			COLORS_AVAILABLE);
	if (NewColor)
	{	Station->TrackColor = GetColorRGB(&ActiveConfig, NewColor, "ColorTrack");
		free(NewColor);
		Station->TrackColorLocked = TRUE;
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuStationColorTrackAltitude(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	Station->TrackColorAltitude = !Station->TrackColorAltitude;
	InvalidateCircle(NULL, TRUE, TRUE);
}

static void MenuStationClearTrack(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;

	if (Station->TrackCount)
	{	TCHAR *Text=(TCHAR*)malloc(sizeof(*Text)*256);
		StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Track Points for %S?"),
			(long) Station->TrackCount, (long) Station->TrackSize,
			HasNickLabelNonBlank(Station)?Station->Nickname->Label:(Station!=MyStation?Station->Station:"Me"));
		if (MessageBox(hwnd, Text, TEXT("Clear Tracks"), MB_YESNO | MB_ICONQUESTION) == IDYES)
		{	if (Station == MyStation)
			{	if (CSVEnabled)	/* If we're CSV-ing, close and re-open a new file */
				{	EnableCSV(hwnd, FALSE, FALSE);
					EnableCSV(hwnd, TRUE, FALSE);
				}
				if (ActiveConfig.Enables.AutoSaveGPX)
					SaveTrackToGPX(hwnd, Station);
			}
			FreeTracks(Station, TRUE);
			InvalidateStatUsage(FALSE);
			InvalidateCircle(NULL, TRUE, TRUE);
		}
		free(Text);
	}
}

static void MenuStationDriveMultiLine(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	int i;

	cInfo->DriveCount = 0;	/* Start with no points */

	TraceLog("Driver", TRUE, hwnd, "Started Driving Along %s\n", Station->Station);

	SetCenterTracking(hwnd, Station, FALSE);

	while (Station && Station->MultiLine)
	{	double lat=0, lon=0;
		for (i=0; i<Station->MultiLine->Count; i++)
		{	lat = Station->MultiLine->Points[i].Lat;
			lon = Station->MultiLine->Points[i].Lon;
			AddDrivingPoint(cInfo, lat, lon);
		}

		if (Station->sComment && Station->pComment)
		{	TCHAR *pcML = wcschr(Station->pComment,TEXT('}'));
			int cLen = pcML - Station->pComment;
			if (cLen > 0)	/* Need a matchable comment */
			for (unsigned long s=0; s<CloseStationCount; s++)
			if (pCloseStations[s]->isObject
			&& pCloseStations[s]->MultiLine
			&& pCloseStations[s]->sComment	/* Must have a matchable comment */
			&& pCloseStations[s]->pComment	/* Must have a matchable comment */
			&& pCloseStations[s]->pCoord
			&& ((pCloseStations[s]->pCoord->lat == lat && pCloseStations[s]->pCoord->lon == lon)
			|| AreCoordinatesEquivalent(pCloseStations[s]->pCoord->lat, pCloseStations[s]->pCoord->lon,
										lat, lon, 0)))
			{	STATION_INFO_S *NewStat = pCloseStations[s];
				TCHAR *ptML = wcschr(NewStat->pComment,TEXT('}'));
				int tLen = ptML - NewStat->pComment;
				if (tLen == cLen
				&& !wcsncmp(Station->pComment, NewStat->pComment, tLen))
				{
					TraceLog("Driver", TRUE, hwnd, "Segment Completed At (or close enough to) %s's %s, Driving through %.*S\n",
							NewStat->Owner, NewStat->Station,
							NewStat->sComment, NewStat->pComment);

					Station = NewStat;
					break;
				} else
					TraceLog("Driver", TRUE, hwnd, "Segment Completed At (or close enough to) %s's %s, But Mismatch (%.*S) vs (%.*S)\n",
							NewStat->Owner, NewStat->Station,
							tLen, NewStat->pComment,
							cLen, Station->pComment);
			}
		}
	}
	StartDriving(cInfo);
}

static void MenuStationDriveTrack(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	int i;

	cInfo->DriveCount = 0;	/* Start with no points */

	TraceLog("Driver", TRUE, hwnd, "Started Driving Along %s\n", Station->Station);

	SetCenterTracking(hwnd, Station, FALSE);

	for (i=0; i<Station->TrackCount; i++)
	if (!Station->Tracks[i].Invalid)
	{	double lat = Station->Tracks[i].pCoord->lat;
		double lon = Station->Tracks[i].pCoord->lon;
		AddDrivingPoint(cInfo, lat, lon);
	}

	StartDriving(cInfo);
}

static void MenuStationTelemetry(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	TelemetryPopup(cInfo->hwnd, cInfo, Station);
}

static void MenuStationKill(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	Station->isKilled = TRUE;
//	UpdateStationVisibility(Station, "Killed", FALSE, FALSE, TRUE);
	InvalidateCircle(NULL, TRUE, TRUE);
}

static void MenuStationAddress(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	ADDRESS_LOOKUP_INFO_S *aInfo = (ADDRESS_LOOKUP_INFO_S *)malloc(sizeof(*aInfo));
	aInfo->hwnd = cInfo->hwnd;
	aInfo->Station = *Station;
	CloseHandle(CreateThread(NULL, 0, AddressLookupThread, aInfo, 0, NULL));
}

static void AddURLsMenuItems(HMENU hSub, CLIENT_INFO_S *cInfo, STRING_LIST_S *pList, STATION_INFO_S *Station, CALLBACK_MENU_R MenuCallback)
{	unsigned long u;
	for (u=0; u<pList->Count; u++)
	{	char *What = _strdup(pList->Entries[u].string);
		char *e = strchr(What,'=');
		if (e)
		{	*e = '\0';	/* Get just the name */
			size_t Len = (strlen(What)+1)*sizeof(TCHAR);
			TCHAR *Text = (TCHAR *)malloc(Len);
			StringCbPrintf(Text, Len, TEXT("%S"), What);
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Text,
								MenuCallback, cInfo, u, Station);
			free(Text);
		}
	}
}

static void MenuInvokeURL(CLIENT_INFO_S *cInfo, STRING_LIST_S *pList, LPARAM index, STATION_INFO_S *Station)
{	if (index >= 0 && (unsigned long) index < pList->Count)
	{	char *c = strchr(pList->Entries[index].string,'=');
		if (c && *++c)
		{	char *p, *What = _strdup(c);
			size_t Len = (strlen(What)+1+sizeof(Station->Station)*4+128)*sizeof(TCHAR);
			TCHAR *URL = (TCHAR*)malloc(Len);
			size_t Remaining = Len;
			TCHAR *Next = URL;
#ifdef UNDER_CE
//			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("iexplore.exe "));
#endif
			p = What;
			while (*p)
			{	char *c = strstr(p, "$Call");
				if (!c) c = strrchr(p,'\0');
				if (c > p)	/* Original stuff to copy over? */
				{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("%.*S"), (int)(c-p), p);
				}
				if (*c)
				{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
									TEXT("%S"), Station->Station);
					p = c + 5;	/* Skip $Call */
				} else p = c;	/* End of the line */
			}
			TraceLog("Activity", TRUE, cInfo->hwnd, "Executing %S\n", URL);
#ifdef UNDER_CE
#ifdef RESTART_CODE
	{	if (OriginalPath[0]
		|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
		{	STARTUPINFO StartupInfo = {0};
			PROCESS_INFORMATION ProcessInfo = {0};

			StartupInfo.cb = sizeof(StartupInfo);
			StartupInfo.lpTitle = NULL;
			//StartupInfo.wShowWindow = SW_SHOW;
			//StartupInfo.dwFlags = STARTF_FORCEONFEEDBACK;
			if (CreateProcess(OriginalPath,TEXT(""),NULL,NULL,FALSE,
					CREATE_NEW_CONSOLE /*| CREATE_NEW_PROCESS_GROUP*/,
					NULL, NULL, &StartupInfo, &ProcessInfo))
			{	CloseHandle(ProcessInfo.hThread);
			}
		}
	}
#endif

			{
	STARTUPINFO StartupInfo = {0};
	PROCESS_INFORMATION ProcessInfo = {0};

	StartupInfo.cb = sizeof(StartupInfo);
	StartupInfo.lpTitle = NULL;
//	StartupInfo.wShowWindow = SW_SHOW;
//	StartupInfo.dwFlags = STARTF_USESHOWWINDOW;

	if (!CreateProcess(TEXT("iexplore.exe"),URL,NULL,NULL,FALSE,
			CREATE_NEW_CONSOLE /*| NORMAL_PRIORITY_CLASS*/,
			NULL, NULL, &StartupInfo, &ProcessInfo))
	{	TraceError(cInfo->hwnd,
			"CreateProcess(%S) Failed, Error %ld\n",
			URL, GetLastError());
	} else if (!CloseHandle(ProcessInfo.hThread))
		TraceError(cInfo->hwnd, "Failed To Close ThreadHandle %p\n",
			(void *) ProcessInfo.hThread);
	else if (!CloseHandle(ProcessInfo.hProcess))
		TraceError(cInfo->hwnd, "Failed To Close ProcessHandle %p\n",
			(void *) ProcessInfo.hProcess);
			}

#else
			ShellExecute(NULL, TEXT("open"), URL, NULL, NULL, SW_SHOWNORMAL);
#endif
			free(URL);
		}
	}
}

static void MenuStationURLs(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	MenuInvokeURL(cInfo, &ActiveConfig.StationURLs, index, Station);
}

static void MenuTelemetryURLs(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	MenuInvokeURL(cInfo, &ActiveConfig.TelemetryURLs, index, Station);
}

static void MenuWeatherURLs(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	MenuInvokeURL(cInfo, &ActiveConfig.WeatherURLs, index, Station);
}

static void MenuStationNickname(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	char *Changed = PromptConfigNickname(hwnd, &ActiveConfig, Station->Station);
	if (Changed)
	{	FixNickname(Changed);
		InvalidateCircle(NULL, TRUE, TRUE);
	}
}

static void MenuStationAVRS(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	HWND hwnd = cInfo->hwnd;
	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	if (Station == MyStation)
		SendAPRSMessage("AVRS", 0, TEXT("?"), FALSE);
	else if (MessageBox(hwnd, TEXT("Warning: This will send AVRS-generated messages to the selected station, Continue?"), TEXT("Initiate AVRS"), MB_YESNO | MB_ICONQUESTION) == IDYES)
	{	TCHAR wToCall[sizeof(Station->Station)];
		StringCbPrintf(wToCall, sizeof(wToCall), TEXT("%S"), Station->Station);
		SendAPRSMessage("AVRS", 0, wToCall, FALSE);
	}
}

static void MenuStationFinger(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	if (Station->isNWS && *Station->IGate && Station->sComment)
	{	TCHAR *seq = wcsrchr(Station->pComment,TEXT('{'));
		if (seq)
		{	NWS_ENTRY_SERVER_S *Srv = GetNWSServer(&ActiveConfig, Station->IGate, Station->Owner, "", FALSE);
			if (Srv && !Srv->Disabled
			&& *Srv->Finger.Server && Srv->Finger.Port)
			{	char Username[80];
				StringCbPrintfA(Username, sizeof(Username), "%s%.3S\r\n", Station->Owner, seq+1);
				int tLen;
				char *aText = Finger(hwnd, Srv->Finger.Server, Srv->Finger.Port, Username, &tLen);
				if (aText && tLen)
				{	size_t Remaining = (tLen+80)*sizeof(TCHAR);
					TCHAR *tText = (TCHAR*)malloc(Remaining);
					StringCbPrintf(tText, Remaining, TEXT("%.*S"), tLen, aText);
					MessageBox(hwnd, tText, Station->pComment, MB_OK | MB_ICONINFORMATION);
					free(tText);
					free(aText);
				} else MessageBox(hwnd, TEXT("Finger Failed"), TEXT("NWS Finger"), MB_OK | MB_ICONERROR);
			}
		}
	}
}

static void MenuStationInfo(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	StationPopup(cInfo->hwnd, cInfo, Station);
}

#ifndef UNDER_CE
static void MenuStationFlashing(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	if (cInfo->Flashing)
	{	FLASHWINFO fw = {0};
		fw.cbSize = sizeof(fw);
		fw.hwnd = cInfo->hwnd;
		fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
		FlashWindowEx(&fw);
		cInfo->Flashing = FALSE;
		cInfo->FlashingAcked = TRUE;
		if (Station->MicEIndex)	/* If there is one... */
		{	if (MessageBox(cInfo->hwnd, TEXT("Ignore Future Notifications?"), TEXT("Wolf-Crier"), MB_ICONQUESTION | MB_YESNO) == IDYES)
			{	DefineIgnoreString(cInfo->hwnd, &ActiveConfig.MicEs.MicE[Station->MicEIndex].Ignores, Station->Station, 1);
				SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Ignore Mic-E");
			}
		}
	}
}
#endif

static void MenuStationMicEIgnored(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	if (Station->MicEIndex == index)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
		if (CheckIgnoreString(cInfo->hwnd, &Action->Ignores, Station->Station))
			DeleteIgnoreString(cInfo->hwnd, &Action->Ignores, Station->Station);
		else DefineIgnoreString(cInfo->hwnd, &Action->Ignores, Station->Station, 1);
		SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Ignore Mic-E");
	}
}

static void MenuStationDXExcluded(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	if (CheckIgnoreString(cInfo->hwnd, &ActiveConfig.DX.Excluded, Station->Station))
		DeleteIgnoreString(cInfo->hwnd, &ActiveConfig.DX.Excluded, Station->Station);
	else DefineIgnoreString(cInfo->hwnd, &ActiveConfig.DX.Excluded, Station->Station, 1);
	SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Ignore DX");
}

static void MenuStationCQLookup(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	HWND hwnd = cInfo->hwnd;
	TCHAR wToCall[24];
	char *e, *e1, *e2;
	e = strchr(Station->Station,'\0');
	e1 = strchr(Station->Station,' ');
	e2 = strchr(Station->Station,'-');
	if (e1 && e1 < e) e = e1;
	if (e2 && e2 < e) e = e2;
	if (SUCCEEDED(StringCbPrintf(wToCall, sizeof(wToCall), TEXT("%S%.*S"),
								ActiveConfig.WhoIsFull?"f ":"",
								(int)(e-Station->Station), Station->Station)))
	{	if (!SendAPRSMessage(/*hwnd,*/ ActiveConfig.WhoIsServer, 0, wToCall, TRUE))
			MessageBox(hwnd, TEXT("SendAPRSMessage Failed"), TEXT("SELECT_CQLOOKUP"), MB_OK | MB_ICONERROR);
	} else MessageBox(hwnd, TEXT("Lookup Format Failed"), TEXT("SELECT_CQLOOKUP"), MB_OK | MB_ICONERROR);
}

static void MenuStationDestination(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	if (!strcmp(MyDestination.Owner, Station->Owner)
	&& !strcmp(MyDestination.Station, Station->Station))
	{	memset(&MyDestination, 0, sizeof(MyDestination));
	} else
	{	strncpy(MyDestination.Owner, Station->Owner, sizeof(MyDestination.Owner));
		strncpy(MyDestination.Station, Station->Station, sizeof(MyDestination.Station));
		MyDestination.lat = Station->pCoord->lat;
		MyDestination.lon = Station->pCoord->lon;
	}
	ShuffleScreenElements(cInfo->hwnd);
}

static void MenuStationCenter(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
	//if (cInfo->CenterStation == Station && cInfo->CenterTracking) Station=MyStation;	/* Go back to me if they uncheck this one! */
	SetCenterTracking(cInfo->hwnd, Station);
}

static void MenuToggleRange(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{
	if (cInfo->Index)
	{	cInfo->CenterRanging = !cInfo->CenterRanging;
		InvalidateCircle(cInfo->hwnd, TRUE, TRUE);
	}
	TransmitFilter();
}
				
static void MenuStationMultiTrack(CLIENT_INFO_S *cInfo, LPARAM index, void *pointer)
{	STATION_INFO_S *Station = (STATION_INFO_S *) pointer;
//TraceError(hwndMain, "Selected MultiTrack(%s)\n", Station->Station);
	for (int tr=1; tr<MAX_TRACKERS; tr++)
	if (!cInfos[tr].Active)
	if (!hwndTracker[tr] || !IsWindow(hwndTracker[tr]))
	{	CreateTrackerWindow(Station->Station, Station->Owner, cInfo->Index);
		break;
	}
//else TraceError(hwndMain, "hwndTracker[%ld]=%p\n", (long) tr, hwndTracker[tr]);
//else TraceError(hwndMain, "hwndTracker[%ld] ACTIVE!\n", (long) tr);
}

static BOOL AddToStationMenu(CLIENT_INFO_S *cInfo, HMENU hPopup, STATION_INFO_S *Station, TCHAR *Label=NULL, SYSTEMTIME *pstPacket=NULL, char *Packet=NULL, int FromRF=0)
{	size_t Remaining = sizeof(TCHAR)*80;
	TCHAR *uCall=(TCHAR*)malloc(Remaining);
	TCHAR *Next = uCall;
	HMENU hSub = CreatePopupMenu();

	if (HasNickLabelNonBlank(Station))
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("%S (%S)"),
				Station->Nickname->Label,
				Station->Station);
	} else
	{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("%S"), Station!=MyStation?Station->Station:"ME");
		if (Station->pPlatform)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" (%S)"), Station->pPlatform);
	}

//	AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, uCall);
	AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, uCall,
						MenuStationInfo, cInfo, 0, Station);
	if (Station->MicEIndex)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
		BOOL Ignored = CheckIgnoreString(cInfo->hwnd, &Action->Ignores, Station->Station);
		if (Action->Enabled)
		if (Action->Highlight)
		{	size_t Remain = sizeof(TCHAR)*80;
			TCHAR *Buffer=(TCHAR*)malloc(Remain);
			TCHAR *Next = Buffer;
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT("Mic-E: %S (%S)"), Action->Name, Action->Color);
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
								MenuStationInfo, cInfo, 0, Station);
			free(Buffer);
		}
#ifndef UNDER_CE
		if (cInfo->Flashing && Action->FlashOnCenter)
		{	AddCallbackMenuItem(hSub, MENU_POS_APPEND, MF_CHECKED | MFS_ENABLED, TEXT("Flashing (Please STOP!)"),
								MenuStationFlashing, cInfo, 0, Station);
		} else	/* Suppresses Ignore Mic-E status immediately below */
#endif
		if (Ignored	/* MUST immediately follow Flashing (Please STOP)! */
		||	((ActiveConfig.Enables.MicENotification
			|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
			&& Action->Enabled
			&& (Action->InternalMessage||Action->MultiTrackNew||Action->MultiTrackActive||Action->FlashOnCenter)))
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, (Ignored?MF_CHECKED:0) | MFS_ENABLED, TEXT("Ignore Mic-E Status"),
								MenuStationMicEIgnored, cInfo, Station->MicEIndex, Station);
	}
	if (Station->Frequency)
	{	size_t Remain = sizeof(TCHAR)*80;
		TCHAR *Buffer=(TCHAR*)malloc(Remain);
		TCHAR *Next = Buffer;

		StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT("%.3lfMHz"),
							(double) Station->Frequency->freq);
		if (Station->Frequency->altfreq)
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT("/%.3lfrx%S"),
							(double) Station->Frequency->altfreq,
							Station->Frequency->altfreq == Station->Frequency->freq?"(BOGUS)":"");
		if (Station->Frequency->tonetype)
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								Station->Frequency->tone?TEXT(" %c:%03ld"):TEXT(" %c:None"),
								Station->Frequency->tonetype, (long) Station->Frequency->tone);
		if (Station->Frequency->offset)
			if (abs(Station->Frequency->offset) >= 100)
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT(" %S%.2lfMHz"),
							Station->Frequency->offset>0?"+":"",
							(double) Station->Frequency->offset/100.0);
			else StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT(" %S%ldKHz"),
							Station->Frequency->offset>0?"+":"",
							Station->Frequency->offset*10);
		if (Station->Frequency->standardoffset)
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT(" %coffset"),
							Station->Frequency->standardoffset);
		if (Station->Frequency->range)
		{	if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" %ldkm"),
					(long) (Station->Frequency->range*KmPerMile));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
					TEXT(" %ldmi"),
					(long) Station->Frequency->range);
		}
		if (Station->Frequency->Issues)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" %S"), Station->Frequency->Issues);

//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Buffer);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
							MenuStationInfo, cInfo, 0, Station);
		free(Buffer);
	}

	if (Station->Storm
	&& (Station->Storm->valid & (VALID_STORM_WINDSPEED|VALID_STORM_GUST)))
	{	size_t BufSize = sizeof(TCHAR)*80;
		TCHAR *Buffer=(TCHAR*)malloc(BufSize);
		size_t Remaining = BufSize;
		TCHAR *Next = Buffer;

		if (Station->Storm->valid & VALID_STORM_TYPE)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%.*S "),
							STRING(Station->Storm->type));
		}

		if (Station->Storm->valid & VALID_STORM_WINDSPEED)
		{	if (ActiveConfig.View.Metric.Windspeed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%ldkn"),
						(long) (Station->Storm->windspeed));
			else if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%ldkm/h"),
						(long) (Station->Storm->windspeed * MilePerNM *KmPerMile + 0.5));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%ldmph"),
						(long) (Station->Storm->windspeed * MilePerNM + 0.5));
		}
		if (Station->Storm->valid & VALID_STORM_GUST)
		{	if (ActiveConfig.View.Metric.Windspeed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" Gust:%ld"),
						(long) (Station->Storm->gust));
			else if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" Gust:%ld"),
						(long) (Station->Storm->gust * MilePerNM *KmPerMile + 0.5));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" Gust:%ld"),
						(long) (Station->Storm->gust * MilePerNM + 0.5));
		}
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Buffer);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
							MenuStationInfo, cInfo, 0, Station);
		free(Buffer);
	} else if (Station->Weather
	&& Station->WeatherParsed
	&& (Station->Weather->Valid&(VALID_WX_TEMPERATURE|VALID_WX_WINDSPEED)))
	{	size_t BufSize = sizeof(TCHAR)*80;
		TCHAR *Buffer=(TCHAR*)malloc(BufSize);
		size_t Remaining = BufSize;
		TCHAR *Next = Buffer;

		if (Station->Weather->Valid & VALID_WX_TEMPERATURE)
		{
			if (ActiveConfig.View.Metric.Temperature)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%ldC"),
							(long) (5.0/9.0*(Station->Weather->temperature-32)));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%ldF"),
							(long) Station->Weather->temperature);
		}

		if (Station->Weather->Valid & VALID_WX_WINDSPEED)
		{	if (ActiveConfig.View.Metric.Windspeed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %ldkn %s"),
						(long) (Station->Weather->windspeed), GetCompassPoint(Station->Weather->direction));
			else if (ActiveConfig.View.Metric.Distance)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %ldkm/h %s"),
						(long) (Station->Weather->windspeed * MilePerNM *KmPerMile + 0.5), GetCompassPoint(Station->Weather->direction));
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" %ldmph %s"),
						(long) (Station->Weather->windspeed * MilePerNM + 0.5), GetCompassPoint(Station->Weather->direction));
		}
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Buffer);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
							MenuStationInfo, cInfo, 0, Station);
		free(Buffer);
	} else if (Station->isNWS)
	{	size_t BufSize = sizeof(TCHAR)*80;
		TCHAR *Buffer=(TCHAR*)malloc(BufSize);
		FormatNWSTitle(Station, Buffer, BufSize);
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Buffer);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
							MenuStationInfo, cInfo, 0, Station);
		free(Buffer);
	} else if (HasNickComment(Station))
	{	size_t BufSize = sizeof(TCHAR)*sizeof(Station->Nickname->Comment);
		TCHAR *Buffer=(TCHAR*)malloc(BufSize);
		StringCbPrintf(Buffer, BufSize, TEXT("%S"), Station->Nickname->Comment);
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Buffer);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Buffer,
							MenuStationInfo, cInfo, 0, Station);
		free(Buffer);
	} else if (Station->sComment && *Station->pComment)
	{	TCHAR *c = wcsrchr(Station->pComment,TEXT('{'));
		TCHAR *s = wcschr(Station->pComment,TEXT('}'));
		if (s && c && s < c) {} else s = NULL;
		if (s) *s = TEXT('\0');
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Station->pComment);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Station->pComment,
							MenuStationInfo, cInfo, 0, Station);
		if (s) *s = TEXT('}');
	} else if (Station->sStatusReport && *Station->pStatusReport)
//		AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, Station->pStatusReport);
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Station->pStatusReport,
							MenuStationInfo, cInfo, 0, Station);

	{	SYSTEMTIME *pst = pstPacket?pstPacket:(Station==MyStation?&ActiveConfig.MyGenius.stLastAPRS:&Station->stLast);

		if (pst->wYear)
		{	size_t Remaining = sizeof(TCHAR)*80;
			TCHAR *uTime = (TCHAR*)malloc(Remaining);
			TCHAR *Next = uTime;
			__int64 Age = SecondsSince(pst);

			if (Age < 0)
			{	StringCbPrintfEx(uTime, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS, 
								TEXT("%04ld-%02ld-%02ld %02ld:%02ld:%02ld"),
								(long) pst->wYear, 
								(long) pst->wMonth, 
								(long) pst->wDay, 
								(long) pst->wHour, 
								(long) pst->wMinute, 
								(long) pst->wSecond);
			} else if (Age == 0)
			{	StringCbPrintfEx(uTime, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS, 
								TEXT("NOW!"));
			} else
			{	char Temp[32];
				StringCbPrintfEx(uTime, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("%S ago"),
							FormatDeltaTime(Age, Temp, sizeof(Temp)));
			}
	if (Station->HeardInternal) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" Internal"));
	if (Station->HeardOnRF) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" LclRF[%ld]"), (long) Station->HeardOnRF-1);
	if (Station->HeardAsRFDigi) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" LclDigi[%ld]"), (long) Station->Packets[0].RFDigi);
	if (Station->HeardAsThird) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" 3rd"));
	if (Station->HeardAsIGate) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" IGATE[%ld]"), (long) Station->Packets[0].IGate);
	if (Station->HeardAsDigi) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" Digi[%ld]"), (long) Station->Packets[0].Digi);
	if (Station->HeardAsTCPIP) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" TCP"));
	if (Station->HeardRemoteRF) StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" RemRF"));

//			AppendMenu(hSub, MF_STRING, SELECT_INFO | Station->Index, uTime);
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, uTime,
								MenuStationInfo, cInfo, 0, Station);
			free(uTime);
		}
	}

	if (Station->isANSRVR)
	{	HMENU hSub1 = CreatePopupMenu();
		int GroupCount = 0;

		for (unsigned int p=0; p<ActiveConfig.ANDefs.Count; p++)
		if (FindANMemberIndex(&ActiveConfig.ANDefs.ANDef[p], Station->Station) != -1)
		{	size_t uRemain = sizeof(TCHAR)*(strlen(ActiveConfig.ANDefs.ANDef[p].Name)+1);
			TCHAR *uGroup = (TCHAR*)malloc(uRemain);
			GroupCount++;
			StringCbPrintf(uGroup, uRemain, TEXT("%S"),
							ActiveConfig.ANDefs.ANDef[p].Name);
			AppendMenu(hSub1, MF_STRING | MF_CHECKED, 0, uGroup);
			free(uGroup);
		}
		AppendMenu(hSub, (GroupCount?MF_CHECKED:0) | MF_POPUP | MF_STRING,
				(UINT_PTR) hSub1, TEXT("ANSRVR"));
	}

	AppendMenu(hSub, MF_SEPARATOR, NULL, NULL);

#ifndef UNDER_CE
	HBITMAP hbm = MakeSymbolBitmap(hwndMain,
						GetStationSymbol(Station),
						GetSystemMetrics(SM_CXMENUCHECK),
						GetSystemMetrics(SM_CYMENUCHECK),
						COLOR_MENU);
	if (hbm) SetMenuItemBitmaps(hSub, 0, MF_BYPOSITION, hbm, hbm);
#endif

#if MAX_TRACKERS > 1
{	BOOL Active = FALSE;
	if (GetFreeTrackerCount(Station,&Active))
	{//	AppendMenu(hSub, MF_STRING | (Active?MF_CHECKED:0), SELECT_NEW_WINDOW | Station->Index, TEXT("MultiTrack"));
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, (Active?MF_CHECKED:0), TEXT("MultiTrack"),
							MenuStationMultiTrack, cInfo, 0, Station);
	}
}
#endif
//	AppendMenu(hSub, (Station==cInfo->CenterStation?MF_CHECKED:0) | MF_STRING, SELECT_CENTER | Station->Index, TEXT("Follow (Center)"));
	AddCallbackMenuItem(hSub, MENU_POS_APPEND, (Station==cInfo->CenterStation?MF_CHECKED:0), TEXT("Follow (Center)"),
						MenuStationCenter, cInfo, 0, Station);

//#ifndef UNDER_CE
if (cInfo->Index)	/* Don't offer this for the main window */
{	if ((cInfo->CenterRanging || ActiveConfig.Range > 0)
	&& (!Station->isObject
		|| (GetFreeRangerCount() && Station==cInfo->CenterStation && RANGE)))
	{//	AppendMenu(hSub, (cInfo->CenterRanging?MF_CHECKED:0) | MF_STRING, SELECT_RANGE | Station->Index, TEXT("Range"));
	UINT id = AddCallbackMenuItem(hSub, MENU_POS_APPEND, (cInfo->CenterRanging?MF_CHECKED:0), TEXT("Range"),
							MenuToggleRange, cInfo, 0, Station);
		if (ActiveConfig.View.Metric.Distance)
			NumberMenuItem(hSub, id,
							(long) (ActiveConfig.Range/10.0*KmPerMile), "km");
		else NumberMenuItem(hSub, id,
							(long) (ActiveConfig.Range/10.0), "mi");
//		if (ActiveConfig.View.Metric.Distance)
//			NumberMenuItem(hSub, SELECT_RANGE | Station->Index,
//							(long) (ActiveConfig.Range/10.0*KmPerMile), "km");
//		else NumberMenuItem(hSub, SELECT_RANGE | Station->Index,
//							(long) (ActiveConfig.Range/10.0), "mi");
	}
}
//#endif

	if (!Station->isCenter)
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Kill Station"),
							MenuStationKill, cInfo, 0, Station);

	if (!cInfo->Index	/* Main window only */
	&& (Station->pCoord->lat || Station->pCoord->lon))
	{	BOOL IsDest = !strcmp(MyDestination.Owner, Station->Owner)
					&& !strcmp(MyDestination.Station, Station->Station);
		UINT Checked = IsDest?MF_CHECKED:0;
//		AppendMenu(hSub, MF_STRING | Checked, SELECT_DESTINATION | Station->Index, TEXT("Set Destination"));
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, Checked, TEXT("Set Destination"),
							MenuStationDestination, cInfo, 0, Station);
	}

	if (ActiveConfig.View.Nicknames)
	if (!Station->isObject || Station->Nickname)
	{	BOOL Checked = ((Station->Nickname&&Station->Nickname->Enabled)?MF_CHECKED:0);
	//	AppendMenu(hSub, ((Station->Nickname&&Station->Nickname->Enabled)?MF_CHECKED:0) | MF_STRING, SELECT_NICKNAME | Station->Index, TEXT("Configure Nickname"));
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, Checked, TEXT("Configure Nickname"),
							MenuStationNickname, cInfo, 0, Station);
	}

	if (ActiveConfig.Enables.Internet)
	{	HMENU hSub1 = CreatePopupMenu();
		AppendMenu(hSub, MF_POPUP | MF_STRING, (UINT_PTR) hSub1, TEXT("Internet"));

		AddURLsMenuItems(hSub1, cInfo, &ActiveConfig.StationURLs, Station, MenuStationURLs);
		if (Station->hasTelemetry)
			AddURLsMenuItems(hSub1, cInfo, &ActiveConfig.TelemetryURLs, Station, MenuTelemetryURLs);
		if (Station->WeatherParsed)
			AddURLsMenuItems(hSub1, cInfo, &ActiveConfig.WeatherURLs, Station, MenuWeatherURLs);

		if (Station->isNWS && *Station->IGate && Station->sComment)
		{	TCHAR *seq = wcsrchr(Station->pComment,TEXT('{'));
			if (seq)
			{	NWS_ENTRY_SERVER_S *Srv = GetNWSServer(&ActiveConfig, Station->IGate, Station->Owner, "", FALSE);
				if (Srv && !Srv->Disabled
				/*&& *Srv->Finger.Server && Srv->Finger.Port*/)
				{	TCHAR Prompt[80];
					UINT Flags = 0;//MF_STRING;
					if (!ActiveConfig.Enables.Internet
					|| !*Srv->Finger.Server || !Srv->Finger.Port) Flags |= MF_GRAYED;
					StringCbPrintf(Prompt, sizeof(Prompt), TEXT("Finger(%S)-%S%.3s"), Srv->EntryCall, Station->Owner, seq+1);
//					AppendMenu(hSub, Flags, SELECT_NWS_FINGER | Station->Index, Prompt);
					AddCallbackMenuItem(hSub1, MENU_POS_APPEND, Flags, Prompt,
										MenuStationFinger, cInfo, 0, Station);
				}
			}
		}
		AddCallbackMenuItem(hSub1, MENU_POS_APPEND, MFS_ENABLED, TEXT("Lookup Address"),
							MenuStationAddress, cInfo, 0, Station);
//		AppendMenu(hSub, MF_STRING, SELECT_ADDRESS | Station->Index, TEXT("Lookup Address"));
	}

	if (Station->TrackCount > 2)
	{	HMENU hSub1 = CreatePopupMenu();
		TCHAR Temp[33];
		StringCbPrintf(Temp, sizeof(Temp), TEXT("Tracks (%ld)"), (long) Station->TrackCount);
		AppendMenu(hSub, MF_POPUP | MF_STRING, (UINT_PTR) hSub1, Temp);
//		if (Station->AutoSaveGPX)
//			AppendMenu(hSub, MF_STRING | MF_CHECKED, SELECT_SAVE_GPX | Station->Index, TEXT("Auto-Save Track"));
//		else AppendMenu(hSub, MF_STRING, SELECT_SAVE_GPX | Station->Index, TEXT("Save Track"));
		if (Station->AutoSaveGPX)
			AddCallbackMenuItem(hSub1, MENU_POS_APPEND, MF_CHECKED, TEXT("Auto-Save Track"),
								MenuStationSaveGPX, cInfo, 0, Station);
		else AddCallbackMenuItem(hSub1, MENU_POS_APPEND, MFS_ENABLED, TEXT("Save Track to GPX"),
								MenuStationSaveGPX, cInfo, 0, Station);
//		AppendMenu(hSub, MF_STRING, SELECT_CLEAR_TRACK | Station->Index, TEXT("Clear Track && Paths"));
		AddCallbackMenuItem(hSub1, MENU_POS_APPEND, MFS_ENABLED, TEXT("Clear Track && Paths"),
							MenuStationClearTrack, cInfo, 0, Station);
		AddCallbackMenuItem(hSub1, MENU_POS_APPEND, MFS_ENABLED, TEXT("Drive Track"),
							MenuStationDriveTrack, cInfo, 0, Station);

		if (!Station->TrackColorLocked
		&& cInfo->CenterStation == Station
		&& Station->alt > 0
		&& ActiveConfig.View.Altitude)
			AddCallbackMenuItem(hSub1, MENU_POS_APPEND, Station->TrackColorAltitude?MF_CHECKED:0, TEXT("Altitude Color Track"),
								MenuStationColorTrackAltitude, cInfo, 0, Station);

		if (!Station->TrackColorAltitude)
		{	COLORREF aColor = Station->TrackColorLocked
								? Station->TrackColor
								: (HasNickColor(Station)
									? Station->Nickname->RGB
									: Station->TrackColor);
			char *colorName = GetRGBColorName(&ActiveConfig, aColor);
			TCHAR tColor[COLOR_SIZE+80];
			StringCbPrintf(tColor, sizeof(tColor), TEXT("Lock Track Color (%S)"),
								colorName);
//			AppendMenu(hSub, MF_STRING | Station->TrackColorLocked?MF_CHECKED:0,
//						SELECT_COLOR_TRACK | Station->Index, tColor);
			AddCallbackMenuItem(hSub1, MENU_POS_APPEND, Station->TrackColorLocked?MF_CHECKED:0, tColor,
								MenuStationColorTrack, cInfo, 0, Station);
		}
	}

	if (!Station->isObject)		/* Not for Objects */
	{//	AppendMenu(hSub, MF_STRING, SELECT_CQLOOKUP | Station->Index, TEXT("WHO-IS Lookup"));
		AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("WHO-IS Lookup"),
							MenuStationCQLookup, cInfo, 0, Station);
		if (Station->hasTelemetry)
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Telemetry"),
								MenuStationTelemetry, cInfo, 0, Station);
//			AppendMenu(hSub, MF_STRING, SELECT_TELEMETRY | Station->Index, TEXT("Telemetry"));
		if (DoesStationMessage(Station))
		{//	AppendMenu(hSub, MF_STRING, SELECT_AVRS | Station->Index, TEXT("AVRS (http://aprs.org/avrs.html)"));
		//	AppendMenu(hSub, MF_STRING, SELECT_MESSAGE | Station->Index, TEXT("Send Message"));
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("AVRS (http://aprs.org/avrs.html)"),
								MenuStationAVRS, cInfo, 0, Station);
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Send Message"),
								MenuStationMessage, cInfo, 0, Station);
		}
	} else
	{
		if (Station->isMyObject)
		{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
			if (Obj)
			{	HMENU hObj = CreatePopupMenu();

				AppendMenu(hSub, MF_POPUP | MF_STRING, (UINT_PTR) hObj, TEXT("My Object"));

//				AppendMenu(hObj, MF_STRING, SELECT_OBJ_EDIT | Station->Index, TEXT("Configure..."));
				AddCallbackMenuItem(hObj, MENU_POS_APPEND, MFS_ENABLED, TEXT("Configure..."),
									MenuObjectEdit, cInfo, 0, Station);
				if (Station->MultiLine
				&& Station->MultiLine->Segments == 1)
					AddCallbackMenuItem(hObj, MENU_POS_APPEND, MFS_ENABLED, TEXT("Drive MultiLine"),
										MenuStationDriveMultiLine, cInfo, 0, Station);
//					AppendMenu(hObj, MF_STRING, SELECT_OBJ_DRIVE | Station->Index, TEXT("Drive MultiLine"));

				if (Station->TrackCount >= 2)
				{//	AppendMenu(hObj, MF_STRING, SELECT_SHRINK_TRACK | Station->Index, TEXT("Shrink Track"));
					AddCallbackMenuItem(hObj, MENU_POS_APPEND, MFS_ENABLED, TEXT("Shrink Track"),
										MenuObjectShrinkTrack, cInfo, 0, Station);
					if (Station->TrackCount >= 3)	/* 3 points describe area */
						AddCallbackMenuItem(hObj, MENU_POS_APPEND, MFS_ENABLED, TEXT("Track to Area"),
											MenuObjectTrack2Area, cInfo, 0, Station);
					// AppendMenu(hObj, MF_STRING, SELECT_TRACK_2_AREA | Station->Index, TEXT("Track to Area"));
					// AppendMenu(hObj, MF_STRING, SELECT_TRACK_2_LINE | Station->Index, TEXT("Track to MultiLine"));
					AddCallbackMenuItem(hObj, MENU_POS_APPEND, MFS_ENABLED, TEXT("Track to MultiLine"),
										MenuObjectTrack2Line, cInfo, 0, Station);
				}

				AppendMenu(hObj, MF_SEPARATOR, NULL, NULL);
				AddCallbackMenuItem(hObj, MENU_POS_APPEND, Obj->Enabled?MF_CHECKED:0, TEXT("Enable"),
									MenuObjectEnable, cInfo, 0, Station);
				AddCallbackMenuItem(hObj, MENU_POS_APPEND, Obj->ISEnabled?MF_CHECKED:0, TEXT("Via -IS"),
									MenuObjectViaIS, cInfo, 0, Station);
				AddCallbackMenuItem(hObj, MENU_POS_APPEND, Obj->RFEnabled?MF_CHECKED:0, TEXT("Via RF"),
									MenuObjectViaRF, cInfo, 0, Station);
				AddCallbackMenuItem(hObj, MENU_POS_APPEND, Obj->Kill?MF_CHECKED:0, TEXT("Kill Object"),
									MenuObjectKill, cInfo, 0, Station);
//				AppendMenu(hObj, MF_STRING | Obj->Enabled?MF_CHECKED:0,
//						SELECT_OBJ_ENABLE | Station->Index, TEXT("Enable"));
//				AppendMenu(hObj, MF_STRING | Obj->ISEnabled?MF_CHECKED:0,
//						SELECT_OBJ_VIAIS | Station->Index, TEXT("Via -IS"));
//				AppendMenu(hObj, MF_STRING | Obj->RFEnabled?MF_CHECKED:0,
//						SELECT_OBJ_VIARF | Station->Index, TEXT("Via RF"));
//				AppendMenu(hObj, MF_STRING | Obj->Kill?MF_CHECKED:0,
//						SELECT_OBJ_KILL | Station->Index, TEXT("Kill Object"));
			} else
			{	if (Station->MultiLine
				&& Station->MultiLine->Segments == 1)
					AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Drive MultiLine"),
										MenuStationDriveMultiLine, cInfo, 0, Station);
//					AppendMenu(hSub, MF_STRING, SELECT_OBJ_DRIVE | Station->Index, TEXT("Drive MultiLine"));
			}
		} else
		{	STATION_INFO_S *Owner = FindStationCall(Station->Owner);
			if (Owner)
			{	TCHAR Temp[80];
				StringCbPrintf(Temp, sizeof(Temp), TEXT("Chat w/Owner %.*S"),
								STRING(Station->Owner));
//				AppendMenu(hSub, MF_STRING, SELECT_MESSAGE | Owner->Index, Temp);
#ifndef MFS_DISABLED	/* WinMo */
#define MFS_DISABLED        MF_GRAYED
#endif
				AddCallbackMenuItem(hSub, MENU_POS_APPEND,  DoesStationMessage(Owner)?MFS_ENABLED:MFS_DISABLED,
									Temp, MenuStationMessage, cInfo, 0, Owner);
			}
			if (Station->Station[0]=='E' && Station->Station[1]=='L'
			&& (Station->Station[2]=='-' || isdigit(Station->Station[2]&0xff))
			&& !strcmp(Station->Owner, "ECHOLINK"))
				AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Adopt EchoLink"),
									MenuObjectAdopt, cInfo, 0, Station);
//				AppendMenu(hSub, MF_STRING, SELECT_OBJ_ADOPT | Station->Index, TEXT("Adopt EchoLink"));

		}

		if (LastChatStation[0])	/* Chatting with someone? */
		{	STATION_INFO_S *Stat = FindStationCall(LastChatStation);
			if (Stat)	/* Have to know the station */
			{	TCHAR Temp[80];
				StringCbPrintf(Temp, sizeof(Temp), TEXT("Send To %.*S"),
								sizeof(LastChatStation), LastChatStation);
				AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Temp,
									MenuStationSend, cInfo, 0, Station);
//				AppendMenu(hSub, MF_STRING, SELECT_OBJ_SEND | Station->Index, Temp);
			}
		}
	}

	AppendMenu(hPopup,
				(Station==cInfo->CenterStation?MF_CHECKED:0) | MF_POPUP | MF_STRING,
				(UINT_PTR) hSub, Label?Label:uCall);

#ifndef UNDER_CE
	hbm = MakeSymbolBitmap(hwndMain,
						GetStationSymbol(Station),
						GetSystemMetrics(SM_CXMENUCHECK),
						GetSystemMetrics(SM_CYMENUCHECK),
						COLOR_MENU);
	if (hbm)
		SetMenuItemBitmaps(hPopup, GetMenuItemCount(hPopup)-1, MF_BYPOSITION, hbm, hbm);
#endif

	free(uCall);
/*
	DX Exclusion list options
*/
	{	BOOL Ignored = CheckIgnoreString(cInfo->hwnd, &ActiveConfig.DX.Excluded, Station->Station);
		if (Ignored || Station->HeardOnRF==1)	/* Direct? */
		{	size_t Remain = sizeof(TCHAR)*80;
			TCHAR *Buffer=(TCHAR*)malloc(Remain);
			TCHAR *Next = Buffer;
			StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
							TEXT("Ignore DX"));
			if (Ignored)
			{	char Buffer[80];
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								TEXT(" (%S)"),
								FormatIgnoreStringDelta(&ActiveConfig.DX.Excluded,
														Station->Station,
														Buffer, sizeof(Buffer)));
			}
			AddCallbackMenuItem(hSub, MENU_POS_APPEND, (Ignored?MF_CHECKED:0) | MFS_ENABLED, Buffer,
								MenuStationDXExcluded, cInfo, 0, Station);
			free(Buffer);
		}
	}
/*
	Now add the station's packet path to the menu
*/
	if (Packet && *Packet)
	{	char *Safe = _strdup(Packet);
		APRS_PARSED_INFO_S *APRS = (APRS_PARSED_INFO_S *) malloc(sizeof(*APRS));
		if (parse_full_aprs(Safe, APRS))
		{	if (APRS->Path.hopCount)
			{	HMENU hPath = CreatePopupMenu();
				TCHAR uStat[STATION_SIZE+16];
				int Used = 0;
				if (FromRF)
				{	AppendMenu(hSub, MF_POPUP | MF_STRING, (UINT_PTR) hPath,TEXT("RF Path"));
				} else 
				{	if (APRS->Path.hopCount > 2)
					{	StringCbPrintf(uStat,sizeof(uStat),TEXT("%S(%S)"),
									(APRS->Path.hopCount>3&&*APRS->Path.Hops[APRS->Path.hopCount-2]=='q')
									? APRS->Path.Hops[APRS->Path.hopCount-2]:"IS",
									APRS->Path.Hops[APRS->Path.hopCount-1]);
					} else StringCbPrintf(uStat,sizeof(uStat),TEXT("IS-Path"));
					AppendMenu(hSub, MF_POPUP | MF_STRING, (UINT_PTR) hPath, uStat);
				}
				for (int h=0; h<APRS->Path.hopCount; h++)
				{	STATION_INFO_S *dStat;
					StringCbPrintf(uStat,sizeof(uStat),TEXT("%S"),APRS->Path.Hops[h]);
					if (APRS->Path.Hops[h][strlen(APRS->Path.Hops[h])-1] == '*')
					{	APRS->Path.Hops[h][strlen(APRS->Path.Hops[h])-1] = '\0';
						Used++;
					} else if (h>1 && h<APRS->Path.hopUnused)
						wcscat(uStat,TEXT("*"));

					dStat = FindStationCall(APRS->Path.Hops[h]);

					if (h==2) AppendMenu(hPath, MF_SEPARATOR, 0,NULL);
					if (h > 1 && dStat	/* Only "real" path components */
					&& (int) dStat->Index != (int) Station->Index)
						AddToStationMenu(cInfo, hPath,dStat,uStat);
					else AppendMenu(hPath,MF_STRING|MF_GRAYED,0,uStat);
				}

				if (FromRF)
				{	TCHAR uStat[64];
					AppendMenu(hPath, MF_SEPARATOR, NULL, NULL);
					if (Used == 0)
						StringCbPrintf(uStat,sizeof(uStat),TEXT("RF(Direct)"));
					else StringCbPrintf(uStat,sizeof(uStat),TEXT("RF(%ld Hop%S)"),
						Used, Used==1?"":"s");
					AppendMenu(hPath,MF_STRING|MF_GRAYED,0,uStat);
					if (Used > pCloseStations[Station->Index]->HeardOnRF)
					{	Used = pCloseStations[Station->Index]->HeardOnRF-1;
						if (Used == 0)
							StringCbPrintf(uStat,sizeof(uStat),TEXT("Best(Direct)"));
						else StringCbPrintf(uStat,sizeof(uStat),TEXT("Best(%ld Hop%S)"),
							Used, Used==1?"":"s");
					}
				}
			}
		}
		free(APRS);
		free(Safe);
	}

	return TRUE;
}

static void TrackStationMenu(HWND hwnd, POINT pt, HMENU hPopup, UINT tpmFlags, TPMPARAMS *tpmp, unsigned long StationCount, char *Packet=NULL, int FromRF=0)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	POINT ptTopLeft, ptBottomRight;
	UINT Selected = 0;
	BOOL Prompted = FALSE;
	HWND hwndPacket = NULL;
#ifdef NOT_ANY_MORE
	APRS_PARSED_INFO_S *APRS = NULL;
#endif

	HMENU hMenu1=NULL, hMenu2=NULL;
	STATION_INFO_S *Object=NULL;

	if (Packet && *Packet)
	{	RECT rcMine = rcCircle(cInfo->Index);
		RECT rc = rcMine;
		size_t tLen = (strlen(Packet)+1)*sizeof(TCHAR)*2;
		TCHAR *Text = (TCHAR*)malloc(tLen);
		HDC hdc = GetDC(hwnd);
		HFONT hOld = NO_FONT, hFont = GetFixedFont();
		if (hFont != NO_FONT) hOld = (HFONT) SelectObject(hdc, hFont);
		//GetClientRect(hwnd, &rc);
		char *c = strchr(Packet,':');
		if (c && c[1])
			StringCbPrintf(Text, tLen, TEXT("%.*S\n%S"),
							(int) (c-Packet)+1, Packet, c+1);
		else StringCbPrintf(Text, tLen, TEXT("%S"), Packet);
		int theight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
		if (hOld != NO_FONT) SelectObject(hdc, hOld);
		ReleaseDC(hwnd, hdc);

#ifdef DOIT_UGLY
		if (tpmp)
		{	RECT rcExclude;
			rcExclude.left = rcMine.left;
			rcExclude.top = rcMine.bottom-theight-2;
			rcExclude.right = rcExclude.left + (rc.right-rc.left+4);
			rcExclude.bottom = rcExclude.top + (rcMine.bottom-rcMine.top+4);
			UnionRect(&tpmp->rcExclude, &tpmp->rcExclude, &rcExclude);
		}
#endif

		hwndPacket = CreateWindow(TEXT("static"),
					Text,
					WS_BORDER | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
					| SS_LEFT | SS_NOPREFIX,
					rcMine.left, rcMine.bottom-theight-2,
					rc.right-rc.left+4, theight+4/*rcMine.bottom-rcMine.top+4*/,
					hwnd, (HMENU) 1,
					g_hInstance, NULL);
		SendMessage(hwndPacket, WM_SETFONT, (WPARAM)GetFixedFont(), 0);
		free(Text);

#ifdef NOT_ANY_MORE
		char *Safe = _strdup(Packet);
		APRS = (APRS_PARSED_INFO_S *) malloc(sizeof(*APRS));
		if (!parse_full_aprs(Safe, APRS))
		{	free(APRS); APRS = NULL;
		}
		free(Safe);
#endif
	}

	ClientToScreen(hwnd, &pt);
	if (tpmp)
	{	ptTopLeft.x = tpmp->rcExclude.left; ptTopLeft.y = tpmp->rcExclude.top; 
		ptBottomRight.x = tpmp->rcExclude.right; ptBottomRight.y = tpmp->rcExclude.bottom; 
		ClientToScreen(hwnd, &ptTopLeft); ClientToScreen(hwnd, &ptBottomRight);
		SetRect(&tpmp->rcExclude, ptTopLeft.x, ptTopLeft.y, ptBottomRight.x, ptBottomRight.y);
	}

	if (GetMenuItemCount(hPopup) == 1)	/* Don't use the cascade, but stack them */
	{	MENUITEMINFO mii = {0};
		mii.cbSize = sizeof(mii);
		mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE /* | MIIM_FULLSTR*/;
		if (GetMenuItemInfo(hPopup, 0, TRUE, &mii)
		&& mii.fType == MFT_STRING)	/* This is what we're looking for */
		{	mii.dwTypeData = (TCHAR*)malloc(sizeof(TCHAR)*++mii.cch);
			/* Win32 - MIIM_TYPE = (MIIM_BITMAP | MIIM_FTYPE | MIIM_STRING) */
			if (GetMenuItemInfo(hPopup, 0, TRUE, &mii))
			{	HMENU hSub = GetSubMenu(hPopup,0);
				if (hSub)
				{//	UINT idSub = GetMenuItemID(hSub, 0);	/* Get the ID of "Info" entry */
					CALLBACK_MENU_INFO_S *cmi = GetCallbackMenuInfo(hSub, 0, TRUE);
					if (cmi && cmi->Callback==MenuStationInfo && cmi->pointer)	/* Get the "Info" entry */
//	A bit of direct area object editing technology here
	{	Object = (STATION_INFO_S*) cmi->pointer;
		OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Object->Station);
		if (Object->isMyObject && Obj)
		{
			if (Object->AreaObjParsed && Object->MultiLine)
			{	MULTILINE_INFO_S *ml = Object->MultiLine;
				hMenu2 = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_OBJ_AREA_COLOR));
				if (hMenu2)
				{	HMENU hmenuSub = GetSubMenu(hMenu2, 0); 
					if (hmenuSub)
					{	InsertMenu(hSub, -1, MF_POPUP | MF_STRING | MF_BYPOSITION, (UINT_PTR) hmenuSub, TEXT("Change Color"));
						CheckMenuItem(hSub, ID_OBJ_AREA_COLOR_LOWEST+ml->Area.Color, MF_CHECKED);
					}
				}
				hMenu1 = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_OBJ_AREA_SHAPE));
				if (hMenu1)
				{	HMENU hmenuSub = GetSubMenu(hMenu1, 0); 
					if (hmenuSub)
					{	InsertMenu(hSub, -1, MF_POPUP | MF_STRING | MF_BYPOSITION, (UINT_PTR) hmenuSub, TEXT("Change Shape"));
						CheckMenuItem(hSub, ID_OBJ_AREA_SHAPE_LOWEST+ml->Area.Type, MF_CHECKED);
					}
				}
				if (ml->Area.Type == 1 || ml->Area.Type == 6)	/* Lines */
				{	InsertMenu(hSub, -1, MF_STRING | MF_BYPOSITION, ID_OBJECTS_WIDTH, TEXT("Set Width"));
					NumberMenuItem(hSub, ID_OBJECTS_WIDTH, ml->Area.Width, "mi");
				}
			}
		}
	}
					Prompted = TRUE;	/* Prevent original popup */
					Selected = TrackPopupMenuEx(hSub, tpmFlags, pt.x, pt.y, hwnd, tpmp);
				} else TraceError(hwnd, "hSub is NULL!\n");
			} else TraceError(hwnd, "Get String Failed with %ld!\n", GetLastError());
			free(mii.dwTypeData);
		} else TraceError(hwnd, "Get MII Failed or Type is not String with %ld!\n", GetLastError());
	}
	if (!Prompted)
	{
		Selected = TrackPopupMenuEx(hPopup, tpmFlags, pt.x, pt.y, hwnd, tpmp);
	}
	if (Selected)	/* Menu worked */
	{//	unsigned long s = STATION(Selected);
		MENUITEMINFO mii = {0};

		mii.cbSize = sizeof(mii);
		mii.fMask = MIIM_DATA;

		if (GetMenuItemInfo(hPopup, Selected, FALSE, &mii)
		&& mii.dwItemData)
		{	CALLBACK_MENU_INFO_S *cmi = (CALLBACK_MENU_INFO_S *)mii.dwItemData;
			if (cmi->Callback) cmi->Callback(cmi->cInfo, cmi->index, cmi->pointer);
		} else
//	T = APRS->course / 100;
//	yOff = APRS->course % 100; yOff *= yOff; yOff /= 1500.0;// Degrees
//	C = APRS->speed / 100;
//	xOff = APRS->speed % 100; xOff *= xOff; xOff /= 1500.0;	// Degrees
//		switch (s)
		switch (Selected)
		{
		case ID_OBJECTS_WIDTH:
		{	if (Object && Object->AreaObjParsed)	// Got Shape?
			if (Object->MultiLine)	/* Need Multiline also */
			{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Object->Station);
				if (Obj)
				{	long width = NumberPrompt(hwnd, "Line Width", "Specify Corridor Width", "Miles", NULL, Object->MultiLine->Area.Width);
					char *s = strchr(Obj->Comment,'{');
					if (s)
					{	char *e = strchr(s+1,'}');
						if (e)
						{	memmove(s,e+1,strlen(e));
						} else memmove(s,s+1,strlen(s));
					}
					sprintf(strchr(Obj->Comment,'\0'),"{%ld}",width);
					if (Obj->Enabled)
					{	TransmitObject(Obj);
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
				}
			}
			break;
		}
		default:
		if (Selected >= ID_OBJ_AREA_SHAPE_LOWEST
		&& Selected <= ID_OBJ_AREA_SHAPE_HIGHEST)
		{	if (Object && Object->AreaObjParsed)	// Got Shape?
			{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Object->Station);
				if (Obj)
				{	if (strlen(Obj->Comment) > 6
					&& isdigit(Obj->Comment[0]&0xff)
					&& isdigit(Obj->Comment[1]&0xff)
					&& isdigit(Obj->Comment[2]&0xff)
					&& (Obj->Comment[3] == '/' || Obj->Comment[3] == '1')
					&& isdigit(Obj->Comment[4]&0xff)
					&& isdigit(Obj->Comment[5]&0xff)
					&& isdigit(Obj->Comment[6]&0xff))
					{	Obj->Comment[0] = (char)((Selected-ID_OBJ_AREA_SHAPE_LOWEST)+'0');
						if (Obj->Enabled)
						{	TransmitObject(Obj);
							InvalidateCircle(hwnd, TRUE, TRUE);
						}
					}
				}
			}
		}
		else if (Selected >= ID_OBJ_AREA_COLOR_LOWEST
		&& Selected <= ID_OBJ_AREA_COLOR_HIGHEST)
		{	if (Object && Object->AreaObjParsed)	// Shape object?
			{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Object->Station);
				if (Obj)
				{	if (strlen(Obj->Comment) > 6
					&& isdigit(Obj->Comment[0]&0xff)
					&& isdigit(Obj->Comment[1]&0xff)
					&& isdigit(Obj->Comment[2]&0xff)
					&& (Obj->Comment[3] == '/' || Obj->Comment[3] == '1')
					&& isdigit(Obj->Comment[4]&0xff)
					&& isdigit(Obj->Comment[5]&0xff)
					&& isdigit(Obj->Comment[6]&0xff))
					{	int newC = Selected-ID_OBJ_AREA_COLOR_LOWEST;
						Obj->Comment[3] = (newC > 9)?'1':'/';
						Obj->Comment[4] = (newC%10)+'0';
						if (Obj->Enabled)
						{	TransmitObject(Obj);
							InvalidateCircle(hwnd, TRUE, TRUE);
						}
					}
				}
			}
		}
#ifdef OBSOLETE
		else if (s >= 0 && s < StationCount)
		{	STATION_INFO_S *Station = pCloseStations[s];
			Selected = SELECTED(Selected);
			switch (Selected)
			{
			case SELECT_MESSAGE:
#ifdef USING_CHAT
				DisplayChat(CALLSIGN, Station->Station);
				RememberMessageCall(hwnd, &ActiveConfig, Station->Station);
#else
				if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Station->Station) == -1)
					MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("ID_SEND_MESSAGE"), MB_OK | MB_ICONERROR);
#endif
#ifdef USING_SIP
				SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
				break;
			case SELECT_OBJ_DRIVE:
				if (cInfo->zoom < 15
				|| MessageBox(hwnd, TEXT("Really Drive At Tight (15+) Zoom?"), TEXT("Drive MultiLine"), MB_ICONQUESTION | MB_YESNO) == IDYES)
				{	SetCenterTracking(hwnd, Station, FALSE);
					SetCenterLatLon(hwnd, Station->MultiLine->Points[0].Lat, Station->MultiLine->Points[0].Lon);
					if (!cInfo->Index)	/* Main window destinates */
					{	memset(&MyDestination,0,sizeof(MyDestination));
						MyDestination.lat = Station->MultiLine->Points[1].Lat;
						MyDestination.lon = Station->MultiLine->Points[1].Lat;
						cInfo->Odometer = 1./5280.;
						ShuffleScreenElements(hwnd);
					}
					cInfo->Locked = FALSE;	/* Don't want to be yanked */
					cInfo->Driving = TRUE;
					cInfo->CurrentMLPoint = 0;
					cInfo->DistanceDriven = 0;
					OSMGetTileServerTotals(NULL, NULL, NULL, NULL,
											&cInfo->StartTilesFetched, 
											NULL, NULL, NULL);
					GetSystemTime(&cInfo->stDriveStart);
					SetTimer(hwnd, DRIVE_TIMER, DriveRate, NULL);
					TraceLog("Driver", TRUE, hwnd, "Started Driving Along %s\n", Station->Station);
				}
				break;
			case SELECT_OBJ_EDIT:
			case SELECT_OBJ_ENABLE:
			case SELECT_OBJ_VIAIS:
			case SELECT_OBJ_VIARF:
			case SELECT_OBJ_KILL:
			case SELECT_TRACK_2_LINE:
			case SELECT_TRACK_2_AREA:
			{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
				if (Obj)
				{	switch (Selected)
					{
					case SELECT_OBJ_KILL:
						Obj->KillXmitCount = 0;
						Obj->Kill = !Obj->Kill; break;
					case SELECT_OBJ_ENABLE:
						Obj->Enabled = !Obj->Enabled; break;
					case SELECT_OBJ_VIAIS:
						Obj->ISEnabled = !Obj->ISEnabled; break;
					case SELECT_OBJ_VIARF:
						Obj->RFEnabled = !Obj->RFEnabled; break;
					case SELECT_TRACK_2_AREA:
					{	size_t MaxLen = sizeof(Obj->Comment)-4-1;
						char *String = Obj->Compressed
							? TrackToVariableMultiLine(Station, MaxLen, TRUE)
							: ScaleTrackToMultiLine(Station, MaxLen, TRUE);
						if (String)
						{	StringCbPrintfA(Obj->Comment, sizeof(Obj->Comment), " }j0%s", String);	/* Trailing {seq included in String */
							Obj->Precision = 2;	/* Force !DAO! as seq */
							free(String);
						} else MessageBox(hwnd, TEXT("MultiLine Format Failed, Track Too Long?"), TEXT("Track To Area"), MB_ICONERROR | MB_OK);
						/* }d0]LPPPSJSJOJNJNLMLLP{I1YAA */
						break;
					}
					case SELECT_TRACK_2_LINE:
					{	size_t MaxLen = sizeof(Obj->Comment)-4-1;
						char *String = Obj->Compressed
							? TrackToVariableMultiLine(Station, MaxLen)
							: ScaleTrackToMultiLine(Station, MaxLen);
						if (String)
						{	StringCbPrintfA(Obj->Comment, sizeof(Obj->Comment), " }j1%s", String);	/* Trailing {seq included in String */
							Obj->Precision = 2;	/* Force !DAO! as seq */
							free(String);
						} else MessageBox(hwnd, TEXT("MultiLine Format Failed, Track Too Long?"), TEXT("Track To Line"), MB_ICONERROR | MB_OK);
						/* }d0]LPPPSJSJOJNJNLMLLP{I1YAA */
						break;
					}
					case SELECT_OBJ_EDIT:
					{	unsigned long id = Obj-ActiveConfig.Objects.Obj;
						char OldName[sizeof(Obj->Name)];
						strncpy(OldName, Obj->Name, sizeof(OldName));
						Obj = PromptConfigObject(hwnd, &ActiveConfig, id);
						if (!Obj || strncmp(Obj->Name, OldName, sizeof(OldName)))
						{	OBJECT_CONFIG_INFO_S *OldObj = FindConfigObject(&ActiveConfig, OldName);
							if (!OldObj || !OldObj->Enabled)	/* Gone or disabled */
							{	STATION_INFO_S *Station = FindStationCall(OldName,CALLSIGN);
								if (Station) Station->isKilled = TRUE;
							}
						}
						break;
					}
					}
					if (Obj && Obj->Enabled)
					{	TransmitObject(Obj);
					} else Station->isKilled = TRUE;

					InvalidateCircle(NULL, TRUE, TRUE);
				} else Station->isKilled = TRUE;
				break;
			}
					
			case SELECT_OBJ_ADOPT:
			{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
				if (!Obj)
				{	char *Comment;
					if (Station->sComment)
					{	size_t wideLen = wcslen(Station->pComment)+1;
						size_t multiLen = wideLen*2;
						Comment = (char*)malloc(multiLen);
						WideCharToMultiByte(CP_UTF8, 0,
									Station->pComment, wideLen, 
									Comment, multiLen, NULL, NULL);
					} else Comment = _strdup("");
					char Sym = Station->isymbol & 0xFF;
					char Tab = Station->isymbol >> 8;
					if (Station->isymbol&0xff0000)
						Tab = (Station->isymbol>>16)&0xff;
					else Tab = Tab?'\\':'/';
					Obj = PromptNewObject(hwnd, &ActiveConfig,
									Station->pCoord->lat, Station->pCoord->lon,
									Tab, Sym, Comment,
									"EchoLinks", Station->Station);
					free(Comment);
					InvalidateCircle(NULL, TRUE, TRUE);
				} else MessageBox(hwnd, TEXT("Object Name Already Defined"), TEXT("Adopt EchoLink"), MB_ICONERROR | MB_OK);
				break;
			}
			case SELECT_OBJ_SEND:
			{	STATION_INFO_S *Stat = FindStationCall(LastChatStation);
				if (Stat)
				{	TransmitStationTo(Station, Stat);
				} else MessageBox(hwnd, TEXT("Chat Station Not Found"), TEXT("Send To"), MB_ICONERROR | MB_OK);
				break;
			}
			case SELECT_SAVE_GPX:
			if (Station->AutoSaveGPX)
			{	MessageBox(hwnd, TEXT("No Longer Auto-Saving GPX Tracks"), TEXT("Save GPX Track"), MB_ICONINFORMATION);
				Station->AutoSaveGPX = FALSE;
			} else 
			{	char *Error = SaveTrackToGPX(hwnd, Station);
				if (Error) TraceError(hwnd, "SaveTrackToGPX Error %s\n", Error);
				else if (MessageBox(hwnd, TEXT("Auto-Save Future Track Changes?"), TEXT("Save GPX Track"), MB_ICONQUESTION | MB_YESNO) == IDYES)
				{	Station->AutoSaveGPX = TRUE;
				}
			}
			break;
			case SELECT_COLOR_TRACK:
			{	char *NewColor = ColorPrompt(hwnd, "Track Color",
						GetRGBColorName(&ActiveConfig, Station->TrackColor),
						COLORS_AVAILABLE);
				if (NewColor)
				{	Station->TrackColor = GetColorRGB(&ActiveConfig, NewColor, "ColorTrack");
					free(NewColor);
					Station->TrackColorLocked = TRUE;
					InvalidateCircle(NULL, TRUE, TRUE);
				}
				break;
			}
			case SELECT_CLEAR_TRACK:
			if (Station->TrackCount)
			{	TCHAR *Text=(TCHAR*)malloc(sizeof(*Text)*256);
				StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Track Points for %S?"),
					(long) Station->TrackCount, (long) Station->TrackSize,
					HasNickLabelNonBlank(Station)?Station->Nickname->Label:(Station!=MyStation?Station->Station:"Me"));
				if (MessageBox(hwnd, Text, TEXT("Clear Tracks"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				{	if (Station == MyStation)
					{	if (CSVEnabled)	/* If we're CSV-ing, close and re-open a new file */
						{	EnableCSV(hwnd, FALSE, FALSE);
							EnableCSV(hwnd, TRUE, FALSE);
						}
						if (ActiveConfig.Enables.AutoSaveGPX)
							SaveTrackToGPX(hwnd, Station);
					}
					FreeTracks(Station, TRUE);
					InvalidateStatUsage(FALSE);
					InvalidateCircle(NULL, TRUE, TRUE);
				}
				free(Text);
			}
			break;
			case SELECT_SHRINK_TRACK:
			if (Station->TrackCount >= 2)
			{
#ifdef OBNOXIOUS
				TCHAR *Text=(TCHAR*)malloc(sizeof(*Text)*256);
				StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Remove Last Point for %S?"),
					HasNickLabelNonBlank(Station)?Station->Nickname->Label:(Station!=MyStation?Station->Station:"Me"));
				if (MessageBox(hwnd, Text, TEXT("Shrink Track"), MB_YESNO | MB_ICONQUESTION) == IDYES)
#endif
				{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
					int t = Station->TrackCount-2;
					double lat = Station->Tracks[t].pCoord->lat;
					double lon = Station->Tracks[t].pCoord->lon;
					SYSTEMTIME stWhen = Station->Tracks[t].st;
					Station->TrackCount -= 2;
					if (!Station->TrackCount)
						FreeTracks(Station, FALSE);
					UpdateStationPosition(hwnd, Station, lat, lon, 0, FALSE,
										CALLSIGN, &stWhen, TRUE, llGetMsec());
					if (Obj)
					{	Obj->Latitude = lat;
						Obj->Longitude = lon;
						TransmitObject(Obj, TRUE);
					}
					InvalidateStatUsage(FALSE);
					InvalidateCircle(NULL, TRUE, TRUE);
				}
#ifdef OBNOXIOUS
				free(Text);
#endif
			}
			break;
			case SELECT_TELEMETRY:
			{	TelemetryPopup(hwnd, cInfo, Station);
				break;
			}
			case SELECT_ADDRESS:
			{	ADDRESS_LOOKUP_INFO_S *aInfo = (ADDRESS_LOOKUP_INFO_S *)malloc(sizeof(*aInfo));
				aInfo->hwnd = hwnd;
				aInfo->Station = *Station;
				CloseHandle(CreateThread(NULL, 0, AddressLookupThread, aInfo, 0, NULL));
				break;
			}
			case SELECT_NICKNAME:
			{	char *Changed = PromptConfigNickname(hwnd, &ActiveConfig, Station->Station);
				if (Changed)
				{	FixNicknames(Changed);
					InvalidateCircle(NULL, TRUE, TRUE);
				}
				break;
			}
			case SELECT_AVRS:
				if (Station == MyStation)
					SendAPRSMessage(/*hwnd,*/ "AVRS", 0, TEXT("?"), FALSE);
				else if (MessageBox(hwnd, TEXT("Warning: This will send AVRS-generated messages to the selected station, Continue?"), TEXT("Initiate AVRS"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				{	TCHAR wToCall[sizeof(Station->Station)];
					StringCbPrintf(wToCall, sizeof(wToCall), TEXT("%S"), Station->Station);
					SendAPRSMessage(/*hwnd,*/ "AVRS", 0, wToCall, FALSE);
				}
				break;
			case SELECT_NWS_FINGER:

	if (Station->isNWS && *Station->IGate && Station->sComment)
	{	TCHAR *seq = wcsrchr(Station->pComment,TEXT('{'));
		if (seq)
		{	NWS_ENTRY_SERVER_S *Srv = GetNWSServer(&ActiveConfig, Station->IGate, Station->Owner, "", FALSE);
			if (Srv && !Srv->Disabled
			&& *Srv->Finger.Server && Srv->Finger.Port)
			{	char Username[80];
				StringCbPrintfA(Username, sizeof(Username), "%s%.3S\r\n", Station->Owner, seq+1);
				int tLen;
				char *aText = Finger(hwnd, Srv->Finger.Server, Srv->Finger.Port, Username, &tLen);
				if (aText && tLen)
				{	size_t Remaining = (tLen+80)*sizeof(TCHAR);
					TCHAR *tText = (TCHAR*)malloc(Remaining);
					StringCbPrintf(tText, Remaining, TEXT("%.*S"), tLen, aText);
					MessageBox(hwnd, tText, Station->pComment, MB_OK | MB_ICONINFORMATION);
					free(tText);
					free(aText);
				} else MessageBox(hwnd, TEXT("Finger Failed"), TEXT("NWS Finger"), MB_OK | MB_ICONERROR);
			}
		}
	}
				break;
			case SELECT_INFO:
				StationPopup(hwnd, cInfo, Station);
				break;
			case SELECT_CQLOOKUP:
			{	TCHAR wToCall[24];
				char *e, *e1, *e2;
				e = strchr(Station->Station,'\0');
				e1 = strchr(Station->Station,' ');
				e2 = strchr(Station->Station,'-');
				if (e1 && e1 < e) e = e1;
				if (e2 && e2 < e) e = e2;
				if (SUCCEEDED(StringCbPrintf(wToCall, sizeof(wToCall), TEXT("%S%.*S"),
											ActiveConfig.WhoIsFull?"f ":"",
											(int)(e-Station->Station), Station->Station)))
				{	if (!SendAPRSMessage(/*hwnd,*/ ActiveConfig.WhoIsServer, 0, wToCall, TRUE))
						MessageBox(hwnd, TEXT("SendAPRSMessage Failed"), TEXT("SELECT_CQLOOKUP"), MB_OK | MB_ICONERROR);
				} else MessageBox(hwnd, TEXT("Lookup Format Failed"), TEXT("SELECT_CQLOOKUP"), MB_OK | MB_ICONERROR);
				break;
			}
			case SELECT_DESTINATION:
				if (!strcmp(MyDestination.Owner, Station->Owner)
				&& !strcmp(MyDestination.Station, Station->Station))
				{	memset(&MyDestination, 0, sizeof(MyDestination));
				} else
				{	strncpy(MyDestination.Owner, Station->Owner, sizeof(MyDestination.Owner));
					strncpy(MyDestination.Station, Station->Station, sizeof(MyDestination.Station));
					MyDestination.lat = Station->pCoord->lat;
					MyDestination.lon = Station->pCoord->lon;
				}
				ShuffleScreenElements(hwnd);
				break;
			case SELECT_CENTER:
				//if (cInfo->CenterStation == Station && cInfo->CenterTracking) Station=MyStation;	/* Go back to me if they uncheck this one! */
				SetCenterTracking(hwnd, Station);
				break;
			case SELECT_RANGE:
				if (cInfo->Index)
				{	cInfo->CenterRanging = !cInfo->CenterRanging;
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
				TransmitFilter();
				break;
			case SELECT_NEW_WINDOW:
//TraceError(hwndMain, "Selected MultiTrack(%s)\n", Station->Station);
				for (int tr=1; tr<MAX_TRACKERS; tr++)
				if (!cInfos[tr].Active)
				if (!hwndTracker[tr] || !IsWindow(hwndTracker[tr]))
				{	CreateTrackerWindow(Station->Station, Station->Owner, cInfo->Index);
					break;
				}
//else TraceError(hwndMain, "hwndTracker[%ld]=%p\n", (long) tr, hwndTracker[tr]);
//else TraceError(hwndMain, "hwndTracker[%ld] ACTIVE!\n", (long) tr);
				break;
			}
		}
#endif
#ifdef OLD_WAY
		else
		{	unsigned long g = s-StationCount;
			if (g >= 0 && g < GeocacheCount)
			{	int Len = sizeof(TCHAR)*(strlen(Geocaches[g].Desc)+strlen(Geocaches[g].ShortDesc)+strlen(Geocaches[g].LongDesc)+80);
				TCHAR *Buffer = (TCHAR*)malloc(Len);
				TCHAR ID[32];
				double Lat = Geocaches[g].lat;
				double Lon = Geocaches[g].lon;
				char NS = (Lat<0)?'S':'N';
				char EW = (Lon<0)?'W':'E';
//				GetCoordIndex(Lat, Lon, "GeoCache");
				if (Lat < 0) Lat = -Lat;
				if (Lon < 0) Lon = -Lon;

				StringCbPrintf(Buffer, Len, TEXT("%S: %S %S %.1lf/%.1lf\n%c%02ld %6.3lf %c%02ld %6.3lf\n%S\n\n%S%S%S"),
					Geocaches[g].ID,
					Geocaches[g].Type, Geocaches[g].Container,
					(double)(Geocaches[g].difficulty)/2.0,
					(double)(Geocaches[g].terrain)/2.0,
					NS, (long) floor(Lat), (double) (Lat - floor(Lat))*60.0,
					EW, (long) floor(Lon), (double) (Lon - floor(Lon))*60.0,
					Geocaches[g].Desc, Geocaches[g].ShortDesc,
					Geocaches[g].ShortDesc&&*Geocaches[g].ShortDesc?"\n\n":"",
					Geocaches[g].LongDesc);
				StringCbPrintf(ID, sizeof(ID), TEXT("%.*S"),
					sizeof(Geocaches[g].ID), Geocaches[g].ID);

				for (;;)	/* Loop until break */
				{	int Pushed;
					BUTTONS_S *Buttons = CreateButtons(-1);
					AddButton(Buttons, "Destination", IDYES);
					if (Geocaches[g].Hint && *Geocaches[g].Hint)
						AddButton(Buttons, "Hint", IDRETRY);
					AddButton(Buttons, "Done", IDNO);

					Pushed = LwdMessageBox2(hwnd, Buffer, ID, MB_ICONINFORMATION, Buttons);
					if (Pushed == IDRETRY)	/* Hint */
					{	int Len = sizeof(TCHAR)*(strlen(Geocaches[g].Hint)+strlen(Geocaches[g].Desc)+80);
						TCHAR *Buffer = (TCHAR*)malloc(Len);
						StringCbPrintf(Buffer, Len, TEXT("%S\n\nHint: %S"),
										Geocaches[g].Desc, Geocaches[g].Hint);
						MessageBox(hwnd, Buffer, ID, MB_OK);
						free(Buffer);
					} else if (Pushed == IDYES)
					{	MyDestination.lat = Geocaches[g].lat;
						MyDestination.lon = Geocaches[g].lon;
						strncpy(MyDestination.Owner, "GeoCaches", sizeof(MyDestination.Owner));
						strncpy(MyDestination.Station, Geocaches[g].ID, sizeof(MyDestination.Station));
						ShuffleScreenElements(hwnd);
						break;
					} else if (Pushed == IDNO || Pushed == 0)/* 0=closed */
					{	break;
					} else TraceError(hwnd, "Geocache got %ld\n", (long) Pushed);
				}
				free(Buffer);
			}
		}
#endif
		}	/* end switch(s) */
	}
	if (hwndPacket) DestroyWindow(hwndPacket);
#ifdef NOT_ANY_MORE
	if (APRS) free(APRS);
#endif
	if (hMenu1) DestroyMenu(hMenu1);
	if (hMenu2) DestroyMenu(hMenu2);
}

static BOOL PopupCircleMenu(HWND hwnd, POINT pt)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	int tr = cInfo->Index;
	BOOL DidMe = FALSE;
	BOOL HadMenu = FALSE;
	unsigned long g, s, s0=0, count=0;
	HMENU hPopup = CreatePopupMenu();
	TPMPARAMS tpmp = {0};
	char *gcDesc = NULL;
	tpmp.cbSize = sizeof(tpmp);
	unsigned long StationCount = CloseStationCount;

	FreezeCloseStations(hwnd);
	for (s=0; s<StationCount; s++)
	{	STATION_INFO_S *pStat = pCloseStations[s];
		if ((pStat->TInfo[tr].rcsymvalid
			&& (PtInRect(&pStat->TInfo[tr].rcSym, pt)))
		|| (pStat->TInfo[tr].rclblvalid
			&& PtInRect(&pStat->TInfo[tr].rcLbl,pt))
		|| (pStat->MultiLine && pStat->MultiLine->Filled
			&& PtInRect(&pStat->MultiLine->Tracker[tr].rcMinMax,pt)))
		{	if (AddToStationMenu(cInfo, hPopup, pStat, NULL,
								NULL, pStat->pLastPacket, pStat->LastFromRF))
			{	if (s==0) DidMe = TRUE;
				if (pStat->TInfo[tr].rcsymvalid
				&& (PtInRect(&pStat->TInfo[tr].rcSym, pt)))
				{	if (!count) tpmp.rcExclude = pStat->TInfo[tr].rcSym;
					else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &pStat->TInfo[tr].rcSym);
				} else if (pStat->TInfo[tr].rclblvalid
				&& PtInRect(&pStat->TInfo[tr].rcLbl,pt)
				&& pStat->TInfo[tr].rcsymvalid)
				{	if (!count) tpmp.rcExclude = pStat->TInfo[tr].rcSym;
					else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &pStat->TInfo[tr].rcSym);
				}
				s0 = s; count++;	/* See if we only end up with one */
			}
		}
	}

	if (cInfo->viewBits & VIEW_GEOCACHES && GeocacheCount)
	{	TCHAR *String=(TCHAR*)malloc(sizeof(*String)*80);
		for (g=0; g<GeocacheCount; g++)
		{	if (Geocaches[g].visible)
			{	if (PtInRect(&Geocaches[g].rc, pt)
				|| (Geocaches[g].labelled
				&& PtInRect(&Geocaches[g].rcLabel,pt)))
				{	StringCbPrintf(String, sizeof(*String)*80, TEXT("%.*S %S\t%.1lf/%.1lf"), sizeof(Geocaches[g].ID), Geocaches[g].ID, Geocaches[g].Container, (double)(Geocaches[g].difficulty)/2.0, (double)(Geocaches[g].terrain)/2.0);
//					if (AppendMenu(hPopup, MF_STRING, StationCount+g, String))
					if (AddCallbackMenuItem(hPopup, MENU_POS_APPEND, MFS_ENABLED, String,
											MenuSelectGeocache, cInfo, g))
					{	if (!count) CopyRect(&tpmp.rcExclude,&Geocaches[g].rc);
						else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &Geocaches[g].rc);
						count++;	/* See if we only end up with one */
						//if (Geocaches[g].ShortDesc && *Geocaches[g].ShortDesc)
						//	gcDesc = Geocaches[g].ShortDesc;
						//else
						if (Geocaches[g].Desc && *Geocaches[g].Desc)
							gcDesc = Geocaches[g].Desc;
					} else TraceError(hwnd, "Failed To Add GeoCache[%ld] %S\n", (long) g, String);
				}
			}
		}
		free(String);
	}

	if (ActiveConfig.Overlays.Count)	/* Got any overlays? */
	{	unsigned long o;
		for (o=0; o<ActiveConfig.Overlays.Count; o++)
		if (ActiveConfig.Overlays.Overlay[o].Enabled)	/* Visible? */
		{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
			int p;
			TraceError(hwnd, "Checking %ld Objects from %s\n", (long) pOver->Runtime.ObjectCount, pOver->FileName);
			for (p=0; p<pOver->Runtime.ObjectCount; p++)
			{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[p];
				if ((Obj->TInfo[tr].rcsymvalid
					&& (PtInRect(&Obj->TInfo[tr].rcSym, pt)))
				|| (Obj->TInfo[tr].rclblvalid
					&& PtInRect(&Obj->TInfo[tr].rcLbl,pt)))
				{	size_t Size = sizeof(TCHAR)*(strlen(Obj->ID)+1);
					TCHAR *String=(TCHAR*)malloc(Size);
					HMENU hSub = CreatePopupMenu();

					StringCbPrintExUTF8(String, Size, NULL, NULL, -1, Obj->ID, NULL);

					AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, String,
											MenuOverlayObject, cInfo, MAKELONG(o,p));
					if (Obj->sComment && *Obj->pComment)
						AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Obj->pComment,
												MenuOverlayObject, cInfo, MAKELONG(o,p));
					if (Obj->sStatusReport && *Obj->pStatusReport)
						AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Obj->pStatusReport,
												MenuOverlayObject, cInfo, MAKELONG(o,p));
					AppendMenu(hSub, MF_SEPARATOR, NULL, NULL);

					{	char *Name = LocateFilename(pOver->FileName);
						size_t tSize = sizeof(TCHAR)*(10+strlen(Name)+1);
						TCHAR *Text = (TCHAR*)malloc(tSize);
						StringCbPrintf(Text, tSize, TEXT("Configure %S"), Name);
						AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, Text,
											MenuOverlayConfig, cInfo, MAKELONG(o,p));
						free(Text);
					}
					if (Obj->TrackCount > 1)
						AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Drive Overlay"),
											MenuOverlayObjectDrive, cInfo, MAKELONG(o,p));
					if (strlen(Obj->ID) <= 9
					&& !FindStationCall(Obj->ID, NULL, TRUE))
						AddCallbackMenuItem(hSub, MENU_POS_APPEND, MFS_ENABLED, TEXT("Make Object"),
												MenuOverlayObjectAdopt, cInfo, MAKELONG(o,p));
					if (AppendMenu(hPopup, MF_POPUP | MF_STRING, (UINT_PTR) hSub, String))
					{	count++;	/* See if we only end up with one */
#ifndef UNDER_CE
	HBITMAP hbm = MakeSymbolBitmap(hwnd,
						Obj->isymbol,
						GetSystemMetrics(SM_CXMENUCHECK),
						GetSystemMetrics(SM_CYMENUCHECK),
						COLOR_MENU);
	if (hbm) SetMenuItemBitmaps(hPopup, GetMenuItemCount(hPopup)-1, MF_BYPOSITION, hbm, hbm);
#endif
						if (Obj->TInfo[tr].rcsymvalid
						&& (PtInRect(&Obj->TInfo[tr].rcSym, pt)))
						{	if (!count) tpmp.rcExclude = Obj->TInfo[tr].rcSym;
							else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &Obj->TInfo[tr].rcSym);
						} else if (Obj->TInfo[tr].rclblvalid
						&& PtInRect(&Obj->TInfo[tr].rcLbl,pt)
						&& Obj->TInfo[tr].rcsymvalid)
						{	if (!count) tpmp.rcExclude = Obj->TInfo[tr].rcSym;
							else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &Obj->TInfo[tr].rcSym);
						}
						TraceError(hwnd, "Added Overlay Object %S\n", String);
					} else TraceError(hwnd, "Failed To Add Overlay Object %S\n", String);
					free(String);
				}
			}
		}
	}

	if (count)
	{	HadMenu = TRUE;
		TrackStationMenu(hwnd, pt, hPopup,
						TPM_CENTERALIGN | TPM_VCENTERALIGN
						| TPM_NONOTIFY | TPM_RETURNCMD,
						&tpmp, StationCount,
						count==1?(gcDesc?gcDesc:pCloseStations[s0]->pLastPacket):NULL,
						count==1?(gcDesc?0:pCloseStations[s0]->LastFromRF):0);
	}
	FreeMenuBitmaps(hPopup);
	DestroyMenu(hPopup);
	ThawCloseStations(hwnd);
	return HadMenu;
}

static void PopupStationMenu(HWND hwnd, POINT pt)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	unsigned long s, s0, count=0;
	HMENU hPopup = CreatePopupMenu();

	FreezeCloseStations(hwnd);
	for (s=0; s<PacketScrollerSize; s++)
	if (*PaintingStations[s].Station && PaintingStations[s].CloseIndex>=0)
	{	if (PtInRect(&rcPaintingStations[s], pt))
		{	unsigned long s1 = PaintingStations[s].CloseIndex;
			if (AddToStationMenu(cInfo, hPopup, pCloseStations[s1], NULL,
								&PaintingStations[s].stPacket,
								PaintingStations[s].Packet,
								PaintingStations[s].HeardOnRF))
			{	if (!count) s0=s;	/* Remember the first one */
				count++;	/* See if we only end up with one */
			}
		}
	}

	if (count)
	{	TrackStationMenu(hwnd, pt, hPopup,
						TPM_CENTERALIGN | TPM_TOPALIGN
						| TPM_NONOTIFY | TPM_RETURNCMD,
						NULL, CloseStationCount,
						count==1?PaintingStations[s0].Packet:NULL,
						count==1?PaintingStations[s0].HeardOnRF:0);
	}
	FreeMenuBitmaps(hPopup);
	DestroyMenu(hPopup);
	ThawCloseStations(hwnd);
}

void PopupContextMenu(HWND hwnd, POINT pt)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
//	int tr = cInfo->Index;
	POINT ptTopLeft, ptBottomRight;
	double Lat=0, Lon=0;
	HMENU hMenu1 = NULL, hMenu2 = NULL;
	STATION_INFO_S *Station = cInfo?cInfo->CenterStation:NULL;
	BOOL DidMe = FALSE;
	BOOL DidCenter = FALSE;
	BOOL DidStation = FALSE;
	long s, s0=0, count=0;
	HMENU hPopup = CreatePopupMenu();
	TPMPARAMS tpmp = {0};
	tpmp.cbSize = sizeof(tpmp);

	FreezeCloseStations(hwnd);
	{	TCHAR *String = (TCHAR*)malloc(sizeof(*String)*80);
		for (s=0; s<(long)CloseStationCount; s++)
		{	STATION_INFO_S *Stat = pCloseStations[s];
			if (Stat->TInfo[cInfo->Index].rcsymvalid)
			{	if (PtInRect(&Stat->TInfo[cInfo->Index].rcSym, pt)
				|| (Stat->TInfo[cInfo->Index].rclblvalid && PtInRect(&Stat->TInfo[cInfo->Index].rcLbl,pt)))
			{	if (Stat == cInfo->CenterStation)
					StringCbPrintf(String, sizeof(*String)*80, TEXT("Return To %S"), HasNickLabelNonBlank(Stat)?Stat->Nickname->Label:(s?Stat->Station:"ME"));
				else StringCbPrintf(String, sizeof(*String)*80, TEXT("Center On %S"), HasNickLabelNonBlank(Stat)?Stat->Nickname->Label:(s?Stat->Station:"ME"));
					AppendMenu(hPopup,
								(Stat==cInfo->CenterStation?MF_CHECKED:0) | MF_STRING,
								s+1, String);
					if (s==0) DidMe = TRUE;
					else
					{	if (Stat == cInfo->CenterStation)
							DidCenter = TRUE;
						DidStation = TRUE;
					}
					if (Stat->TInfo[cInfo->Index].rcsymvalid)
					{	if (!count) CopyRect(&tpmp.rcExclude,&Stat->TInfo[cInfo->Index].rcSym);
						else UnionRect(&tpmp.rcExclude, &tpmp.rcExclude, &Stat->TInfo[cInfo->Index].rcSym);
					}
					s0 = s; count++;	/* See if we only end up with one */
				}
			}
		}
		free(String);
	}
	// if (count != 1)	/* Always offer the right click menu */
	{	if (!DidMe	/* Centered elsewhere, offer ME */
		&& (cInfo->CenterStation!=MyStation || !cInfo->CenterTracking))
		{	//HMENU hSub = CreatePopupMenu();
			s = 0;	/* Point to me */
			if (HasNickLabelNonBlank(MyStation))
			{	TCHAR Buffer[sizeof(MyStation->Nickname->Label)+16];
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Center On %S"),
								MyStation->Nickname->Label);
				AppendMenu(hPopup, MF_STRING, s+1, Buffer);
			} else AppendMenu(hPopup, MF_STRING, s+1, TEXT("Center On ME"));
			s0 = 0; count++;	/* See if we only end up with one */
		}

		if (!DidCenter	/* May need to move back to center */
		&& cInfo->CenterStation
		&& cInfo->CenterStation != MyStation)	/* Me is above */
		{	TCHAR Buffer[sizeof(MyStation->Nickname->Label)+16];
			STATION_INFO_S *Stat = cInfo->CenterStation;
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Return To %S"), HasNickLabelNonBlank(Stat)?Stat->Nickname->Label:Stat->Station);
			AppendMenu(hPopup,
							MF_CHECKED | MF_STRING,
							Stat->Index+1, Buffer);
			s0 = Stat->Index; count++;	/* See if we only end up with one */
		}
	
		if (!IsPreferredView(hwnd, cInfo))
		{	AppendMenu(hPopup, MF_STRING, ID_VIEW_PREFERRED_RESTORE, TEXT("Preferred View"));
			s0 = 0; count++;	/* See if we only end up with one */
		}
/*
Add any existing MultiTrack windows to the popup
*/
		{	int trCount = 0;
			for (int tr=0; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active)
					trCount++;
			if (trCount > 1)	/* Not if it's only me! */
			{	TCHAR *Title = (TCHAR*)malloc(sizeof(TCHAR)*512);
				if (count) AppendMenu(hPopup, MF_SEPARATOR, NULL, NULL);
				for (int tr=0; tr<MAX_TRACKERS; tr++)
				if (cInfos[tr].Active)
				if (tr != cInfo->Index)
				{	GetWindowText(hwndTracker[tr], Title, 512);
					AppendMenu(hPopup, MF_STRING, tr+ID_MULTITRACK_MENU, Title);
					count++;
				}
			}
#ifndef UNDER_CE
			if (hwndSatellites)
			{	if (!trCount && count)
					AppendMenu(hPopup, MF_SEPARATOR, NULL, NULL);
				AppendMenu(hPopup, MF_STRING, ID_SATELLITE_DETAILS, TEXT("Satellite Details"));
				count++;
			}
#endif
		}
/*
Add the active chats if there are any
*/
		if (ChatCount)
		{	unsigned long p;
			for (p=0; p<ChatCount; p++)
			if (Chats[p])
				break;
			if (p < ChatCount)	/* There really is an active chat! */
			{	if (count) AppendMenu(hPopup, MF_SEPARATOR, NULL, NULL);
				for (p=0; p<ChatCount; p++)
				if (Chats[p])
				{	TCHAR Name[80];
					CHAT_INFO_S *Chat = Chats[p];
					if (!_strnicmp(Chat->From, CALLSIGN, sizeof(Chat->From)))
						StringCbPrintf(Name, sizeof(Name), TEXT("Chat(%S)"), Chat->To);
					else if (!_strnicmp(Chat->To, CALLSIGN, sizeof(Chat->To)))
						StringCbPrintf(Name, sizeof(Name), TEXT("Chat(%S)"), Chat->From);
					else StringCbPrintf(Name, sizeof(Name), TEXT("Mon(%S<>%S)"), Chat->From, Chat->To);
					AppendMenu(hPopup, MF_STRING, ID_CHAT_NEW+(p+1), Name);
					CheckMenuItem(cInfo->hMenu, ID_CHAT_NEW+(p+1), 
								Chat->isActive?MF_CHECKED:MF_UNCHECKED);
				}
			}
		}
#ifdef SUPPORT_TRACE_LOGS
		if (!DidStation)	/* Only if there's no stations at the top */
			count += TraceLogPopupMenuBuild(hwnd, hPopup, count!=0);
#endif
	}
	if (count > 1 || s0==0)	/* Need to popup? */
	{

		if (cInfo->ts)
		{
#ifdef DEBUGGING_POINTS
			{	HDC hdc = GetDC(hwnd);
				RECT rc;
				GetWindowRect(hwnd, &rc);
				TraceLogThread("Point2LatLon", TRUE, "windows %ld %ld -> %ld %ld pt %ld %ld\n",
						rc.left, rc.top, rc.right, rc.bottom,
						pt.x, pt.y);
				MoveToEx(hdc, rc.left-rc.left, pt.y, NULL);
				LineTo(hdc, rc.right-rc.left, pt.y);
				MoveToEx(hdc, pt.x, rc.top-rc.top, NULL);
				LineTo(hdc, pt.x, rc.bottom-rc.top);
				ReleaseDC(hwnd, hdc);
			}
#endif

			if (OSMPointToLatLon(cInfo->ts, &pt, &Lat, &Lon)
			&& (Lat != 0.0 || Lon != 0.0))	/* Must be a real coordinate */
			{	TCHAR uTemp[80];
				TCHAR *LatLon = APRSLatLon(Lat, Lon, ' ', ' ', 3);
				HMENU hSub = CreatePopupMenu();
		//		StringCbPrintf(uTemp,sizeof(uTemp),TEXT("%ld %ld -> %s"),
		//						(long) pt.x, (long) pt.y, LatLon);
				InsertMenu(hPopup, -1, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
				InsertMenu(hPopup, -1, MF_POPUP | MF_STRING | MF_BYPOSITION, (UINT_PTR) hSub, LatLon);
				count++;
				free(LatLon);

				if (!cInfo->Index)	/* Main window only */
					AppendMenu(hSub, MF_STRING | MF_ENABLED,
							IDB_SET_DESTINATION, TEXT("Set Destination"));

#if MAX_TRACKERS > 1
				if (GetFreeTrackerCount() && GetFreeRangerCount())
					AppendMenu(hSub, MF_STRING | MF_ENABLED,
							IDB_MULTITRACK, TEXT("MultiTrack"));
#endif

				AppendMenu(hSub, MF_STRING | MF_ENABLED,
							ID_SCREEN_CENTER_TRACKED, TEXT("Center Here"));

				/* ME must always be at the top to prevent */
				/* WM_INITMENUPOPUP from expanding ID_OBJECTS_NEW */
				{	BOOL MoveEnabled = !GPSEnabled
									&& cInfo->zoom >= MIN_SETTABLE_ZOOM
									&& (Lat != LastGoodPosition.dblLatitude
										|| Lon != LastGoodPosition.dblLongitude)
									&& (!MyStation->TInfo[cInfo->Index].rcsymvalid
										|| !PtInRect(&MyStation->TInfo[cInfo->Index].rcSym, pt));
					StringCbPrintf(uTemp, sizeof(*uTemp)*80, TEXT("Move %S HERE"), HasNickLabelNonBlank(MyStation)?MyStation->Nickname->Label:"ME");
					AppendMenu(hSub, MF_STRING | (MoveEnabled?MF_ENABLED:MF_GRAYED),
								ID_TRANSMIT, uTemp);
				}

				if (Station
				&& Station->isObject
				&& Station->isMyObject
				&& (!Station->TInfo[cInfo->Index].rcsymvalid
					|| !PtInRect(&Station->TInfo[cInfo->Index].rcSym, pt))
				&& (Lat != Station->pCoord->lat || Lon != Station->pCoord->lon))
				{	StringCbPrintf(uTemp,sizeof(uTemp),TEXT("Move %S HERE"),
									HasNickLabelNonBlank(Station)?Station->Nickname->Label:Station->Station);
					AppendMenu(hSub, MF_STRING, ID_OBJECTS_MOVE, uTemp);
					if (Station->BRGNRQParsed		/* Got BRNNRQ? */
					&& Station->pBRGNRQ)			/* Info in here */
					{	double distance, bearing;
						AprsHaversineLatLon(Station->pCoord->lat, Station->pCoord->lon, Lat, Lon,
										&distance, &bearing);
						if (bearing != Station->pBRGNRQ->bearing)
						{	StringCbPrintf(uTemp,sizeof(uTemp),TEXT("Point %S HERE (%ld->%ld)"),
										Station->Station,
										(long) Station->pBRGNRQ->bearing, (long) bearing);
							AppendMenu(hSub, MF_STRING, ID_OBJECTS_BEARING, uTemp);
						}
					}
					if (Station->AreaObjParsed
					&& Station->MultiLine)
					{	MULTILINE_INFO_S *ml = Station->MultiLine;
						double dLat = Lat - Station->pCoord->lat;
						double dLon = Station->pCoord->lon - Lon;
						if (ml->Area.Type == 6) dLon = -dLon;	// other line
						if (dLat >= 0.0 && dLon >= 0.0)
						{	StringCbPrintf(uTemp,sizeof(uTemp),TEXT("Stretch %S HERE"),
										Station->Station);
							AppendMenu(hSub, MF_STRING, ID_OBJECTS_OFFSET, uTemp);
						}
					}
				}

				//if (ActiveConfig.Objects.Count<999)
				{	AppendMenu(hSub, MF_STRING, ID_OBJECTS_NEW, TEXT("Create Object HERE"));

					hMenu1 = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_OBJ_AREA_SHAPE));
					if (hMenu1)
					{	HMENU hmenuSub = GetSubMenu(hMenu1, 0); 
						if (hmenuSub)
						{	InsertMenu(hSub, -1, MF_POPUP | MF_STRING | MF_BYPOSITION, (UINT_PTR) hmenuSub, TEXT("Create Shape HERE"));
						} else TraceLogThread("Menu", TRUE, "GetSubMenu Returned NULL, LastError=%ld\n", (long) GetLastError());
					}


					if (ActiveConfig.View.DF.Enabled)
					{
						hMenu2 = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_DF_QUALITY));
						if (hMenu2)
						{	HMENU hmenuSub = GetSubMenu(hMenu2, 0); 
							if (hmenuSub)
							{	InsertMenu(hSub, -1, MF_POPUP | MF_STRING | MF_BYPOSITION, (UINT_PTR) hmenuSub, TEXT("New DF @ Center"));
							} else AppendMenu(hSub, MF_STRING, ID_OBJECTS_NEW_DF_CENTER, TEXT("New DF @ Center"));
						} else AppendMenu(hSub, MF_STRING, ID_OBJECTS_NEW_DF_CENTER, TEXT("New DF @ Center"));

						AppendMenu(hSub, MF_STRING, ID_OBJECTS_NEW_DF, TEXT("New DF HERE"));
					}
				}
			}
		}
		ClientToScreen(hwnd, &pt); 
		ptTopLeft.x = tpmp.rcExclude.left; ptTopLeft.y = tpmp.rcExclude.top; 
		ptBottomRight.x = tpmp.rcExclude.right; ptBottomRight.y = tpmp.rcExclude.bottom; 
		ClientToScreen(hwnd, &ptTopLeft); ClientToScreen(hwnd, &ptBottomRight);
		SetRect(&tpmp.rcExclude, ptTopLeft.x, ptTopLeft.y, ptBottomRight.x, ptBottomRight.y);
		s = TrackPopupMenuEx(hPopup, TPM_CENTERALIGN | TPM_VCENTERALIGN | TPM_RETURNCMD, pt.x, pt.y, hwnd, &tpmp);
		if (!s) s = CloseStationCount+1;	/* Invalid selection offset by 1! */
	} else s = s0+1;

	if (count)
	{	switch (s)
		{
#ifndef UNDER_CE
		case ID_SATELLITE_DETAILS:
			if (hwndSatellites)
			{	ShowWindow(hwndSatellites, SW_RESTORE);
				SetForegroundWindow(hwndSatellites);
			}
			break;
#endif
		case ID_SCREEN_CENTER_TRACKED:
			SetCenterLatLon(hwnd, Lat, Lon, cInfo->Index!=0);
			break;
		case IDB_SET_DESTINATION:
		{	MyDestination.lat = Lat;
			MyDestination.lon = Lon;
			memset(MyDestination.Owner,0,sizeof(MyDestination.Owner));
			memset(MyDestination.Station,0,sizeof(MyDestination.Station));
			ShuffleScreenElements(hwnd);
			break;
		}
#if MAX_TRACKERS > 1
		case IDB_MULTITRACK:
		{	HWND hwnd = CreateTrackerWindow(CALLSIGN);
			if (hwnd) SetCenterLatLon(hwnd, Lat, Lon, TRUE);
			break;
		}
#endif
		case ID_VIEW_PREFERRED_RESTORE:
			RestorePreferredView(hwnd, cInfo);
			break;
		case ID_TRANSMIT:
		{	TCHAR *LatLon = APRSLatLon(Lat, Lon, ' ', ' ', 3);
			if (MessageBox(hwnd, TEXT("Really Move ME?"), LatLon,
							MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	GPS_POSITION NewPos = {0};
				GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
				ForceTransmit = TRUE;
				if (Genius->LastAPRSUpdate) Genius->LastAPRSUpdate -= MINIMUM_APRS_DELTA*2;	/* Allow the FORCE */

				NewPos.dblLatitude = Lat;
				NewPos.dblLongitude = Lon;
				GetSystemTime(&NewPos.stUTCTime);
				NewPos.dwValidFields = GPS_VALID_UTC_TIME | GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE;	/* Only these */
				SetMyPosition(hwnd, cInfo, &NewPos);
				SetMyPosition(hwnd, cInfo, &NewPos);/* Clear the deltas */
			}
			free(LatLon);
			break;
		}
		case ID_COMPANIONS_NEW:
		{	COMPANION_INFO_S *Companon = PromptNewCompanion(hwnd, &ActiveConfig);
			TransmitCompanions();
#ifdef FUTURE
			if (Companion && Companion->Enabled)
			{	STATION_INFO_S *Station = TransmitObject(Obj);
				if (Station) SetCenterTracking(hwnd, Station);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
#endif
			break;
		}
		case ID_OBJECTS_NEW:
		{	//TCHAR *LatLon = APRSLatLon(Lat, Lon, ' ', ' ', 3);
			OBJECT_CONFIG_INFO_S *Obj = PromptNewObject(hwnd, &ActiveConfig, Lat, Lon);
			if (Obj && Obj->Enabled)
			{	STATION_INFO_S *Station = TransmitObject(Obj);
				if (Station) SetCenterTracking(hwnd, Station);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			//free(LatLon);
			break;
		}
		case ID_OBJECTS_NEW_DF_CENTER:
		case ID_DF_QUALITY_240:
		case ID_DF_QUALITY_120:
		case ID_DF_QUALITY_64:
		case ID_DF_QUALITY_32:
		case ID_DF_QUALITY_16:
		case ID_DF_QUALITY_8:
		case ID_DF_QUALITY_4:
		case ID_DF_QUALITY_2:
		case ID_DF_QUALITY_1:
		case ID_OBJECTS_NEW_DF:
		{	double distance, bearing;
			AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
								cInfo->LastCenterPosition.dblLongitude,
								Lat, Lon, &distance, &bearing);	
			if (s != ID_OBJECTS_NEW_DF)
			{	Lat = cInfo->LastCenterPosition.dblLatitude;
				Lon = cInfo->LastCenterPosition.dblLongitude;
//					GetCoordIndex(Lat, Lon, "DFObj");
			} else bearing = ((long)bearing+180)%360;	/* Turn it around */
			int Quality = s - ID_DF_QUALITY_BASE;
			if (Quality < 0 || Quality > 9) Quality = 3;
			char *Name = MakeNewObjectName("DF");
			char Comment[16];
			int Range = 0;
			if (cInfo->Scale > 0)
				Range = (int) (log(cInfo->Scale)/log(2.0));
			if (Range < 0) Range = 0;
			else if (Range > 9) Range = 9;
			sprintf(Comment,".../.../%03ld/9%1ld%1ld",
					(long)bearing,(long)Range,(long)Quality);
			OBJECT_CONFIG_INFO_S *Obj = PromptNewObject(hwnd, &ActiveConfig, Lat, Lon, '/', '\\', Comment, "DF", Name);
			if (Obj && Obj->Enabled)
			{	STATION_INFO_S *Station = TransmitObject(Obj);
				if (Station) SetCenterTracking(hwnd, Station);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			break;
		}
		case ID_OBJECTS_MOVE:
		if (Station)
		{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
			if (Obj)
			{	Obj->Latitude = Lat;
				Obj->Longitude = Lon;
				if (Obj->Enabled)
				{	TransmitObject(Obj);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
				SaveConfiguration(hwnd, &ActiveConfig, "User:Object:Move");
			}
		}
		break;
		case ID_OBJECTS_BEARING:
		if (Station)
		{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
			if (Obj)
			{	double distance, bearing;
				AprsHaversineLatLon(Station->pCoord->lat, Station->pCoord->lon, Lat, Lon,
								&distance, &bearing);
/*	.../.../nnn/xxx.... */
				if (strlen(Obj->Comment) > 11
				&& Obj->Comment[3] == '/'
				&& Obj->Comment[7] == '/'
				&& isdigit(Obj->Comment[8]&0xff)
				&& isdigit(Obj->Comment[9]&0xff)
				&& isdigit(Obj->Comment[10]&0xff)
				&& Obj->Comment[11] == '/')
				{	sprintf(Obj->Comment, "%.8s%03ld%s\n",
											Obj->Comment,
											(long) bearing,
											&Obj->Comment[11]);
					if (Obj->Enabled)
					{	TransmitObject(Obj);
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
					SaveConfiguration(hwnd, &ActiveConfig, "User:Object:Bearing");
				}
			}
		}
		break;
		case ID_OBJECTS_OFFSET:	/* Modify offset(s) */
		if (Station && Station->AreaObjParsed)	// Shape object?
		{	OBJECT_CONFIG_INFO_S *Obj = FindConfigObject(&ActiveConfig, Station->Station);
			double dLat = Lat - Station->pCoord->lat;
			double dLon = Station->pCoord->lon - Lon;
			if (Obj && Obj->Comment[0] == '6') dLon = -dLon;
			if (Obj && dLat >= 0.0 && dLon >= 0.0)
			{	int iLat = (int) sqrt(dLat*1500.0);
				int iLon = (int) sqrt(dLon*1500.0);
				if (iLat > 99) iLat = 99;
				if (iLon > 99) iLon = 99;
//	T = APRS->course / 100;
//	yOff = APRS->course % 100; yOff *= yOff; yOff /= 1500.0;// Degrees
//	C = APRS->speed / 100;
//	xOff = APRS->speed % 100; xOff *= xOff; xOff /= 1500.0;	// Degrees
				if (strlen(Obj->Comment) > 6
				&& isdigit(Obj->Comment[0]&0xff)
				&& isdigit(Obj->Comment[1]&0xff)
				&& isdigit(Obj->Comment[2]&0xff)
				&& (Obj->Comment[3] == '/' || Obj->Comment[3] == '1')
				&& isdigit(Obj->Comment[4]&0xff)
				&& isdigit(Obj->Comment[5]&0xff)
				&& isdigit(Obj->Comment[6]&0xff))
				{	Obj->Comment[1] = (iLat/10)+'0';
					Obj->Comment[2] = (iLat%10)+'0';
					Obj->Comment[5] = (iLon/10)+'0';
					Obj->Comment[6] = (iLon%10)+'0';
					if (Obj->Enabled)
					{	TransmitObject(Obj);
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
				}
			}
		}
		break;
//case ID_OBJ_AREA_SHAPE_LOWEST		42110	/* These must be in order */
		case ID_OBJ_AREA_SHAPE_OPEN_CIRCLE:
		case ID_OBJ_AREA_SHAPE_LINE_DOWN_RIGHT:
		case ID_OBJ_AREA_SHAPE_OPEN_ELLIPSE:
		case ID_OBJ_AREA_SHAPE_OPEN_TRIANGLE:
		case ID_OBJ_AREA_SHAPE_OPEN_BOX:
		case ID_OBJ_AREA_SHAPE_FILLED_CIRCLE:
		case ID_OBJ_AREA_SHAPE_LINE_DOWN_LEFT:
		case ID_OBJ_AREA_SHAPE_FILLED_ELLIPSE:
		case ID_OBJ_AREA_SHAPE_FILLED_TRIANGLE:
		case ID_OBJ_AREA_SHAPE_FILLED_BOX:
//case ID_OBJ_AREA_SHAPE_HIGHEST:
//	T = APRS->course / 100;
//	yOff = APRS->course % 100; yOff *= yOff; yOff /= 1500.0;// Degrees
//	C = APRS->speed / 100;
//	xOff = APRS->speed % 100; xOff *= xOff; xOff /= 1500.0;	// Degrees
		{	char *Name = MakeNewObjectName("SH");
			double dstLat, dstLon;
			AprsProjectLatLon(Lat, Lon, cInfo->Scale/2, 315,
								&dstLat, &dstLon);
			double dLat = dstLat - Lat;
			double dLon = dstLon - Lon;
			if (dLat < 0) dLat = - dLat;
			if (dLon < 0) dLon = - dLon;
			int iLat = (int) sqrt(dLat*1500.0);
			int iLon = (int) sqrt(dLon*1500.0);
			if (iLat > 99) iLat = 99;
			if (iLon > 99) iLon = 99;
			char Comment[8];
			sprintf(Comment, "%c%02ld/0%02ld",
					(s-ID_OBJ_AREA_SHAPE_LOWEST)+'0',
					(long) iLat, (long) iLon);
			OBJECT_CONFIG_INFO_S *Obj = PromptNewObject(hwnd, &ActiveConfig, Lat, Lon, '\\', 'l', Comment, "Shapes", Name);
			if (Obj && Obj->Enabled)
			{	STATION_INFO_S *Station = TransmitObject(Obj);
				if (Station) SetCenterTracking(hwnd, Station);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
		}
		break;
		default:			
		if (s<=(long)CloseStationCount)
		{	if (s < 0)	/* Must be Preferred */
			{	RestorePreferredView(hwnd, cInfo);
			} else
			{	s--;	/* Make back to zero relative */
				SetCenterTracking(hwnd, pCloseStations[s]);
			}
		} else if (s>=ID_MULTITRACK_MENU && s<ID_MULTITRACK_MENU+MAX_TRACKERS)
		{	int tr = s - ID_MULTITRACK_MENU;
			if (cInfos[tr].Active)
			{	ShowWindow(hwndTracker[tr], SW_RESTORE);
				SetForegroundWindow(hwndTracker[tr]);
			}
		} else if (s > ID_CHAT_NEW && (unsigned long)s <= ID_CHAT_NEW+ChatCount)
		{	s -= ID_CHAT_NEW+1;
			if (s>=0 && (unsigned long)s<ChatCount && Chats[s])
			{	DisplayChat(Chats[s]->From, Chats[s]->To);
			}
		}
#ifdef SUPPORT_TRACE_LOGS
		else
		{	TraceLogPopupMenuOption(s);
		}
#endif
		}	/* End switch(s) */
	}
	if (hMenu1) DestroyMenu(hMenu1);
	if (hMenu2) DestroyMenu(hMenu2);
	FreeMenuBitmaps(hPopup);
	DestroyMenu(hPopup);
	ThawCloseStations(hwnd);
}


void PopupPendingMessages(HWND hwnd)
{	if (PendingMsgCount)
	{	int m, count=0;
		HMENU hPopup = CreatePopupMenu();
		for (m=0; m<PendingMsgCount; m++)
		{	if (AppendMenu(hPopup, MF_STRING, m+1, PendingMsgs[m].uTo))
			{	count++;
				if (PendingMsgs[m].Subordinated)	/* Not allowed to mess with this? */
					EnableMenuItem(hPopup, m+1, MF_GRAYED);
			}
		}
		if (count)
		{	RECT rc;
			POINT pt;
			GetWindowRect(hwnd,&rc);
			pt.x = (rc.left+rc.right)/2;
			pt.y = (rc.top+rc.bottom)/2;
			if (count==1 && PendingMsgCount==1)
				m = 1;
			else m = TrackPopupMenuEx(hPopup, TPM_CENTERALIGN | TPM_VCENTERALIGN | TPM_RETURNCMD, pt.x, pt.y, hwnd, NULL);
			if (m && m-1 < PendingMsgCount)	/* Got a selection */
			{	int m1, Result;
				size_t Remaining = 128;	/* Overhead */
				TCHAR *Buffer, *Next, *Title;

				m--;	/* Adjust back to zero relative */

				for (m1=m; m1<PendingMsgCount; m1++)
				if (!strcmp(PendingMsgs[m].aTo, PendingMsgs[m1].aTo))
				{	Remaining += strlen(PendingMsgs[m].MessageBody)+64;
				}
				Remaining *= sizeof(*Buffer);
				Next = Buffer = (TCHAR*)malloc(Remaining);
				Title = (TCHAR*)malloc(sizeof(*Title)*64);
				StringCbPrintf(Title, sizeof(*Title)*64, TEXT("%s Msgs"), PendingMsgs[m].uTo);

				for (m1=m; m1<PendingMsgCount; m1++)
				if (!strcmp(PendingMsgs[m].aTo, PendingMsgs[m1].aTo))
				{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%S"), m==m1?"":"\n");
					StringCbPrintExUTF8(Next, Remaining, &Next, &Remaining, -1, PendingMsgs[m1].MessageBody, NULL);
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT(" (%02ld-%02ld %02ld:%02ld:%02ld)"),
								(long) PendingMsgs[m1].stQueued.wMonth,
								(long) PendingMsgs[m1].stQueued.wDay,
								(long) PendingMsgs[m1].stQueued.wHour,
								(long) PendingMsgs[m1].stQueued.wMinute,
								(long) PendingMsgs[m1].stQueued.wSecond);
					if (PendingMsgs[m1].OneShot)
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT(" *ONESHOT*"));
				}

				if (PendingMsgs[m].Retries < MAX_MSG_RETRIES)
				{	long NextSend = (long)(PendingMsgs[m].msNextSend - llGetMsec()) / 1000;
					if (NextSend > 0)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n\n%SRetry %ld of %ld in %ld seconds"),
										PendingMsgs[m].Retriggered?"Second ":"",
										(long) PendingMsgs[m].Retries+1,
										(long) MAX_MSG_RETRIES, (long) NextSend);
					} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n\n%SRetry %ld of %ld"),
										PendingMsgs[m].Retriggered?"Second ":"",
										(long) PendingMsgs[m].Retries+1,
										(long) MAX_MSG_RETRIES);
				} else
				{	long NextSend = (long)(llGetMsec()-PendingMsgs[m].msNextSend) / 1000;
					if (NextSend < 0) NextSend = 0;
					if (NextSend < 120)	/* 2 minutes gives seconds */
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S Retry (%ld) sent %ld seconds ago"),
											PendingMsgs[m].Retriggered?"FINAL":"Final",
											(long) PendingMsgs[m].Retries, (long) NextSend);
					else if (NextSend < 2*60*60)	/* 2 hours gives minutes */
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S Retry (%ld) sent %ld minutes ago"),
											PendingMsgs[m].Retriggered?"FINAL":"Final",
											(long) PendingMsgs[m].Retries, (long) NextSend/60);
					else if (NextSend < 2*24*60*60)	/* 2 days gives hours */
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S Retry (%ld) sent %.1lf hours ago"),
											PendingMsgs[m].Retriggered?"FINAL":"Final",
											(long) PendingMsgs[m].Retries, (double) NextSend/60.0/60.0);
					else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S Retry (%ld) sent %.1lf days ago"),
											PendingMsgs[m].Retriggered?"FINAL":"Final",
											(long) PendingMsgs[m].Retries, (double) NextSend/60.0/60.0/24.0);
				}

				Result = MessageBox(hwnd, Buffer, Title,
									MB_ABORTRETRYIGNORE | MB_ICONQUESTION | MB_DEFBUTTON2);

				free(Buffer); free(Title);

				if (m < PendingMsgCount)	/* Make sure it didn't ack away while we were waiting for the operator */
				switch (Result)
				{
				case IDABORT:
#ifdef USING_CHAT
					if (!PendingMsgs[m].SuppressChat)
					{	BOOL Reply = FALSE;
						CHAT_INFO_S *Chat = FindChat(CALLSIGN, PendingMsgs[m].aTo, &Reply);
						if (Chat)
						{	AddToChat(Chat, Reply, MESSAGE_ME, PendingMsgs[m].MessageBody, NULL, COLOR_MESSAGE_SOURCE_CANCELLED);
						}
					}
#endif
					RemovePendingMessage(m, "Abort");
#ifdef REDUNDANT_CODE
					if (--PendingMsgCount)	/* Any left? */
					{	int m1;
						for (m1=m+1; m1<=PendingMsgCount; m1++)
						if (PendingMsgs[m1].Subordinated
						&& !strcmp(PendingMsgs[m].aTo, PendingMsgs[m1].aTo))
						{	PendingMsgs[m1].Subordinated = FALSE;
							RetriggerPendingMessage(m1,"Abort",FALSE);	/* Start transmitting */
							break;	/* Only 1! */
						}
						if (PendingMsgCount!=m)
						{	memmove(&PendingMsgs[m], &PendingMsgs[m+1], sizeof(*PendingMsgs)*(PendingMsgCount-m));
						}
					}
#endif
					InvalidateMessage(TRUE);
					break;
				case IDRETRY:
					RetriggerPendingMessage(m, "Retry", TRUE);
					break;
#ifdef OLD_WAY
				{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
					QueueToTransmit(MESSAGE_PACKET, PendingMsgs[m].Message);
					if (!PendingMsgs[m].RFOnly) PendingMsgs[m].msLastIS = llGetMsec();	/* Went out -IS */
					PendingMsgs[m].Retriggered = TRUE;	/* A manual retry counts as a Retrigger? */
					PendingMsgs[m].Retries = 0;	/* Restart the retries */
					PendingMsgs[m].msNextSend = NEXT_MSG_SEND(PendingMsgs[m].Retries);
					break;
				}
#endif
				}
			}
		}
		FreeMenuBitmaps(hPopup);
		DestroyMenu(hPopup);
	}
}

LRESULT BottomHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	return TRUE;
}

LRESULT DefaultHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_PAINT:
		FrameRect(hdc, &Info->Tracker[cInfo->Index].rc, (HBRUSH) GetStockObject(BLACK_BRUSH));
		DrawText(hdc, Info->uLabel, -1, &Info->Tracker[cInfo->Index].rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		break;
	}
	return TRUE;
}

LRESULT ClearHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_PAINT:
	    FillRect(hdc, &Info->Tracker[cInfo->Index].rc, GetSysColorBrush(COLOR_WINDOW));
		break;
	}
	return TRUE;
}

LRESULT SliderHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	RECT rc;

	if (ActiveConfig.View.ZoomMax < ActiveConfig.View.ZoomMin)
	{	ActiveConfig.View.ZoomMax = ActiveConfig.View.ZoomMin = (ActiveConfig.View.ZoomMax+ActiveConfig.View.ZoomMin)/2;
	}
	if (cInfo->zoom < ActiveConfig.View.ZoomMin) cInfo->zoom = ActiveConfig.View.ZoomMin;
	if (cInfo->zoom > ActiveConfig.View.ZoomMax) cInfo->zoom = ActiveConfig.View.ZoomMax;

	switch (msg)
	{
	case WM_MOUSEWHEEL:
	{	int Delta = WHEEL_DELTA*ActiveConfig.View.WheelDelta/4;
		if (Delta <= 0) Delta = WHEEL_DELTA;
#ifdef VERBOSE
TraceLog("Activity", TRUE, hwnd, "WHEEL_DELTA(%ld) is %ld, Wheel Did %ld + %ld Overage\n",
		 (long) WHEEL_DELTA, (long) Delta,
		 (long) GET_WHEEL_DELTA_WPARAM(wp),
		 (long) cInfo->WheelDelta);
#endif
		cInfo->WheelDelta += GET_WHEEL_DELTA_WPARAM(wp);
		if (cInfo->WheelDelta > 0)
		{	while (cInfo->WheelDelta >= Delta)
			{	PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);	/* + for away from user */
				cInfo->WheelDelta -= Delta;
			}
		}
		else if (cInfo->WheelDelta < 0)
		{	while (cInfo->WheelDelta <= -Delta)
			{	PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);	/* - for towards user */
				cInfo->WheelDelta += Delta;
			}
		}
		return 0;
	}
	case WM_LBUTTONDBLCLK:
	{	int OrgZoom = cInfo->zoom;
		POINT pt;
		RECT rc;
		BOOL DidIt = FALSE;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.top + (rc.right-rc.left);	/* + at top of bar */
		if (PtInRect(&rc, pt))
			cInfo->zoom = OrgZoom /*MIN_OSM_ZOOM*/;
		else
		{	rc = Info->Tracker[cInfo->Index].rc;
			rc.top = rc.bottom - (rc.right-rc.left);	/* - at bottom of bar */
			if (PtInRect(&rc, pt))
				cInfo->zoom = OrgZoom /*MAX_OSM_ZOOM*/;	/* Will still get button-up */
			else
			{	float Perc = (float)(pt.y-Info->Tracker[cInfo->Index].rc.top) / (float)(Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top);
				if (ActiveConfig.View.ZoomReverse)
					cInfo->zoom = (int) ((ActiveConfig.View.ZoomMax-ActiveConfig.View.ZoomMin)*(1.0-Perc)+0.5);
				else cInfo->zoom = (int) ((ActiveConfig.View.ZoomMax-ActiveConfig.View.ZoomMin)*Perc+0.5);
				if (cInfo->zoom < ActiveConfig.View.ZoomMin) cInfo->zoom = ActiveConfig.View.ZoomMin;
				if (cInfo->zoom > ActiveConfig.View.ZoomMax) cInfo->zoom = ActiveConfig.View.ZoomMax;
			}
		}
		if (cInfo->zoom != OrgZoom)
		{
			if (ActiveConfig.Screen.Show.CrossHairs > 0)
			{	cInfo->CrossHairs = TRUE;
				SetTimer(hwnd, CROSSHAIR_TIMER, ActiveConfig.Screen.Show.CrossHairTime, NULL);
			}
			cInfo->msLastSigChange = llGetMsec();
			InvalidateScale(hwnd, FALSE);
			InvalidateStations(hwnd, FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
		}
		break;
	}
	case WM_LBUTTONUP:
	{	POINT pt;
		RECT rc;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.top + (rc.right-rc.left);	/* + at top of bar */
		if (PtInRect(&rc, pt))
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);
		rc = Info->Tracker[cInfo->Index].rc;
		rc.top = rc.bottom - (rc.right-rc.left);	/* - at bottom of bar */
		if (PtInRect(&rc, pt))
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);
		break;
	}
	case WM_PAINT:
//		FrameRect(hdc, &Info->rc, (HBRUSH) GetStockObject(BLACK_BRUSH));

		int width = (Info->Tracker[cInfo->Index].rc.right - Info->Tracker[cInfo->Index].rc.left);
static	double L2 = log((double)2.0);
#define log2(f) (log((double)(f))/L2)
		rc = Info->Tracker[cInfo->Index].rc;
//		rc.top += width;
//		rc.bottom -= width;
#ifdef DO_OSM
		if (ActiveConfig.View.ZoomReverse)
			DrawRGRectangle(hdc, &rc, TRUE, cInfo->zoom, ActiveConfig.View.ZoomMax, ActiveConfig.View.ZoomMin, TRUE);
		else	DrawRGRectangle(hdc, &rc, TRUE, cInfo->zoom, ActiveConfig.View.ZoomMin, ActiveConfig.View.ZoomMax, TRUE);
#else
		DrawRGRectangle(hdc, &rc, TRUE, log2(cInfo->Scale), log2(MAX_SCALE), log2(MIN_SCALE), TRUE);
#endif
#undef log2

		rc = Info->Tracker[cInfo->Index].rc;
		rc.right++;	/* Doesn't draw this bit */
		rc.bottom = rc.top + (rc.right-rc.left)+1;	/* + at top of bar */
//		FrameRect(hdc, &rc, (HBRUSH) GetStockObject(BLACK_BRUSH));
		FrameRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOWTEXT));
		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom++;	/* Doesn't draw this bit */
		rc.right++;	/* Doesn't draw this bit */
		rc.top = rc.bottom - (rc.right-rc.left);	/* - at bottom of bar */
		FrameRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOWTEXT));

		int prevBkMode = SetBkMode(hdc, TRANSPARENT);
		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.top + width;
		DrawText(hdc, TEXT(" + "), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		rc = Info->Tracker[cInfo->Index].rc;
		rc.top = rc.bottom - width;
		DrawText(hdc, TEXT(" - "), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

		/* Draw the zoom number inside the slider */
		if (cInfo->Circle.msNotAllExpire>0)
		{	TCHAR tBuff[8];
			StringCbPrintf(tBuff, sizeof(tBuff), TEXT("%ld"), cInfo->zoom);
			rc = Info->Tracker[cInfo->Index].rc;
			if (cInfo->zoom >= MIN_SETTABLE_ZOOM)
			{	COLORREF prevColor = SetTextColor(hdc, RGB(0,255,0));
				DrawText(hdc, tBuff, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				SetTextColor(hdc, prevColor);
			} else DrawText(hdc, tBuff, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		}

		SetBkMode(hdc, prevBkMode);
		break;
	}
	return TRUE;
}

#ifdef SUPPORT_HOURLY_PACKET_COUNT
static void AddHourly(char *What, size_t Count, unsigned long *Counts, TCHAR **Next, size_t *Remaining)
{	size_t h;
	TCHAR *FirstGood = *Next;
	TCHAR *LastGood = *Next;
	size_t LastRemain = *Remaining;

	for (h=0; h<Count; h++)
	{	double Display, Divisor = 1;
		int Digits=0;
		char *Suffix="";
		unsigned long Value = Counts[h];

		if (h == 0)
		{	SYSTEMTIME stNow;
			GetSystemTime(&stNow);
			if (stNow.wMinute)
			{	Value *= 60;
				Value /= stNow.wMinute;
			}
		}

		if (Value > 1000*1000*1000)
		{	Divisor = 1000.0*1000.0*1000; Suffix = "b";
		} else if (Value > 1000*1000)
		{	Divisor = 1000.0*1000.0; Suffix = "m";
		} else if (Value > 10*1000)
		{	Divisor = 1000.0; Suffix = "k";
		} else { Divisor = 1.0; Suffix = ""; }
		Display = (double) Value/Divisor;
		if (Divisor > 1)
		{	if (Display >= 100) { Digits=0; }
			else if (Display >= 10) { Digits=1; }
			else { Digits=2; }
		} else { Digits=0; }
		if (!h)
		{	StringCbPrintfEx(*Next, *Remaining, Next, Remaining,
							STRSAFE_IGNORE_NULLS, TEXT("\n%S: "), What);
		} else StringCbPrintfEx(*Next, *Remaining, Next, Remaining,
								STRSAFE_IGNORE_NULLS, TEXT(" "));
		StringCbPrintfEx(*Next, *Remaining, Next, Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("%.*lf%S"), (int) Digits, (double) Display, Suffix);
		if (Display)
		{	LastGood = *Next; LastRemain = *Remaining;
		}
	}
#define FUTURE
#ifdef FUTURE
#undef FUTURE
	if (FirstGood != LastGood)
	{	StringCbPrintfEx(LastGood, LastRemain, Next, Remaining, STRSAFE_IGNORE_NULLS, TEXT(" /hr"));
	} else
	{	*Next = LastGood;
		*Remaining = LastRemain;
		**Next = TEXT('\0');
	}
#else
	StringCbPrintfEx(*Next, *Remaining, Next, Remaining, STRSAFE_IGNORE_NULLS, TEXT(" /hr"));
#endif

}
#endif

LRESULT StatUsageHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	unsigned int s;
		size_t Remaining = sizeof(TCHAR)*1024;
		TCHAR *Buffer=(TCHAR*)malloc(Remaining);
		TCHAR *Next = Buffer;
		long TotalCount=0, TotalDupes=0, TotalSize=0, TotalInvalids=0;
		unsigned long DirectStationCount = 0, LocalStationCount = 0, RFStationCount = 0;
		for (s=0; s<CloseStationCount; s++)
		{	TotalCount += pCloseStations[s]->TrackCount;
			TotalDupes += pCloseStations[s]->TrackDupes;
			TotalInvalids += pCloseStations[s]->TrackInvalids;
			TotalSize += pCloseStations[s]->TrackSize;
			if (pCloseStations[s]->HeardOnRF)
			{	RFStationCount++;
				if (pCloseStations[s]->HeardOnRF <= LOCAL_MAX_HOPS+1)
					LocalStationCount++;
				if (pCloseStations[s]->HeardOnRF == 1)
					DirectStationCount++;
			}
		}

		*Buffer = *TEXT("");	/* Initial null termination */
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("Using %ld of %ld Stations"),
						(long) CloseStationCount, (long) ActiveConfig.Stations.AvgCount);
//#ifndef UNDER_CE
		if (ActiveConfig.Stations.AvgIntervals && ActiveConfig.Stations.AvgCount)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT(" (Runs:%ld)"),
						(long) ActiveConfig.Stations.AvgIntervals);

		}
//#endif
		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nAge %ld to %ld (%ld) Minutes"),
						(long) ActiveConfig.Stations.MinAge, (long) ActiveConfig.Stations.MaxAge, (long) ActiveConfig.Stations.BuddyMaxAge);

		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nTrack Age %ld (%ld) Hours"),
						(long) ActiveConfig.Aging.TrackHours, (long) ActiveConfig.Aging.BuddyTrackHours);

		StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
						TEXT("\nBulletins %ld Hours, TelemDefs %ld Days"),
						(long) ActiveConfig.Aging.TelemetryDefDays,
						(long) ActiveConfig.Aging.TelemetryDefDays);

#ifdef TRACK_FIND_STATIONS
#ifdef SUPPORT_HOURLY_PACKET_COUNT
		AddHourly("Old", HOURLY_PACKETS, OldStations, &Next, &Remaining);
		AddHourly("New", HOURLY_PACKETS, NewStations, &Next, &Remaining);
		AddHourly("Sort", HOURLY_PACKETS, SortStations, &Next, &Remaining);
		AddHourly("Find1", HOURLY_PACKETS, Find1Stations, &Next, &Remaining);
		AddHourly("Find2", HOURLY_PACKETS, Find2Stations, &Next, &Remaining);
#endif
#endif

		if (DirectStationCount || LocalStationCount || RFStationCount)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n%ld via RF (%ld Direct %ld Local)"),
							(long) RFStationCount,
							(long) DirectStationCount,
							(long) LocalStationCount);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nIStoRF: %ld hops in %ld minutes"),
							(long) LOCAL_MAX_HOPS,
							(long) RECENTLY_HEARD_MINUTES);
		}
#ifdef MONITOR_PHONE
		if (CellularSize)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n%ld/%ld Cellular Points (%ldKb)"),
							(long) CellularCount, (long) CellularSize,
							(long) (sizeof(*Cellulars)*CellularSize+1023)/1024);
#endif
		if (MyStation)
		{	if (MyStation->TrackSize)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n%ld/%ld Track Points (%ldKb)"),
								(long) MyStation->TrackCount, (long) MyStation->TrackSize,
								(long) (sizeof(*MyStation->Tracks)*MyStation->TrackSize+1023)/1024);
			if (MyStation->TrackDupes || MyStation->TrackInvalids)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT(" (%ld Dupes, %ld Inv)"),
							(long) MyStation->TrackDupes,
							(long) MyStation->TrackInvalids);
			if (TotalSize)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n%ld/%ld Total Points (%ldKb)"),
							(long) TotalCount, (long) TotalSize,
							(long) (sizeof(*MyStation->Tracks)*TotalSize+1023)/1024);
			if (TotalDupes || TotalInvalids)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n(%ld Dupes, %ld Inv)"),
							(long) TotalDupes, (long) TotalInvalids);
		}

#ifdef SUPPORT_RFID
		if (RFIDCount)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n\n%ld RFID IDs (%ld Type%S)"),
							(long) RFIDCount, (long) RFIDTypeCount, RFIDTypeCount==1?"":"s");
#endif
		{	char *Temp = GetDupeStats();
			if (Temp)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\n%S"), Temp);
				free(Temp);
			}
		}

#ifdef ORIGINAL
		StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Using %ld of %ld Stations\n%ld/%ld Track Points (%ldKb) (%ld Dupes, %ld Inv)\n%ld/%ld Total Points (%ldKb)\n(%ld Dupes, %ld Inv)"),
						(long) CloseStationCount, (long) ActiveConfig.Stations.MaxCount,
						(long) CloseStations[0].TrackCount, (long) CloseStations[0].TrackSize,
						(long) (sizeof(*CloseStations[0].Tracks)*CloseStations[0].TrackSize+1023)/1024,
						(long) CloseStations[0].TrackDupes,
						(long) CloseStations[0].TrackInvalids,
						(long) TotalCount, (long) TotalSize,
						(long) (sizeof(*CloseStations[0].Tracks)*TotalSize+1023)/1024,
						(long) TotalDupes, (long) TotalInvalids);
#endif

		if (ActiveConfig.Update.Development)
		{	char *Temp = GetCloseStationStats();
			if (Temp)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\n\n%S"), Temp);
				free(Temp);
			}
		}

		MessageBox(hwnd, Buffer, TEXT("Close Stations"), MB_OK | MB_ICONINFORMATION);
#ifdef USING_SIP
//		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
		free(Buffer);
		break;
	}
	case WM_PAINT:
	{	RECT rc = Info->Tracker[cInfo->Index].rc;
#ifdef SHOW_TRACK_MEMORY_CONSUMPTION
		long TotalSize=0;
		for (unsigned int s=0; s<CloseStationCount; s++)
		{	TotalSize += pCloseStations[s]->TrackSize;
		}
		rc.right -= (rc.right-rc.left)/2;
		DrawRGRectangle(hdc, &rc, TRUE, (double) CloseStationCount,
						(double) (ActiveConfig.Stations.AvgCount?
						ActiveConfig.Stations.AvgCount:CloseStationCount*2),
						0, TRUE);
		rc.right = Info->Tracker[cInfo->Index].rc.right;
		rc.left += (rc.right-rc.left)/2;
		DrawRGRectangle(hdc, &rc, TRUE, (double) TotalSize*sizeof(*MyStation->Tracks), (double) 64*1024, 0, TRUE);
#else
#ifdef SHOW_STATION_LIST_SIZE
		DrawRGRectangle(hdc, &rc, TRUE, (double) CloseStationCount,
					(double) (ActiveConfig.Stations.AvgCount?
					ActiveConfig.Stations.AvgCount:CloseStationCount*2),
					0, TRUE);
#else
		DrawRGRectangle(hdc, &rc, TRUE, (double) DupeInUse,
					(double) DupeUseMax,
					0, TRUE);
#endif
#endif
		break;
	}
	}
	return TRUE;
}

LRESULT PowerHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
/*
typedef struct _SYSTEM_POWER_STATUS_EX {
  BYTE ACLineStatus;
  BYTE  BatteryFlag;
  BYTE BatteryLifePercent;
  BYTE Reserved1;
  DWORD BatteryLifeTime;
  DWORD BatteryFullLifeTime;
  BYTE Reserved2;
  BYTE BackupBatteryFlag;
  BYTE BackupBatteryLifePercent;
  BYTE Reserved3;

Copy Code

  DWORD BackupBatteryLifeTime;
  DWORD BackupBatteryFullLifeTime;
} SYSTEM_POWER_STATUS_EX, *PSYSTEM_POWER_STATUS_EX,
*LPSYSTEM_POWER_STATUS_EX;

 ACLineStatus - It is one of the following values.
    AC_LINE_OFFLINE Offline
    AC_LINE_ONLINE Online
    AC_LINE_BACKUP_POWER Backup Power
    AC_LINE_UNKNOWN Unknown status
    All other values are reserved.

BatteryFlag - It can be a combination of the following values:
    BATTERY_FLAG_HIGH High
    BATTERY_FLAG_LOW Low
    BATTERY_FLAG_CRITICAL Critical
    BATTERY_FLAG_CHARGING Charging
    BATTERY_FLAG_NO_BATTERY No system battery
    BATTERY_FLAG_UNKNOWN Unknown status

BatteryLifePercent - Percentage of full battery charge remaining. This member can be a value in the range 0 to 100, or BATTERY_FLAG_UNKNOWN if status is unknown. All other values are reserved.
BatteryLifeTime - Number of seconds of battery life remaining, or BATTERY_FLAG_UNKNOWN if remaining seconds are unknown.
BatteryFullLifeTime - Number of seconds of battery life when at full charge, or BATTERY_FLAG_UNKNOWN if full lifetime is unknown.
BackupBatteryFlag - It can be a combination of the following values:
        * BATTERY_FLAG_HIGH
        * BATTERY_FLAG_CRITICAL
        * BATTERY_FLAG_CHARGING
        * BATTERY_FLAG_NO_BATTERY
        * BATTERY_FLAG_UNKNOWN
        * BATTERY_FLAG_LOW
BackupBatteryLifePercent - Percentage of full backup battery charge remaining. Must be in the range 0 to 100, or BATTERY_PERCENTAGE_UNKNOWN.

*/
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{
#ifdef UNDER_CE
		if (GetSystemPowerStatusEx2(&sps2, sizeof(sps2), TRUE))
#else
		if (GetSystemPowerStatus(&sps))
#endif
		{
#define DEBUG_POWER
#ifdef DEBUG_POWER
#define DOIT(f) TraceLogThread("Power", FALSE, "%s:%ld\n", #f, (long) sps2.f);
			DOIT(ACLineStatus);
			DOIT(BatteryFlag);
			DOIT(BatteryLifePercent);
			DOIT(BatteryLifeTime);
			DOIT(BatteryFullLifeTime);
#ifdef UNDER_CE
			DOIT(BackupBatteryFlag);
			DOIT(BackupBatteryLifePercent);
			DOIT(BackupBatteryLifeTime);
			DOIT(BackupBatteryFullLifeTime);
			DOIT(BatteryVoltage);
			DOIT(BatteryCurrent);
			DOIT(BatteryAverageCurrent);
			DOIT(BatteryAverageInterval);
			DOIT(BatterymAHourConsumed);
			DOIT(BatteryTemperature);
			DOIT(BackupBatteryVoltage);
			DOIT(BatteryChemistry);
#endif
#undef DOIT
#endif

//#ifdef UNDER_CE
//#ifdef CE50
//		memset(&sps,0,sizeof(sps));
//#else
//		if (GetSystemPowerStatusEx(&sps, TRUE))
//#endif
//#else
//		if (GetSystemPowerStatus(&sps))
//#endif
			struct
			{	int Hours, Minutes, Seconds;
			} Life = {0}, FullLife = {0};
			char *ACStatus;
			TCHAR Buffer[256], BatStatus[80]={0};
			size_t Remaining = sizeof(Buffer);
			TCHAR *Next = Buffer;

			switch (sps2.ACLineStatus)
			{
			case AC_LINE_OFFLINE: ACStatus = "Offline"; break;
			case AC_LINE_ONLINE: ACStatus = "Online"; break;
			case AC_LINE_BACKUP_POWER: ACStatus = "Backup"; break;
			case AC_LINE_UNKNOWN: ACStatus = "Unknown"; break;
			default: ACStatus = "Undefined";
			}
			if (sps2.BatteryLifeTime != BATTERY_LIFE_UNKNOWN)
			{	Life.Seconds = sps2.BatteryLifeTime % 60;
				Life.Minutes = sps2.BatteryLifeTime / 60;
				Life.Hours = Life.Minutes / 60;
				Life.Minutes = Life.Minutes % 60;
			}
			if (sps2.BatteryFullLifeTime != BATTERY_LIFE_UNKNOWN)
			{	FullLife.Seconds = sps2.BatteryFullLifeTime % 60;
				FullLife.Minutes = sps2.BatteryFullLifeTime / 60;
				FullLife.Hours = FullLife.Minutes / 60;
				FullLife.Minutes = FullLife.Minutes % 60;
			}

#ifdef UNDER_CE
			if (sps2.BatteryVoltage)
				StringCbPrintf(BatStatus, sizeof(BatStatus), TEXT("%.2lfv "), (double) sps2.BatteryVoltage/1000.0);
#endif
			if (sps2.BatteryFlag == BATTERY_FLAG_UNKNOWN) 
				StringCchCat(BatStatus, ARRAYSIZE(BatStatus), TEXT("Unknown"));
			else
			{	if (sps2.BatteryFlag & BATTERY_FLAG_HIGH) StringCbCat(BatStatus, sizeof(BatStatus), TEXT("High "));
				if (sps2.BatteryFlag & BATTERY_FLAG_LOW) StringCbCat(BatStatus, sizeof(BatStatus), TEXT("Low "));
				if (sps2.BatteryFlag & BATTERY_FLAG_CRITICAL) StringCbCat(BatStatus, sizeof(BatStatus), TEXT("Critical "));
				if (sps2.BatteryFlag & BATTERY_FLAG_CHARGING) StringCbCat(BatStatus, sizeof(BatStatus), TEXT("Charging "));
				if (sps2.BatteryFlag & BATTERY_FLAG_NO_BATTERY) StringCbCat(BatStatus, sizeof(BatStatus), TEXT("None "));
			}

			if (sps2.BatteryLifePercent != BATTERY_PERCENTAGE_UNKNOWN)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Battery: %ld%% %s\n"),
								(long) sps2.BatteryLifePercent, BatStatus);

			if (sps2.BatteryLifeTime != BATTERY_LIFE_UNKNOWN
			&& sps2.BatteryLifeTime != 0)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("LifeTime: %2ld:%02ld:%02ld\n"),
								(long) Life.Hours, (long) Life.Minutes, (long) Life.Seconds);

			if (sps2.BatteryFullLifeTime != BATTERY_LIFE_UNKNOWN
			&& sps2.BatteryFullLifeTime != 0)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("MaxLife: %2ld:%02ld:%02ld\n"),
								(long) FullLife.Hours, (long) FullLife.Minutes, (long) FullLife.Seconds);

#ifdef UNDER_CE
			TCHAR BackStatus[80]={0};
			if (sps2.BackupBatteryVoltage)
				StringCbPrintf(BackStatus, sizeof(BackStatus), TEXT("%.2lfv "), (double) sps2.BackupBatteryVoltage/1000.0);

			if (sps2.BackupBatteryFlag == BATTERY_FLAG_UNKNOWN) 
				StringCchCat(BackStatus, ARRAYSIZE(BackStatus), TEXT("Unknown"));
			else
			{	StringCchCopy(BackStatus, ARRAYSIZE(BackStatus), TEXT(""));
				if (sps2.BackupBatteryFlag & BATTERY_FLAG_HIGH) StringCbCat(BackStatus, sizeof(BackStatus), TEXT("High "));
				if (sps2.BackupBatteryFlag & BATTERY_FLAG_LOW) StringCbCat(BackStatus, sizeof(BackStatus), TEXT("Low "));
				if (sps2.BackupBatteryFlag & BATTERY_FLAG_CRITICAL) StringCbCat(BackStatus, sizeof(BackStatus), TEXT("Critical "));
				if (sps2.BackupBatteryFlag & BATTERY_FLAG_CHARGING) StringCbCat(BackStatus, sizeof(BackStatus), TEXT("Charging "));
				if (sps2.BackupBatteryFlag & BATTERY_FLAG_NO_BATTERY) StringCbCat(BackStatus, sizeof(BackStatus), TEXT("None "));
			}

			if (sps2.BackupBatteryLifePercent!=BATTERY_PERCENTAGE_UNKNOWN)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Backup: %ld%% %s\n"),
								(long) sps2.BackupBatteryLifePercent, BackStatus);

			if (sps2.BatteryCurrent)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Current: %ldmA\n"),
								(long) sps2.BatteryCurrent);

			if (sps2.BatteryAverageCurrent)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("CurrAvg: %ldmA (%ldmsec)\n"),
								(long) sps2.BatteryAverageCurrent,
								(long) sps2.BatteryAverageInterval);

			if (sps2.BatterymAHourConsumed)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Consumed: %ldmAHr\n"),
								(long) sps2.BatterymAHourConsumed);

			if (sps2.BatteryTemperature)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Temperature: %.1lfC\n"),
								(double) sps2.BatteryTemperature/10.0);
#endif

			if (sps2.ACLineStatus != AC_LINE_UNKNOWN)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("A/C: %S\n"),
								ACStatus);

#ifdef USING_POWER
			if (PowerCount)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("\n%ld/%ld Power Transitions"),
								(long) PowerCount, (long) POWER_COUNT);
#endif

			if (Next == Buffer)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("No Power Status Available"));

			InvalidatePower(TRUE);

			MessageBox(hwnd, Buffer, TEXT("Power Status"), MB_OK | MB_ICONINFORMATION);

#ifdef USING_SIP
//			SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
		}
		break;
	}
	case WM_PAINT:
#ifdef USING_POWER
		if (pbpi.dwBatteryFullLifeTime != BATTERY_LIFE_UNKNOWN
		&& pbpi.dwBatteryFullLifeTime
		&& pbpi.dwBatteryLifeTime != BATTERY_LIFE_UNKNOWN
		&& pbpi.dwBatteryLifeTime)
			DrawRGRectangle(hdc, &Info->Tracker[cInfo->Index].rc, TRUE, pbpi.dwBatteryLifeTime, 0, pbpi.dwBatteryFullLifeTime, FALSE);
		else if (pbpi.bBatteryLifePercent != BATTERY_PERCENTAGE_UNKNOWN)
			DrawRGRectangle(hdc, &Info->Tracker[cInfo->Index].rc, TRUE, pbpi.bBatteryLifePercent, 0, 100, FALSE);
		else DrawRGRectangle(hdc, &Info->Tracker[cInfo->Index].rc, TRUE, 50, 0, 100, FALSE);
#else
static	unsigned long BadCount = 0;
		if (sps2.BatteryLifePercent != BATTERY_PERCENTAGE_UNKNOWN)
		{	BadCount = 0;
			DrawRGRectangle(hdc, &Info->Tracker[cInfo->Index].rc, TRUE, sps2.BatteryLifePercent, 0, 100, FALSE);
		} else
		{	if (BadCount++ == 60)
			{	ActiveConfig.Screen.Show.Battery = FALSE;
				ShuffleScreenElements(hwnd);
			}
			DrawRGRectangle(hdc, &Info->Tracker[cInfo->Index].rc, TRUE, 50, 0, 100, FALSE);
		}
#endif
		break;
	}
	return TRUE;
}

LRESULT ScaleHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	TCHAR Buffer[80];

	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	if (!RestorePreferredView(hwnd, cInfo))
		if (cInfo->CenterStation != MyStation
		|| cInfo->LastCenterPosition.dblLatitude != LastGoodPosition.dblLatitude
		|| cInfo->LastCenterPosition.dblLongitude != LastGoodPosition.dblLongitude)
		{	SetCenterTracking(hwnd, MyStation);
		}
		break;
	}
	case WM_PAINT:
	{	double Scale = cInfo->Scale;
		if (ActiveConfig.View.Metric.Distance) Scale *= KmPerMile;
		if (Scale >= 100.0)
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld"), (long) Scale);
		else if (Scale >= 10.0)
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.1lf"), (double) Scale);
		else if (ActiveConfig.View.Metric.Distance)
		{	if (Scale > (999.0/1000.0))
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.2lf"), (double) Scale);
			else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ldm"), (long) (Scale*1000.0));
		} else
		{	if (Scale > (999.0/5280.0))
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.2lf"), (double) Scale);
			else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld'"), (long) (Scale*5280.0));
		}
		DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		break;
	}
	}
	return TRUE;
}

LRESULT StationHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
#ifdef TOO_OBNOXIOUS
	case WM_MOUSEMOVE:	/* This only comes through when captured */
	{	POINT		pt;
		pt.x = LOWORD(lp); 
		pt.y = HIWORD(lp); 
		if (!PtInRect(&Info->Tracker[cInfo->Index].rc, pt))
		{	SendMessage(hwnd, WM_RBUTTONUP, wp, lp);
		}
		break;
	}
#endif
	case WM_CONTEXTMENU:
	case WM_RBUTTONUP:
		if (cInfo->Captured && cInfo->CaptureHandler == StationHandler)
		{	cInfo->Captured = FALSE;
			ReleaseCapture();
			PaintingStationsFrozen = FALSE;
			if (PendingStationsCount)	/* Buffer any? */
			{	RecoverPendingStations(hwnd);
			}
			InvalidateStations(hwnd, FALSE);
			InvalidatePortStatus(TRUE);	/* Color it normal */
			// InvalidateStations(hwnd,TRUE);	/* Get the frozen border cleared */
		} else
		{	POINT pt;
			pt.x = LOWORD(lp); pt.y = HIWORD(lp);
			if (PtInRect(&Info->Tracker[cInfo->Index].rc, pt))
				PopupStationMenu(hwnd, pt);
		}
		return TRUE;
	case WM_LBUTTONUP:
	if (!ActiveConfig.Scroller.FreezeOnClick
	|| (cInfo->Captured && cInfo->CaptureHandler == StationHandler))
	{	POINT pt;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		if (PtInRect(&Info->Tracker[cInfo->Index].rc, pt))
			PopupStationMenu(hwnd, pt);
		else SendMessage(hwnd, WM_RBUTTONUP, wp, lp);
		break;
	} else if (ActiveConfig.Scroller.FreezeOnClick && !cInfo->Captured)
	{	cInfo->Captured = TRUE;
		cInfo->ibCapture = Info;
		cInfo->CaptureHandler = StationHandler;
		cInfo->ptCapture.x = LOWORD(lp); 
		cInfo->ptCapture.y = HIWORD(lp); 
		SetCapture(hwnd);
		PaintingStationsFrozen = TRUE;
		InvalidatePortStatus();	/* Color it pink */
		InvalidateStations(hwnd,TRUE);	/* Get the frozen border drawn */
		break;
	}
	case WM_PAINT:
	{	unsigned long s;
		RECT rc = Info->Tracker[cInfo->Index].rc;
		int height = DrawText(hdc, TEXT("KJ4ERJ"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
		unsigned long VisibleCount = ((Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top)/height)+1;
		COLORREF foreColor = GetSysColor(COLOR_WINDOWTEXT), backColor = GetSysColor(COLOR_WINDOW);
		COLORREF prevColor = SetTextColor(hdc, foreColor);
		COLORREF prevBkColor = SetBkColor(hdc, backColor);
		BOOL newPos = (cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);
		HDC hMemDC = CreateCompatibleDC(hdc);
		BOOL WidthChanged = FALSE;

		if (VisibleCount > ActiveConfig.PacketScrollerSize)
		{	TraceLog("Activity", TRUE, hwnd, "Scroller %ld %ld -> %ld %ld Height %ld / %ld = %ld entries (was %ld)\n",
					Info->Tracker[cInfo->Index].rc.left, Info->Tracker[cInfo->Index].rc.top,
					Info->Tracker[cInfo->Index].rc.right, Info->Tracker[cInfo->Index].rc.bottom,
					(Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top), height,
					VisibleCount, ActiveConfig.PacketScrollerSize);
			ActiveConfig.PacketScrollerSize = VisibleCount;
			rc = Info->Tracker[cInfo->Index].rc;
			DrawText(hdc, TEXT("RESIZE!"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
			ReSizePacketScroller(hwnd);
		} else
		{

#ifdef OLD_WAY
		for (s=0; s<PacketScrollerSize; s++)
			SetRectEmpty(&PaintingStations[s].rc);
#else
		memset(rcPaintingStations,0,sizeof(*rcPaintingStations)*PacketScrollerSize);
#endif
		rc = Info->Tracker[cInfo->Index].rc;
		rc.left += 2;
		for (s=0; s<PacketScrollerSize; s++)
		if (*PaintingStations[s].Station)
		{	int offset;
			int cIndex = PaintingStations[s].CloseIndex;
			COLORREF TextColor, BkColor = PaintingStations[s].BackColor;

			if (PaintingStations[s].Lat || PaintingStations[s].Lon)	/* We have a position */
			{	double distance, bearing;
				AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude,
									PaintingStations[s].Lat, PaintingStations[s].Lon, &distance, &bearing);
				TextColor = GetScaledRGColorText(distance, 0, cInfo->Scale);
			} else TextColor = GetSysColor(COLOR_WINDOWTEXT);

			if (cIndex != -1	/* If we know this one */
			&& BkColor == GetSysColor(COLOR_WINDOW))	/* and Default background, see if it changes! */
			{	if (pCloseStations[cIndex]->isBuddy && TextColor != RGB(0,0,0))	/* Reverse video my buddies, but only if position */
				{	COLORREF t = TextColor;
					TextColor = BkColor;
					BkColor = t;
				} else if (pCloseStations[cIndex]->isClient)
				{	BkColor = RGB(255,255,128);	/* Highlight APRSISCE/32 Users! */
				}
			}

#define COLOR_STATIONS
#ifdef COLOR_STATIONS

//if (TextColor == BkColor || foreColor == BkColor)
//TraceLog("Scroller", TRUE, hwnd, "%s(%08lX) fore:%08lX Text:%08lX Back:%08lX\n",
//		 PaintingStations[s].Station, (long) PaintingStations[s].BackColor, (long) foreColor, (long) TextColor, (long) BkColor);

			if (TextColor == BkColor)
			{	if (TextColor == RGB(0,0,0))
					TextColor = RGB(255,255,255);
				else if (BkColor != RGB(128,128,128))
					BkColor = RGB(128,128,128);
				else BkColor = RGB(255,255,255);
			}

			if (foreColor != TextColor)
			{	SetTextColor(hdc, TextColor);
				foreColor = TextColor;
			}
			if (backColor != BkColor)
			{	SetBkColor(hdc, BkColor);
				backColor = BkColor;
			}
#endif
			rc.left = Info->Tracker[cInfo->Index].rc.left + 2;	/* Reset left edge */

			if (backColor != GetSysColor(COLOR_WINDOW))
			{	HBRUSH hbrBack = CreateSolidBrush(backColor);
				FillRect(hdc, &rc, hbrBack);
				DeleteObject(hbrBack);
			} else FillRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOW));

			{	size_t Remain = sizeof(TCHAR)*80;
				TCHAR *Buffer = (TCHAR*)malloc(Remain);
				TCHAR *Next = Buffer;
				BOOL Digid = PaintingStations[s].Digipeated;
				int RFCount = PaintingStations[s].HeardOnRF?PaintingStations[s].RFDupeCount+1:0;
				char *Which = Digid?"@":(PaintingStations[s].HeardAsThird?"#":(RFCount?"*":""));
#ifdef UNDER_CE
				if (ActiveConfig.Scroller.ShowIGateOrDigi)
					StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("%.*S%S%S"),
									STRING(PaintingStations[s].IGateOrDigi),
									!strncmp(PaintingStations[s].IGateOrDigi, PaintingStations[s].Owner,
										min(sizeof(PaintingStations[s].IGateOrDigi),sizeof(PaintingStations[s].Owner)))
									?"":">",
									Which);
				else StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("%.*S%S"),
									STRING(PaintingStations[s].Label),
									Which);
#else
				if (ActiveConfig.Scroller.ShowIGateOrDigi)
				{	if (strncmp(PaintingStations[s].IGateOrDigi, PaintingStations[s].Label,
								min(sizeof(PaintingStations[s].IGateOrDigi),sizeof(PaintingStations[s].Label))))
					{
						TCHAR Temp[sizeof(PaintingStations[s].IGateOrDigi)+33+1];
						if (PaintingStations[s].HeardViaTCP)
							StringCbPrintf(Temp, sizeof(Temp), 
										TEXT("%.*S*I "),
										STRING(PaintingStations[s].IGateOrDigi));
						else if (PaintingStations[s].pUsedHops)
							StringCbPrintf(Temp, sizeof(Temp), 
										TEXT("%.*S*%d/%ld "),
										STRING(PaintingStations[s].IGateOrDigi),
										PaintingStations[s].aUsedHops,
										PaintingStations[s].pUsedHops);
						else StringCbPrintf(Temp, sizeof(Temp), 
										TEXT("%.*S "),
										STRING(PaintingStations[s].IGateOrDigi));
						if (wcslen(Temp) >= MaxWidthIGateLength)
						{	RECT rcTemp;
//							StringCbPrintf(Temp, sizeof(Temp), TEXT("%S<"), PaintingStations[s].IGateOrDigi);
							GetWindowRect(hwnd, &rcTemp);
							DrawText(hdc, Temp, -1, &rcTemp, DT_NOPREFIX | DT_CALCRECT);
							if (MaxWidthIGateWidth < rcTemp.right - rcTemp.left + 2)
							{	wcscpy(MaxWidthIGateID, Temp);
								MaxWidthIGateWidth = rcTemp.right - rcTemp.left + 2;
								MaxWidthIGateLength = strlen(PaintingStations[s].IGateOrDigi);
								WidthChanged = TRUE;
							}
						}
						DrawText(hdc, Temp, -1, &rc, DT_LEFT | DT_BOTTOM | DT_SINGLELINE | DT_NOPREFIX);
#ifdef OOPS
						if (MaxWidthIGateWidth < rc.right - rc.left + 2)
						{	wcscpy(MaxWidthIGateID, Temp);
							MaxWidthIGateWidth = rc.right - rc.left + 2;
							MaxWidthIGateLength = strlen(PaintingStations[s].IGateOrDigi);
							WidthChanged = TRUE;
						}
#endif
				}
					rc.left += MaxWidthIGateWidth;
				}
				StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("%.*S%S"),
									STRING(PaintingStations[s].Label),
									Which);
#endif
				if (RFCount > 1)
					StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("%ld"),
									(long) RFCount);
				if (PaintingStations[s].ISDupeCount)
					StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("(%ld)"),
									(long) PaintingStations[s].ISDupeCount+1);
				StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
									TEXT("                        "));
				offset = DrawText(hdc, Buffer, -1, &rc,
									DT_LEFT | DT_BOTTOM | DT_SINGLELINE | DT_NOPREFIX);
				free(Buffer);
			}
			if (cIndex >= 0)
			{	RECT rcSym = rc;
				rcSym.right -= 8;
				rcSym.bottom -= 8+(height-16)/2;

//#define OLD_WAY
#ifdef OLD_WAY
#undef OLD_WAY
				BltSymbol(hdc, rcSym.right, rcSym.bottom, 16/*9*/, 16, CloseStations[cIndex].symbol>>8, (CloseStations[cIndex].symbol&0xFF)-'!', 100, &rcSym);

#else
				BltSymbolBitmap(hwnd, hdc, hMemDC, rcSym.right, rcSym.bottom, 16/*9*/, 16, GetStationSymbol(pCloseStations[cIndex]), 100, COLOR_WINDOW, &rcSym);
#endif	/* OLD_WAY */
				rcPaintingStations[s] = rc;
				rcPaintingStations[s].top = rcPaintingStations[s].bottom - height;
				if (PaintingStations[s].HeardOnRF == 1)	/* Direct stations get framed */
				{	rcSym.right += rcSym.left; rcSym.bottom += rcSym.top;
					FrameRect(hdc, &rcSym, (HBRUSH) GetStockObject(BLACK_BRUSH));
				}
			}

			OffsetRect(&rc, 0, -height);
			if (!IntersectRect(&rc, &rc, &Info->Tracker[cInfo->Index].rc)) break;
		}

		}	/* End of resize check */
		SetTextColor(hdc, prevColor);
		SetBkColor(hdc, prevBkColor);
		DeleteDC(hMemDC);
		if (WidthChanged) ShuffleScreenElements(hwnd);
		else if (PaintingStationsFrozen)
		{	HBRUSH hbrRed = CreateSolidBrush(RGB(255,0,0));
			rc = Info->Tracker[cInfo->Index].rc;
//			FrameRect(hdc, &rc, (HBRUSH) GetStockObject(LTGRAY_BRUSH));
			FrameRect(hdc, &rc, hbrRed);
			InflateRect(&rc, -1, -1);
//			FrameRect(hdc, &rc, (HBRUSH) GetStockObject(LTGRAY_BRUSH));
			FrameRect(hdc, &rc, hbrRed);
			InflateRect(&rc, -1, -1);
//			FrameRect(hdc, &rc, (HBRUSH) GetStockObject(LTGRAY_BRUSH));
			FrameRect(hdc, &rc, hbrRed);
			DeleteObject(hbrRed);
//		} else
//		{	rc = Info->Tracker[cInfo->Index].rc; rc.right++; rc.bottom++;
//			Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		}

		break;
	}
	}
	return TRUE;
}

#ifdef DOCUMENTATION
/*
http://searchstorage.techtarget.com/sDefinition/0,,sid5_gci499008,00.html

Examples of quantities or phenomena in which power-of-10 prefix multipliers
apply include frequency (including computer clock speeds), physical mass,
power, energy, electrical voltage, and electrical current. Power-of-10 multipiers
are also used to define binary data speeds. Thus, for example, 1 kbps (one kilobit
per second) is equal to 103, or 1,000, bps (bits per second); 1 Mbps (one megabit
per second) is equal to 106, or 1,000,000, bps. (The lowercase k is the technically
correct symbol for kilo- when it represents 103, although the uppercase K is often
used instead.)

When binary data is stored in memory or fixed media such as a hard drive,
diskette, ZIP disk, tape, or CD-ROM, power-of-2 multipliers are used. Technically,
the uppercase K should be used for kilo- when it represents 210. Therefore 1 KB
(one kilobyte) is 210, or 1,024, bytes; 1 MB (one megabyte) is 220, or 1,048,576 bytes.

The choice of power-of-10 versus power-of-2 prefix multipliers can appear arbitrary.
It helps to remember that in common usage, multiples of bits are almost always
expressed in powers of 10, while multiples of bytes are almost always expressed in
powers of 2. Rarely is data speed expressed in bytes per second, and rarely is data
storage or memory expressed in bits. Such usages are considered improper. Confusion
is not likely, therefore, provided one adheres strictly to the standard usages of
the terms bit and byte. 
*/

#endif

LRESULT APRSHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	char Why[80];
	RECT rc;

	switch (msg)
	{
#ifndef UNDER_CE
	case WM_CONTEXTMENU:
	{	int p;
		POINT pt;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		ClientToScreen(hwnd, &pt);
		HMENU hPopup = NULL;
		BOOL OneActive = FALSE;

		for (p=0; p<PortStatusCount; p++)
		{	unsigned long ppc = GetPortPacketIndex(PortStatuses[p].wp, PortStatuses[p].Name);
			size_t Size = (strlen(PortStatuses[p].Name)+1)*sizeof(TCHAR);
			TCHAR *Buffer = (TCHAR*) malloc(Size);
			StringCbPrintf(Buffer, Size, TEXT("%S"), PortStatuses[p].Name);
			if (!hPopup) hPopup = CreatePopupMenu();
			AppendMenu(hPopup, MF_STRING | (PortPackets[ppc].hwnd?MF_CHECKED:0), p+1, Buffer);
			if (!PortStatuses[p].DisplayFlag) OneActive = TRUE;
		}
		if (hPopup)
		{	AppendMenu(hPopup, MF_SEPARATOR, NULL, NULL);
			AppendMenu(hPopup, MF_STRING, 0xaff, TEXT("Active Ports"));
			AppendMenu(hPopup, MF_STRING, 0xcff, TEXT("Busy Stations"));
			AppendMenu(hPopup, MF_STRING, 0xbff, TEXT("Memory Summary"));
			p = TrackPopupMenu(hPopup,
						TPM_CENTERALIGN | TPM_VCENTERALIGN
						| TPM_NONOTIFY | TPM_RETURNCMD,
						pt.x, pt.y, 0, hwnd, NULL);
			if (p==0xaff)
			{	for (p=0; p<PortStatusCount; p++)
				if (!PortStatuses[p].DisplayFlag)	/* Active ones first */
				{	unsigned long ppc = GetPortPacketIndex(PortStatuses[p].wp, PortStatuses[p].Name);
					if (!PortPackets[ppc].hwnd)
					{	CreatePortStatusWindow(&PortPackets[ppc]);
					} else if (IsWindow(PortPackets[ppc].hwnd))
					{	ShowWindow(PortPackets[ppc].hwnd, SW_RESTORE);
						SetForegroundWindow(PortPackets[ppc].hwnd);
					}
				}
			} else if (p==0xbff)
			{	CreateStationMemoryWindow();
			} else if (p==0xcff)
			{	CreateBusyStationsWindow();
			} else if (p > 0 && p <= PortStatusCount)
			{	unsigned long ppc = GetPortPacketIndex(PortStatuses[p-1].wp, PortStatuses[p-1].Name);
				if (!PortPackets[ppc].hwnd)
				{	CreatePortStatusWindow(&PortPackets[ppc]);
				} else if (IsWindow(PortPackets[ppc].hwnd))
				{	ShowWindow(PortPackets[ppc].hwnd, SW_RESTORE);
					SetForegroundWindow(PortPackets[ppc].hwnd);
				}
			}
			DestroyMenu(hPopup);
		}
		return 0;
	}
#endif

	case WM_LBUTTONDBLCLK:
	{	long Attempts, Connects, BytesSent, BytesRecv;

		tcp_get_comm_stats(&Attempts, &Connects, &BytesSent, &BytesRecv);
		if (PacketsXmit || PacketsRecv || Attempts || PortStatusCount)
		{	size_t Remaining = sizeof(TCHAR)*8192;
			TCHAR *Buffer = (TCHAR*)malloc(Remaining);
			TCHAR *Next = Buffer;

			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("APRS-IS Packets:\nSent: %ld Recv: %ld"),
						(long) PacketsXmit, (long) PacketsRecv);
			if (PacketsDupe)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" Dupe: %ld\n"),
							(long) PacketsDupe);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));

			if (PacketsPassed || PacketsQNOT)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("Passed: %ld"), (long) PacketsPassed);
				if (PacketsQNOT)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" (QNOT:%ld)"), (long) PacketsQNOT);
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
			}

			if (PacketsIGated || MessagesGated || PacketsRGated || PositionsGated)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("RFtoIS: %ld"), (long) PacketsIGated);
				if (MessagesGated || PositionsGated)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" Msg: %ld (%ld Pos)"), (long) MessagesGated, (long) PositionsGated);
				if (PacketsRGated)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" IStoRF: %ld"), (long) PacketsRGated);
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
			}	
			if (PacketsDigid)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("DigiPeat: %ld\n"), (long) PacketsDigid);
			}

			if (Connects || Attempts || BytesSent || BytesRecv)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\nConnect: %ld (%ld Failed)\nBytes Sent: %ld\nBytes Recv: %ld\n\nTotal Bytes: %ld"),
						(long) Connects, (long) Attempts-Connects,
						(long) BytesSent, (long) BytesRecv,
						(long) BytesSent + BytesRecv);

			if (PortStatusCount)
			{	int p;
				for (p=0; p<PortStatusCount; p++)
				if (!PortStatuses[p].DisplayFlag)	/* Active ones first */
				{	char *Line = BuildPortStatusString(p, TRUE);
					if (Line)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n%S"), Line);
						free(Line);
					}
				}

				for (p=0; p<PortStatusCount; p++)
				if (PortStatuses[p].DisplayFlag)	/* Now the inactive ones */
				{	char *Line = BuildPortStatusString(p, TRUE);
					if (Line)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n%S"), Line);
						free(Line);
					}
				}
			}

	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
					STRSAFE_IGNORE_NULLS, TEXT("\n"));
#define DOPKT(t,w) \
	AddHourly(#t, HOURLY_PACKETS, w, &Next, &Remaining)
			DOPKT(t/p,PktPosition);
			DOPKT(t/o,PktObject);
			DOPKT(t/i,PktItem);
			DOPKT(t/m,PktMessage);
			DOPKT(t/q,PktQuery);
			DOPKT(t/s,PktStatus);
			DOPKT(t/t,PktTelemetry);
			DOPKT(t/u,PktUser);
			DOPKT(t/n,PktNWS);
			DOPKT(t/w,PktWeather);
			DOPKT(oth,PktOther);
#undef DOPKT

			if (wp & MK_CONTROL)
			{	MEMORYSTATUS ms;
				ms.dwLength = sizeof(ms);
				GlobalMemoryStatus(&ms);
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("\n\nMemory Load: %lu%%\n"),
								(unsigned long) ms.dwMemoryLoad);
				if (ActiveConfig.Update.Development)
				{
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Phys: %luM/%luM\n"),
								(unsigned long) ms.dwAvailPhys/1024/1024,
								(unsigned long) ms.dwTotalPhys/1024/1024);
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Page: %luM/%luM\n"),
								(unsigned long) ms.dwAvailPageFile/1024/1024,
								(unsigned long) ms.dwTotalPageFile/1024/1024);
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
								STRSAFE_IGNORE_NULLS,
								TEXT("Virt: %luM/%luM"),
								(unsigned long) ms.dwAvailVirtual/1024/1024,
								(unsigned long) ms.dwTotalVirtual/1024/1024);
				}

				if (ActiveConfig.Update.Development)
				{
					{	char *Temp = GetCloseStationStats();
						if (Temp)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n\n%S"), Temp);
							free(Temp);
						}
					}

					{	char *Temp = GetDupeStats();
						if (Temp)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n\n%S"), Temp);
							free(Temp);
						}
					}

					{	char *Temp = GetShapeIndexStats();
						if (Temp)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S"), Temp);
							free(Temp);
						}
					}

					{	char *Temp = GetShapeCacheStats();
						if (Temp)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S"), Temp);
							free(Temp);
						}
					}

					{	char *Temp = GetTraceLogStats(TRUE);
						if (Temp)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%S"), Temp);
							free(Temp);
						}
					}


#ifdef _DEBUG
					{
					static BOOL First = TRUE;
					static _CrtMemState statePrevious = {0};
					static _CrtMemState stateOriginal = {0};
						HANDLE hLogFile;

						if (!strcmp(CALLSIGN, "KJ4ERJ-AL"))
						if (wp & MK_SHIFT)
						{
							if (MessageBox(hwnd, TEXT("Purge Memory Before Dump?"), TEXT("Debug Dump"), MB_YESNO | MB_ICONQUESTION) == IDYES)
							{	PurgeCloseStations(hwnd,TRUE);
								PurgeTraceLogs(0,0,0,0,0);
								OSMFlushTileCache(0);
							}

							//if (First) _CrtSetDumpClient(DumpClientFunction);
							//DumpFile = fopen("MemoryDump-all.txt", "w");
							//WhichDump = "All";
							hLogFile = CreateFile(TEXT("MemoryDump-all.txt"), GENERIC_WRITE, 
												FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 
												FILE_ATTRIBUTE_NORMAL, NULL);
							_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
							_CrtSetReportFile(_CRT_WARN, hLogFile);
							_CrtMemDumpAllObjectsSince(NULL);
							//fclose(DumpFile);
							//DumpFile = NULL;
							_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
							CloseHandle(hLogFile);
						} else MessageBox(hwnd, TEXT("Shift DblClk for Memory Dump"), TEXT("Debug Dump"), MB_OK | MB_ICONINFORMATION);
	   
						if (First)
						{	First = FALSE;
							_CrtMemCheckpoint(&statePrevious);
							stateOriginal = statePrevious;
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n\n%lu/%lu Bytes Allocated"),
											(unsigned long) statePrevious.lSizes[_NORMAL_BLOCK],
											(unsigned long) statePrevious.lHighWaterCount);
						} else
						{	_CrtMemState stateNew, stateDiff;

							if (!strcmp(CALLSIGN, "KJ4ERJ-AL"))
							if (wp & MK_SHIFT)
							{
								//DumpFile = fopen("MemoryDump-new.txt", "w");
								//WhichDump = "New";
								hLogFile = CreateFile(TEXT("MemoryDump-new.txt"), GENERIC_WRITE, 
													FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 
													FILE_ATTRIBUTE_NORMAL, NULL);
								_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
								_CrtSetReportFile(_CRT_WARN, hLogFile);
								_CrtMemDumpAllObjectsSince(&stateOriginal);
								//fclose(DumpFile);
								//DumpFile = NULL;
								_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
								CloseHandle(hLogFile);
							}

							_CrtMemCheckpoint(&stateNew);
							_CrtMemDifference(&stateDiff, &statePrevious, &stateNew);
							char *NO = "New";
							if (((long) stateDiff.lSizes[_NORMAL_BLOCK]) < 0)
							{	stateDiff.lSizes[_NORMAL_BLOCK] = -((long) stateDiff.lSizes[_NORMAL_BLOCK]);
								NO = "Freed";
							}
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("\n%lu/%lu Bytes Allocated (%ld %S)"),
											(unsigned long) stateNew.lSizes[_NORMAL_BLOCK],
											(unsigned long) stateNew.lHighWaterCount,
											(long) stateDiff.lSizes[_NORMAL_BLOCK], NO);
							statePrevious = stateNew;
						}
					}
#endif
#ifndef UNDER_CE
					{
						HANDLE hProc = GetCurrentProcess();
						DWORD nGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
						DWORD nUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n\nObjects: %ld GDI %ld User"),
									(long) nGDIObjects, (long) nUserObjects);
					}
#endif
					if (BitmapSizeCount)
					{	for (int b=0; b<BitmapSizeCount; b++)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
											STRSAFE_IGNORE_NULLS,
											TEXT("%S%ldx%ld:%ld(*%.1lf)"),
											b?" ":"\n\n",
											BitmapSizes[b].xSize,
											BitmapSizes[b].ySize,
											BitmapSizes[b].SymbolBitmapCount,
					(double) BitmapSizes[b].Count/(BitmapSizes[b].SymbolBitmapCount?BitmapSizes[b].SymbolBitmapCount:1));
						}
					}

				}	/* Development mode information */
			} else
			{	static BOOL ControlInformed = FALSE;
				if (!(ControlInformed++%16)) MessageBox(hwnd, TEXT("Control/DblClick for Memory Info"), TEXT("Port Status"), MB_ICONINFORMATION | MB_OK);
			}
	
			MessageBox(hwnd, Buffer, TEXT("Port Status"), MB_OK | MB_ICONINFORMATION);
			free(Buffer);
		}

#ifdef SHOW_CONNMGR_CONNECTIONS
		CONNMGR_CONNECTION_DETAILED_STATUS *pStatusBuffer = NULL;
		DWORD chBufferSize = 0;
		HRESULT cmStatus;
		while ((cmStatus=ConnMgrQueryDetailedStatus(pStatusBuffer,&chBufferSize)) == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
		{	if (pStatusBuffer) free(pStatusBuffer);
			pStatusBuffer = (CONNMGR_CONNECTION_DETAILED_STATUS *) calloc(1,chBufferSize);
		}
		if (cmStatus == S_OK)
		{	CONNMGR_CONNECTION_DETAILED_STATUS *p;
			if (!pStatusBuffer) MessageBox(hwnd, TEXT("QueryDetailedStatus NULL"), TEXT("CommMgr"), MB_OK | MB_ICONERROR);
			for (p=pStatusBuffer; p; p=p->pNext)
			{	TCHAR Buffer[256];
static DWORD Valids = CONNMGRDETAILEDSTATUS_PARAM_TYPE
					| CONNMGRDETAILEDSTATUS_PARAM_SUBTYPE
					| CONNMGRDETAILEDSTATUS_PARAM_DESCRIPTION
					| CONNMGRDETAILEDSTATUS_PARAM_CONNSTATUS;

				if ((p->dwParams & (Valids)) == (Valids))
					StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%s\n%s\n%s"),
						p->szDescription,
						GetConnMgrTypeSubType(p->dwType, p->dwSubtype),
						GetConnMgrStatusWord(p->dwConnectionStatus));
				else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Valid: 0x%lX"), (long) p->dwParams);
				MessageBox(hwnd, Buffer, TEXT("DetailedStatus"), MB_OK | MB_ICONINFORMATION);
#ifdef FUTURE
typedef struct _CONNMGR_CONNECTION_DETAILED_STATUS{
  DWORD dwType; 
  DWORD dwSubtype;
  DWORD dwFlags; 
  DWORD dwSecure;
  GUID guidDestNet;
  GUID guidSourceNet; 
  TCHAR* szDescription;
  TCHAR* szAdapterName;
  DWORD dwConnectionStatus; 
  SYSTEMTIME LastConnectTime;
  DWORD dwSignalQuality; 
  CONNMGR_CONNECTION_IPADDR* pIPAddr;
} CONNMGR_CONNECTION_DETAILED_STATUS; Members 
dwParams 
Combination of Connection Manager detailed status parameter constants. See Connection Manager Detailed Status Parameter Constants.
CONNMGRDETAILEDSTATUS_PARAM_DESTNET The guidDestNet member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_SOURCENET The guidSourceNet member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_FLAGS The dwFlags member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_SECURE The dwSecure member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_ADAPTERNAME The szAdapterName member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_LASTCONNECT The LastConnectTime member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_SIGNALQUALITY The dwSignalQuality member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.
CONNMGRDETAILEDSTATUS_PARAM_IPADDR The pIPAddr member of CONNMGR_CONNECTION_DETAILED_STATUS is valid.

dwFlags One or more connection options. For possible values, see Connection Manager Connection Options Constants.

dwSecure The security level of the connection. The security level corresponds with the connection type. If the security level is greater than zero, the connection is secure.

guidDestNet GUID of the destination network.

guidSourceNet GUID of the source network.

szDescription Name of the connection specified in a null-terminated string. If no name is available, this parameter must be set to NULL.

szAdapterName Null-terminated name of the adapter. If no adapter name is available, this parameter must be set to NULL.

dwConnectionStatus One of the Connection Manager status constants. For possible values, see Connection Manager Status Constants.

LastConnectTime Time the connection was last established.

dwSignalQuality Quality of the signal; can be a value between 0 and 255.

pIPAddr Available IP addresses, set to NULL, if no IP address is available.
#endif
			}
			free(pStatusBuffer);
		} else MessageBox(hwnd, TEXT("QueryDetailedStatus Failed"), TEXT("CommMgr"), MB_OK | MB_ICONERROR);
#ifdef USING_SIP
//		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
#endif
		break;
	}

	case WM_PAINT:
#define BAR_HEIGHT 3
#define BAR_COUNT 3
		TCHAR Buffer[80];

#ifdef USE_PORT_STATUS
		COLORREF backColor = PaintingStationsFrozen?RGB(255,192,192):CloseStationFreeze?RGB(255,255,0):GetSysColor(COLOR_WINDOW);
		COLORREF prevBkColor = SetBkColor(hdc, backColor);

		SYSTEMTIME st;
		GetSystemTime(&st);
		if (st.wSecond != PortStatusSecond)
		{	int i;
			for (i=0; i<PortStatusCount; i++)	/* Only one pass through statuses */
			{	if (++PortStatusIndex >= PortStatusCount)
					PortStatusIndex = 0;
				if (PortStatusSecond == -1
				|| !PortStatuses[PortStatusIndex].DisplayFlag) break;	/* Show this one */
			}
			if (i >= PortStatusCount) PortStatusIndex = 0;	/* Default to display first port */
			PortStatusSecond = st.wSecond;
		}
		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.top + (rc.bottom-rc.top-BAR_HEIGHT*BAR_COUNT) / 2;
		DrawText(hdc, PortStatusCount?PortStatuses[PortStatusIndex].Status:TEXT("No Status"), -1, &rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

		SetBkColor(hdc, prevBkColor);
#else
#ifdef UNDER_CE
		DWORD ConnStatus;
		TCHAR *StatusWord;
#ifdef USING_COMM_MGR
		if (!hConnection) ConnStatus = CONNMGR_STATUS_DISCONNECTED;
		else if (ConnMgrConnectionStatus(hConnection,&ConnStatus) != S_OK)
			ConnStatus = CONNMGR_STATUS_UNKNOWN;
		StatusWord = GetConnMgrStatusWord(ConnStatus);
#endif

		rc = Info->rc;
		rc.bottom = rc.top + (rc.bottom-rc.top-BAR_HEIGHT*BAR_COUNT) / 2;
		{	SYSTEMTIME LocalTime;
				GetLocalTime(&LocalTime);
#ifdef FUTURE
		if (KISSEnabled && KISSLine && LocalTime.wSecond&1)
		{	TCHAR Buffer[80];
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("KISS %ld (%ld/%ld)"),
							(long) KISSLine, (long) KISSTransmitCount, (long) KISSTransmitSize);
			DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		} else
#endif
#ifdef USING_COMM_MGR
			DrawText(hdc, APRSEnabled?(ConnStatus==CONNMGR_STATUS_CONNECTED?((ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)?TEXT("APRS OK"):wgettcpstatus()):StatusWord):TEXT("Disabled"), -1, &rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#else
			DrawText(hdc, (APRSEnabled && ActiveConfig.Enables.Internet)?WasConnected?TEXT("APRS OK"):TEXT("APRS-IS Down"):TEXT("Disabled"), -1, &rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#endif
		}
#else
		rc = Info->rc;
		rc.bottom = rc.top + (rc.bottom-rc.top-BAR_HEIGHT*BAR_COUNT) / 2;

#ifdef FUTURE
		if (AGWLine && time(NULL)&1)
		{	TCHAR Buffer[80];
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("AGW %ld (%ld/%ld)"),
							(long) AGWLine, (long) KISSTransmitCount, (long) KISSTransmitSize);
			DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		} else
#endif
#ifdef TRAKVIEW
			DrawText(hdc, (APRSEnabled && ActiveConfig.Enables.Internet)?((ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)?TEXT("Connected"):wgettcpstatus()):TEXT("Standalone"), -1, &rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#else
			DrawText(hdc, (APRSEnabled && ActiveConfig.Enables.Internet)?((ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)?WasConnected?TEXT("APRS OK"):TEXT("APRS-IS Down"):wgettcpstatus()):TEXT("Disabled"), -1, &rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#endif
#endif
#endif

		__int64 Now = llGetMsec();
		GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;

		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.bottom - BAR_HEIGHT*0;
		rc.top = rc.bottom - BAR_HEIGHT;
		if (BeaconEnabled)
			DrawRGRectangle(hdc, &rc, FALSE, (double) CalcTransmitPressure(cInfo, Genius, &gpsPosition,Now, Why), 100, 0, TRUE);
		else DrawRGRectangle(hdc, &rc, FALSE, 0, 100, 0, TRUE);

		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.bottom - BAR_HEIGHT*1;
		rc.top = rc.bottom - BAR_HEIGHT;
		if (APRSEnabled && ActiveConfig.Enables.Internet)
			DrawRGRectangle(hdc, &rc, FALSE, (double) (MAXIMUM_APRS_QUIET_TIME-(Now-LastAPRSReceive)), 0, MAXIMUM_APRS_QUIET_TIME, TRUE);
		else DrawRGRectangle(hdc, &rc, FALSE, 0, 0, MAXIMUM_APRS_QUIET_TIME, TRUE);

		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.bottom - BAR_HEIGHT*2;
		rc.top = rc.bottom - BAR_HEIGHT;
		if (BeaconEnabled)
			DrawRGRectangle(hdc, &rc, FALSE, (double) (Now-Genius->LastAPRSUpdate), 0, MINIMUM_APRS_DELTA, TRUE);
		else DrawRGRectangle(hdc, &rc, FALSE, 0, 0, MINIMUM_APRS_DELTA, TRUE);

		rc = Info->Tracker[cInfo->Index].rc;
		rc.top = rc.top + (rc.bottom-rc.top-BAR_HEIGHT*BAR_COUNT) / 2;
		rc.bottom -= BAR_HEIGHT*BAR_COUNT;
		StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%S"), BeaconSuspended?"Suspended":(BeaconEnabled?Why:"Disabled"));
		DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

#undef BAR_HEIGHT
#undef BAR_COUNT

		break;
	}
	return TRUE;
}

static void GetScaleMultDiv(double scale, int width, int *pMult, int *pDiv)
{
//#ifdef UNDER_CE
	if (ActiveConfig.Screen.SymbolSizeAdjust)
		scale /= pow(2.0,(double)ActiveConfig.Screen.SymbolSizeAdjust);

	if (scale >= 128)
	{	*pMult = 1; *pDiv = 2;
	} else if (scale >= 64)
	{	*pMult = 2; *pDiv = 3;
	} else if (scale >= 32)
	{	*pMult = 3; *pDiv = 4;
	} else if (scale >= 8)	/* Bigger screens begin to magnify */
	{	*pMult = 1; *pDiv = 1;
	} else if (scale >= 2)
	{	*pMult = 5; *pDiv = 4;
	} else if (scale >= 0.5)
	{	*pMult = 6; *pDiv = 4;
	} else if (scale >= 0.125)
	{	*pMult = 7; *pDiv = 4;
	} else
	{	*pMult = 2; *pDiv = 1;
	}

	if (width < 320 && *pMult > *pDiv)	/* Drop out all 320x240 screen */
		*pMult = *pDiv = 1;

//#else
//		*pMult = *pDiv = 1;
//#endif
}

static void GetSymbolSize(RECT *rc, double scale, int *pWidth, int *pHeight)
{	int Mult=1, Div=1;
	int bmWidth = 337;
	int bmHeight = 127;
	int w16 = bmWidth/16, dw;	/* 337 => 21 */
	int h6 = bmHeight / 6, dh;	/* 127 => 21 */

	GetScaleMultDiv(scale, (rc->right-rc->left), &Mult, &Div);

	dw = Mult * w16 / Div;
	dh = Mult * h6 / Div;

	*pWidth = dw - 4*Mult/Div;	/* Effectively 17 * Mult / Div */
	*pHeight = dh - 4*Mult/Div;	/* Effectively 17 * Mult / Div */
}

static void DrawSymbol(HWND hwnd, HDC hdc, HDC hMemDC, RECT *rc, int Symbol, int x, int y, int Percentage, RECT *prc, double scale)
{	int Mult=1, Div = 1;
	int width = rc->right - rc->left;
	int height = rc->bottom - rc->top;

	GetScaleMultDiv(scale, width, &Mult, &Div);

	BltSymbolBitmap(hwnd, hdc, hMemDC, x, y, Mult, Div, Symbol, Percentage, COLOR_WINDOW, prc);

	prc->right += prc->left;
	prc->bottom += prc->top;
}

static void DrawCompassLabel(HDC hdc, RECT *rc, double bearing, double range, TCHAR *Label)
{	RECT rcChar;
	int prevBkMode = SetBkMode(hdc, TRANSPARENT);
	int x = (int) (sin(DegToRad(bearing)) * range + 0.5 + (rc->right-rc->left)/2 + rc->left);
	int y = (int) (-cos(DegToRad(bearing)) * range + 0.5 + (rc->bottom-rc->top)/2 + rc->top);
	rcChar.left = x - 50; rcChar.right = x + 50;
	rcChar.bottom = y - 50; rcChar.top = y + 50;
	DrawText(hdc, Label, -1, &rcChar, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
	SetBkMode(hdc, prevBkMode);
}

static int ScaleSymbol(HWND hwnd, HDC hdc, HDC hMemDC, RECT *rc, int Symbol, double bearing, double range, double scale, int Percentage, RECT *prc)
{	int width = (rc->right-rc->left), x;
	int height = (rc->bottom-rc->top), y;

	SetRectEmpty(prc); /*memset(prc, 0, sizeof(*prc));*/
	if (range > scale) return 0;
	x = (int) (sin(DegToRad(bearing)) * range / scale * width/2 + 0.5 + width/2 + rc->left);
	y = (int) (-cos(DegToRad(bearing)) * range / scale * height/2 + 0.5 + height/2 + rc->top);

	DrawSymbol(hwnd, hdc, hMemDC, rc, Symbol, x, y, Percentage, prc, scale);
	return 1;
}

static int ScaleSymbol2(HWND hwnd, HDC hdc, HDC hMemDC, RECT *rc, int Symbol, int x, int y, double scale, int Percentage, RECT *prc)
{	SetRectEmpty(prc);/*memset(prc, 0, sizeof(*prc));*/
	DrawSymbol(hwnd, hdc, hMemDC, rc, Symbol, x, y, Percentage, prc, scale);
	return 1;
}

static BOOL GetScreenPoint(CLIENT_INFO_S *cInfo, RECT *prcCircle, double DispHeading, double Lat, double Lon, POINT *pp, BOOL Visibility)
{	BOOL Visible = FALSE;

	if (cInfo->ts && cInfo->ts->Count && cInfo->Percent > 0)
	{	if (OSMGetXYPos(cInfo->ts, Lat, Lon, pp, Visibility))
		{	Visible = TRUE;
		}
	} else
	{	int width = (prcCircle->right-prcCircle->left);
		int height = (prcCircle->bottom-prcCircle->top);
		double distance, bearing;
		AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
							cInfo->LastCenterPosition.dblLongitude,
							Lat, Lon, &distance, &bearing);
		pp->x = (int) (sin(DegToRad(bearing)) * distance / cInfo->Scale * width/2 + 0.5 + width/2 + prcCircle->left);
		pp->y = (int) (-cos(DegToRad(bearing)) * distance / cInfo->Scale * height/2 + 0.5 + height/2 + prcCircle->top);
		Visible = (distance <= cInfo->Scale);
	}
	return Visible;
}

#ifndef NO_PATH_TRACKING
static __int64 DrawPath(INFO_BLOCK *Info, HWND hwnd, HDC hdc, HDC hMemDC, RECT *rcWin, STATION_INFO_S *Station,
					 OSM_TILE_SET_S *ts, double DispHeading, long MaxMiles, __int64 msNow, char *LabelNeeded)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	__int64 msEldest = 0;

	if (Station->PathCount)	/* Even 1 is enough */
	{	POINT Line[2];
		int width = (Info->Tracker[cInfo->Index].rc.right-Info->Tracker[cInfo->Index].rc.left);
		int height = (Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top);
		double xOffset = 0.5 + width/2 + Info->Tracker[cInfo->Index].rc.left, xMult = width/2.0 / cInfo->Scale;
		double yOffset = 0.5 + height/2 + Info->Tracker[cInfo->Index].rc.top, yMult = height/2.0 / cInfo->Scale;
		int p;
		BOOL DidOne = FALSE;
		__int64 msOldest = llGetMsec();
		__int64 msThis = 0;

		if (cInfo->Paths.MaxAge == 0)	/* Only most recent */
		{	for (p=0; p<Station->PathCount; p++)
				if (!msThis || msThis < Station->Paths[p].msec)
					msThis = Station->Paths[p].msec;
		} else msOldest = llGetMsec() - cInfo->Paths.MaxAge*1000;

//TraceLogThread("Paths", FALSE, "Drawing %ld Paths for %s\n", (long) Station->PathCount, Station->Station);

		if (!cInfo->Paths.RGBFixed)
		{	cInfo->Paths.Direct.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Direct.Color, "Paths.Direct");
			cInfo->Paths.First.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.First.Color, "Paths.First");
			cInfo->Paths.Middle.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Middle.Color, "Paths.Middle");
			cInfo->Paths.Final.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Final.Color, "Paths.Final");
			cInfo->Paths.Packet.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Packet.Color, "Paths.Packet");
			cInfo->Paths.All.Time = -1;
			cInfo->Paths.Last.Time = 0;
			cInfo->Paths.RGBFixed = TRUE;
		}

		int lWidth = cInfo->Paths.Final.Width;
		HPEN hpen2 = CreatePen(PS_SOLID, lWidth, cInfo->Paths.Final.RGB);
		HGDIOBJ hold2 = SelectObject(hdc, hpen2);

		if (cInfo->Paths.ShowAllLinks || cInfo->Paths.Final.Enabled)
		for (p=0; p<Station->PathCount; p++)
		if (Station->Paths[p].Type == PATH_LINE_LAST)
		if (!cInfo->Paths.LclRF || Station->Paths[p].FromRF)
		if (Station->Paths[p].msec == msThis || Station->Paths[p].msec >= msOldest)
		{	GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].from.pCoord->lat, Station->Paths[p].from.pCoord->lon, &Line[0], TRUE);	/* Get the invalids to wrap around the globe */
			GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].to.pCoord->lat, Station->Paths[p].to.pCoord->lon, &Line[1], TRUE);	/* Get the invalids to wrap around the globe */
			LONG dx = abs(Line[0].x-Line[1].x);
			LONG dy = abs(Line[0].y-Line[1].y);
			if (dx > 2 || dy > 2)	/* Move enough to notice */
			if (!MaxMiles || Station->Paths[p].Length <= MaxMiles)	/* But not TOO far! */
			{
//TraceLogThread("Paths", FALSE, "%s[%ld] GREEN %ld,%ld->%ld,%ld\n", Station->Station, (long) p, Line[0].x, Line[0].y, Line[1].x, Line[1].y);
				Polyline(hdc, Line, 2);
			}
//#define PRINT_DETAILS
#ifdef PRINT_DETAILS
else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld > %ld miles\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) Station->Paths[p].Length, (long) MaxMiles);
#ifdef EXTREME_DETAIL
			else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld %ld < 2 pixels\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) dx, (long) dy);
#endif
#endif
			LabelNeeded[Station->Paths[p].from.SeenIndex] = TRUE;
			LabelNeeded[Station->Paths[p].to.SeenIndex] = TRUE;
			if (!msEldest || Station->Paths[p].msec < msEldest)
				msEldest = Station->Paths[p].msec;
			DidOne = TRUE;
		}
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);

		lWidth = cInfo->Paths.Middle.Width;
		hpen2 = CreatePen(PS_SOLID, lWidth, cInfo->Paths.Middle.RGB);
		hold2 = SelectObject(hdc, hpen2);
		if (cInfo->Paths.ShowAllLinks || cInfo->Paths.Middle.Enabled)
		for (p=0; p<Station->PathCount; p++)
		if (Station->Paths[p].Type == PATH_LINE_MIDDLE)
		if (!cInfo->Paths.LclRF || Station->Paths[p].FromRF)
		if (Station->Paths[p].msec == msThis || Station->Paths[p].msec >= msOldest)
		{	GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].from.pCoord->lat, Station->Paths[p].from.pCoord->lon, &Line[0], TRUE);	/* Get the invalids to wrap around the globe */
			GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].to.pCoord->lat, Station->Paths[p].to.pCoord->lon, &Line[1], TRUE);	/* Get the invalids to wrap around the globe */
//			if (!RFIDReader) SplitPolyline(hdc, Points, p, MaxSegment);
			LONG dx = abs(Line[0].x-Line[1].x);
			LONG dy = abs(Line[0].y-Line[1].y);
			if (dx > 2 || dy > 2)	/* Move enough to notice */
			if (!MaxMiles || Station->Paths[p].Length <= MaxMiles)	/* But not TOO far! */
			{
//TraceLogThread("Paths", FALSE, "%s[%ld] RED %ld,%ld->%ld,%ld\n", Station->Station, (long) p, Line[0].x, Line[0].y, Line[1].x, Line[1].y);
				Polyline(hdc, Line, 2);
			}
#ifdef PRINT_DETAILS
else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld > %ld miles\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) Station->Paths[p].Length, (long) MaxMiles);
#ifdef EXTREME_DETAIL
			else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld %ld < 2 pixels\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) dx, (long) dy);
#endif
#endif
			LabelNeeded[Station->Paths[p].from.SeenIndex] = TRUE;
			LabelNeeded[Station->Paths[p].to.SeenIndex] = TRUE;
			if (!msEldest || Station->Paths[p].msec < msEldest)
				msEldest = Station->Paths[p].msec;
			DidOne = TRUE;
		}
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);

		lWidth = cInfo->Paths.First.Width;
		hpen2 = CreatePen(PS_SOLID, lWidth, cInfo->Paths.First.RGB);
		hold2 = SelectObject(hdc, hpen2);
		if (cInfo->Paths.ShowAllLinks || cInfo->Paths.First.Enabled)
		for (p=0; p<Station->PathCount; p++)
		if (Station->Paths[p].Type == PATH_LINE_FIRST)
		if (!cInfo->Paths.LclRF || Station->Paths[p].FromRF)
		if (Station->Paths[p].msec == msThis || Station->Paths[p].msec >= msOldest)
		{	GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].from.pCoord->lat, Station->Paths[p].from.pCoord->lon, &Line[0], TRUE);	/* Get the invalids to wrap around the globe */
			GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].to.pCoord->lat, Station->Paths[p].to.pCoord->lon, &Line[1], TRUE);	/* Get the invalids to wrap around the globe */
//			if (!RFIDReader) SplitPolyline(hdc, Points, p, MaxSegment);
			LONG dx = abs(Line[0].x-Line[1].x);
			LONG dy = abs(Line[0].y-Line[1].y);
			if (dx > 2 || dy > 2)	/* Move enough to notice */
			if (!MaxMiles || Station->Paths[p].Length <= MaxMiles)	/* But not TOO far! */
			{
//TraceLogThread("Paths", FALSE, "%s[%ld] RED %ld,%ld->%ld,%ld\n", Station->Station, (long) p, Line[0].x, Line[0].y, Line[1].x, Line[1].y);
				Polyline(hdc, Line, 2);
			}
#ifdef PRINT_DETAILS
else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld > %ld miles\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) Station->Paths[p].Length, (long) MaxMiles);
#ifdef EXTREME_DETAIL
			else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld %ld < 2 pixels\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) dx, (long) dy);
#endif
#endif
			LabelNeeded[Station->Paths[p].from.SeenIndex] = TRUE;
			LabelNeeded[Station->Paths[p].to.SeenIndex] = TRUE;
			if (!msEldest || Station->Paths[p].msec < msEldest)
				msEldest = Station->Paths[p].msec;
			DidOne = TRUE;
		}
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);

		lWidth = cInfo->Paths.Direct.Width;
		hpen2 = CreatePen(PS_SOLID, lWidth, cInfo->Paths.Direct.RGB);
		hold2 = SelectObject(hdc, hpen2);
		if (cInfo->Paths.ShowAllLinks || cInfo->Paths.Direct.Enabled)
		for (p=0; p<Station->PathCount; p++)
		if (Station->Paths[p].Type == PATH_LINE_DIRECT)
		if (!cInfo->Paths.LclRF || Station->Paths[p].FromRF)
		if (Station->Paths[p].msec == msThis || Station->Paths[p].msec >= msOldest)
		{	GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].from.pCoord->lat, Station->Paths[p].from.pCoord->lon, &Line[0], TRUE);	/* Get the invalids to wrap around the globe */
			GetScreenPoint(cInfo, rcWin, DispHeading, Station->Paths[p].to.pCoord->lat, Station->Paths[p].to.pCoord->lon, &Line[1], TRUE);	/* Get the invalids to wrap around the globe */
//			if (!RFIDReader) SplitPolyline(hdc, Points, p, MaxSegment);
			LONG dx = abs(Line[0].x-Line[1].x);
			LONG dy = abs(Line[0].y-Line[1].y);
			if (dx > 2 || dy > 2)	/* Move enough to notice */
			if (!MaxMiles || Station->Paths[p].Length <= MaxMiles)	/* But not TOO far! */
			{
//TraceLogThread("Paths", FALSE, "%s[%ld] RED %ld,%ld->%ld,%ld\n", Station->Station, (long) p, Line[0].x, Line[0].y, Line[1].x, Line[1].y);
				Polyline(hdc, Line, 2);
			}
#ifdef PRINT_DETAILS
else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld > %ld miles\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) Station->Paths[p].Length, (long) MaxMiles);
#ifdef EXTREME_DETAIL
			else TraceLogThread("PathTooLong", FALSE, "[%ld] %c Path From %s To %s is %ld %ld < 2 pixels\n",
					(long) cInfo->Index,
					Station->Paths[p].Type,
					SeenStations[Station->Paths[p].from.SeenIndex].Station,
					SeenStations[Station->Paths[p].to.SeenIndex].Station,
					(long) dx, (long) dy);
#endif
#endif
			LabelNeeded[Station->Paths[p].from.SeenIndex] = TRUE;
			LabelNeeded[Station->Paths[p].to.SeenIndex] = TRUE;
			if (!msEldest || Station->Paths[p].msec < msEldest)
				msEldest = Station->Paths[p].msec;
			DidOne = TRUE;
		}
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);

		if (!DidOne	/* None drawn here */
		&& (cInfo->viewBits & VIEW_PATHS))	/* And visibility based on paths */
			UpdateStationVisibility(Station, "NoPath");
	}
	return msEldest;	/* Oldest drawn path component */
}

static void DrawPacketPath(INFO_BLOCK *Info, HWND hwnd, HDC hdc, HDC hMemDC, RECT *rcWin, STATION_INFO_S *Station,
					 OSM_TILE_SET_S *ts, double DispHeading, long MaxMiles, __int64 msNow, char *LabelNeeded)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	if (Station->PacketPath)	/* Must at least have a packet path */
	{	PACKET_PATH_S *PktPath = Station->PacketPath;
		POINT Line[2];
		int width = (Info->Tracker[cInfo->Index].rc.right-Info->Tracker[cInfo->Index].rc.left);
		int height = (Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top);
		double xOffset = 0.5 + width/2 + Info->Tracker[cInfo->Index].rc.left, xMult = width/2.0 / cInfo->Scale;
		double yOffset = 0.5 + height/2 + Info->Tracker[cInfo->Index].rc.top, yMult = height/2.0 / cInfo->Scale;
		int h;
		BOOL DidOne = FALSE;

		if (!cInfo->Paths.RGBFixed)
		{	cInfo->Paths.Direct.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Direct.Color, "Paths.Direct");
			cInfo->Paths.First.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.First.Color, "Paths.First");
			cInfo->Paths.Middle.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Middle.Color, "Paths.Middle");
			cInfo->Paths.Final.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Final.Color, "Paths.Final");
			cInfo->Paths.Packet.RGB = GetColorRGB(&ActiveConfig, cInfo->Paths.Packet.Color, "Paths.Packet");
			cInfo->Paths.All.Time = -1;
			cInfo->Paths.Last.Time = 0;
			cInfo->Paths.RGBFixed = TRUE;
		}

		int lWidth = cInfo->Paths.Packet.Width;
		HPEN hpen2 = CreatePen(PS_SOLID, lWidth, cInfo->Paths.Packet.RGB);	/* Orange */
		HGDIOBJ hold2 = SelectObject(hdc, hpen2);

		if (!cInfo->Paths.LclRF || PktPath->FromRF)
		for (h=0; h<PktPath->HopCount-1; h++)
		if (PktPath->Hops[h].pCoord
		&& (PktPath->Hops[h].pCoord->lat!=0 || PktPath->Hops[h].pCoord->lon!=0)
		&& PktPath->Hops[h+1].pCoord
		&& (PktPath->Hops[h+1].pCoord->lat!=0 || PktPath->Hops[h+1].pCoord->lon!=0))	/* Enough to draw a line segment? */
		{	GetScreenPoint(cInfo, rcWin, DispHeading, PktPath->Hops[h].pCoord->lat, PktPath->Hops[h].pCoord->lon, &Line[0], TRUE);
			GetScreenPoint(cInfo, rcWin, DispHeading, PktPath->Hops[h+1].pCoord->lat, PktPath->Hops[h+1].pCoord->lon, &Line[1], TRUE);
			LONG dx = abs(Line[0].x-Line[1].x);
			LONG dy = abs(Line[0].y-Line[1].y);
			if (dx > 2 || dy > 2)	/* Move enough to notice */
//			if (!MaxMiles || Station->Paths[p].Length <= MaxMiles)	/* But not TOO far! */
			{
//TraceLogThread("Paths", FALSE, "%s[%ld] GREEN %ld,%ld->%ld,%ld\n", Station->Station, (long) p, Line[0].x, Line[0].y, Line[1].x, Line[1].y);
				Polyline(hdc, Line, 2);
			}
			LabelNeeded[PktPath->Hops[h].SeenIndex] = TRUE;
			LabelNeeded[PktPath->Hops[h+1].SeenIndex] = TRUE;
		}
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);
	}
	return;
}
#endif

static void DrawTrackLine(INFO_BLOCK *Info, HWND hwnd, HDC hdc, HDC hMemDC, RECT *rcWin,
							  int tCount, TRACK_INFO_S *Tracks, COLORREF cColor, int lWidth,
							  double DispHeading, long MaxSegment)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	int tr = cInfo->Index;
		POINT *Points = (POINT *) malloc(sizeof(*Points)*(tCount+3));
		int width = (Info->Tracker[tr].rc.right-Info->Tracker[tr].rc.left);
		int height = (Info->Tracker[tr].rc.bottom-Info->Tracker[tr].rc.top);
		double xOffset = 0.5 + width/2 + Info->Tracker[tr].rc.left, xMult = width/2.0 / cInfo->Scale;
		double yOffset = 0.5 + height/2 + Info->Tracker[tr].rc.top, yMult = height/2.0 / cInfo->Scale;
		int t, p, b;

		for (t=0, p=0, b=0; t<tCount; t++)
		if (Tracks[t].pCoord->lat || Tracks[t].pCoord->lon)
		{
			GetScreenPoint(cInfo, rcWin, DispHeading, Tracks[t].pCoord->lat, Tracks[t].pCoord->lon, &Points[p], TRUE);	/* Get the invalids to wrap around the globe */
			if (!p || Points[p].x!=Points[p-1].x || Points[p].y!= Points[p-1].y) p++;	/* Only bump if not 
duplicate */
		}

		{	HPEN hpen2 = CreatePen(PS_SOLID, lWidth, cColor);
			HGDIOBJ hold2 = SelectObject(hdc, hpen2);

			SplitPolyline(hdc, Points, p, MaxSegment);

			SelectObject(hdc, hold2);
			DeleteObject(hpen2);
		}
		free(Points);
}


static COLORREF DrawTrack(INFO_BLOCK *Info, HWND hwnd, HDC hdc, HDC hMemDC, RECT *rcWin, STATION_INFO_S *Station, OSM_TILE_SET_S *ts, double DispHeading, BOOL Following, BOOL ToCenter, long MaxSegment)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	int HA = SymbolInt('H', 'A');	/* RFID HotSpot */
	int tr = cInfo->Index;
	BOOL RFIDReader = (Station->isymbol == HA) && (Station->RFID.Type != 0);

	COLORREF cColor;
	if (RFIDReader) cColor = RGB(0,0,0);
	else if (Station->TrackColorLocked)
		cColor = Station->TrackColor;
	else if (HasNickColor(Station))
		cColor = Station->Nickname->RGB;
	else if (Following)
		cColor = ActiveConfig.Screen.Track.Follow.RGB;
	else if (ActiveConfig.Screen.Track.Other.Color[0])
		cColor = ActiveConfig.Screen.Track.Other.RGB;
	else cColor = Station->TrackColor;

	if (Station->TrackCount > 1 || ToCenter || Station==MyStation)
	{	int tCount = min(Station->TrackCount,(int)ActiveConfig.Screen.Track.Other.Count);
		if (Following || RFIDReader || ActiveConfig.Screen.Track.Other.Count==0)
			tCount = Station->TrackCount;	/* Temporarily display ALL of them! */
		BOOL LastBad = FALSE;
typedef struct ALT_TRACK_INFO_S
{	long alt;
	int p;
} ALT_TRACK_INFO_S;
		ALT_TRACK_INFO_S *Alts = (ALT_TRACK_INFO_S *) malloc(sizeof(*Alts)*(tCount+3));
		POINT *Points = (POINT *) malloc(sizeof(*Points)*(tCount+3));
		POINT *BadPoints = (POINT *) malloc(sizeof(*BadPoints)*(tCount+3));
		TRACK_VALIDITY_V *BadInvalids = (TRACK_VALIDITY_V *) malloc(sizeof(*BadInvalids)*(tCount+3));
		int width = (Info->Tracker[tr].rc.right-Info->Tracker[tr].rc.left);
		int height = (Info->Tracker[tr].rc.bottom-Info->Tracker[tr].rc.top);
		double xOffset = 0.5 + width/2 + Info->Tracker[tr].rc.left, xMult = width/2.0 / cInfo->Scale;
		double yOffset = 0.5 + height/2 + Info->Tracker[tr].rc.top, yMult = height/2.0 / cInfo->Scale;
		int t, p, b, aCount=0;
		long MinAlt, MaxAlt;

		for (t=Station->TrackCount-tCount, p=0, b=0; t<Station->TrackCount; t++)
		if (Station->Tracks[t].pCoord->lat || Station->Tracks[t].pCoord->lon)
		{
			GetScreenPoint(cInfo, rcWin, DispHeading, Station->Tracks[t].pCoord->lat, Station->Tracks[t].pCoord->lon, &Points[p], /*FALSE*/ TRUE || Station->Tracks[t].Invalid || Following || ToCenter);	/* Get the invalids to wrap around the globe */
			if (Station->Tracks[t].Invalid)
			{	LastBad = TRUE;
				BadPoints[b] = Points[p];
				BadInvalids[b] = Station->Tracks[t].Invalid;
				if (!b || BadPoints[b].x!=BadPoints[b-1].x || BadPoints[b].y!= BadPoints[b-1].y) b++;
			} else
			{	LastBad = FALSE;
				if (!p || Points[p].x!=Points[p-1].x || Points[p].y!= Points[p-1].y)
				{
					if (Station->Tracks[t].alt > 0)
					{	long alt = Station->Tracks[t].alt;
						if (!aCount)	/* First one sets min/max */
							MinAlt = MaxAlt = alt;
						else
						{	if (alt < MinAlt) MinAlt = alt;
							if (alt > MaxAlt) MaxAlt = alt;
						}
						Alts[aCount].alt = alt;
						Alts[aCount].p = p;
						aCount++;	/* Count the altitude point */
					}
					p++;	/* Only bump if not 
duplicate */
				}
			}
		}
		if (Station == MyStation)
		{	GetScreenPoint(cInfo, rcWin, DispHeading, Station->pCoord->lat, Station->pCoord->lon, &Points[p], /*FALSE*/ TRUE || Station->Tracks[t].Invalid || Following || ToCenter);	/* Get the invalids to wrap around the globe */
			p++;
		}
		if (ToCenter && !LastBad)
		{	Points[p].x = (int) xOffset;
			Points[p].y = (int) yOffset;
			p++;
		}

		{	int lWidth = RFIDReader?1:Following?ActiveConfig.Screen.Track.Follow.Width:ActiveConfig.Screen.Track.Other.Width;
			HPEN hpen2 = CreatePen(PS_SOLID, lWidth, cColor);
			HGDIOBJ hold2 = SelectObject(hdc, hpen2);

			if (Following					/* Must be following the station */
			&& !RFIDReader					/* RFIDReader's don't do altitude */
			&& Station->TrackColorAltitude	/* Must have been selected by user */
			&& aCount > 2					/* Must have at least 2 segments */
			&& MaxAlt != MinAlt				/* And an altitude differential */
			&& ActiveConfig.View.Altitude)	/* Only if altitude is labelled */
			{	RECT rcLast;
				int a, Width, Height, First = TRUE;
				GetSymbolSize(&Info->Tracker[tr].rc, cInfo->Scale, &Width, &Height);
				Width = Width/4/2;	/* Scale block size */
				Height = Height/4/2;/* Scale block size */

//				SplitPolyline(hdc, Points, p, MaxSegment);	/* For now, really want to colorize segments */


//TraceLogThread("AltColor", FALSE, "%s @%ld Min:%ld Max:%ld %ld/%ld/%ld Alts %ld Bads\n",
//			   Station->Station, (long) Station->alt,
//			   (long) MinAlt, (long) MaxAlt,
//			   (long) aCount, (long) p, (long) Station->TrackCount, (long) b);

				for (a=0; a<aCount; a++)
				{	COLORREF pColor = GetScaledRGColor(Alts[a].alt, MaxAlt, MinAlt);
					int p = Alts[a].p;

					if (a	/* Only after the first */
					&& (!MaxSegment
						|| (abs(Points[p].x-Points[p].x <= MaxSegment
								&& abs(Points[p].y-Points[p].y <= MaxSegment)))))
					{	POINT pt[3];
						pt[0] = Points[Alts[a-1].p];
						pt[2] = Points[Alts[a].p];
						pt[1].x = (pt[0].x+pt[2].x)/2;
						pt[1].y = (pt[0].y+pt[2].y)/2;
						HPEN hpen3 = CreatePen(PS_SOLID, lWidth, pColor);
						HGDIOBJ hold3 = SelectObject(hdc, hpen3);
						Polyline(hdc, &pt[1], 2);
						SelectObject(hdc, hold3);
						DeleteObject(hpen3);
						COLORREF aColor = GetScaledRGColor(Alts[a-1].alt, MaxAlt, MinAlt);
						hpen3 = CreatePen(PS_SOLID, lWidth, aColor);
						hold3 = SelectObject(hdc, hpen3);
						Polyline(hdc, &pt[0], 2);
						SelectObject(hdc, hold3);
						DeleteObject(hpen3);
					}

					if (PtInRect(rcWin, Points[p])
					&& !PtInRect(&Station->TInfo[tr].rcSym, Points[p]))
					{	HBRUSH hbrColor = CreateSolidBrush(pColor);
						RECT rc, rcInter;
						SetRect(&rc, Points[p].x-Width, Points[p].y-Height,
									Points[p].x+Width+1, Points[p].y+Height+1);
						if (First || !IntersectRect(&rcInter, &rc, &rcLast))
						{	FillRect(hdc, &rc, hbrColor);
							First = FALSE;
							rcLast = rc;
						}
						DeleteObject(hbrColor);
					}
				}
			} else
			{
				if (!RFIDReader) SplitPolyline(hdc, Points, p, MaxSegment);

				if (Following || RFIDReader)
				{	HBRUSH hbrColor = CreateSolidBrush(cColor);
					int Width, Height;
					int First = TRUE;
					RECT rcLast;

					GetSymbolSize(&Info->Tracker[tr].rc, cInfo->Scale, &Width, &Height);
					Width = Width/4/2;	/* Scale block size */
					Height = Height/4/2;/* Scale block size */

					for (t=max(0,p-((RFIDReader||ActiveConfig.Screen.Track.Follow.Count==0)?p:(int)ActiveConfig.Screen.Track.Follow.Count)); t<p; t++)
					{
						if (PtInRect(rcWin, Points[t])
						&& !PtInRect(&Station->TInfo[tr].rcSym, Points[t]))
						{	RECT rc, rcInter;
							SetRect(&rc, Points[t].x-Width, Points[t].y-Height,
										Points[t].x+Width+1, Points[t].y+Height+1);
							if (First || !IntersectRect(&rcInter, &rc, &rcLast))
							{	FillRect(hdc, &rc, hbrColor);
								First = FALSE;
								rcLast = rc;
							}
						}
					}
					DeleteObject(hbrColor);
				}
			}
			if (b)	/* If we have dupes, draw them regardless */
			{	TRACK_VALIDITY_V LastTrack = TRACK_OK;
				HGDIOBJ hOld = 0;
				int Width, Height;
				int First = TRUE;
				RECT rcLast;

				GetSymbolSize(&Info->Tracker[tr].rc, cInfo->Scale, &Width, &Height);

				for (t=0; t<b; t++)
				if (PtInRect(rcWin, BadPoints[t])
				&& !PtInRect(&Station->TInfo[tr].rcSym, BadPoints[t]))
				{	RECT rc, rcInter;
	#define ORANGE_SIZE 4
					SetRect(&rc, BadPoints[t].x-Width/ORANGE_SIZE/2, BadPoints[t].y-Height/ORANGE_SIZE/2,
								BadPoints[t].x+Width/ORANGE_SIZE/2+1, BadPoints[t].y+Height/ORANGE_SIZE/2+1);
					if (First || !IntersectRect(&rcInter, &rc, &rcLast))
					{	if (First || LastTrack != BadInvalids[t])
						{	HBRUSH hbr = CreateSolidBrush(GetInvalidColor(BadInvalids[t]));
							if (First) hOld = SelectObject(hdc,hbr);	/* Remember original brush */
							else DeleteObject(SelectObject(hdc,hbr));	/* Destroy previous brush */
							LastTrack = BadInvalids[t];
							First = FALSE;
						}
						Rectangle(hdc, rc.left-1, rc.top-1, rc.right+1, rc.bottom+1);
						/* FillRect(hdc, &rc, hbrOrange); */
					}
				}
				if (!First)
				{	DeleteObject(SelectObject(hdc,hOld));
				}
			}
			SelectObject(hdc, hold2);
			DeleteObject(hpen2);
		}
		free(BadInvalids);
		free(BadPoints);
		free(Points);
		free(Alts);
	}
	return cColor;
}

static void DrawWindBarb(HDC hdc, STATION_INFO_S *Station, POINT *ppt, RECT *prc, double Speed, int Dir)
{static double xm=0.0, ym=0.0;

#define ANGLE 75.0
	if (!xm && !ym)
	{	xm = sin(ANGLE/DegreesPerRadian);
		ym = cos(ANGLE/DegreesPerRadian);
	}
#undef ANGLE

	long l = ((prc->bottom-prc->top)+(prc->right-prc->left))/2;
	long lb = (long) (xm*l);
	long mx = (Station->pCoord->lat < 0)?-1:1;

	if (lb > 2)	/* Make sure it's worthwhile */
	{	long p, ptCount=0;
		POINT pts[32];
		pts[0].x = 0; pts[0].y = l/2;	// Starting of line is top edge of symbol
		pts[1].x = 0; pts[1].y = l*3;	// It goes out 3 times rectangle dimension
		ptCount = 2;

#define ADD_TRIANGLE(n) \
		pts[ptCount].x = 0; pts[ptCount].y = l*(2+n); \
		pts[ptCount+1].x = 0; pts[ptCount+1].y = l*(3+n); \
		pts[ptCount+2].x = l; pts[ptCount+2].y = pts[ptCount+1].y; \
		pts[ptCount+3] = pts[ptCount]; \
		ptCount += 4

		if (Speed > 150) Speed = 150.0;

		while (Speed >= 50.0)
		{	int n = (int) (Speed / 50.0);
			ADD_TRIANGLE(n);
			Speed -= 50.0;
		}

#define ADD_BARB(n,m) \
		pts[ptCount].x = 0; pts[ptCount].y = (long) (l*(3.5-n/2.0)); \
		pts[ptCount+1].x = (long) (lb*m); pts[ptCount+1].y = (long) (l*(3.5+ym*m-n/2.0)); \
		pts[ptCount+2] = pts[ptCount]; \
		ptCount += 3

		int n = 1;
		while (Speed > 0)
		{	double m = Speed / 10.0;
			if (m > 1.0) m = 1.0;
			//int n = (int)m+1;
			ADD_BARB(n,m);
			Speed -= 10.0;
			n++;
		}

		if (Dir)	// Need rotation?
		{	POINT ptNew;
			double sa = sin(Dir/DegreesPerRadian);
			double ca = cos(Dir/DegreesPerRadian);
			for (p=0; p<ptCount; p++)
			{	ptNew.x = (long) (pts[p].x*ca + pts[p].y*sa);
				ptNew.y = (long) (pts[p].y*ca - pts[p].x*sa);
				pts[p] = ptNew;
			}
		}

		for (p=0; p<ptCount; p++)
		{	pts[p].x = mx*pts[p].x + ppt->x;
			pts[p].y = ppt->y - pts[p].y;
		}
		HPEN hpen2 = CreatePen(PS_SOLID, ActiveConfig.Screen.WindBarbs.Width, ActiveConfig.Screen.WindBarbs.RGB);
		HGDIOBJ hold2 = SelectObject(hdc, hpen2);
		Polyline(hdc, &pts[0], ptCount);
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);
	}
}

static BOOL DeadReckon(INFO_BLOCK *Info, HWND hwnd, HDC hdc, HDC hMemDC, RECT *rcWin, STATION_INFO_S *Station, double speed, double course, OSM_TILE_SET_S *ts, double DispHeading, __int64 msElapsed=0, __int64 msMax=5*60*1000)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	BOOL Result = FALSE;

	if (speed > MOVING_SPEED)	/* Must be moving */
	{	if (!msElapsed)
		{	__int64 msNow = llGetMsec();
			msElapsed = llMsecSince(Station->Last.msec, msNow);
		}
		if (msElapsed < 1000)	/* Need to try this one again! */
			Result = TRUE;		/* Kick the windows refresh by returning TRUE */
		else if (msElapsed < msMax)	/* Only trust it between 1 second and specified maximum */
		{	double nLat, nLon;
			double forecastDistance = msElapsed*(speed*MilePerNM)/60.0/60.0/1000.0;	/* Miles */
			AprsProjectLatLon(Station->Last.lat, Station->Last.lon, forecastDistance, course, &nLat, &nLon);

			POINT *Points = (POINT *) malloc(sizeof(*Points)*(2));

#ifndef OLD_WAY
			GetScreenPoint(cInfo, &Info->Tracker[cInfo->Index].rc, DispHeading, Station->Last.lat, Station->Last.lon, &Points[0], FALSE);
			GetScreenPoint(cInfo, &Info->Tracker[cInfo->Index].rc, DispHeading, nLat, nLon, &Points[1], FALSE);
#else
			int width = (Info->Tracker[cInfo->Index].rc.right-Info->Tracker[cInfo->Index].rc.left);
			int height = (Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top);
			double xOffset = 0.5 + width/2 + Info->Tracker[cInfo->Index].rc.left, xMult = width/2.0 / cInfo->Scale;
			double yOffset = 0.5 + height/2 + Info->Tracker[cInfo->Index].rc.top, yMult = height/2.0 / cInfo->Scale;

			if (!ts || !ts->Count)	/* No OSM, do distance/bearing plot */
			{	double distance, bearing;

				AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude,
									Station->Last.lat, Station->Last.lon, &distance, &bearing);
				bearing -= DispHeading;
				Points[0].x = (int) (sin(DegToRad(bearing)) * distance * xMult + xOffset);
				Points[0].y = (int) (-cos(DegToRad(bearing)) * distance * yMult + yOffset);

				AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude,
									nLat, nLon, &distance, &bearing);
				bearing -= DispHeading;
				Points[1].x = (int) (sin(DegToRad(bearing)) * distance * xMult + xOffset);
				Points[1].y = (int) (-cos(DegToRad(bearing)) * distance * yMult + yOffset);
			} else
			{	OSMGetXYPos(ts, Station->Last.lat, Station->Last.lon, &Points[0]);
				OSMGetXYPos(ts, nLat, nLon, &Points[1]);
			}
#endif
			if ((Points[0].x != Points[1].x || Points[0].y != Points[1].y)
			/*&& !PtInRect(&Station->Tracker[cInfo->Index].rc, Points[1])*/)
			{	COLORREF cRedGreen = GetScaledRGColor((double)msElapsed, (double)msMax, 1000);
#ifdef UNDER_CE
				HPEN hpen2 = CreatePen(PS_SOLID, 1, cRedGreen);
#else
				HPEN hpen2 = CreatePen(PS_SOLID, 2, cRedGreen);
#endif
				HGDIOBJ hold2 = SelectObject(hdc, hpen2);

				Polyline(hdc, Points, 2);

				SelectObject(hdc, hold2);
				DeleteObject(hpen2);
#ifndef UNDER_CE
				Polyline(hdc, Points, 2);	/* Add a black line in the middle */
#endif
				{	RECT rcDummy;
					DrawSymbol(hwnd, hdc, hMemDC, rcWin, GetStationSymbol(Station), Points[1].x, Points[1].y, (int) 100, &rcDummy, cInfo->Scale);
				}
			}
			Result = TRUE;	/* Out here so it will move when it clears the main symbol */
			free(Points);
		}
	}
	return Result;
}

static void DrawLatLonLines(INFO_BLOCK *Info, HWND hwnd, HDC hdc, double DispHeading)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	int pMax = (180+180)/10 + 4;
	POINT *Points = (POINT *) malloc(sizeof(*Points)*pMax);
	int width = (Info->Tracker[cInfo->Index].rc.right-Info->Tracker[cInfo->Index].rc.left);
	int height = (Info->Tracker[cInfo->Index].rc.bottom-Info->Tracker[cInfo->Index].rc.top);
	double xOffset = 0.5 + width/2 + Info->Tracker[cInfo->Index].rc.left, xMult = width/2.0 / cInfo->Scale;
	double yOffset = 0.5 + height/2 + Info->Tracker[cInfo->Index].rc.top, yMult = height/2.0 / cInfo->Scale;
	int p;
	double lat, lon;

	for (lat = -80; lat <= 80.0; lat += 10)
	{	for (lon=-180, p=0; lon<=180 && p<pMax; lon+=10, p++)
		{	double distance, bearing;
			AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude,
									lat, lon, &distance, &bearing);
			bearing -= DispHeading;
			Points[p].x = (int) (sin(DegToRad(bearing)) * distance * xMult + xOffset);
			Points[p].y = (int) (-cos(DegToRad(bearing)) * distance * yMult + yOffset);
			if (Points[p].x < -32767 || Points[p].x > 32767
			|| Points[p].y < -32767 || Points[p].y > 32767)
			{	if (p > 1) Polyline(hdc, Points, p);
				p = -1;	/* Restart the list, auto increment above */
			}
		}
		if (p > 1) Polyline(hdc, Points, p);
	}

	for (lon=-180; lon<=180; lon+=10)
	{	for (lat=-80, p=0; lat<=80.0 && p<pMax; lat+=10, p++)
		{
			double distance, bearing;
			AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude,
									lat, lon, &distance, &bearing);
			bearing -= DispHeading;
			Points[p].x = (int) (sin(DegToRad(bearing)) * distance * xMult + xOffset);
			Points[p].y = (int) (-cos(DegToRad(bearing)) * distance * yMult + yOffset);
			if (Points[p].x < -32767 || Points[p].x > 32767
			|| Points[p].y < -32767 || Points[p].y > 32767)
			{	if (p > 1) Polyline(hdc, Points, p);
				p = -1;	/* Restart the list, auto increment above */
			}
		}
		if (p > 1) Polyline(hdc, Points, p);
	}
	free(Points);
}

#ifdef UNDER_CE
static long RX(double h, double d)
{	return (long) (h*sin(d/180*3.1415926));
}

static long RY(double h, double d)
{	return (long) (h*cos(d/180*3.1415926));
}

static void DrawCircle(HDC hdc, long r, POINT c, double s, double e)
{	POINT *p = (POINT*)malloc(sizeof(*p)*361);
	double a;
	int i;

	p[0].x = c.x+RX(r,s); p[0].y = c.y-RY(r,s);
	for (i=1, a=s; a<e; i++, a+=12)
	{	p[i].x = c.x+RX(r,a);
		p[i].y = c.y-RY(r,a);
	}
	p[i].x = c.x+RX(r,e);
	p[i].y = c.y-RY(r,e);
	i++;
	if (i>361) exit(0);
	Polyline(hdc, p, i);
	free(p);
}
#endif

static void DrawOSMQueueCircle(RECT rc, HWND hwnd, HDC hdc)
{	int Count, Servers, Outstanding = OSMGetQueueStats(&Count, &Servers);
	if (Outstanding && Count)
	{	HGDIOBJ hold = SelectObject(hdc,GetStockObject(NULL_BRUSH));
#ifdef UNDER_CE
		HPEN hpen2 = CreatePen(PS_SOLID, 1, RGB(255,255,0));
#else
		HPEN hpen2 = CreatePen(PS_SOLID, 2, RGB(255,255,0));
#endif
		HGDIOBJ hold2 = SelectObject(hdc, hpen2);
		int Height = rc.bottom - rc.top;
		int Width = rc.right - rc.left;
		InflateRect(&rc, -(Width*Outstanding/Count/2), -(Height*Outstanding/Count/2));
		Ellipse(hdc, rc.left, rc.top, rc.right, rc.bottom);
		SelectObject(hdc, hold2);
		DeleteObject(hpen2);
		SelectObject(hdc, hold);
	}
}

static void HighlightStation(CLIENT_INFO_S *cInfo, HDC hdc, STATION_INFO_S *Station, int PenWidth, COLORREF Color)
{	int tr = cInfo->Index;
	HPEN hpen2 = CreatePen(PS_SOLID, PenWidth, Color);
	HGDIOBJ hold2 = SelectObject(hdc, hpen2);
	RECT rc = Station->TInfo[tr].rcSym;
	{	POINT Pts[5];
		Pts[0].x = rc.left-PenWidth; Pts[0].y = rc.top-PenWidth;
		Pts[1].x = rc.right+PenWidth; Pts[1].y = rc.top-PenWidth;
		Pts[2].x = rc.right+PenWidth; Pts[2].y = rc.bottom+PenWidth;
		Pts[3].x = rc.left-PenWidth; Pts[3].y = rc.bottom+PenWidth;
		Pts[4].x = rc.left-PenWidth; Pts[4].y = rc.top-PenWidth;
		Polyline(hdc, Pts, 5);
	}
	SelectObject(hdc, hold2);
	DeleteObject(hpen2);
}

static char *KMGT(double Value, int Decimals, char *Buffer)
{	char *b = "Bytes";
	if (Value > 1024.0)
	{	Value /= 1024.0;
		b = "KB";
		if (Value > 1024.0)
		{	Value /= 1024.0;
			b = "MB";
			if (Value > 1024.0)
			{	Value /= 1024.0;
				b = "GB";
				if (Value > 1024.0)
				{	Value /= 1024.0;
					b = "TB";
				}
			}
		}
	} else Decimals = 0;
	sprintf(Buffer, "%.*lf%s", (int) Decimals, Value, b);
	return Buffer;
}

static void PanCircle(CLIENT_INFO_S *cInfo, int x, int y, BOOL CrossHairs = TRUE)
{
	if (!cInfo->Locked)
		cInfo->CenterTracking = FALSE;	/* Manually set center, quit tracking! (unless locked) */

	cInfo->LastCenterPosition.dblLatitude -= (double)y*GetLatPixelDelta(cInfo->LastCenterPosition.dblLatitude,cInfo->zoom);
	if (cInfo->LastCenterPosition.dblLatitude > 85) cInfo->LastCenterPosition.dblLatitude = 85;
	if (cInfo->LastCenterPosition.dblLatitude < -85) cInfo->LastCenterPosition.dblLatitude = -85;
	cInfo->LastCenterPosition.dblLongitude -= (double)x*GetLongPixelDelta(cInfo->LastCenterPosition.dblLatitude,cInfo->zoom);
	if (cInfo->LastCenterPosition.dblLongitude > 180) cInfo->LastCenterPosition.dblLongitude = -180;
	if (cInfo->LastCenterPosition.dblLongitude < -180) cInfo->LastCenterPosition.dblLongitude = 180;
	cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */

	if (FirstRun)
	{	if (!CloseStationCount) DefineME(cInfo->hwnd);
		MyStation->pCoord = GetCoordIndex(cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude, "MyStation", MyStation->Station, MyStation->pCoord);
//		MyStation->lat = cInfo->LastCenterPosition.dblLatitude;
//		MyStation->lon = cInfo->LastCenterPosition.dblLongitude;
//		MyStation->tileX = long2tilex(MyStation->lon, MAX_OSM_ZOOM);
//		MyStation->tileY = lat2tiley(MyStation->lat, MAX_OSM_ZOOM);
//		MyStation->tileZ = MAX_OSM_ZOOM;
	}
#ifdef UNDER_CE
	if (cInfo->Dragging)	/* Not from keyboard */
	if (((int) cInfo->RestorePercent == (int) cInfo->Percent)
	&& ((int) cInfo->Percent != 100)
	&& !OSMIsTileSetCompatible(NULL, cInfo->ts, &rcCircle(cInfo->Index), &cInfo->tsInfo, ActiveConfig.Screen.Dim, cInfo->zoom, cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude, cInfo->Percent, FALSE))
		cInfo->Percent = 100;	/* Pans faster this way */
#endif
	if (CrossHairs && ActiveConfig.Screen.Show.CrossHairs > 0)
	{	cInfo->CrossHairs = TRUE;
		SetTimer(cInfo->hwnd, CROSSHAIR_TIMER, ActiveConfig.Screen.Show.CrossHairTime,NULL);
	}
	cInfo->msLastSigChange = llGetMsec();
	InvalidateStationPoints(cInfo->Index,"Dragging", TRUE);
	InvalidateCenter(cInfo->hwnd, TRUE+TRUE);
}

LRESULT CircleHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	double DispHeading = 0;
static	int Index = 0;
	switch (msg)
	{
	case WM_MOUSEWHEEL:	/* Hand the wheel off to the slider for zoom processing */
		return SliderHandler(Info, hwnd, cInfo, hdc, msg, wp, lp);

    case WM_LBUTTONDOWN: 
	{	RECT rcClient;
		POINT ptClientUL, ptClientLR;

		cInfo->Captured = TRUE;
		cInfo->ibCapture = Info;
		cInfo->CaptureHandler = CircleHandler;
		cInfo->ptCapture.x = LOWORD(lp); 
		cInfo->ptCapture.y = HIWORD(lp); 
		SetCapture(hwnd);

		GetClientRect(hwndMain, &rcClient); 
		CopyRect(&rcClient, &rcCircle(cInfo->Index));
		ptClientUL.x = rcClient.left; 
		ptClientUL.y = rcClient.top; 

		// Add one to the right and bottom sides, because the 
		// coordinates retrieved by GetClientRect do not 
		// include the far left and lowermost pixels. 

		ptClientLR.x = rcClient.right + 1; 
		ptClientLR.y = rcClient.bottom + 1; 
		ClientToScreen(hwnd, &ptClientUL); 
		ClientToScreen(hwnd, &ptClientLR); 

		// Copy the client coordinates of the client area 
		// to the rcClient structure. Confine the mouse cursor 
		// to the client area by passing the rcClient structure 
		// to the ClipCursor function. 

		SetRect(&rcClient, ptClientUL.x, ptClientUL.y, 
			ptClientLR.x, ptClientLR.y); 
		ClipCursor(&rcClient); 
		break;
	}
    case WM_MOUSEMOVE: 
	{	POINT		pt;
		pt.x = LOWORD(lp); 
		pt.y = HIWORD(lp); 

		if (!cInfo->Dragging)
		{
#ifdef UNDER_CE
			int cxDrag = 8, cyDrag = 8;
#else
			int cxDrag = GetSystemMetrics(SM_CXDRAG)*2;
			int cyDrag = GetSystemMetrics(SM_CYDRAG)*2;
#endif
			if (cxDrag < 0) cxDrag = -cxDrag;
			if (cxDrag < 0) cyDrag = -cyDrag;
			if (pt.x < cInfo->ptCapture.x-cxDrag
			|| pt.x > cInfo->ptCapture.x+cxDrag
			|| pt.y < cInfo->ptCapture.y-cyDrag
			|| pt.y > cInfo->ptCapture.y+cyDrag)
			{	cInfo->Dragging = TRUE;
				cInfo->RestorePercent = cInfo->Percent;
				if (ActiveConfig.Screen.Show.CrossHairs > 0)
				{	cInfo->CrossHairs = TRUE;
					KillTimer(hwnd, CROSSHAIR_TIMER);
				}
			}
		}

		if (cInfo->Dragging)
		{	pt.x -= cInfo->ptCapture.x; 
			pt.y -= cInfo->ptCapture.y; 

#ifdef OLD_WAY
			cInfo->LastCenterPosition.dblLatitude -= (double)pt.y*GetLatPixelDelta(cInfo->LastCenterPosition.dblLatitude,cInfo->zoom);
			if (cInfo->LastCenterPosition.dblLatitude > 85) cInfo->LastCenterPosition.dblLatitude = 85;
			if (cInfo->LastCenterPosition.dblLatitude < -85) cInfo->LastCenterPosition.dblLatitude = -85;
			cInfo->LastCenterPosition.dblLongitude -= (double)pt.x*GetLongPixelDelta(cInfo->LastCenterPosition.dblLatitude,cInfo->zoom);
			if (cInfo->LastCenterPosition.dblLongitude > 180) cInfo->LastCenterPosition.dblLongitude = -180;
			if (cInfo->LastCenterPosition.dblLongitude < -180) cInfo->LastCenterPosition.dblLongitude = 180;
			cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */

			if (FirstRun)
			{	if (!CloseStationCount) DefineME(hwnd);
				MyStation->lat = cInfo->LastCenterPosition.dblLatitude;
				MyStation->lon = cInfo->LastCenterPosition.dblLongitude;
				MyStation->pCoord = GetCoordIndex(MyStation->lat, MyStation->lon, "MyStation", MyStation->pCoord);
				MyStation->tileX = long2tilex(MyStation->lon, MAX_OSM_ZOOM);
				MyStation->tileY = lat2tiley(MyStation->lat, MAX_OSM_ZOOM);
				MyStation->tileZ = MAX_OSM_ZOOM;
			}

#ifdef UNDER_CE
			if (((int) cInfo->RestorePercent == (int) cInfo->Percent)
			&& ((int) cInfo->Percent != 100)
			&& !OSMIsTileSetCompatible(NULL, cInfo->ts, &Info->Tracker[cInfo->Index].rc, &cInfo->tsInfo, ActiveConfig.Screen.Dim, cInfo->zoom, cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude, cInfo->Percent, FALSE))
				cInfo->Percent = 100;	/* Pans faster this way */
#endif

			InvalidateStationPoints(cInfo->Index,"Dragging", TRUE);
			InvalidateCenter(hwnd, TRUE+TRUE);
#else
			PanCircle(cInfo, pt.x, pt.y, FALSE);
#endif
			cInfo->ptCapture.x = LOWORD(lp); 
			cInfo->ptCapture.y = HIWORD(lp); 

		}
        break; 
	}

    case WM_LBUTTONUP: 
	if (cInfo->Captured)	/* SHRecognizedGesture can mess this up */
	{	POINT		pt;
		pt.x = LOWORD(lp) - cInfo->ptCapture.x; 
		pt.y = HIWORD(lp) - cInfo->ptCapture.y; 

		cInfo->Captured = FALSE;
		ClipCursor(NULL); 
		ReleaseCapture(); 
		if (cInfo->Dragging)
		{	cInfo->Dragging = FALSE;
			cInfo->msDragComplete = llGetMsec();	/* For drag delay timing */
			TransmitFilter();	/* Update our filter for the new center */
			cInfo->Percent = cInfo->RestorePercent;
			if (ActiveConfig.Screen.Show.CrossHairs > 0)
			{	SetTimer(hwnd, CROSSHAIR_TIMER, ActiveConfig.Screen.Show.CrossHairTime, NULL);
			}
			InvalidateCircle(hwnd, TRUE, TRUE);
#ifdef AFTER_DRAG
			CenterTracking = FALSE;	/* Manually set center, quit tracking! */
			LastCenterPosition.dblLatitude += (double)pt.y/1000.0;
			if (LastCenterPosition.dblLatitude > 90) LastCenterPosition.dblLatitude = 90;
			if (LastCenterPosition.dblLatitude < -90) LastCenterPosition.dblLatitude = -90;
			LastCenterPosition.dblLongitude -= (double)pt.x/1000.0;
			if (LastCenterPosition.dblLongitude > 180) LastCenterPosition.dblLongitude = 180;
			if (LastCenterPosition.dblLongitude < -180) LastCenterPosition.dblLongitude = -180;
			LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
			InvalidateCenter(hwnd, TRUE);
			cInfo->msLastSigChange = llGetMsec();
#endif
		} else
		{	POINT pt;
			pt.x = LOWORD(lp); pt.y = HIWORD(lp);
			if (!PopupCircleMenu(hwnd, pt))	/* Didn't pop a menu, check rcAll */
			{	if (PtInRect(&cInfo->Circle.rcAll, pt))
				{	cInfo->viewBits ^= VIEW_ALL;
					if (cInfo->hwndViewChooser && IsWindow(cInfo->hwndViewChooser))
						PostMessage(cInfo->hwndViewChooser, WM_SET_CONTROLS, 0, 0);
					else if (!cInfo->viewBits)	/* Gone to None? bring up chooser */
						cInfo->hwndViewChooser = PopupViewChooser(hwnd, WM_REFRESH_CIRCLE, &cInfo->viewBits);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
			}
		}
	}
	break;

//	case WM_RBUTTONUP:
	case WM_CONTEXTMENU:

	if (cInfo && cInfo->Captured && !cInfo->Dragging)
	{	cInfo->Captured = FALSE;
		ClipCursor(NULL); 
		ReleaseCapture(); 
	}
		
	if (cInfo && !cInfo->Captured)	/* Ignore right button if captured */
	{	POINT pt;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		PopupContextMenu(hwnd, pt);
	}
	break;	/* End of CONTEXTMENU */

	case WM_LBUTTONDBLCLK:
	{
#ifdef THIS_NEVER_RUNS
#ifndef UNDER_CE
		POINT pt;
		pt.x = LOWORD(lp); pt.y = HIWORD(lp);
		if (PtInRect(&cInfo->Circle.rcAll, pt))
		{	if (cInfo->hwndViewChooser && IsWindow(cInfo->hwndViewChooser))
				ShowWindow(cInfo->hwndViewChooser, SW_SHOW);
			else if (!cInfo->viewBits)	/* Gone to None? bring up chooser */
				cInfo->hwndViewChooser = PopupViewChooser(hwnd, WM_REFRESH_CIRCLE, &cInfo->viewBits);
		} else
#endif
#endif
		{
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK Start\n");		
		char *QueueStatus = OSMGetQueueStatus();
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK QueueStatus:%p\n", QueueStatus);
		size_t Remaining = sizeof(TCHAR)*(512+strlen(QueueStatus)+(sizeof(ActiveConfig.OSM.Name)+sizeof(ActiveConfig.OSM.Path)+80)*ActiveConfig.TileServers.Count);
		TCHAR *Buffer=(TCHAR*)malloc(Remaining);
		TCHAR *Next = Buffer;
		unsigned long TotalTiles;
		unsigned __int64 TotalSpace, TotalDSpace, TotalFree;
		long TilesAttempted, TilesFetched, TileBytesSent, TileBytesRecv;
		double msGetTime;
		int QueueSize, QueueServers, QueueCount = OSMGetQueueStats(&QueueSize, &QueueServers);

		if (cInfo->ts)
		{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("[%S] z:%ld x:%ld-%ld y:%ld-%ld\n"),
							cInfo->tsInfo.Name, cInfo->zoom,
							cInfo->ts->xs, cInfo->ts->xe,
							cInfo->ts->ys, cInfo->ts->ye);
			if (ActiveConfig.Enables.Internet
			&& ActiveConfig.Enables.OSMFetch
			&& cInfo->tsInfo.SupportsStatus)
			if (cInfo->zoom <= cInfo->tsInfo.MaxServerZoom)
			{	char *URL = (char *) malloc(strlen(cInfo->tsInfo.URLPrefix)+33*3+80);
				sprintf(URL, "%.*s%ld/%ld/%ld.png/status",
						STRING(cInfo->tsInfo.URLPrefix),
						(long) cInfo->zoom,
						(long) cInfo->ts->xt,
						(long) cInfo->ts->yt);
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK Get(%s)\n", URL);
				int rlen;
				char *Status = httpGetBuffer(hwnd, cInfo->tsInfo.Server,
										cInfo->tsInfo.Port, URL, &rlen,
										PROGNAME, FALSE);
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK Got:%p\n", Status);
				if (Status)
				{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("x:%ld y:%ld %.*S%S"),
							cInfo->ts->xt, cInfo->ts->yt,
							(int) rlen, Status,
							Status[rlen-1]=='\n'?"":"\n");
					TraceLogThread("OSM", TRUE, "%s %s\n", URL, Status);
					free(Status);
				} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("x:%ld y:%ld Failed To Retreive /status\n"),
							cInfo->ts->xt, cInfo->ts->yt);
				free(URL);
			} else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("x:%ld y:%ld MaxZoom %ld\n"),
							cInfo->ts->xt, cInfo->ts->yt,
							cInfo->tsInfo.MaxServerZoom);
			else StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("x:%ld y:%ld /status Not Enabled\n"),
							cInfo->ts->xt, cInfo->ts->yt);
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK CheckTileState\n");
			char *TileState = OSMCheckTileState(&cInfo->tsInfo, cInfo->zoom, cInfo->ts->xt, cInfo->ts->yt);
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK CheckTileState:%p\n", TileState);
			if (TileState)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining,
							STRSAFE_IGNORE_NULLS,
							TEXT("%S\n"), TileState);
				free(TileState);
			}
		}

		TCHAR *Start = Next;	/* For double-newline separation */

//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK GetTileServerTotals\n");
		OSMGetTileServerTotals(&TotalTiles, &TotalSpace, &TotalDSpace, &TilesAttempted, &TilesFetched, &TileBytesSent, &TileBytesRecv, &msGetTime);
		// if (TilesAttempted || TotalTiles)
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK GotTileServerTotals\n");
		{	int Failures =TilesAttempted-TilesFetched-(QueueCount?QueueServers:0);
			if (QueueCount)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("Queue: %ld of %ld\n%S\n\n"),
								(long) QueueCount, (long) QueueSize, QueueStatus);
			if (TilesFetched || Failures > 0)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("Fetched: %ld"),
						(long) TilesFetched);
				if (Failures > 0)
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" (%ld Failed)"),
						(long) Failures);
			}
			if (TileBytesSent || TileBytesRecv)
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\nBytes Sent: %ld\nBytes Recv: %ld\nTotal Xfer: %ld"),
						(long) TileBytesSent, (long) TileBytesRecv,
						(long) TileBytesSent + TileBytesRecv);
			if (msGetTime)	/* Any time to divide by? */
			{	double Bps = (TileBytesSent+TileBytesRecv) / (msGetTime / 1000);
				if (Bps > 1024*1024)	/* MBps */
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" %.2lfMBps"), Bps/1024/1024);
				else if (Bps > 1024)	/* KBps */
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" %.2lfKBps"), Bps/1024);
				else
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT(" %.2lfBps"), Bps);
			}

			if (TotalTiles)
			{
#ifdef SUPPRESS_BREAKOUT
				if (Next != Buffer)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n\n"));
#ifdef UNDER_CE
				else
#endif
#else
				if (Next != Start)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n\n"));
#endif
				{	TCHAR *AgeStats = OSMGetTileAgeStats();
					if (AgeStats)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("%s\n\n"), AgeStats);
						free(AgeStats);
					}
				}

				for (unsigned int s=0; s<ActiveConfig.TileServers.Count; s++)
				{	unsigned __int64 ClusterSize = OSMGetClusterSize(&ActiveConfig.TileServers.Server[s]);

//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK TileServer[%ld](%s)\n",(long) s, ActiveConfig.TileServers.Server[s].Name);
					if (!OSMGetFreeSpace(&ActiveConfig.TileServers.Server[s], &TotalFree)) TotalFree = 0;
					{	char Free[16], Space[16], DSpace[16], Cluster[16];
						OSMGetTileServerStats(&ActiveConfig.TileServers.Server[s],
											&TotalTiles, &TotalSpace, &TotalDSpace);
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("%.*S->%.*S\n%ld/%S/%S(*%S) %S Free\n\n"),
									STRING(ActiveConfig.TileServers.Server[s].Name),
									STRING(ActiveConfig.TileServers.Server[s].Path),
									TotalTiles,
									KMGT((double)(__int64)TotalSpace,2,Space),
									KMGT((double)(__int64)TotalDSpace,2,DSpace),
									KMGT((double)(__int64)ClusterSize, 0, Cluster),
									KMGT((double)(__int64)TotalFree, 2, Free));
					}
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK Did TileServer[%ld](%s)\n",(long) s, ActiveConfig.TileServers.Server[s].Name);
				}
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("%ld MB Min Free"),
								ActiveConfig.OSMMinMBFree);
			}

			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("\nMenus: %ld/%ld"),
							(long) cInfo->MenuCount, (long) cInfo->MenuSize);

//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK MessageBox\n");
			if (Next != Buffer)
				MessageBox(hwnd, Buffer, TEXT("OSM Map Tiles"), MB_OK | MB_ICONINFORMATION);
		}
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK free(%p) (%ld Remaining)\n", Buffer, Remaining);
		free(Buffer);
//TraceLog("OSM", TRUE, hwnd, "CircleHandler:LBUTTONDBLCLK Complete!\n");
		}
		break;
	}
	case WM_PAINT:
	{	__int64 msNow = llGetMsec();
		__int64 msPaintStart = msNow;
	
		if (cInfo->Index	/* MultiTrack */
		&& (!cInfo->viewBits	/* Viewing NONE */
			|| cInfo->viewBits == VIEW_NWS)	/* Viewing NWS Objects */
		&& cInfo->CenterTracking	/* Not panning around */
		&& cInfo->CenterStation		/* And centered on something */
		&& cInfo->CenterStation->isNWS	/* Centered on an NWS object */
		&& cInfo->CenterStation->isKilled	/* And it's expired */
		&& ActiveConfig.NWS.MultiTrackCloseOnExpire	/* And we're auto-closing */
		&& strcmp(cInfo->CenterStation->Owner,"ZZZZZZ"))	/* Not my test */
		{	STATION_INFO_S *Station = cInfo->CenterStation;
			PostMessage(hwnd, WM_CLOSE, 0, 0);
#ifdef DEBUG_EXPIRES
			TraceLogThread("NWS-Debug", TRUE, "%s(%s) AutoClosing MultiTrack(%S)\n",
							Station->Station, Station->Owner,
							Station->Comment);
#endif
		}
	{	int tr = cInfo->Index;
		RECT *prcWin = &Info->Tracker[tr].rc;
		int width = prcWin->right-prcWin->left;
		int height = prcWin->bottom-prcWin->top;
		RECT rcSmaller = *prcWin;
		unsigned long VisibleCount = 0, ReCalcCount = 0, DeadReckonCount = 0;
		unsigned long ValidCount = 0, InvisibleCount = 0, NoShowCount = 0;
		unsigned long DFCount = 0, DRCount = 0;
		unsigned long PHGCount = 0, AmbCount = 0;
		unsigned long VisibleGeoCaches = 0;
		__int64 tDR=0, tDF=0, tPHG=0;
		long didDR=0, didDF=0, didPHG=0;
		__int64 Start = llGetMsec();
		__int64 oStart = Start;	/* for overall timing */
	static __int64 msMax=0, msLast=0;

/*	These are for the AlphaBlend of MultiLine overlays */
#if defined(SUPPORT_AREA_FILL) || defined(SUPPORT_POLYGON_FILL) || defined(SUPPORT_RECTANGLE_FILL)
		RECT rcAlpha;
		GetWindowRect(hwnd, &rcAlpha);
		long alphaWidth = rcAlpha.right - rcAlpha.left;
		long alphaHeight = rcAlpha.bottom - rcAlpha.top;
		HDC hdcAlpha = NULL;
		HGDIOBJ orgAlpha = NULL;
		HBITMAP hbmpAlpha = NULL;       // bitmap handle 
		VOID *pvBitsAlpha;          // pointer to DIB section 
#endif

//#define rcSmaller Info->rc

		if (width < height)
		{	InflateRect(&rcSmaller, 0, (width-height)/2);
		} else if (height < width)
		{	InflateRect(&rcSmaller, (height-width)/2, 0);
		}
		if (rcSmaller.left < rcSlider(tr).right)
			InflateRect(&rcSmaller, rcSmaller.left-rcSlider(tr).right, rcSmaller.left-rcSlider(tr).right);
		if (!IsRectEmpty(&rcStatUsage(tr))
		&& rcSmaller.right > rcStatUsage(tr).left)
			InflateRect(&rcSmaller, rcStatUsage(tr).left-rcSmaller.right, rcStatUsage(tr).left-rcSmaller.right);

Start = DebugTimer("CirclePaint","Init",Start,&msMax,&msLast,hwnd);

#ifndef DO_OSM
		if (GPSEnabled && LastGoodPosition.dwValidFields & GPS_VALID_HEADING)
			DispHeading = LastGoodPosition.flHeading;
//		if (cInfo->gpsPosition.dwValidFields & GPS_VALID_SPEED)
//		if (cInfo->gpsPosition.flSpeed == 0.0)
//			DispHeading = 0;
#endif

#define SKIP_OSM
#ifdef SKIP_OSM
#undef SKIP_OSM
#ifdef DO_OSM
		if ((cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			BOOL tsUpdated;
			char *Why;
		__int64 tStart = llGetMsec();
			if (!OSMIsTileSetCompatible(hwnd, cInfo->ts, prcWin,
									&cInfo->tsInfo, ActiveConfig.Screen.Dim, cInfo->zoom,
									cInfo->LastCenterPosition.dblLatitude,
									cInfo->LastCenterPosition.dblLongitude,
									cInfo->Percent,
									ActiveConfig.Screen.Show.GridSquare
										&& (cInfo->Percent == 45
											|| cInfo->Percent == 95),
									&tsUpdated, &Why))
			{
{static char Buffer[512];
static __int64 mstMax=0, mstLast=0;
if (cInfo->ts)
sprintf(Buffer,"OSM(c%ld):%ldx%ld=%ld/%ld/%ld/%ld%s%s (%s)", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"", Why);
else sprintf(Buffer,"OSM(c%ld):%ldx%ld=FAIL", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top));
tStart = DebugTimer("CirclePaint",Buffer,tStart,&mstMax,&mstLast,hwnd);
}
				if (cInfo->ts)
				{
{static char Buffer[512];
static __int64 mstMax=0, mstLast=0;
sprintf(Buffer,"OSM(f%ld):%ldx%ld=%ld/%ld/%ld/%ld%s%s (%s)", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"", Why);
tStart = DebugTimer("CirclePaint",Buffer,tStart,&mstMax,&mstLast,hwnd);
}
					OSMFreeTileSet(cInfo->ts);
				}
				cInfo->ts = OSMGetTileSet(hwnd, prcWin,
											&cInfo->tsInfo, ActiveConfig.Screen.Dim, cInfo->zoom,
											cInfo->LastCenterPosition.dblLatitude,
											cInfo->LastCenterPosition.dblLongitude,
											cInfo->Percent,
											ActiveConfig.Screen.Show.GridSquare
												&& (cInfo->Percent == 45 || cInfo->Percent == 95));

{static char Buffer[512];
static __int64 mstMax=0, mstLast=0;
if (cInfo->ts)
#ifdef PRIME_CENTER_TILE
sprintf(Buffer,"OSM(g%ld):%ldx%ld@%ld=%ld/%ld/%ld/%ld%s%s P:%.1lf B:%.1lf(S:%.1lf) W:%.1lf (%s)", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->zoom,
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"",
		(double) cInfo->ts->msPrime/1000.0,
		(double) cInfo->ts->msBuilt/1000.0,
		(double) cInfo->ts->msStretch/1000.0,
		(double) cInfo->ts->msWorld/1000.0,
		Why);
#else
sprintf(Buffer,"OSM(g%ld):%ldx%ld@%ld=%ld/%ld/%ld/%ld%s%s B:%.1lf(S:%.1lf) W:%.1lf (%s)", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->zoom,
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"",
		(double) cInfo->ts->msBuilt/1000.0,
		(double) cInfo->ts->msStretch/1000.0,
		(double) cInfo->ts->msWorld/1000.0,
		Why);
#endif
else sprintf(Buffer,"OSM(g%ld):%ldx%ld=FAIL", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top));
TraceLog("OSM", TRUE, hwnd, "%s\n", Buffer);
tStart = DebugTimer("CirclePaint",Buffer,tStart,&mstMax,&mstLast,hwnd);
}
				tsUpdated = TRUE;
			}	/* is compatible */
else
{static char Buffer[512];
static __int64 mstMax=0, mstLast=0;
if (cInfo->ts)
sprintf(Buffer,"OSM(c%ld):%ldx%ld=%ld/%ld/%ld/%ld%s%s (%s)", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"", Why);
else sprintf(Buffer,"OSM(c%ld):%ldx%ld=FAIL", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top));
tStart = DebugTimer("CirclePaint",Buffer,tStart,&mstMax,&mstLast,hwnd);
}

		if  (tsUpdated) InvalidateStationPoints(cInfo->Index,"IncompatibleTileSet",TRUE);

		} else TraceError(hwnd, "LastCenter[%ld] NOT Valid? 0x%lX vs 0x%lX\n", tr, (long) cInfo->LastCenterPosition.dwValidFields, (long) (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE));
		if (cInfo->ts)
		{	double OrgScale = cInfo->Scale;
			cInfo->Scale = OSMCalculateScale(cInfo->ts, &rcSmaller);

			if (ActiveConfig.Screen.FilterCircle
			&& cInfo->Scale != OrgScale)
				TransmitFilter();

			//if (cInfo->ts->BuiltTooMany) InvalidateRect(hwnd, &rcCircle, FALSE);	/* Get a repaint queued up */
#ifdef NOT_NECESSARY
			if (cInfo->Scale != OrgScale)
			{	InvalidateRect(hwnd, &rcScale, FALSE);
				InvalidateRect(hwnd, &rcSlider, FALSE);
				InvalidateRect(hwnd, &rcCircle, FALSE);
				InvalidateRect(hwnd, &rcStations, FALSE);
			}
#endif
		}
#endif
{static char Buffer[80];
if (cInfo->ts)
sprintf(Buffer,"OSM(c+g)[%ld]:%ldx%ld=%ld/%ld/%ld/%ld%s%s", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top),
		(long) cInfo->ts->BuiltCount,
		(long) cInfo->ts->StretchCount,
		(long) cInfo->ts->MissingCount,
		(long) cInfo->ts->Count,
		(long) cInfo->ts->BuiltTooMany?"T":"",
		(long) cInfo->ts->StillLoading?"L":"");
else sprintf(Buffer,"OSM(c+g)[%ld]:%ldx%ld=FAIL", tr,
		(long)(rcCircle(tr).right-rcCircle(tr).left),
		(long)(rcCircle(tr).bottom-rcCircle(tr).top));
Start = DebugTimer("CirclePaint",Buffer,Start,&msMax,NULL,hwnd);
}

		if (cInfo->viewBits != cInfo->viewBitsPainted)
		{	InvalidateStationPoints(tr, "ViewBitsChanged", TRUE);
			cInfo->viewBitsPainted = cInfo->viewBits;
			cInfo->Circle.msNotAllStart = msNow;
		}

#define SHADOW_CIRCLE
#ifdef SHADOW_CIRCLE
		HDC hdcShadow = hdc;
		BOOL Shadowed = FALSE;
		RECT rc;
		GetWindowRect(hwnd, &rc);
		if (!EqualRect(&cInfo->Circle.rcShadow, &rc))	/* Rectangle changed */
		{
			if (cInfo->Circle.hdcShadow && cInfo->Circle.hOrgMap) SelectObject(cInfo->Circle.hdcShadow, cInfo->Circle.hOrgMap);
			if (cInfo->Circle.hShadowMap) DeleteObject(cInfo->Circle.hShadowMap);
			if (cInfo->Circle.hdcShadow) DeleteDC(cInfo->Circle.hdcShadow);
			SetNextCirclePaint(cInfo, 0, "NewBitmap");

			cInfo->Circle.rcShadow = rc;
			cInfo->Circle.hdcShadow = CreateCompatibleDC(hdc);
			if (cInfo->Circle.hdcShadow)
			{	cInfo->Circle.hShadowMap = CreateCompatibleBitmap(hdc, rc.right-rc.left, rc.bottom-rc.top);
				if (cInfo->Circle.hShadowMap)
				{	cInfo->Circle.hOrgMap = SelectObject(cInfo->Circle.hdcShadow, cInfo->Circle.hShadowMap);
					if (cInfo->Circle.hOrgMap)
					{
						//		FillRect(cInfo->Circle.hdcShadow, &rc, GetSysColorBrush(COLOR_WINDOW));
					}
#define SHOW_OOPS
#ifdef SHOW_OOPS
					else
					{	TraceLog("Oops", TRUE, hwnd, "SelectObject(%p,%p) returned %p LastError %ld\n",
								(void*)cInfo->Circle.hdcShadow,
								(void*)cInfo->Circle.hShadowMap,
								(void*)cInfo->Circle.hOrgMap,
								(long) GetLastError());
						ShowTraceLog("Oops", TRUE);
						DeleteObject(cInfo->Circle.hShadowMap);
						DeleteDC(cInfo->Circle.hdcShadow);
						cInfo->Circle.hShadowMap = NULL;
						cInfo->Circle.hdcShadow = NULL;
					}
#endif
				}
#define SHOW_OOPS
#ifdef SHOW_OOPS
				else
				{	TraceLog("Oops", TRUE, hwnd, "CreateCompatibleBitmap(%p %ldx%ld) returned %p LastError %ld\n",
							(void*)hdc,
							(long) rc.right-rc.left,
							(long) rc.bottom-rc.top,
							cInfo->Circle.hShadowMap,
							(long) GetLastError());
					ShowTraceLog("Oops", TRUE);
						DeleteDC(cInfo->Circle.hdcShadow);
						cInfo->Circle.hdcShadow = NULL;
				}
#endif
			}
#define SHOW_OOPS
#ifdef SHOW_OOPS
			else
			{	TraceLog("Oops", TRUE, hwnd, "CreateCompatibleDC(%p) returned %p LastError %ld\n",
						(void*)hdc,
						(void*)cInfo->Circle.hdcShadow,
						(long) GetLastError());
				ShowTraceLog("Oops", TRUE);
			}
#endif
		}
/*
	Now that the shadow map has been reconstructed, see if we can use it
*/
		if (cInfo->Circle.hdcShadow)
		{	hdcShadow = cInfo->Circle.hdcShadow;

			__int64 msValid = llMsecSince(cInfo->Circle.msLastPaint,msNow);
			__int64 msMaxValid;

			if (!cInfo->Circle.StationsValid) msMaxValid = 250;
			else if (cInfo->Circle.DeadReckoning
			|| cInfo->Circle.StormSpinning) msMaxValid = STORM_SPIN_MSEC;
			else msMaxValid = 10000;

			if (msNow < cInfo->Circle.msNextPaint)
			{	Shadowed = TRUE;
#ifdef DEBUG_CIRCLE_PAINT
				if (msValid>msMaxValid)
					TraceLog("CirclePaint", FALSE, hwnd, "%d:Using ShadowCircle %s(Valid %ld Next %ld)\n", cInfo->Index, msValid>msMaxValid?cInfo->Circle.InvalidReason:"", (long) msValid, (long) llMsecSince(msNow,cInfo->Circle.msNextPaint));
#endif
#ifdef VERBOSELY_ANTIBUG
				for (unsigned long s=0; s<CloseStationCount; s++)
					if (!pCloseStations[s]->TInfo[tr].valid
					&& pCloseStations[s]->TInfo[tr].visible)
					TraceLog("CirclePaint", FALSE, hwnd, "%d:Station(%s) Visible but INVALID! (Valid %ld)\n", cInfo->Index, pCloseStations[s]->Station, (long) msValid);
#endif
			} else	/* Need to paint up a new shadow circle */
			{	Shadowed = FALSE;
#ifdef DEBUG_CIRCLE_PAINT
				TraceLog("CirclePaint", FALSE, hwnd, "%d:[%ld]RePainting(%s) ShadowCircle (Valid %I64d)\n", cInfo->Index, cInfo->Circle.PaintCount+1, cInfo->Circle.InvalidReason, (__int64) (cInfo->Circle.msLastPaint?msValid:-1));
#endif
				cInfo->Circle.StationsValid = TRUE;	/* Updating circle! */
				cInfo->Circle.InvalidReason = "Valid(NOT)";
				cInfo->Circle.msLastPaint = msNow;
	#ifdef UNDER_CE
				cInfo->Circle.msNextPaint = msNow + 30000;	/* Every 30 seconds */
	#else
				cInfo->Circle.msNextPaint = msNow + 10000;	/* Every 10 seconds */
	#endif
				cInfo->Circle.StormSpinning = FALSE;	/* Gets reset if we spin one */

	#ifdef ANTI_BUGGING
				{	unsigned long s;
				for (s=0; s<CloseStationCount; s++)
					if (!pCloseStations[s]->TInfo[tr].valid)
						break;
				if (s >= CloseStationCount)
					TraceLog("CirclePaint", TRUE, hwnd, "%d:ALL Stations VALID!\n" ,cInfo->Index);
				}
	#endif
			}
		}
//else TraceLog("CirclePaint", TRUE, hwnd, "NULL hdcShadow!\n");

		if (!Shadowed)	/* Only do all the painting if necessary */
		{
#define hdc hdcShadow
	COLORREF prevBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
	COLORREF prevText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	HBRUSH prevBrush = (HBRUSH) SelectObject(hdc, GetSysColorBrush(COLOR_WINDOW));

Start = DebugTimer("CirclePaint","ShadowCircle",Start,&msMax,NULL,hwnd);

#endif	/* SHADOW_CIRCLE */

#define OVERFLOW_MAP
#ifndef OVERFLOW_MAP
#ifdef UNDER_CE
#define CLIP_RECTRGN
#define CROP_CIRCLE
#else
#define CLIP_CIRCLE
#endif
#endif

#ifdef CLIP_CIRCLE
		SaveDC(hdc);
		BeginPath(hdc);
		Arc(hdc, rcSmaller.left, rcSmaller.top, rcSmaller.right, rcSmaller.bottom,
			rcSmaller.left, (rcSmaller.bottom-rcSmaller.top)/2,
			rcSmaller.left, (rcSmaller.bottom-rcSmaller.top)/2);
		EndPath(hdc);
		SelectClipPath(hdc, RGN_AND);	/* Possibly RGN_COPY */
#endif

#ifdef CLIP_RECTRGN
		SaveDC(hdc);
		HRGN hrgn = CreateRectRgnIndirect(&Info->rc);
		SelectClipRgn(hdc, hrgn);
#endif

		HDC hMemDC = CreateCompatibleDC(hdc);	/* For symbol painting */
		HRGN rgnLabels = CreateRectRgn(0,0,0,0);

		double PixelsPerMile = cInfo->Scale?(rcSmaller.right-rcSmaller.left)/2.0/cInfo->Scale:0;
		long MaxSegment = (long)(PixelsPerMile*EarthRadius/2);	/* max 1/2 planet radius */

		FillRect(hdc, prcWin, GetSysColorBrush(COLOR_WINDOW));

#define BROKEN_CIRCLE_CONTENTS
#ifdef BROKEN_CIRCLE_CONTENTS
#undef BROKEN_CIRCLE_CONTENTS
		{	HGDIOBJ hold2 = SelectObject(hdc,GetStockObject(NULL_BRUSH));
#ifndef UNDER_CE
//			HPEN hpen = CreatePen(PS_SOLID, 2, RGB(0,0,0));
			HPEN hpen = CreatePen(PS_SOLID, 2, RGB(0xC0,0xC0,0xC0));
			HGDIOBJ hold1 = SelectObject(hdc, hpen);
#endif

			if (cInfo->ts && cInfo->ts->Count && cInfo->Percent > 0)
				OSMPaintTileSet(hwnd, hdc, prcWin, cInfo->Percent, cInfo->ts);

			if (ActiveConfig.Screen.Show.Circle)
				Ellipse(hdc, rcSmaller.left, rcSmaller.top, rcSmaller.right, rcSmaller.bottom);
//			DrawOSMQueueCircle(rcSmaller, hwnd, hdc);

#ifndef UNDER_CE
			SelectObject(hdc, hold1);
			DeleteObject(hpen);
#endif
			SelectObject(hdc, hold2);
		}
#else	/* DO_OSM */
		if (ActiveConfig.Screen.Show.Circle)
			Ellipse(hdc, rcSmaller.left, rcSmaller.top, rcSmaller.right, rcSmaller.bottom);
#endif	/* DO_OSM */
Start = DebugTimer("CirclePaint","Background",Start,&msMax,NULL,hwnd);

		if (cInfo->Percent <= 0)
			DrawLatLonLines(Info, hwnd, hdc, DispHeading);

		BOOL TopLabelled = FALSE;
		if (cInfo->CenterStation
		&& cInfo->CenterTracking
		&& cInfo->CenterStation->MicEIndex
		&& ActiveConfig.MicEs.MicE[cInfo->CenterStation->MicEIndex].Enabled
		&& ActiveConfig.MicEs.MicE[cInfo->CenterStation->MicEIndex].Highlight)
		{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[cInfo->CenterStation->MicEIndex];
			int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
			RECT rcText;

			StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("Mic-E: %S%S"), Action->Name, cInfo->CenterStation->isEmergencySymbol?" (Symbol)":"");

//			rcText = Info->Tracker[tr].rc;
//			DrawText(hdc, Buffer, -1, &rcText, DT_NOPREFIX | DT_TOP | DT_SINGLELINE | DT_CENTER | DT_CALCRECT);
			rcText = Info->Tracker[tr].rc;
			DrawText(hdc, Buffer, -1, &rcText, DT_CENTER | DT_NOPREFIX);
			SetBkMode(hdc, prevBkMode);
			free(Buffer);
			TopLabelled = TRUE;
		} else if (ActiveConfig.AltNet[0])
		{	int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
			RECT rcText;

			StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("AltNet: %.*S"), STRING(ActiveConfig.AltNet));

//			rcText = Info->Tracker[tr].rc;
//			DrawText(hdc, Buffer, -1, &rcText, DT_NOPREFIX | DT_TOP | DT_SINGLELINE | DT_CENTER | DT_CALCRECT);
			rcText = Info->Tracker[tr].rc;
			DrawText(hdc, Buffer, -1, &rcText, DT_CENTER | DT_NOPREFIX);
			SetBkMode(hdc, prevBkMode);
			free(Buffer);
			TopLabelled = TRUE;
		}

		if (cInfo->msLastSigChange > cInfo->Circle.msNotAllStart)
			cInfo->Circle.msNotAllStart = cInfo->msLastSigChange;
		cInfo->Circle.msNotAllExpire = (cInfo->Circle.msNotAllStart+5000L)-msNow;
		if (cInfo->Circle.msNotAllExpire < 0) cInfo->Circle.msNotAllExpire = 0;
		BOOL DrawNotAll = cInfo->Circle.msNotAllExpire>0;

		{	BOOL ViewAll = (cInfo->viewBits&VIEW_ALL)!=0;
			BOOL ViewNone = (cInfo->viewBits==0);
			BOOL ViewSome = !ViewAll && !ViewNone;	/* Needs to be circled */
			TCHAR *Text = ViewNone?TEXT("one"):TEXT("all");
			HGDIOBJ hold2 = SelectObject(hdc,GetStockObject(NULL_BRUSH));
			HPEN hpen = CreatePen(PS_SOLID, 2, ViewAll?RGB(128,128,128):RGB(255,0,0));
			HGDIOBJ hold1 = SelectObject(hdc, hpen);
			COLORREF prevText = SetTextColor(hdc, ViewAll?RGB(128,128,128):RGB(0,0,0));
			int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			int Height, Width;
			RECT *rc = &cInfo->Circle.rcAll;
			*rc = Info->Tracker[tr].rc;
			DrawText(hdc, Text, -1, rc, DT_NOPREFIX | DT_TOP | DT_SINGLELINE | DT_CENTER | DT_CALCRECT);
			Width = rc->right - rc->left;
			Height = rc->bottom - rc->top;
			SetRect(rc, rcSlider(tr).right+2,	/* Just right of the slider */
						(rcSlider(tr).bottom+rcSlider(tr).top)/2-Height/2,	/* Centered vertically */
						rcSlider(tr).right+Width+2,
						(rcSlider(tr).bottom+rcSlider(tr).top)/2+Height/2);	/* Centered vertically */
			if (DrawNotAll) DrawText(hdc, Text, -1, rc, DT_CENTER | DT_NOPREFIX);
			if (ViewSome)	/* Put the circle around it */
			{	POINT apt[2];
				InflateRect(rc, 2, (Width-Height)/2+2);
				long Offset = (long)((rc->right-rc->left)/2.0*0.2928932);	/* 1-Sqrt(2)/2 for 45 degrees*/
//				apt[0].x = rc->left; apt[0].y = (rc->top+rc->bottom)/2;
//				apt[1].x = rc->right; apt[1].y = (rc->top+rc->bottom)/2;
				apt[0].x = rc->left+Offset; apt[0].y = rc->top+Offset;
				apt[1].x = rc->right-Offset; apt[1].y = rc->bottom-Offset;
				if (DrawNotAll)
				{	Polyline(hdc, apt, 2);
					Ellipse(hdc, rc->left, rc->top, rc->right, rc->bottom);
				}
			}
			SetBkMode(hdc, prevBkMode);
			SetTextColor(hdc, prevText);
			SelectObject(hdc, hold1);
			DeleteObject(hpen);
			SelectObject(hdc, hold2);
		}

		if (ActiveConfig.Screen.Show.Circle)
		{	RECT rcDummy;
			if (!TopLabelled)
				DrawCompassLabel(hdc, prcWin, 0-DispHeading, (rcSmaller.right-rcSmaller.left)/2-6, TEXT("N"));
			DrawCompassLabel(hdc, prcWin, 90-DispHeading, (rcSmaller.right-rcSmaller.left)/2-6, TEXT("E"));
			if (!DrawNotAll || !IntersectRect(&rcDummy, &cInfo->Circle.rcAll, &rcSmaller))
				DrawCompassLabel(hdc, prcWin, 270-DispHeading, (rcSmaller.right-rcSmaller.left)/2-6, TEXT("W"));
		}

		if (cInfo->Awaiting
		|| (cInfo->CenterStation	/* Must have one */
			&& (!cInfo->CenterTracking
				|| cInfo->CenterStation!=MyStation)))	/* Map frozen or tracking not me */
		{	int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
			int TextHeight;
			RECT rcText, rcTemp;
			char *Ranging = (cInfo->Index&&cInfo->CenterRanging)?" - RANGING":"";

			if (cInfo->Awaiting)
				StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("Await(%.*S)%S"),
								STRING(cInfo->CenterID), Ranging);
			else if (cInfo->CenterStation)
			{	STATION_INFO_S *Station = cInfo->CenterStation;
				
				if (Station->isNWS && cInfo->Scale && Station->sComment && cInfo->CenterTracking)
					FormatNWSTitle(Station, Buffer, sizeof(*Buffer)*80,
									Ranging);
				else
				{	char *What = cInfo->Locked?"Lock":"Follow";
					if (!cInfo->CenterTracking)
					{	if (IsPreferredView(hwnd,cInfo,TRUE))
						{	What = "Pref";
						} else What = "Pan";
					}
					if (HasNickLabelNonBlank(Station))
						StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%S(%.*S)%S"),
									What, STRING(Station->Nickname->Label), Ranging);
					else if (Station == MyStation)
							StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%S(ME)%S"),
									What, Ranging);
					else StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%S(%.*S)%S"),
									What, STRING(Station->Station), Ranging);
				}
			} else StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("NULL?%S"), Ranging);

			if (cInfo->CenterStation)
			{	STATION_INFO_S *Station = cInfo->CenterStation;
				if (Station->isObject
				&& Station->isMyObject
				&& Station->HeardInternal)
				if (Station->sComment)	/* Got a comment? */
				{	TCHAR *c = wcsrchr(Station->pComment,TEXT('{'));
					TCHAR *s = wcsstr(Station->pComment,TEXT(" }"));
					size_t cLen = Station->sComment-1;	/* Don't draw the null */

					if (s && c && s < c) cLen = s-Station->pComment;

					rcTemp = Info->Tracker[tr].rc;
					TextHeight = DrawText(hdc,
							Station->pComment, cLen,
							&rcTemp, DT_NOPREFIX | DT_CENTER | DT_CALCRECT);
					rcText = Info->Tracker[tr].rc;
					rcTemp.top = rcText.top = rcText.bottom - TextHeight * 2;

					rcTemp.bottom = rcTemp.top
						+ DrawText(hdc, Station->pComment, cLen,
									&rcText, DT_CENTER | DT_NOPREFIX);
//TraceLog("Centering", FALSE, hwnd, "\"%.*S\"", Station->sComment, Station->pComment);

					/* Keep labels away from the bottom center stuff */
					OffsetRect(&rcTemp, (rcText.right-rcTemp.right)/2, 0);
					{	HRGN rgnText = CreateRectRgnIndirect(&rcTemp);
						CombineRgn(rgnLabels, rgnLabels, rgnText, RGN_OR);
						DeleteObject(rgnText);
					}
				}
			}

			rcTemp = Info->Tracker[tr].rc;
			TextHeight = DrawText(hdc, Buffer, -1, &rcTemp, DT_NOPREFIX | DT_SINGLELINE | DT_CENTER | DT_CALCRECT);
			rcText = Info->Tracker[tr].rc;
			rcTemp.top = rcText.top = rcText.bottom - TextHeight;

			rcTemp.bottom = rcTemp.top
				+ DrawText(hdc, Buffer, -1, &rcText, DT_SINGLELINE | DT_CENTER | DT_NOPREFIX);
//TraceLog("Centering", FALSE, hwnd, "\"%S\" at %ld->%ld or %ld->%ld\n", Buffer, rcText.left, rcText.right, rcTemp.left, rcTemp.right);

			/* Keep labels away from the bottom center stuff */
			OffsetRect(&rcTemp, (rcText.right-rcTemp.right)/2, 0);
			{	HRGN rgnText = CreateRectRgnIndirect(&rcTemp);
				CombineRgn(rgnLabels, rgnLabels, rgnText, RGN_OR);
				DeleteObject(rgnText);
			}

			SetBkMode(hdc, prevBkMode);
			free(Buffer);
		} else	/* Centered on ME */
		{	if (ActiveConfig.Screen.Show.Circle)
				DrawCompassLabel(hdc, prcWin, 180-DispHeading, (rcSmaller.right-rcSmaller.left)/2-6,  (cInfo->Index&&cInfo->CenterRanging)?TEXT("RANGING"):TEXT("S"));
		}

Start = DebugTimer("CirclePaint","Compass",Start,&msMax,NULL,hwnd);

/*
#
# JUST MOBILE SYMBOLS: Use these symbols to select only mobile/portable stations for display.
. . . Primary: '<=>()*0COPRSUXY[^abefgjkpsuv . Alternate: /0>AKOS^knsuv
# JUST WEATHER SYMBOLS: Primary: _ and W and Alternate: ([*:<@BDEFGHIJTUW_efgptwy{
*/
		if (cInfo->LastCenterPosition.dwValidFields & GPS_VALID_LATITUDE)
		if (cInfo->LastCenterPosition.dwValidFields & GPS_VALID_LONGITUDE)
		{	unsigned long s;
			unsigned long mlTotal=0, mlOpt=0, mlPaint=0, mlSegs=0, mlPoints=0, mlActualP=0, mlOriginal=0, mlActualO=0;
			__int64 mlTooLong = llGetMsec()+500;/* Tracking MultiLine Recalcs */
			BOOL mlDeferred = FALSE;		/* Goes to TRUE if MLs don't finish */
			__int64 Now = llGetMsec();
			int SymbolWidth, SymbolHeight;
			RECT rcTemp = Info->Tracker[tr].rc;
			int TextHeight = DrawText(hdc, TEXT("KJ4ERJ"), -1, &rcTemp, DT_NOPREFIX | DT_CALCRECT);
			char *LabelNeeded = (char*)calloc(SeenStationCount, sizeof(*LabelNeeded));

			GetSymbolSize(prcWin, cInfo->Scale, &SymbolWidth, &SymbolHeight);

#ifdef NO_MORE
if (!cInfo->ts->SomeMissing)
{	double lat, lon;
	int t;
	for (lat=-80; lat<=80; lat+=10)
	for (t=0; t<cInfo->ts->Count; t++)
	{	if (lat <= cInfo->ts->Tiles[t].Tile->min.lat
		&& lat >= cInfo->ts->Tiles[t].Tile->max.lat)
		{	POINT p[2];
			if (OSMGetXYPos(cInfo->ts, lat, cInfo->ts->Tiles[t].Tile->min.lon+1, &p[0])
			&& OSMGetXYPos(cInfo->ts, lat, cInfo->ts->Tiles[t].Tile->max.lon-1, &p[1]))
			{	Polyline(hdc, p, 2);
			}
		}
	}
}
#endif
/*
	Put my objects on the screen
*/
#define BROKEN
#ifdef BROKEN
#undef BROKEN
			if (cInfo->ShowMyObjects)
			for (s=0; s<ActiveConfig.Objects.Count; s++)
			{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[s];
				int Percent = 100;

				{	POINT pt;
					GetScreenPoint(cInfo, prcWin, DispHeading, Obj->Latitude, Obj->Longitude, &pt, TRUE);
					ScaleSymbol2(hwnd, hdc, hMemDC, prcWin, 
							SymbolInt(Obj->Symbol.Table,Obj->Symbol.Symbol),
							pt.x, pt.y, cInfo->Scale, Percent, &rcTemp);
				}
			}
#endif

/*
	Put my overlay objects on the screen
*/
#define BROKEN
#ifdef BROKEN
#undef BROKEN
		if (ActiveConfig.Overlays.Count)	/* Don't bother if we don't have any */
		{	int o, p, oCount=0;
			unsigned long v, vCount=0;
#define ALPHA_RES 5
#define ALPHA_COUNT (100/ALPHA_RES)
			HDC hdcAlphas[ALPHA_COUNT] = {0};
			HBITMAP hbmpAlphas[ALPHA_COUNT] = {0};
			HGDIOBJ orgAlphas[ALPHA_COUNT] = {0};
			void *pvBitsAlphas[ALPHA_COUNT] = {0};

			for (v=0; v<ActiveConfig.Overlays.Count; v++)
			if (ActiveConfig.Overlays.Overlay[v].Enabled)
			{	oCount += ActiveConfig.Overlays.Overlay[v].Runtime.ObjectCount;
			}

//			BOOL *oVisible = (BOOL *)calloc(sizeof(*oVisible),oCount);
//			POINT *oPoint = (POINT *)calloc(sizeof(*oPoint),oCount);
//			RECT *oRC = (RECT *)calloc(sizeof(*oRC),oCount);
		
			for (p=0, v=0; v<ActiveConfig.Overlays.Count; v++)
			if (ActiveConfig.Overlays.Overlay[v].Enabled)
			{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[v];
				if (!pOver->RGBFixed)
				{	pOver->Route.Line.RGB = GetColorRGB(&ActiveConfig, pOver->Route.Line.Color, "Overlay.Route.Line");
					pOver->Track.Line.RGB = GetColorRGB(&ActiveConfig, pOver->Track.Line.Color, "Overlay.Track.Line");
					pOver->RGBFixed = TRUE;
				}
				for (o=0; o<pOver->Runtime.ObjectCount; o++, p++)
				{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[o];
					OVERLAY_CONFIG_POINT_S *pPoint = &pOver->Waypoint;

					Obj->TInfo[tr].ptVisible = Obj->TInfo[tr].rclblvalid = Obj->TInfo[tr].rcsymvalid = FALSE;

					switch (Obj->Type)
					{
					case 'P': pPoint = &pOver->Waypoint; break;
					case 'R': pPoint = &pOver->Route; break;
					case 'T': pPoint = &pOver->Track; break;
					}
					if (Obj->TrackCount)
					if (pPoint->Enabled)
					if (pPoint->Line.Opacity > 0)	/* No sense drawing invisible ones! */
					if (!(cInfo->Captured && cInfo->Dragging))	/* Turn off when panning */
					{	HDC hdcLine = hdc;
						if (pPoint->Line.Opacity <= (100-(ALPHA_RES)) && pPoint->Line.Opacity > 0)
						{	int a = (pPoint->Line.Opacity+(ALPHA_RES)/2) / (ALPHA_RES);
							if (a < 0) a = 0; else if (a >= ALPHA_COUNT) a = ALPHA_COUNT-1;
							if (!hdcAlphas[a])	/* Did we build one yet? */
							{	BITMAPINFO bmi = {0};        // bitmap header 
								bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
								bmi.bmiHeader.biWidth = alphaWidth;
								bmi.bmiHeader.biHeight = alphaHeight;
								bmi.bmiHeader.biPlanes = 1;
								bmi.bmiHeader.biBitCount = 32;         // four 8-bit components 
								bmi.bmiHeader.biCompression = BI_RGB;
								bmi.bmiHeader.biSizeImage = alphaWidth * alphaHeight * sizeof(UINT32);
								hdcAlphas[a] = CreateCompatibleDC(hdc);
								hbmpAlphas[a] = CreateDIBSection(hdcAlphas[a], &bmi, DIB_RGB_COLORS, &pvBitsAlphas[a], NULL, 0x0);
								orgAlphas[a] = SelectObject(hdcAlphas[a], hbmpAlphas[a]);
								memset(pvBitsAlphas[a], 0, bmi.bmiHeader.biSizeImage);
							}
							if (hdcAlphas[a]) hdcLine = hdcAlphas[a];
						}
						DrawTrackLine(Info, hwnd, hdcLine, hMemDC, prcWin,
										Obj->TrackCount, Obj->Tracks, 
										pPoint->Line.RGB,
										pPoint->Line.Width,
										DispHeading, MaxSegment);
					}
					if (pPoint->Enabled
					&& GetScreenPoint(cInfo, prcWin, DispHeading, Obj->pCoord->lat, Obj->pCoord->lon, &Obj->TInfo[tr].ptObj, TRUE)
					&& PtInRect(prcWin, Obj->TInfo[tr].ptObj))
					{	vCount++;
						Obj->TInfo[tr].ptVisible = TRUE;
						if (pPoint->Symbol.Show)
						{	int iSym = Obj->isymbol;
							if ((Obj->Type == 'P' && pPoint->Symbol.Force)
							|| !iSym) iSym = SymbolInt(pPoint->Symbol.Symbol.Table,
														pPoint->Symbol.Symbol.Symbol);
							ScaleSymbol2(hwnd, hdc, hMemDC, prcWin, iSym,
									Obj->TInfo[tr].ptObj.x, Obj->TInfo[tr].ptObj.y, cInfo->Scale, 100, &Obj->TInfo[tr].rcSym);
							Obj->TInfo[tr].rcsymvalid = TRUE;

							if (!ActiveConfig.View.LabelOverlap)
							if (vCount <= MAX_STATION_LABELS)
							{	HRGN rgnSymbol = CreateRectRgnIndirect(&Obj->TInfo[tr].rcSym);
								CombineRgn(rgnLabels, rgnLabels, rgnSymbol, RGN_OR);
								DeleteObject(rgnSymbol);
							}
						} else SetRect(&Obj->TInfo[tr].rcSym, Obj->TInfo[tr].ptObj.x, Obj->TInfo[tr].ptObj.y, Obj->TInfo[tr].ptObj.x, Obj->TInfo[tr].ptObj.y);
					}
				}
			}

			if (vCount <= MAX_STATION_LABELS)
			if (!(cInfo->Captured && cInfo->Dragging))	/* Turn off when panning */
			{
				int wOffset = (SymbolHeight)/4;
				int hOffset = (SymbolHeight)/4;

				int width = (Info->Tracker[tr].rc.right-Info->Tracker[tr].rc.left);
				int height = (Info->Tracker[tr].rc.bottom-Info->Tracker[tr].rc.top);
				double xOffset = 0.5 + width/2 + Info->Tracker[tr].rc.left, xMult = width/2.0 / cInfo->Scale;
				double yOffset = 0.5 + height/2 + Info->Tracker[tr].rc.top, yMult = height/2.0 / cInfo->Scale;

				HFONT hOld = (HFONT) 0;
				int prevBkMode = SetBkMode(hdc, TRANSPARENT);

				if (SymbolHeight < TextHeight)
				{	HFONT hFont = LoadPaintFont(TEXT(""), max(8,SymbolHeight), FALSE);	/* 8 is as small as we go */
					if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
				}

				for (p=0, v=0; v<ActiveConfig.Overlays.Count; v++)
				if (ActiveConfig.Overlays.Overlay[v].Enabled)
				if (ActiveConfig.Overlays.Overlay[v].Label.Enabled)
				{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[v];
					for (o=0; o<pOver->Runtime.ObjectCount; o++, p++)
					if (pOver->Runtime.Objects[o].TInfo[tr].ptVisible)
					{	OVERLAY_OBJECT_INFO_S *Obj = &pOver->Runtime.Objects[o];
						OVERLAY_CONFIG_POINT_S *pPoint = &pOver->Waypoint;
						switch (Obj->Type)
						{
						case 'P': pPoint = &pOver->Waypoint; break;
						case 'R': pPoint = &pOver->Route; break;
						case 'T': pPoint = &pOver->Track; break;
						}
						if (pPoint->Label)
						{
						size_t Remaining = sizeof(TCHAR)*(strlen(Obj->ID)+(Obj->alt>0?40:0)+1+Obj->sComment+1+Obj->sStatusReport+1);
						TCHAR *Buffer = (TCHAR*)malloc(Remaining);
						TCHAR *Next = Buffer;
						RECT rcText, rcTest;
						if (pOver->Label.ID)
							StringCbPrintExUTF8(Buffer, Remaining, &Next, &Remaining, -1, Obj->ID, NULL);
//							StringCbPrintfEx(Buffer, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, 
//											TEXT("%S"), Obj->ID);
	if (pOver->Label.Altitude
	&& Obj->alt > 0)	/* Got an altitude? */
	{	BOOL HasComment = (pOver->Label.Comment && Obj->sComment && *Obj->pComment)
							|| (pOver->Label.Status && Obj->sStatusReport && *Obj->pStatusReport);
		if (ActiveConfig.View.Metric.Altitude)
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S%ldm%S"), HasComment?" (":(Next!=Buffer?"\n":""), (long) (Obj->alt), HasComment?")":"");
		else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S%ldft%S"), HasComment?" (":(Next!=Buffer?"\n":""), (long) (Obj->alt*FeetPerMeter), HasComment?")":"");
	}
						if (pOver->Label.Comment
						&& Obj->sComment && *Obj->pComment)
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%S%s"), Next!=Buffer?"\n":"", Obj->pComment);
						if (pOver->Label.Status
						&& Obj->sStatusReport && *Obj->pStatusReport)
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("%S%s"), Next!=Buffer?"\n":"", Obj->pStatusReport);

						if (Next!=Buffer)	/* Format anything? */
						{
						RECT rcStat = Obj->TInfo[tr].rcSym;
						UINT Align = DT_NOPREFIX | DT_LEFT;
						SetRect(&rcText, rcStat.right, rcStat.top, Info->Tracker[tr].rc.right, rcStat.bottom);
						int LocalHeight = DrawText(hdc, Buffer, -1, &rcText, Align | DT_CALCRECT);

						if ((Obj->TInfo[tr].rcSym.bottom-Obj->TInfo[tr].rcSym.top) >= LocalHeight)
						{	rcText.top = rcStat.top; rcText.bottom = rcStat.bottom;
						} else
						{	rcStat.top = rcText.top; rcStat.bottom = rcText.bottom;
						}

						rcTest = rcText;	/* Start where we want */
						if (!ActiveConfig.View.LabelOverlap)
						if (RectInRegion(rgnLabels, &rcTest))	/* Preferred (right center) any good? */
						{	SetRect(&rcTest, rcStat.left-(rcText.right-rcText.left), rcStat.top,
											rcStat.left, rcStat.top+LocalHeight);
							Align = DT_NOPREFIX | DT_RIGHT;
							if (RectInRegion(rgnLabels, &rcTest))	/* left center is crowded */
							{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4,
												rcStat.bottom,
												(rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4+(rcText.right-rcText.left),
												rcStat.bottom+LocalHeight);
								Align = DT_NOPREFIX | DT_LEFT;
								if (RectInRegion(rgnLabels, &rcTest))	/* bottom right is crowded */
								{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4, rcStat.top-LocalHeight,
												(rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4+(rcText.right-rcText.left),
												rcStat.top);
									Align = DT_NOPREFIX | DT_LEFT;
									if (RectInRegion(rgnLabels, &rcTest))	/* top right is crowded */
									{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4-(rcText.right-rcText.left),
															rcStat.bottom, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4,
															rcStat.bottom+LocalHeight);
										Align = DT_NOPREFIX | DT_RIGHT;
										if (RectInRegion(rgnLabels, &rcTest))	/* bottom left is crowded */
										{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4-(rcText.right-rcText.left),
															rcStat.top-LocalHeight, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4,
															rcStat.top);
											Align = DT_NOPREFIX | DT_RIGHT;
											if (RectInRegion(rgnLabels, &rcTest))	/* top left is crowded */
											{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcText.right-rcText.left)/2,
																rcStat.bottom+LocalHeight,
																(rcStat.right+rcStat.left)/2+(rcText.right-rcText.left)/2,
																rcStat.bottom+LocalHeight*2);
												Align = DT_NOPREFIX | DT_CENTER;
												if (RectInRegion(rgnLabels, &rcTest))	/* 2*bottom center is crowded */
												{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcText.right-rcText.left)/2,
																	rcStat.top-LocalHeight*2,
																	(rcStat.right+rcStat.left)/2+(rcText.right-rcText.left)/2,
																	rcStat.top-LocalHeight);
													Align = DT_NOPREFIX | DT_CENTER;
													if (RectInRegion(rgnLabels, &rcTest))	/* 2*top center is crowded, Give up and stack it! */
													{	rcTest = rcText;
														Align = DT_NOPREFIX | DT_LEFT;
													}
												}
											}
										}
									}
								}
							}
						}
						{	int tHeight = DrawText(hdc, Buffer, -1, &rcTest, Align | DT_NOPREFIX);
							rcTest.bottom = rcTest.top + tHeight;
							Obj->TInfo[tr].rcLbl = rcTest;
							Obj->TInfo[tr].rclblvalid = TRUE;
							if (!ActiveConfig.View.LabelOverlap)
							{	HRGN rgnLabel = CreateRectRgnIndirect(&rcTest);
								CombineRgn(rgnLabels, rgnLabels, rgnLabel, RGN_OR);
								DeleteObject(rgnLabel);
							}
						}
						}
						free(Buffer);
						}
					}
				}
				SetBkMode(hdc, prevBkMode);
				if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
			}
/*
	Now get the translucent lines on the screen
*/
			for (int a=0; a<ALPHA_COUNT; a++)
			{
				if (hdcAlphas[a])	/* Got any AlphaBlend Overlays? */
				{	BLENDFUNCTION bf;      // structure for alpha blending 
					int   x,y;          // stepping variables 
					int Opacity = a*ALPHA_RES;
					if (!Opacity) Opacity = ALPHA_RES/2;

					bf.BlendOp = AC_SRC_OVER;
					bf.BlendFlags = 0;
					bf.SourceConstantAlpha = (BYTE)(255*Opacity/100);
					bf.AlphaFormat = 0;             // ignore source alpha channel 
					bf.AlphaFormat = AC_SRC_ALPHA;

#ifndef UNDER_CE
					GdiFlush();
#endif
					register int bitCount=0;
					for (y = 0; y < alphaHeight; y++)
					{	UINT32 *pvRow = &((UINT32 *)(pvBitsAlphas[a]))[y*alphaWidth];
						for (x = 0; x < alphaWidth; x++)
							if (pvRow[x])	/* Painted? */
							{	pvRow[x] |= 0xff000000;
								bitCount++;
							}
						//bf.SourceConstantAlpha<<24;
					}
#ifndef NO_ALPHABLEND
					if (bitCount
					&& !AlphaBlend(hdc, 0, 0, alphaWidth, alphaHeight, 
									hdcAlphas[a], 0, 0, alphaWidth, alphaHeight, bf))
						TraceError(hwnd, "AlphaBlend Failed!\n");
#endif
					SelectObject(hdcAlphas[a], orgAlphas[a]);
					if (!DeleteObject(hbmpAlphas[a]))
						TraceError(hwnd, "DeleteObject(hbmpAlpha) Failed With %ld", GetLastError());
					DeleteDC(hdcAlphas[a]);
				}
			}
#undef ALPHA_RESOLUTION
#undef ALPHA_COUNT
		}
#endif

#define BROKEN
#ifdef BROKEN
#undef BROKEN

			for (s=0; s<CloseStationCount; s++)
			if (pCloseStations[s]->TInfo[tr].ptvalid
			&& !pCloseStations[s]->TInfo[tr].visible
			&& !pCloseStations[s]->TInfo[tr].alwaysvisible)
			{	pCloseStations[s]->TInfo[tr].rcsymvalid = pCloseStations[s]->TInfo[tr].rclblvalid = FALSE;	/* No rcs are valid */
				InvisibleCount++;
			} else
			{	STATION_INFO_S *Station = pCloseStations[s];
				BOOL ShowIt = FALSE;

				Station->TInfo[tr].rcsymvalid = Station->TInfo[tr].rclblvalid = FALSE;	/* No rcs are valid */

				if (!Station->isKilled
				|| Station->isMyObject
				|| Station == cInfo->CenterStation)
				{
					ShowIt = Station->TInfo[tr].visible || Station->TInfo[tr].alwaysvisible;
					if (!ShowIt) NoShowCount++;

					if (ShowIt && (!s || Station->lastMsec))
					{	__int64 Age = (Now - Station->lastMsec) / 60 / 1000;	/* Age in Minutes */
						int Percent;

						if (!s) Percent = 100;	/* ME is ALWAYS visible! */
						else if (Station->isMyObject && Station->HeardInternal
						&& Station->isObject && !Station->isKilled)
							Percent = 100;	/* My overlays do NOT fade! */
						else
						{	long MaxAge = Station->isBuddy?ActiveConfig.Stations.BuddyMaxAge:ActiveConfig.Stations.MaxAge;

							if (Age <= ActiveConfig.Stations.MinAge
							|| MaxAge == 0)
								Percent = 100;
							else	Percent = 100 - (int) (Age/MaxAge*100);

							if (Station->isBuddy
							|| Station->isKilled
							|| Station->isNWS
							|| Station==cInfo->CenterStation)
								Percent = max(Percent,5);
							else
							{	//if (Percent <= 0 && Age > ActiveConfig.Stations.MaxAge+60)
								//	TraceLog("AgePaint", FALSE, hwnd, "%s(%s) Age %ld/%ld Percent %ld, WHY?\n", Station->Station, Station->Owner, (long) Age, (long) ActiveConfig.Stations.MaxAge, (long) Percent);
								if (Percent < 0) Percent = 0;
							}
						}

						if (Percent <= 0)
							ShowIt = FALSE;
						else
						{	double lat = Station->pCoord->lat;
							double lon = Station->pCoord->lon;
							BOOL Duplicate = FALSE;
							double duplat, duplon;

							if (Station->TrackCount
							&& Station->Tracks[Station->TrackCount-1].Invalid == TRACK_DUP)
							{	int t = Station->TrackCount-1;
								Duplicate = TRUE;
								duplat = Station->Tracks[t].pCoord->lat;
								duplon = Station->Tracks[t].pCoord->lon;
							}

							{	POINT pt;
								BOOL Visible;
								if (Station->TInfo[tr].ptvalid)
								{	pt = Station->pCoord->pt[tr];
									Visible = Station->TInfo[tr].visible
											|| Station->TInfo[tr].alwaysvisible;
									ValidCount++;
								} else
								{	Visible = GetScreenPoint(cInfo, prcWin, DispHeading, lat, lon, &pt, TRUE)
												|| Station == MyStation
												|| Station == cInfo->CenterStation;
#ifdef VERBOSE
if (Station->TInfo[tr].valid)
{	BOOL Moved = pt.x != Station->TInfo[tr].pt.x
				|| pt.y != Station->TInfo[tr].pt.y;
	if ((!Visible != !Station->TInfo[tr].visible) || Moved)
		TraceLogThread("ValidVisible", TRUE, "[%ld]Station[%ld](%s) %s %s %ld,%ld -> %ld,%ld\n",
					tr, s, Station->Station,
					Visible?(Station->TInfo[tr].visible?"Visibly":"Appeared"):"DISAPPEARED",
					Moved?"MOVED":"at",
					Station->TInfo[tr].pt.x, Station->TInfo[tr].pt.y,
					pt.x, pt.y);
}
#endif
									Station->TInfo[tr].visible = Visible;
									Station->TInfo[tr].ptvalid = TRUE;
									Station->pCoord->pt[tr] = pt;
									ReCalcCount++;
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]Recalc(Valid) %s %sVisible\n", (int) tr, Station->Station, Station->TInfo[tr].visible?"":"NOT ");
								}
								Station->TInfo[tr].inCircle = PtInRect(prcWin,pt);
								if (Visible)
								{	RECT rcIntersect;
									Station->TInfo[tr].rcsymvalid = TRUE;
									if (ScaleSymbol2(hwnd, hdc, hMemDC,
										prcWin,
										GetStationSymbol(Station),
										pt.x, pt.y, cInfo->Scale,
										Percent, &Station->TInfo[tr].rcSym)
									&& (!s || Station==cInfo->CenterStation	/* Always show these stations */
										|| IntersectRect(&rcIntersect, &Station->TInfo[tr].rcSym, prcWin)))
									{	VisibleCount++;

										if (cInfo->AutoZoomViewOut
										&& Station->TInfo[tr].inCircle)
										{	RECT rcTemp;
											if (!IntersectRect(&rcTemp, &Station->TInfo[tr].rcSym, prcWin)
											|| !EqualRect(&rcTemp, &Station->TInfo[tr].rcSym))
											{	Station->TInfo[tr].inCircle = FALSE;
												TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Station %s Symbol NOT Fully InCircle\n",
														cInfo->Index, Station->Station);
											}
										}

										if (Duplicate)
										{	POINT pt2;
											if (GetScreenPoint(cInfo, prcWin, DispHeading, duplat, duplon, &pt2, TRUE))
											{	RECT rcDummy;
												ScaleSymbol2(hwnd, hdc, hMemDC,
														prcWin,
														GetStationSymbol(Station),
														pt2.x, pt2.y, cInfo->Scale,
														Percent/2, &rcDummy);	/* Shadow duplilcate position */
											}
										}

										if (!ActiveConfig.View.LabelOverlap)
										if ((ActiveConfig.View.Callsign || ActiveConfig.View.LabelWeather)
										&& (VisibleCount <= MAX_STATION_LABELS
										|| SymbolHeight >= TextHeight))
										{	HRGN rgnSymbol = CreateRectRgnIndirect(&Station->TInfo[tr].rcSym);
											CombineRgn(rgnLabels, rgnLabels, rgnSymbol, RGN_OR);
											DeleteObject(rgnSymbol);
										}

										COLORREF TrackColor = RGB(0,0,0);
										/* Drawing tracks? */
										if (Station->TrackCount
										&& (ActiveConfig.Screen.Show.Tracks
											|| (Station->isRFID && Station->isymbol==SymbolInt('H', 'A'))))
										{
											TrackColor = DrawTrack(Info, hwnd, hdc, hMemDC, prcWin, Station,
														cInfo->ts, DispHeading,
														Station==cInfo->CenterStation,
														cInfo->CenterTracking&&Station==cInfo->CenterStation,
														MaxSegment);
										}

										/* Let's put out a wind-barb if we have the data */
										if (ActiveConfig.Screen.WindBarbs.Enabled)
										{	double WindSpeed = 0;
											int WindDir = 0;
											if (Station->Weather
											&& Station->Weather->Valid & VALID_WX_WINDSPEED
											&& Station->Weather->Valid & VALID_WX_DIRECTION)
											{	WindSpeed = Station->Weather->windspeed;
												WindDir = Station->Weather->direction;
											} else if (ActiveConfig.Screen.WindBarbs.RotateStorm
											&& Station->Storm
											&& Station->Storm->valid & VALID_STORM_WINDSPEED)
											{	WindSpeed = Station->Storm->windspeed;
												WindDir = (msNow/STORM_SPIN_ROT_SECONDS*360/1000)%360;
												if (Station->pCoord->lat >= 0) WindDir = 360-WindDir;
												cInfo->Circle.StormSpinning = TRUE;
											}
											if (WindSpeed)
											{	TraceLog("WindBarb", FALSE, hwnd, "%s:Wind %.1lf @ %ld\n", Station->Station, (double) WindSpeed, (long) WindDir);
												DrawWindBarb(hdc, Station, &pt, &Station->TInfo[tr].rcSym, WindSpeed, WindDir);
											}
										}

										/* Do we need footprint circle? */
										if (ActiveConfig.View.Footprint.Enabled
										&& Station->pPHG		/* Got PHG info? */
										&& !Station->PHGParsed	/* Not the real ones */
										&& !Station->DFSParsed	/* Not the real ones */
										&& !Station->BRGNRQParsed	/* Not the real ones */
										&& Station->hadAltitude	/* Got altitude? */
										&& Station->pPHG->range	/* got a bit of range? */
										&& Station->alt*FeetPerMeter >= ActiveConfig.View.Footprint.MinAltitude
										&& Station->alt*FeetPerMeter <= ActiveConfig.View.Footprint.MaxAltitude)
										if (!(cInfo->Captured && cInfo->Dragging))	/* Turn off when panning */
										{	LONG cwidth = rcSmaller.right-rcSmaller.left;
											LONG cheight = rcSmaller.bottom-rcSmaller.top;
											double Percent = Station->pPHG->range / cInfo->Scale;
											LONG rwidth = (LONG)(cwidth*Percent)/2;
											LONG rheight = (LONG)(cheight*Percent)/2;
											HPEN hpen3 = CreatePen(PS_SOLID, 1, TrackColor);
											HGDIOBJ hold3 = SelectObject(hdc, hpen3);
											HBRUSH hbr4 = (HBRUSH) GetStockObject(NULL_BRUSH);
											HGDIOBJ hOld4 = SelectObject(hdc, hbr4);
											Ellipse(hdc, 
													pt.x-rwidth,
													pt.y-rheight,
													pt.x+rwidth,
													pt.y+rheight);
											SelectObject(hdc, hOld4);
											DeleteObject(SelectObject(hdc, hold3));
										}
/*
	Highlight frequency-bearing stations (especially invalids)
*/
										if (Station->Frequency && Station->Frequency->Issues)
										{	COLORREF Color = GetColorRGB(&ActiveConfig, Station->Frequency->Issues?"DeepPink":"LimeGreen", "FreqSpec");
											HighlightStation(cInfo, hdc, Station, 1, Color);
										}

										if (Station->MicEIndex)
										{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Station->MicEIndex];
											if (Action->Enabled)
											if (Action->Highlight)
											{	if (!Action->ColorFixed)
												{	Action->RGB = GetColorRGB(&ActiveConfig, Action->Color, "MicE");
													Action->ColorFixed = TRUE;
												}
#ifdef UNDER_CE
	int PenWidth = 1;	/* Typically smaller screens */
#else
	int PenWidth = Action->MultiTrackActive?3:Action->FlashOnCenter?2:1;
#endif
												HighlightStation(cInfo, hdc, Station, PenWidth, Action->RGB);
											}
#ifndef UNDER_CE
											if (cInfo->CenterStation == Station)	/* Double-check flashing */
											{	if (!Action->Enabled
												|| !Action->FlashOnCenter)
												{	cInfo->FlashingAcked = FALSE;	/* So it'll start flashing again if necessary */
													if (cInfo->Flashing)
													{	FLASHWINFO fw = {0};
														fw.cbSize = sizeof(fw);
														fw.hwnd = hwnd;
														fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
														FlashWindowEx(&fw);
														cInfo->Flashing = FALSE;
													}
												}
												if (Action->Enabled)
												if (Action->FlashOnCenter
												&& !cInfo->Flashing
												&& !cInfo->FlashingAcked)
												if (ActiveConfig.Enables.MicENotification
												|| (ActiveConfig.Enables.MicEEmergency && Station->MicEIndex == 1))
												if (!CheckIgnoreString(hwnd, &Action->Ignores, Station->Station, FALSE))
												{	FLASHWINFO fw = {0};
													fw.cbSize = sizeof(fw);
													fw.hwnd = hwnd;
													fw.dwFlags = FLASHW_ALL | FLASHW_TIMER;
													FlashWindowEx(&fw);
													cInfo->Flashing = TRUE;
													cInfo->Locked = TRUE;
												}
											}
#endif
										}
#ifndef UNDER_CE
										else if (cInfo->Flashing)	/* Any residual flashing? */
										{	FLASHWINFO fw = {0};
											fw.cbSize = sizeof(fw);
											fw.hwnd = hwnd;
											fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
											FlashWindowEx(&fw);
											cInfo->Flashing = FALSE;
											cInfo->FlashingAcked = FALSE;	/* So it'll start flashing again if necessary */
										}
#endif

#ifdef SHOW_RFID_READER_TARGETS
	/*
		Show where the station's RFID targets would end up
	*/
										if (Station->RFID.Grid.dlat	/* if we've got a delta */
										|| Station->RFID.Grid.dlon
										|| Station->RFID.Grid.offset)	/* or an offset */
										{	int r, c;
											double llat, llon;
											double latoffset = (double)Station->RFID.Grid.offset/1000.0/60.0;
											double lonoffset = latoffset*2/cos(Station->lat);

	/*
	Then it begins the next column which is offset in longitude 16
	times the latitude increment (divided by the local COS(lat)) so
	that the separation works at all latitudes.
	*/
										
											for (c=0, llon=Station->lon+(double)Station->RFID.Grid.dlon/100.0/60.0; c<3; c++, llon+=lonoffset)
											{	for (r=0, llat=Station->lat+(double)Station->RFID.Grid.dlat/100.0/60.0; r<Station->RFID.Grid.rows; r++, llat+=latoffset)
												{	if (OSMGetXYPos(cInfo->ts, llat, llon, &pt))
													{	RECT rcDummy;
														ScaleSymbol2(hdc, &Info->rc, 0, 'A'-'!',
																	pt.x, pt.y, cInfo->Scale, 50, &rcDummy);
														if (!latoffset) break;	/* No need to be redundant */
													}
												}
												if (!lonoffset) break;	/* No need to be redundant */
											}
										}
	#endif
									} else ShowIt = FALSE;
								} else if (Station==cInfo->CenterStation && Station->TrackCount		/* Always show center's and RFID HotSpot Track */
								&& (ActiveConfig.Screen.Show.Tracks || (Station->isRFID && Station->isymbol==SymbolInt('H', 'A'))))
								{	int Mult=1, Div = 1;
									RECT *rc = prcWin, rcSafe = Station->TInfo[tr].rcSym;
									int width = rc->right - rc->left;
									int height = rc->bottom - rc->top;

									VisibleCount++;	/* need to show altitude labels on track! */

									GetScaleMultDiv(cInfo->Scale, width, &Mult, &Div);
									Station->TInfo[tr].rcSym.left = Station->TInfo[tr].rcSym.right - ((337/16-4)*Mult/Div);	/* Width of "station" for dots */
									Station->TInfo[tr].rcSym.top = Station->TInfo[tr].rcSym.bottom - ((127/6-4)*Mult/Div);	/* Height of "station" for dots */
									DrawTrack(Info, hwnd, hdc, hMemDC, prcWin, Station, cInfo->ts, DispHeading,
												Station==cInfo->CenterStation, cInfo->CenterTracking&&Station==cInfo->CenterStation, MaxSegment);
									Station->TInfo[tr].rcSym = rcSafe;
								} else ShowIt = FALSE;

								if (Station==MyStation
								&& (MyDestination.lat != 0
								|| MyDestination.lon != 0)
								&& GetScreenPoint(cInfo, prcWin, DispHeading, MyDestination.lat, MyDestination.lon, &pt, TRUE))
								{	RECT rcDummy;
									ScaleSymbol2(hwnd, hdc, hMemDC,
											prcWin,
											SymbolInt('\\','/'),
											pt.x, pt.y, cInfo->Scale,
											100, &rcDummy);
								}
							}

							if (Station->MultiLine && Station->MultiLine->Count >= 2)
							if ((Station->MultiLine->Segments <= 1	/* Or Normal  */
								&& Station->MultiLine->Count <= 24)		/* ... Simple MultiLine? */
							|| !Station->MultiLine->Filled	/* Non-filled always display */
#ifdef SUPPORT_SHAPEFILES
							|| ActiveConfig.NWS.ShapesEnabled		/* Are shapes enabled? */
#endif
							)
							{	MULTILINE_INFO_S *ml = Station->MultiLine;
								mlTotal++;
								if (Station->isKilled
								&& !Station->isMyObject
								&& Station != cInfo->CenterStation)
								{	SetRectEmpty(&ml->Tracker[tr].rcMinMax);	/* Nope, nothing to see here! */
								} else 
								{
								POINT ptTest = {0};
								RECT rcTest, rcScrap;

								GetScreenPoint(cInfo, prcWin, DispHeading, ml->Min.Lat, ml->Min.Lon, &ptTest, FALSE);
								rcTest.left = ptTest.x; rcTest.bottom = ptTest.y+1;
								GetScreenPoint(cInfo, prcWin, DispHeading, ml->Max.Lat, ml->Max.Lon, &ptTest, FALSE);
								rcTest.right = ptTest.x+1; rcTest.top = ptTest.y;
								if (!IntersectRect(&rcScrap, &rcTest, prcWin))
								{
#ifdef VERBOSE
									TraceLog("MultiLine", FALSE, hwnd, "%s %ld %ld -> %ld %ld Not On Screen %ld %ld -> %ld %ld\n",
											Station->Station,
											(long) rcTest.left, (long) rcTest.top,
											(long) rcTest.right, (long) rcTest.bottom,
											(long) prcWin->left, (long) prcWin->top,
											(long) prcWin->right, (long) prcWin->bottom);
#endif
									SetRectEmpty(&ml->Tracker[tr].rcMinMax);	/* Nope, nothing to see here! */
									ShowIt = FALSE;
								} else
								{	//BOOL SkipIt = FALSE;
									ShowIt = TRUE;

									if (!Station->TInfo[tr].visible)
									{	Station->TInfo[tr].visible = TRUE;	/* Force it back visible */
										VisibleCount++;	/* And count it */
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]Multiline(FORCE) %s %sVisible %s\n", (int) tr, Station->Station, Station->TInfo[tr].visible?"":"NOT ");
									}
//else if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]Multiline(ShowIt) %s %sVisible %s\n", (int) tr, Station->Station, Station->TInfo[tr].visible?"":"NOT ");

#ifdef VERBOSE
									TraceLog("MultiLine", FALSE, hwnd, "%s %ld %ld -> %ld %ld ON Screen %ld %ld -> %ld %ld\n",
											Station->Station,
											(long) rcTest.left, (long) rcTest.top,
											(long) rcTest.right, (long) rcTest.bottom,
											(long) prcWin->left, (long) prcWin->top,
											(long) prcWin->right, (long) prcWin->bottom);
#endif
								if (!EqualRect(&rcTest, &ml->Tracker[tr].rcMinMax))
								{
									//if (mlOpt && !mlDeferred
									//&& OSMGetMsec() > mlTooLong)
									//	mlDeferred = TRUE;
									//if (mlDeferred) SkipIt = TRUE;
									//else
									{
									__int64 mlOptStart = llGetMsec();
									mlOpt++;
									mlActualO += ml->Count;
									if (ml->Tracker[tr].ptEnds) free(ml->Tracker[tr].ptEnds);
									if (ml->Tracker[tr].pts) free(ml->Tracker[tr].pts);
									ml->Tracker[tr].ptEnds = (int*)malloc(sizeof(*ml->Tracker[tr].ptEnds)*ml->Segments);
									ml->Tracker[tr].pts = (POINT*)malloc(sizeof(*ml->Tracker[tr].pts)*ml->Count);
#ifdef SUPPORT_RECTANGLE_FILL
									if (ml->Tracker[tr].rcBounds) free(ml->Tracker[tr].rcBounds);
									ml->Tracker[tr].rcBounds = (RECT*)malloc(sizeof(*ml->Tracker[tr].rcBounds)*ml->Segments);
#endif
									int c = 0, p = 0;
									for (int s=0; s<ml->Segments; s++)
									{	int pOrg = p;
#ifdef SUPPORT_RECTANGLE_FILL
										RECT *prcBound = &ml->Tracker[tr].rcBounds[s];
										BOOL FirstPoint = TRUE;
										SetRectEmpty(prcBound);
#endif
										for (; p<ml->SegEnds[s]; p++)
										{	POINT pt, ptLast;
											if (cInfo->ts)
											{//	OSM_TILE_COORD_S tCoord;
//												LatLonToTileCoord(ml->Points[p].Lat,
//																ml->Points[p].Lon,
//																&tCoord);
												OSMTileCoordToPoint(cInfo->ts, &ml->tCoords[p], &pt, TRUE);
//TraceLog("ML-Opt", TRUE, hwnd, "%.5lf %.5lf is %ld %ld or tCoord %ld %ld making %ld %ld\n",
//		 ml->Points[p].Lat, ml->Points[p].Lon,
//		 pt.x, pt.y,
//		 tCoord.x, tCoord.y, pt2.x, pt2.y);
											} else
											GetScreenPoint(cInfo, prcWin, DispHeading, ml->Points[p].Lat, ml->Points[p].Lon, &pt, TRUE);
											if (c) ptLast = ml->Tracker[tr].pts[c-1];
											if (!c || (s&&c==ml->SegEnds[s-1])
											|| abs(pt.x - ptLast.x) > 2	/* Has to move far enough to notice */
											|| abs(pt.y - ptLast.y) > 2)	/* Move enough to notice */
											{	ml->Tracker[tr].pts[c++] = pt;
#ifdef SUPPORT_RECTANGLE_FILL
												if (FirstPoint)
												{	prcBound->left = prcBound->right = pt.x;
													prcBound->top = prcBound->bottom = pt.y;
													FirstPoint = FALSE;
												} else
												{	if (pt.x < prcBound->left) prcBound->left = pt.x;
													if (pt.x > prcBound->right) prcBound->right = pt.x;
													if (pt.y < prcBound->top) prcBound->top = pt.y;
													if (pt.y > prcBound->bottom) prcBound->bottom = pt.y;
												}
#endif
											}
										}
#ifdef SUPPORT_RECTANGLE_FILL
										if (!IsRectEmpty(prcBound))
										{	prcBound->right++;	/* Need to fill to the edges */
											prcBound->bottom++;	/* Need to fill to the edges */
										}
#endif
										ml->Tracker[tr].ptEnds[s] = c;
//										TraceLog("ML-Opt", FALSE, hwnd, "[%ld]%s[%ld] %ld-%ld (%ld Points)\n",
//												tr, Station->Station, s, pOrg, p, p-pOrg);
									}
									mlActualP += ml->Tracker[tr].ptEnds[ml->Segments-1];
#ifdef VERBOSE
									TraceLog("ML-Opt", FALSE, hwnd, "[%ld]%s %ld %ld -> %ld %ld REBUILT Cache %ld %ld -> %ld %ld (Drawing %ld/%ld Points in %ld Segments) %ldms\n",
											tr, Station->Station,
											(long) rcTest.left, (long) rcTest.top,
											(long) rcTest.right, (long) rcTest.bottom,
											(long) ml->Tracker[tr].rcMinMax.left, (long) ml->Tracker[tr].rcMinMax.top,
											(long) ml->Tracker[tr].rcMinMax.right, (long) ml->Tracker[tr].rcMinMax.bottom,
											(long) ml->Tracker[tr].ptEnds[ml->Segments-1],
											(long) ml->Count, (long) ml->Segments,
											(long) llMsecSince(mlOptStart,llGetMsec()));
#endif
									ml->Tracker[tr].rcMinMax = rcTest;	/* Remember optimized points */
									}
								}
#ifdef VERBOSE
								else TraceLog("ML-Opt", FALSE, hwnd, "[%ld]%s %ld %ld -> %ld %ld EQUALS Cache %ld %ld -> %ld %ld (Drawing %ld/%ld Points in %ld Segments)\n",
											tr, Station->Station,
											(long) rcTest.left, (long) rcTest.top,
											(long) rcTest.right, (long) rcTest.bottom,
											(long) ml->Tracker[tr].rcMinMax.left, (long) ml->Tracker[tr].rcMinMax.top,
											(long) ml->Tracker[tr].rcMinMax.right, (long) ml->Tracker[tr].rcMinMax.bottom,
											(long) ml->Tracker[tr].ptEnds[ml->Segments-1],
											(long) ml->Count, (long) ml->Segments);
#endif
//								if (!SkipIt)
								if (!(cInfo->Captured && cInfo->Dragging))	/* Turn off when panning */
								{
//#define SHOW_SIMPLIFIED
#ifdef SHOW_SIMPLIFIED
//#undef SUPPORT_AREA_FILL
//#undef SUPPORT_POLYGON_FILL
//#undef SUPPORT_RECTANGLE_FILL

if (!strcmp(Station->Owner, "ZZZZZZ")
&& !strncmp(Station->Station, "TST", 3))
{
	POINT *pts = (POINT*)malloc(sizeof(*pts)*ml->Count);
	int p = 0;
	for (int s=0; s<ml->Segments; s++)
	{	int pCount = ml->SegEnds[s]-p;

		Point *sV, *V = ml->Points;
		double perc, minLat, minLon, maxLat, maxLon;
		sV= (Point *)malloc(sizeof(*sV)*pCount);
		for (int i=0; i<pCount; i++)
		{	if (!i)
			{	minLat = maxLat = V[i+p].Lat;
				minLon = maxLon = V[i+p].Lon;
			} else
			{	if (V[i+p].Lat < minLat) minLat = V[i+p].Lat;
				else if (V[i+p].Lat > maxLat) maxLat = V[i+p].Lat;
				if (V[i+p].Lon < minLon) minLon = V[i+p].Lon;
				else if (V[i+p].Lon > maxLon) maxLon = V[i+p].Lon;
			}
		}
		TraceLog("ShapeCache", FALSE, hwnd, "(%s)[%ld] %ld-%ld (%ld Points)\n",
				Station->Station, s, p, ml->SegEnds[s], pCount);
		for (perc=0; perc<=4; perc+=.5)
		{	double tol = max((maxLat-minLat)*perc/100.0, (maxLon-minLon)*perc/100.0);
			long New = poly_simplify(tol, &V[p], pCount, sV);
			int c = 0;
			for (long i=0; i<New; i++)
			{	POINT pt/*, ptLast*/;
				GetScreenPoint(cInfo, prcWin, DispHeading, sV[i].Lat, sV[i].Lon, &pt, FALSE);
//				if (c) ptLast = pts[c-1];
//				if (!c || (s&&c==ml->SegEnds[s-1])
//				|| abs(pt.x - ptLast.x) > 2	/* Has to move far enough to notice */
//				|| abs(pt.y - ptLast.y) > 2)	/* Move enough to notice */
				{	pts[c++] = pt;
				}
			}
			TraceLogThread("ShapeCache", FALSE, "(%s)[%ld] %ld -> %ld (%ld?) @%.2lf%% (tol:%.4lf for %.4lf->%.4lf %.4lf->%.4lf)\n",
							Station->Station, s, pCount, New, c, perc,
							tol, minLat, maxLat,
							minLon, maxLon);
			if (c > 1)
			{	HPEN hpen2 = CreatePen(PS_SOLID, 1, RGB(0,0,0));
				HGDIOBJ hold2 = SelectObject(hdc, hpen2);
				if (!Polyline(hdc, pts, c))
				SelectObject(hdc, hold2);
				DeleteObject(hpen2);
			}
		}
		free(sV);
		p += pCount;
	}
	free(pts);
}
#endif	/* SHOW_SIMPLIFIED */





#ifdef UNDER_CE
								HPEN hpen2 = CreatePen(ml->style, 1, ml->color);
#else
								HPEN hpen2 = CreatePen(ml->style, ml->style==PS_SOLID?2:1, ml->color);
#endif
								HGDIOBJ hold2 = SelectObject(hdc, hpen2);

								mlPaint++;
								mlOriginal += ml->Count;
								for (int p=0, s=0; s<ml->Segments; p=ml->Tracker[tr].ptEnds[s++])
								{	int c = ml->Tracker[tr].ptEnds[s] - p;
									POINT *apt = &ml->Tracker[tr].pts[p];
									if (c > 1)
									{
mlSegs++;
mlPoints += c;
#if defined(SUPPORT_AREA_FILL) || defined(SUPPORT_POLYGON_FILL) || defined(SUPPORT_RECTANGLE_FILL)
if (ml->Filled && ActiveConfig.NWS.Opacity)	/* Only polygon objects */
{
		if (width && height)	/* No window?  No need! */
		{
			if (!hdcAlpha)	/* Did we build one yet? */
			{	hdcAlpha = CreateCompatibleDC(hdc);

				// setup bitmap info  
				BITMAPINFO bmi;        // bitmap header 
				// zero the memory for the bitmap info 
				ZeroMemory(&bmi, sizeof(BITMAPINFO));

				bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
				bmi.bmiHeader.biWidth = alphaWidth;
				bmi.bmiHeader.biHeight = alphaHeight;
				bmi.bmiHeader.biPlanes = 1;
				bmi.bmiHeader.biBitCount = 32;         // four 8-bit components 
				bmi.bmiHeader.biCompression = BI_RGB;
				bmi.bmiHeader.biSizeImage = alphaWidth * alphaHeight * sizeof(UINT32);

				// create our DIB section and select the bitmap into the dc 
				hbmpAlpha = CreateDIBSection(hdcAlpha, &bmi, DIB_RGB_COLORS, &pvBitsAlpha, NULL, 0x0);
				orgAlpha = SelectObject(hdcAlpha, hbmpAlpha);
				
				// in top window area, constant alpha = 50%, but no source alpha 
				// the color format for each pixel is 0xaarrggbb  
				// set all pixels to blue and set source alpha to zero 

				memset(pvBitsAlpha, 0, bmi.bmiHeader.biSizeImage);

				// Outline areas in black
				SelectObject(hdcAlpha, GetStockObject(BLACK_PEN));
			}

			if (!Station->isNWS || Station->isNWSIssued)	/* Fill issued objects */
			{	HBRUSH hbr = CreateSolidBrush(Station->isKilled?RGB(192,192,192):ml->color);
#ifdef SUPPORT_AREA_FILL
				HGDIOBJ hOld = SelectObject(hdcAlpha, hbr); 
//				BeginPath(hdcAlpha); 
//				if (!Polyline(hdcAlpha, apt, c))
//					TraceLog("MultiLine", FALSE, hwnd, "Failed to draw %ld Points\n", c);
//				EndPath(hdcAlpha); 
//				//StrokeAndFillPath(hdcAlpha); 
//				FillPath(hdcAlpha); 
				SelectObject(hdcAlpha, hOld);
#elif defined(SUPPORT_POLYGON_FILL)
				HGDIOBJ hOld = SelectObject(hdcAlpha, hbr); 
				Polygon(hdcAlpha, apt, c);
				SelectObject(hdcAlpha, hOld);
#elif defined(SUPPORT_RECTANGLE_FILL)
				if (!IsRectEmpty(&ml->Tracker[tr].rcBounds[s]))
					FillRect(hdcAlpha, &ml->Tracker[tr].rcBounds[s], hbr);
#endif
				DeleteObject(hbr);
			} else 
			{	//HPEN hpen3 = CreatePen(style, style==PS_SOLID?2:1, color);
				//HGDIOBJ hold3 = SelectObject(hdcAlpha, hpen3);
				//if (!Polyline(hdcAlpha, apt, c))
				if (!Polyline(hdc, apt, c))
					TraceLog("MultiLine", FALSE, hwnd, "Failed to draw %ld Points\n", c);
				//SelectObject(hdcAlpha, hold3);
				//DeleteObject(hpen3);
			}
		}
}// else	/* No else so that we outline the areas boldly */
#endif
if (!Station->isNWS || Station->isNWSIssued)	/* Draw the heavy outline */
{	if (!SplitPolyline(hdc, apt, c, MaxSegment))
		TraceLog("MultiLine", FALSE, hwnd, "Failed to draw %ld Points\n", c);
}
									}
								}
								SelectObject(hdc, hold2);
								DeleteObject(hpen2);
								}// else ShowIt = FALSE;
								}
								}
							}
						}
					} else ShowIt = FALSE;
				} else ShowIt = FALSE;
				if (!ShowIt)
				{	Station->TInfo[tr].visible = FALSE;	/* First make it non-visible */
					Station->TInfo[tr].rcsymvalid = Station->TInfo[tr].rclblvalid = FALSE;	/* Non-clickable */
					if (Station->MultiLine)
						SetRectEmpty(&Station->MultiLine->Tracker[tr].rcMinMax);
//if (Station->isNWS) TraceLogThread("NWSVisible", FALSE, "[%ld]Paint(!ShowIt) %s %sVisible\n", (int) tr, Station->Station, Station->TInfo[tr].visible?"":"NOT ");
				} else	/* Count visibles for paint optimization */
				{	if (Station->speed
					|| Station->speedAverage
					|| Station->speedCalculated) DRCount++;
					if (Station->PHGParsed) PHGCount++;
					if (Station->Ambiguity) AmbCount++;
				}
				if (Station->BRGNRQParsed
				|| Station->DFSParsed)
					if (Station->TInfo[tr].visible
					|| Station->TInfo[tr].alwaysvisible)
						DFCount++;
			}
			if (mlDeferred)
			{	TraceLog("Deferred",TRUE,hwnd,"Deferring ML Optimization, Did %ld in %ldms\n", mlOpt, (long) llMsecSince(mlTooLong-500,llGetMsec()));
				//InvalidateCircle(hwnd, FALSE);
			}
{	char Temp[132];
if (!mlTotal)
sprintf(Temp,"Stations[%ld]:%ld/%ld",tr,(long)VisibleCount, (long)CloseStationCount);
else if (!mlPaint && !mlOpt)
sprintf(Temp,"Stations[%ld]:%ld/%ld ml:%ld/%ld",tr,(long)VisibleCount, (long)CloseStationCount, mlPaint, mlTotal);
else
sprintf(Temp,"Stations[%ld]:%ld/%ld ml%s:%ld/%ld/%ld pt:%ld/%ld/%ld",tr,(long)VisibleCount, (long)CloseStationCount, mlDeferred?"DEFERRED":"", mlOpt, mlPaint, mlTotal, mlOriginal, mlPoints, mlSegs);
Start = DebugTimer("CirclePaint",Temp,Start,&msMax,NULL,hwnd);
if (mlOpt) TraceLog("ML-Opt", FALSE, hwnd, "[%ld]Optimized %ld/%ld from %ld/%ld to %ld/%ld points over %ld segments %ldms\n", tr, mlOpt, mlTotal, mlActualO, mlOriginal, mlActualP, mlPoints, mlSegs, (long) llMsecSince(mlTooLong-500,llGetMsec()));
}

#endif
#if defined(SUPPORT_AREA_FILL) || defined(SUPPORT_POLYGON_FILL) || defined(SUPPORT_RECTANGLE_FILL)
			if (hdcAlpha)	/* Got any AlphaBlend Overlays? */
			{	BLENDFUNCTION bf;      // structure for alpha blending 
				int   x,y;          // stepping variables 

				bf.BlendOp = AC_SRC_OVER;
				bf.BlendFlags = 0;
				bf.SourceConstantAlpha = (BYTE)(255*ActiveConfig.NWS.Opacity/100);
				bf.AlphaFormat = 0;             // ignore source alpha channel 
				bf.AlphaFormat = AC_SRC_ALPHA;

#ifndef UNDER_CE
				GdiFlush();
#endif
				register int bitCount=0;
				for (y = 0; y < alphaHeight; y++)
				{	UINT32 *pvRow = &((UINT32 *)pvBitsAlpha)[y*alphaWidth];
					for (x = 0; x < alphaWidth; x++)
						if (pvRow[x])	/* Painted? */
						{	pvRow[x] |= 0xff000000;
							bitCount++;
						}
					//bf.SourceConstantAlpha<<24;
				}

#ifndef NO_ALPHABLEND
				if (bitCount
				&& !AlphaBlend(hdc, 0, 0, alphaWidth, alphaHeight, 
								hdcAlpha, 0, 0, alphaWidth, alphaHeight, bf))
					TraceError(hwnd, "AlphaBlend Failed!\n");
#endif

				// do cleanup 
				SelectObject(hdcAlpha, orgAlpha);
				if (!DeleteObject(hbmpAlpha))
					TraceError(hwnd, "DeleteObject(hbmpAlpha) Failed With %ld", GetLastError());
				hbmpAlpha = NULL;	/* It's all gone */
				DeleteDC(hdcAlpha);
				hdcAlpha = NULL;	/* We no longer have one! */
Start = DebugTimer("CirclePaint","AlphaBlendOverlays",Start,&msMax,NULL,hwnd);
			}
#endif

#define BROKEN
#ifdef BROKEN
#undef BROKEN

//if (!tr) TraceLogThread("ValidVisible", TRUE, "[%ld]Station[%ld](%s) %s at %ld,%ld\n", cInfo->Index, tr, MyStation->Station, MyStation->TInfo[tr].visible?"Visible":"INVISIBLE", MyStation->TInfo[tr].pt.x, MyStation->TInfo[tr].pt.y);

/*
	Add in the dead reckoning stations
*/
tDR = llGetMsec();
			if (VisibleCount && VisibleCount <= MAX_STATION_LABELS
			&& !(cInfo->Captured && cInfo->Dragging)	/* Not when panning */
			&& ActiveConfig.Screen.Show.Reckoning
			&& DRCount)
			for (s=0; s<CloseStationCount; s++)
			{	STATION_INFO_S *Station = pCloseStations[s];
				if (Station->TInfo[tr].visible)
				{	BOOL GotOne = FALSE;
					double speed=0, course = 0;

					if (Station == MyStation)	/* ME is different */
					{	GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
						if (ActiveConfig.Beacon.CourseSpeed	/* If we beacon it, we show it */
						&& (Genius->LastAPRSPosition.dwValidFields & (GPS_VALID_HEADING | GPS_VALID_SPEED))
														== (GPS_VALID_HEADING | GPS_VALID_SPEED))
						{	__int64 msElapsed = llMsecSince(Genius->LastAPRSUpdate,llGetMsec());
							speed = Genius->LastAPRSPosition.flSpeed;
							course = Genius->LastAPRSPosition.flHeading;
							GotOne = TRUE;
							if (ActiveConfig.View.Speed.All && speed > 0)
							{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
											prcWin,
											Station, speed, course,
											cInfo->ts, DispHeading))
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckonME";
//									Station->TInfo[tr].valid = FALSE;
								}
							}
						}
					} else if (Station->isNWS)
					{
						if (Station->CSEParsed
						&& Station->speed > 0
						&& Station->pNWSTimes)
						{	SYSTEMTIME stNow;
							__int64 msElapsed, msMax;
							speed = Station->speed;
							course = Station->course;

							GetSystemTime(&stNow);
							msElapsed = DeltaSeconds(&Station->pNWSTimes->stIssued, &stNow) * 1000;
							msMax = DeltaSeconds(&Station->pNWSTimes->stIssued, &Station->pNWSTimes->stExpires)*1000;
							if (msMax <= 0)
								msMax = 60*60*1000;
							else if (msMax > 4*60*60*1000)
								msMax = 4*60*60*1000;
#ifdef VERBOSE
							TraceLog("DeadReckon", FALSE, hwnd, "DR(%s) %ld @ %ld from %02ld %02ld:%02ld to %02ld %02ld:%02ld is %ld/%ld seconds\n",
								Station->Station, (long) speed, (long) course,
								stIssued.wDay, stIssued.wHour, stIssued.wMinute,
								stNow.wDay, stNow.wHour, stNow.wMinute,
								(long) (msElapsed/1000), (long) (msMax/1000));
#endif

							if (msElapsed > 0)
							{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
											prcWin,
											Station, speed, course,
											cInfo->ts, DispHeading,
											msElapsed, msMax))	/* 1-4 hours */
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckon";
//									Station->TInfo[tr].valid = FALSE;
								}
							}
						}
					} else if (!Station->isSignpost)	/* Signposts use cse/spd for direction of applicability (http://www.aprs.org/traffic/traffic.txt) */
														/* "This requires a mod to APRSdos so that it does not dead-reckon this sign!" */
					{	if (Station->CSEParsed)
						{	speed = Station->speed;
							course = Station->course;
							GotOne = TRUE;
							if (ActiveConfig.View.Speed.All && speed > 0)
							{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
											prcWin,
											Station, speed, course,
											cInfo->ts, DispHeading))
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckon";
//									Station->TInfo[tr].valid = FALSE;
								}
							}
						}

						if ((!GotOne || ActiveConfig.View.Speed.All)
						&& (ActiveConfig.View.Speed.Calculated /*&& !Station->Bad.msec*/))
						{	speed = Station->speedCalculated;
							course = Station->courseCalculated;
							GotOne = TRUE;
							if (ActiveConfig.View.Speed.All && speed > 0)
							{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
											prcWin,
											Station, speed, course,
											cInfo->ts, DispHeading))
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckon";
//									Station->TInfo[tr].valid = FALSE;
								}
							}
						}

						if ((!GotOne || ActiveConfig.View.Speed.All)
						&& (ActiveConfig.View.Speed.Averaged /*&& !Station->Bad.msec*/))
						{	speed = Station->speedAverage;
							course = Station->courseCalculated;
							GotOne = TRUE;
							if (ActiveConfig.View.Speed.All && speed > 0)
							{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
											prcWin,
											Station, speed, course,
											cInfo->ts, DispHeading))
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckon";
//									Station->TInfo[tr].valid = FALSE;
								}
							}
						}

						if (GotOne && !ActiveConfig.View.Speed.All && speed > 0)
						{	if (DeadReckon(Info, hwnd, hdc, hMemDC,
										prcWin,
										Station, speed, course,
										cInfo->ts, DispHeading))
								{	DeadReckonCount++;
									cInfo->Circle.InvalidReason = "DeadReckon";
//									Station->TInfo[tr].valid = FALSE;
								}
						}
					}
				}
			}
didDR = DeadReckonCount;
tDR = llMsecSince(tDR,llGetMsec());

/*
	Overlay the DF wedges and circles
*/
#if defined(SUPPORT_POLYGON_FILL)
			if (cInfo->Scale			/* Must have non-zero divisor */
			&& !(cInfo->Captured && cInfo->Dragging)	/* Not when panning */
			&& ActiveConfig.View.DF.Enabled
			&& DFCount)
			{	LONG cwidth = rcSmaller.right-rcSmaller.left;
				LONG cheight = rcSmaller.bottom-rcSmaller.top;
tDF = llGetMsec();
				for (s=0; s<CloseStationCount; s++)
				{	STATION_INFO_S *Station = pCloseStations[s];
					if ((Station->TInfo[tr].visible || Station->TInfo[tr].alwaysvisible)
					&& Station->TInfo[tr].ptvalid)	/* Must have point! */
					if ((Station->BRGNRQParsed		/* Got BRNNRQ? */
						&& Station->pBRGNRQ			/* Info in here */
						&& Station->pBRGNRQ->number	/* 0 number is meaningless */
						&& Station->pBRGNRQ->quality/* 0 quality is useless */
						&& Station->pBRGNRQ->range)	/* 0 range disappears */
					|| (Station->DFSParsed			/* Got DFS? */
						&& Station->pPHG			/* DFS info in here */
						&& Station->pPHG->range))	/* 0 range disappears */
					{
						if (!hdcAlpha	/* Did we build one yet? */
						&& ActiveConfig.View.DF.Opacity)	/* And need to? */
						{	hdcAlpha = CreateCompatibleDC(hdc);

							BITMAPINFO bmi = {0};        // bitmap header 

							bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
							bmi.bmiHeader.biWidth = alphaWidth;
							bmi.bmiHeader.biHeight = alphaHeight;
							bmi.bmiHeader.biPlanes = 1;
							bmi.bmiHeader.biBitCount = 32;         // four 8-bit components 
							bmi.bmiHeader.biCompression = BI_RGB;
							bmi.bmiHeader.biSizeImage = alphaWidth * alphaHeight * sizeof(UINT32);

							hbmpAlpha = CreateDIBSection(hdcAlpha, &bmi, DIB_RGB_COLORS, &pvBitsAlpha, NULL, 0x0);
							orgAlpha = SelectObject(hdcAlpha, hbmpAlpha);
							
#ifdef OLD_WAY
							for (y = 0; y < winHeight; y++)
								for (x = 0; x < winWidth; x++)
									((UINT32 *)pvBitsAlpha)[x + y * winWidth] = 0;	/* Empty */

#else
							memset(pvBitsAlpha, 0, bmi.bmiHeader.biSizeImage);
#endif
							SelectObject(hdcAlpha, GetStockObject(BLACK_PEN));
						}

						if (Station->BRGNRQParsed)
						{	COLORREF color = Station->isKilled?RGB(192,192,192):RGB(255,204,0);	/* orange */
							double Percent = Station->pBRGNRQ->range / cInfo->Scale;
							LONG rwidth = (LONG)(cwidth*Percent)/2;
							LONG rheight = (LONG)(cheight*Percent)/2;

				HPEN hpen3 = CreatePen(PS_SOLID, 1, color);
				HGDIOBJ hold3 = SelectObject(hdc, hpen3);
/*
Examples
=4903.50N/07201.75W\088/036/270/729 no timestamp, course/speed/bearing/NRQ, with APRS messaging.
										DF station moving (CSE is non-zero).
=4903.50N/07201.75W\000/036/270/729 Same report, DF station fixed (CSE=000).
*/
							{	long radius = (rwidth+rheight)/2;
								double bearing = Station->pBRGNRQ->bearing+(Station->CSEParsed?Station->course:0.0);
								double raddir = DegToRad(bearing);
								double cosa = cos(raddir);
								double sina = sin(raddir);
								POINT *p = (POINT*)malloc(sizeof(*p)*363);
								double a;
								double as = bearing-Station->pBRGNRQ->quality/2;
								double ae = bearing+Station->pBRGNRQ->quality/2;
								int i;

								p[0] = Station->pCoord->pt[tr];
								for (i=1, a=as; a<ae+12; i++, a+=12)
								{	if (a > ae) a = ae;
									double arad = DegToRad(a);
									p[i].x = (long) (Station->pCoord->pt[tr].x + radius*sin(arad));
									p[i].y = (long) (Station->pCoord->pt[tr].y - radius*cos(arad));
								}
								p[i++] = p[0];	/* Close the figure */
								if (hdcAlpha)
								{	HBRUSH hbr = CreateSolidBrush(color);
									HGDIOBJ hOld = SelectObject(hdcAlpha, hbr);
									Polygon(hdcAlpha, p, i);
									SelectObject(hdcAlpha, hOld);
									DeleteObject(hbr);
								}
								Polyline(hdc, p, i);
								free(p);
							}
				SelectObject(hdc, hold3);
				DeleteObject(hpen3);
							didDF++;
						} else if (Station->DFSParsed)
						{	COLORREF color = Station->isKilled?RGB(192,192,192):(Station->pPHG->sunits>0?RGB(204,153,0):RGB(64,64,64));
							double Percent = Station->pPHG->range / cInfo->Scale;
							LONG rwidth = (LONG)(cwidth*Percent)/2;
							LONG rheight = (LONG)(cheight*Percent)/2;

				HPEN hpen3 = CreatePen(PS_SOLID, 1, color);
				HGDIOBJ hold3 = SelectObject(hdc, hpen3);

							if (!Station->pPHG->dir)	/* Omni-Directional? */
							{
								if (hdcAlpha)
								{	HBRUSH hbr = CreateSolidBrush(color);
									HGDIOBJ hOld = SelectObject(hdcAlpha, hbr);
									Ellipse(hdcAlpha, 
											Station->pCoord->pt[tr].x-rwidth,
											Station->pCoord->pt[tr].y-rheight,
											Station->pCoord->pt[tr].x+rwidth,
											Station->pCoord->pt[tr].y+rheight);
									SelectObject(hdcAlpha, hOld);
									DeleteObject(hbr);
								}
								HBRUSH hbr4 = (HBRUSH) GetStockObject(NULL_BRUSH);
								HGDIOBJ hOld4 = SelectObject(hdc, hbr4);
								Ellipse(hdc, 
										Station->pCoord->pt[tr].x-rwidth,
										Station->pCoord->pt[tr].y-rheight,
										Station->pCoord->pt[tr].x+rwidth,
										Station->pCoord->pt[tr].y+rheight);
								SelectObject(hdc, hOld4);
/* Stocks don't delete */		//DeleteObject(hbr4);
							} else
							{	long radius = (rwidth+rheight)/2;
								double raddir = DegToRad(Station->pPHG->dir-90.0);
								double cosa = cos(raddir);
								double sina = sin(raddir);
								POINT *p = (POINT*)malloc(sizeof(*p)*361);
								double a;
								int i;
								for (i=0, a=0; a<360+12; i++, a+=12)
								{	double arad = DegToRad(a);
									double x = radius * cos(arad)
											+ radius/2 * cos(arad*2)
											+radius*0.15;	/* Offset a bit */
									double y = radius * sin(arad)
											+ radius/2 * sin(arad*2);
									p[i].x = (LONG) (Station->pCoord->pt[tr].x
										+ x*cosa + y*sina);
									p[i].y = (LONG) (Station->pCoord->pt[tr].y
										- y*cosa + x*sina);
								}
								p[i++] = p[0];	/* Close the figure */
								if (hdcAlpha)
								{	HBRUSH hbr = CreateSolidBrush(color);
									HGDIOBJ hOld = SelectObject(hdcAlpha, hbr);
									Polygon(hdcAlpha, p, i);
									SelectObject(hdcAlpha, hOld);
									DeleteObject(hbr);
								}
								Polyline(hdc, p, i);
								free(p);
							}
				SelectObject(hdc, hold3);
				DeleteObject(hpen3);
							didDF++;
						}


				if (hdcAlpha)	/* Got any AlphaBlend Overlays? */
				{	BLENDFUNCTION bf;      // structure for alpha blending 
					int   x,y;          // stepping variables 

					bf.BlendOp = AC_SRC_OVER;
					bf.BlendFlags = 0;
					bf.SourceConstantAlpha = (BYTE)(255*ActiveConfig.View.DF.Opacity/100);
					bf.AlphaFormat = 0;             // ignore source alpha channel 
					bf.AlphaFormat = AC_SRC_ALPHA;

#ifndef UNDER_CE
					GdiFlush();
#endif
#ifdef OLD_WAY
					for (y = 0; y < alphaHeight; y++)
					for (x = 0; x < alphaWidth; x++)
					if (((UINT32 *)pvBitsAlpha)[x + y * alphaWidth])	/* Painted? */
						((UINT32 *)pvBitsAlpha)[x + y * alphaWidth] |= 0xff000000;
#else
					register int bitCount=0;
					for (y = 0; y < alphaHeight; y++)
					{	UINT32 *pvRow = &((UINT32 *)pvBitsAlpha)[y*alphaWidth];
						for (x = 0; x < alphaWidth; x++)
							if (pvRow[x])	/* Painted? */
							{	pvRow[x] |= 0xff000000;
								bitCount++;
							}
						//bf.SourceConstantAlpha<<24;
					}
#endif

#ifndef NO_ALPHABLEND
					if (bitCount
					&& !AlphaBlend(hdc, 0, 0, alphaWidth, alphaHeight, 
									hdcAlpha, 0, 0, alphaWidth, alphaHeight, bf))
						TraceError(hwnd, "AlphaBlend Failed!\n");
#endif

					memset(pvBitsAlpha, 0, alphaHeight*alphaWidth*sizeof(UINT32));
	Start = DebugTimer("CirclePaint","AlphaBlendDFs",Start,&msMax,NULL,hwnd);
				}

					}
				}
				if (hdcAlpha)	/* Got any AlphaBlend Overlays? */
				{	SelectObject(hdcAlpha, orgAlpha);
					if (!DeleteObject(hbmpAlpha))
						TraceError(hwnd, "DeleteObject(hbmpAlpha) Failed With %ld", GetLastError());
					hbmpAlpha = NULL;	/* All gone */
					DeleteDC(hdcAlpha);
					hdcAlpha = NULL;	/* No longer have one */
	Start = DebugTimer("CirclePaint","AlphaBlendDFs",Start,&msMax,NULL,hwnd);
				}
tDF = llMsecSince(tDF,llGetMsec());
			}
#endif	/* defined(SUPPORT_POLYGON_FILL) */


/*
	Overlay the PHG/Range circles
*/
#if defined(SUPPORT_POLYGON_FILL)
			if (cInfo->Scale			/* Must have non-zero divisor */
			&& !(cInfo->Captured && cInfo->Dragging)	/* Not when panning */
			&& ActiveConfig.View.Range.Enabled
			&& PHGCount <= MAX_STATION_LABELS)
			{	LONG cwidth = rcSmaller.right-rcSmaller.left;
				LONG cheight = rcSmaller.bottom-rcSmaller.top;
tPHG = llGetMsec();
				for (s=0; s<CloseStationCount; s++)
				{	STATION_INFO_S *Station = pCloseStations[s];
					if (Station->TInfo[tr].visible
					&& ((Station->PHGParsed && Station->pPHG && Station->pPHG->range)
						|| (Station->Frequency && Station->Frequency->range)))
					{
						if (!hdcAlpha)	/* Did we build one yet? */
						{	hdcAlpha = CreateCompatibleDC(hdc);

							BITMAPINFO bmi = {0};        // bitmap header 

							bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
							bmi.bmiHeader.biWidth = alphaWidth;
							bmi.bmiHeader.biHeight = alphaHeight;
							bmi.bmiHeader.biPlanes = 1;
							bmi.bmiHeader.biBitCount = 32;         // four 8-bit components 
							bmi.bmiHeader.biCompression = BI_RGB;
							bmi.bmiHeader.biSizeImage = alphaWidth * alphaHeight * sizeof(UINT32);

							hbmpAlpha = CreateDIBSection(hdcAlpha, &bmi, DIB_RGB_COLORS, &pvBitsAlpha, NULL, 0x0);
							orgAlpha = SelectObject(hdcAlpha, hbmpAlpha);

							memset(pvBitsAlpha, 0, bmi.bmiHeader.biSizeImage);
							SelectObject(hdcAlpha, GetStockObject(BLACK_PEN));
						}

						if (Station->PHGParsed && Station->pPHG && Station->pPHG->range)
						{	COLORREF color = Station->isKilled?RGB(192,192,192):ActiveConfig.View.Range.Half?RGB(240,0,0):RGB(0,240,0);
							HBRUSH hbr = CreateSolidBrush(color);	/* Gray or Green */
							HGDIOBJ hOld = SelectObject(hdcAlpha, hbr);
							double Percent = Station->pPHG->range / cInfo->Scale;
							if (ActiveConfig.View.Range.Half) Percent /= 2;
							LONG rwidth = (LONG)(cwidth*Percent)/2;
							LONG rheight = (LONG)(cheight*Percent)/2;

				HPEN hpen3 = CreatePen(PS_SOLID, 1, color);
				HGDIOBJ hold3 = SelectObject(hdc, hpen3);

							if (!Station->pPHG->dir)	/* Omni-Directional? */
							{	Ellipse(hdcAlpha, 
										Station->pCoord->pt[tr].x-rwidth,
										Station->pCoord->pt[tr].y-rheight,
										Station->pCoord->pt[tr].x+rwidth,
										Station->pCoord->pt[tr].y+rheight);
								HBRUSH hbr4 = (HBRUSH) GetStockObject(NULL_BRUSH);
								HGDIOBJ hOld4 = SelectObject(hdc, hbr4);
								Ellipse(hdc, 
										Station->pCoord->pt[tr].x-rwidth,
										Station->pCoord->pt[tr].y-rheight,
										Station->pCoord->pt[tr].x+rwidth,
										Station->pCoord->pt[tr].y+rheight);
								SelectObject(hdc, hOld4);
/* Stocks don't delete */		//DeleteObject(hbr4);
							} else
							{	long radius = (rwidth+rheight)/2;
								double raddir = DegToRad(Station->pPHG->dir-90.0);
								double cosa = cos(raddir);
								double sina = sin(raddir);
								POINT *p = (POINT*)malloc(sizeof(*p)*361);
								double a;
								int i;
								for (i=0, a=0; a<360+12; i++, a+=12)
								{	double arad = DegToRad(a);
									double x = radius * cos(arad)
											+ radius/2 * cos(arad*2)
											+radius*0.15;	/* Offset a bit */
									double y = radius * sin(arad)
											+ radius/2 * sin(arad*2);
									p[i].x = (LONG) (Station->pCoord->pt[tr].x
										+ x*cosa + y*sina);
									p[i].y = (LONG) (Station->pCoord->pt[tr].y
										- y*cosa + x*sina);
								}
								p[i++] = p[0];	/* Close the figure */
								Polygon(hdcAlpha, p, i);
								Polyline(hdc, p, i);
								free(p);
							}
				SelectObject(hdc, hold3);
				DeleteObject(hpen3);
							SelectObject(hdcAlpha, hOld);
							DeleteObject(hbr);
							didPHG++;
						}

						if (Station->Frequency && Station->Frequency->range)
						{	COLORREF color = Station->isKilled?RGB(192,192,192):RGB(128,128,240);
							HBRUSH hbr = CreateSolidBrush(color);	/* Gray or Blue */
							HGDIOBJ hOld = SelectObject(hdcAlpha, hbr);
							double Percent = Station->Frequency->range / cInfo->Scale;
							LONG rwidth = (LONG)(cwidth*Percent)/2;
							LONG rheight = (LONG)(cheight*Percent)/2;

				HPEN hpen3 = CreatePen(PS_SOLID, 1, color);
				HGDIOBJ hold3 = SelectObject(hdc, hpen3);

							{	Ellipse(hdcAlpha, 
										Station->pCoord->pt[tr].x-rwidth,
										Station->pCoord->pt[tr].y-rheight,
										Station->pCoord->pt[tr].x+rwidth,
										Station->pCoord->pt[tr].y+rheight);
								HBRUSH hbr4 = (HBRUSH) GetStockObject(NULL_BRUSH);
								HGDIOBJ hOld4 = SelectObject(hdc, hbr4);
								Ellipse(hdc, 
										Station->pCoord->pt[tr].x-rwidth,
										Station->pCoord->pt[tr].y-rheight,
										Station->pCoord->pt[tr].x+rwidth,
										Station->pCoord->pt[tr].y+rheight);
								SelectObject(hdc, hOld4);
/* Stocks don't delete */		//DeleteObject(hbr4);
							}
				SelectObject(hdc, hold3);
				DeleteObject(hpen3);
							SelectObject(hdcAlpha, hOld);
							DeleteObject(hbr);
						}
					}
				}
				if (hdcAlpha)	/* Got any AlphaBlend Overlays? */
				{	BLENDFUNCTION bf;      // structure for alpha blending 
					int   x,y;          // stepping variables 

					bf.BlendOp = AC_SRC_OVER;
					bf.BlendFlags = 0;
					bf.SourceConstantAlpha = (BYTE)(255*ActiveConfig.View.Range.Opacity/100);
					bf.AlphaFormat = 0;             // ignore source alpha channel 
					bf.AlphaFormat = AC_SRC_ALPHA;

#ifndef UNDER_CE
					GdiFlush();
#endif
#ifdef OLD_WAY
					for (y = 0; y < alphaHeight; y++)
					for (x = 0; x < alphaWidth; x++)
					if (((UINT32 *)pvBitsAlpha)[x + y * alphaWidth])	/* Painted? */
						((UINT32 *)pvBitsAlpha)[x + y * alphaWidth] |= 0xff000000;
#else
					register int bitCount=0;
					for (y = 0; y < alphaHeight; y++)
					{	UINT32 *pvRow = &((UINT32 *)pvBitsAlpha)[y*alphaWidth];
						for (x = 0; x < alphaWidth; x++)
							if (pvRow[x])	/* Painted? */
							{	pvRow[x] |= 0xff000000;
								bitCount++;
							}
						//bf.SourceConstantAlpha<<24;
					}
#endif
#ifndef NO_ALPHABLEND
					if (bitCount
					&& !AlphaBlend(hdc, 0, 0, alphaWidth, alphaHeight, 
									hdcAlpha, 0, 0, alphaWidth, alphaHeight, bf))
						TraceError(hwnd, "AlphaBlend Failed!\n");
#endif
					SelectObject(hdcAlpha, orgAlpha);
					if (!DeleteObject(hbmpAlpha))
						TraceError(hwnd, "DeleteObject(hbmpAlpha) Failed With %ld", GetLastError());
					hbmpAlpha = NULL;	/* All gone */
					DeleteDC(hdcAlpha);
					hdcAlpha = NULL;	/* No longer have one */
	Start = DebugTimer("CirclePaint","AlphaBlendPHGs",Start,&msMax,NULL,hwnd);
				}
tPHG = llMsecSince(tPHG,llGetMsec());
			}
#endif	/* defined(SUPPORT_POLYGON_FILL) */

/*
	Do the paths onto an alpha-blended overlay
*/
			cInfo->Circle.msPathExpire = -1;	/* No path expirations to force paint */
#ifndef NO_PATH_TRACKING
			if (cInfo->Paths.Network)
			{	__int64 msNow = llGetMsec();
				__int64 msEldest = 0;
				unsigned long PathCount = 0;
				long MaxMiles = (long) (cInfo->Paths.ReasonabilityLimit/(ActiveConfig.View.Metric.Distance?KmPerMile:1.0));

				for (s=0; s<CloseStationCount; s++)
				if (pCloseStations[s]->TInfo[tr].visible
				&& (s || cInfo->viewBits || cInfo->CenterStation == MyStation))
				{	STATION_INFO_S *Station = pCloseStations[s];

					if (Station->PathCount)
					{
#ifdef NO_ALPHABLEND
#define hdcAlpha hdc
#else
						if (!hdcAlpha)	/* Did we build one yet? */
						{	hdcAlpha = CreateCompatibleDC(hdc);
							BITMAPINFO bmi = {0};        // bitmap header 
							bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
							bmi.bmiHeader.biWidth = alphaWidth;
							bmi.bmiHeader.biHeight = alphaHeight;
							bmi.bmiHeader.biPlanes = 1;
							bmi.bmiHeader.biBitCount = 32;         // four 8-bit components 
							bmi.bmiHeader.biCompression = BI_RGB;
							bmi.bmiHeader.biSizeImage = alphaWidth * alphaHeight * sizeof(UINT32);
							hbmpAlpha = CreateDIBSection(hdcAlpha, &bmi, DIB_RGB_COLORS, &pvBitsAlpha, NULL, 0x0);
							orgAlpha = SelectObject(hdcAlpha, hbmpAlpha);
							memset(pvBitsAlpha, 0, bmi.bmiHeader.biSizeImage);
							SelectObject(hdcAlpha, GetStockObject(BLACK_PEN));
						}
#endif
						__int64 msThis = DrawPath(Info, hwnd, hdcAlpha, hMemDC, prcWin, Station,
								cInfo->ts, DispHeading, MaxMiles, msNow, LabelNeeded);
						if (!msEldest || msThis < msEldest) msEldest = msThis;
						PathCount++;
					}
				}
				if (msEldest && cInfo->Paths.MaxAge != 0 && cInfo->Paths.MaxAge != -1)	/* Not ALL or Last */
				{	cInfo->Circle.msPathExpire = cInfo->Paths.MaxAge*1000 - (msNow-msEldest);
//TraceLog("PathExpire", FALSE, hwnd, "[%ld]Drew %ld Paths, Next PathExpire in %ldsec (of %ldsec)\n",
//		 (long) cInfo->Index, (long) PathCount, (long) (cInfo->Circle.msPathExpire/1000), (long) cInfo->Paths.MaxAge);
				}
#ifdef NO_ALPHABLEND
#undef hdcAlpha
#else
				if (hdcAlpha)	/* Got any AlphaBlend Overlays? */
				{	BLENDFUNCTION bf;      // structure for alpha blending 
					int   x,y;          // stepping variables 
					bf.BlendOp = AC_SRC_OVER;
					bf.BlendFlags = 0;
					bf.SourceConstantAlpha = (BYTE)(255*cInfo->Paths.Opacity/100);
					bf.AlphaFormat = 0;             // ignore source alpha channel 
					bf.AlphaFormat = AC_SRC_ALPHA;
#ifndef UNDER_CE
					GdiFlush();
#endif
					register int bitCount=0;
					for (y = 0; y < alphaHeight; y++)
					{	UINT32 *pvRow = &((UINT32 *)pvBitsAlpha)[y*alphaWidth];
						for (x = 0; x < alphaWidth; x++)
							if (pvRow[x])	/* Painted? */
							{	pvRow[x] |= 0xff000000;
								bitCount++;
							}
						//bf.SourceConstantAlpha<<24;
					}
					if (bitCount
					&& !AlphaBlend(hdc, 0, 0, alphaWidth, alphaHeight, 
									hdcAlpha, 0, 0, alphaWidth, alphaHeight, bf))
						TraceError(hwnd, "AlphaBlend Failed!\n");
					SelectObject(hdcAlpha, orgAlpha);
					if (!DeleteObject(hbmpAlpha))
						TraceError(hwnd, "DeleteObject(hbmpAlpha) Failed With %ld", GetLastError());
					hbmpAlpha = NULL;	/* All gone */
					DeleteDC(hdcAlpha);
					hdcAlpha = NULL;	/* No longer have one */
				}
#endif
{	char Temp[80];
sprintf(Temp,"Paths:%ld",(long)PathCount);
Start = DebugTimer("CirclePaint",Temp,Start,&msMax,NULL,hwnd);
}
			}

/*
	But the centered station's packet gets full color
*/
			if (cInfo->CenterStation && cInfo->Paths.Station
			&& (!cInfo->Paths.MyStation || cInfo->CenterStation != MyStation))	/* Not both */
			{	__int64 msNow = llGetMsec();
				long MaxMiles = (long) (cInfo->Paths.ReasonabilityLimit/(ActiveConfig.View.Metric.Distance?KmPerMile:1.0));
				DrawPacketPath(Info, hwnd, hdc, hMemDC, prcWin, cInfo->CenterStation,
								cInfo->ts, DispHeading, MaxMiles, msNow, LabelNeeded);
			}
			if (MyStation && cInfo->Paths.MyStation)
			{	__int64 msNow = llGetMsec();
				long MaxMiles = (long) (cInfo->Paths.ReasonabilityLimit/(ActiveConfig.View.Metric.Distance?KmPerMile:1.0));
				DrawPacketPath(Info, hwnd, hdc, hMemDC, prcWin, MyStation,
								cInfo->ts, DispHeading, MaxMiles, msNow, LabelNeeded);
			}
#endif

/*
	Now get a bunch of labels out there
*/
			if (MyStation)
			{	cInfo->AutoZoomME = (cInfo->CenterStation==MyStation) || LabelNeeded[MyStation->SeenIndex];
			}

			if (VisibleCount
			&& (ActiveConfig.View.Callsign
				|| ActiveConfig.View.Altitude
#ifdef MONITOR_PHONE
				|| ActiveConfig.View.Cellular
#endif
				|| ActiveConfig.View.LabelWeather))
			{	if (VisibleCount <= MAX_STATION_LABELS || SymbolHeight >= TextHeight)
				{	int prevBkMode = SetBkMode(hdc, TRANSPARENT);
					size_t BufSize = sizeof(TCHAR)*128;
					TCHAR *Buffer=(TCHAR*)malloc(BufSize);
					if (VisibleCount)
					{	BOOL NeedFont = (SymbolHeight < TextHeight);
						HFONT hOld = (HFONT) 0;

						for (s=0; s<CloseStationCount; s++)
						if (pCloseStations[s]->TInfo[tr].visible
						|| LabelNeeded[pCloseStations[s]->SeenIndex])
						{	STATION_INFO_S *Station = pCloseStations[s];
							size_t Remaining = BufSize;
							TCHAR *Next = Buffer;
							long LinesOfText;
							int LocalHeight;
							RECT rcTest, rcText, rcStat;

							if (!pCloseStations[s]->TInfo[tr].visible)	/* Must be LabelNeeded[] */
							{	POINT pt;	/* Need to establish screen rectangle */
								GetScreenPoint(cInfo, prcWin, DispHeading, Station->pCoord->lat, Station->pCoord->lon, &pt, TRUE);
								ScaleSymbol2(hwnd, hdc, hMemDC,
												prcWin,
												GetStationSymbol(Station),
												pt.x, pt.y, cInfo->Scale,
												50, &Station->TInfo[tr].rcSym);
								Station->TInfo[tr].rcsymvalid = TRUE;
								Station->TInfo[tr].viewed = TRUE;
								Station->TInfo[tr].ptvalid = TRUE;
								Station->pCoord->pt[tr] = pt;
								Station->TInfo[tr].inCircle = PtInRect(prcWin,pt);
								{	HRGN rgnSymbol = CreateRectRgnIndirect(&Station->TInfo[tr].rcSym);
									CombineRgn(rgnLabels, rgnLabels, rgnSymbol, RGN_OR);
									DeleteObject(rgnSymbol);
								}
								if (cInfo->AutoZoomViewOut
								&& Station->TInfo[tr].inCircle)
								{	RECT rcTemp;
									if (!IntersectRect(&rcTemp, &Station->TInfo[tr].rcSym, prcWin)
									|| !EqualRect(&rcTemp, &Station->TInfo[tr].rcSym))
									{	Station->TInfo[tr].inCircle = FALSE;
										TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Labeled Station %s Symbol NOT Fully InCircle\n",
												cInfo->Index, Station->Station);
									}
								}
							} else if (Station == MyStation && LabelNeeded[pCloseStations[s]->SeenIndex])
								Station->TInfo[cInfo->Index].viewed = TRUE;
							rcStat = Station->TInfo[tr].rcSym;

							if (NeedFont)
							{	HFONT hFont = LoadPaintFont(TEXT(""), max(10,SymbolHeight), FALSE);	/* 10 is as small as we go */
								if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
								NeedFont = FALSE;
							}

							LinesOfText = 0;
							if (ActiveConfig.View.Callsign
							&& (ActiveConfig.View.LabelNWS || !pCloseStations[s]->isNWS))
							{	if (s)	/* Not ME */
								{	if (!ActiveConfig.View.CallsignNotMine
									|| Station == cInfo->CenterStation
									|| !Station->isMine)
									{	BOOL DidSign = FALSE;
										if (Station->isSignpost && Station->sComment)
										{	TCHAR *o = wcschr(Station->pComment,TEXT('{'));
											if (o)
											{	TCHAR *c = wcschr(o+1,TEXT('}'));
												if (c)
												{	DidSign = TRUE;
													StringCbPrintfEx(Next, Remaining,
																	&Next, &Remaining,
																	STRSAFE_IGNORE_NULLS,
																	TEXT("%.*s"),
																	(int)(c-o+1), o);
													LinesOfText++;
												}
											}
										}
										if (!DidSign)
										{	if (!HasNickLabel(Station)
											|| *Station->Nickname->Label)
											{	StringCbPrintfEx(Next, Remaining,
															&Next, &Remaining,
															STRSAFE_IGNORE_NULLS,
															TEXT("%S"),
															HasNickLabel(Station)?Station->Nickname->Label:Station->
Station);
												LinesOfText++;
											}
										}
									}
								} else if (!ActiveConfig.View.CallsignNotMe)
								{	if (!HasNickLabel(Station)
									|| *Station->Nickname->Label)
									{	StringCbPrintfEx(Next, Remaining,
													&Next, &Remaining,
													STRSAFE_IGNORE_NULLS,
													TEXT("%S"),
													HasNickLabel(Station)?Station->Nickname->Label:"ME");
										LinesOfText++;
									}
								}
							}

#ifdef MONITOR_PHONE
							if (!s && ActiveConfig.View.Cellular)
							{	if (LinesOfText)
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%s %ld%%"), szOldOperatorName, (long) dwOldSignalStrength);
								LinesOfText++;
							}
#endif
							if (Station != MyStation)	/* Don't speed-label ME */
							if (ActiveConfig.View.Altitude && Station->alt > 0)	/* Got an altitude? */
							{	if (LinesOfText)
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
								if (ActiveConfig.View.Metric.Altitude)
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldm"), (long) (Station->alt));
								else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldft"), (long) (Station->alt*FeetPerMeter));

								if (ActiveConfig.View.Footprint.Enabled
								&& !Station->PHGParsed
								&& !Station->BRGNRQParsed
								&& !Station->DFSParsed
								&& Station->alt*FeetPerMeter >= ActiveConfig.View.Footprint.MinAltitude
								&& Station->alt*FeetPerMeter <= ActiveConfig.View.Footprint.MaxAltitude)
								{	if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("~%.0lfkm"),
													Station->pPHG->range*KmPerMile);
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("~%.0lfmi"),
													Station->pPHG->range);
								}
								LinesOfText++;
							}

							if (ActiveConfig.View.LabelWeather
							&& Station->Weather
							&& Station->WeatherParsed
							&& (Station->Weather->Valid & (VALID_WX_TEMPERATURE
														| VALID_WX_WINDSPEED)))
							{	if (LinesOfText)
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
								if (Station->Weather->Valid & VALID_WX_TEMPERATURE)
								{
									if (ActiveConfig.View.Metric.Temperature)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldC"),
													(long) (5.0/9.0*(Station->Weather->temperature-32)));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldF"),
													(long) Station->Weather->temperature);
								}

								if (Station->Weather->Valid & VALID_WX_WINDSPEED)
								{	if (ActiveConfig.View.Metric.Windspeed)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" %ldkn %s"),
												(long) (Station->Weather->windspeed), GetCompassPoint(Station->Weather->direction));
									else if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" %ldkm/h %s"),
												(long) (Station->Weather->windspeed * MilePerNM *KmPerMile + 0.5), GetCompassPoint(Station->Weather->direction));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" %ldmph %s"),
												(long) (Station->Weather->windspeed * MilePerNM + 0.5), GetCompassPoint(Station->Weather->direction));
								}
								LinesOfText++;
							}

							if (ActiveConfig.View.LabelWeather
							&& Station->Storm
							&& (Station->Storm->valid & (VALID_STORM_WINDSPEED
														|VALID_STORM_GUST)))
							{	if (LinesOfText)
									StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
								if (Station->Storm->valid & VALID_STORM_WINDSPEED)
								{	if (ActiveConfig.View.Metric.Windspeed)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%ldkn"),
												(long) (Station->Storm->windspeed));
									else if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%ldkm/h"),
												(long) (Station->Storm->windspeed * MilePerNM *KmPerMile + 0.5));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT("%ldmph"),
												(long) (Station->Storm->windspeed * MilePerNM + 0.5));
								}
								if (Station->Storm->valid & VALID_STORM_GUST)
								{	if (ActiveConfig.View.Metric.Windspeed)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" Gust:%ld"),
												(long) (Station->Storm->gust));
									else if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" Gust:%ld"),
												(long) (Station->Storm->gust * MilePerNM *KmPerMile + 0.5));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
												TEXT(" Gust:%ld"),
												(long) (Station->Storm->gust * MilePerNM + 0.5));
								}
								LinesOfText++;
							}

							if (Station != MyStation)	/* Don't speed-label ME */
							{	BOOL DidOne = FALSE;

								if (ActiveConfig.View.Speed.Beaconed && Station->CSEParsed)
								{	DidOne = TRUE;
									if (LinesOfText)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
									if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldkm/h %s"),
													(long) (Station->speed * MilePerNM *KmPerMile + 0.5), GetCompassPoint(Station->course));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldmph %s"),
													(long) (Station->speed * MilePerNM + 0.5), GetCompassPoint(Station->course));
									LinesOfText++;
								}

								if ((!DidOne || ActiveConfig.View.Speed.All)
								&& (ActiveConfig.View.Speed.Calculated && Station->speedCalculated > 1))
								{	DidOne = TRUE;
									if (LinesOfText)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
									if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldkm/h %s"),
													(long) (Station->speedCalculated*KmPerMile+0.5),
													GetCompassPoint((int) Station->courseCalculated));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldmph %s"),
													(long) (Station->speedCalculated+0.5),
													GetCompassPoint((int) Station->courseCalculated));
									LinesOfText++;
								}

								if ((!DidOne || ActiveConfig.View.Speed.All)
								&& (ActiveConfig.View.Speed.Averaged && Station->speedAverage > 1))
								{	DidOne = TRUE;
									if (LinesOfText)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
									if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldkm/h %s"),
													(long) (Station->speedAverage*KmPerMile+0.5),
													GetCompassPoint((int) Station->courseCalculated));
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("%ldmph %s"),
													(long) (Station->speedAverage+0.5),
													GetCompassPoint((int) Station->courseCalculated));
									LinesOfText++;
								}
							}

							if (LinesOfText)
							{	UINT Align = DT_NOPREFIX | DT_LEFT;
								SetRect(&rcText, rcStat.right, rcStat.top, Info->Tracker[tr].rc.right, rcStat.bottom);
								LocalHeight = DrawText(hdc, Buffer, -1, &rcText, Align | DT_CALCRECT);

								if ((Station->TInfo[tr].rcSym.bottom-Station->TInfo[tr].rcSym.top) >= LocalHeight)
								{	rcText.top = rcStat.top; rcText.bottom = rcStat.bottom;
								} else
								{	rcStat.top = rcText.top; rcStat.bottom = rcText.bottom;
								}

								rcTest = rcText;	/* Start where we want */
								if (!ActiveConfig.View.LabelOverlap)
								if (RectInRegion(rgnLabels, &rcTest))	/* Preferred (right center) any good? */
								{	SetRect(&rcTest, rcStat.left-(rcText.right-rcText.left), rcStat.top,
													rcStat.left, rcStat.bottom);
									Align = DT_NOPREFIX | DT_RIGHT;
									if (RectInRegion(rgnLabels, &rcTest))	/* left center is crowded */
									{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4,
														rcStat.bottom,
														(rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4+(rcText.right-rcText.left),
														rcStat.bottom+LocalHeight);
										Align = DT_NOPREFIX | DT_LEFT;
										if (RectInRegion(rgnLabels, &rcTest))	/* bottom right is crowded */
										{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4, rcStat.top-LocalHeight,
														(rcStat.right+rcStat.left)/2+(rcStat.right-rcStat.left)/4+(rcText.right-rcText.left),
														rcStat.top);
											Align = DT_NOPREFIX | DT_LEFT;
											if (RectInRegion(rgnLabels, &rcTest))	/* top right is crowded */
											{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4-(rcText.right-rcText.left),
																	rcStat.bottom, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4,
																	rcStat.bottom+LocalHeight);
												Align = DT_NOPREFIX | DT_RIGHT;
												if (RectInRegion(rgnLabels, &rcTest))	/* bottom left is crowded */
												{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4-(rcText.right-rcText.left),
																	rcStat.top-LocalHeight, (rcStat.right+rcStat.left)/2-(rcStat.right-rcStat.left)/4,
																	rcStat.top);
													Align = DT_NOPREFIX | DT_RIGHT;
													if (RectInRegion(rgnLabels, &rcTest))	/* top left is crowded */
													{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcText.right-rcText.left)/2,
																		rcStat.bottom+LocalHeight,
																		(rcStat.right+rcStat.left)/2+(rcText.right-rcText.left)/2,
																		rcStat.bottom+LocalHeight*2);
														Align = DT_NOPREFIX | DT_CENTER;
														if (RectInRegion(rgnLabels, &rcTest))	/* 2*bottom center is crowded */
														{	SetRect(&rcTest, (rcStat.right+rcStat.left)/2-(rcText.right-rcText.left)/2,
																			rcStat.top-LocalHeight*2,
																			(rcStat.right+rcStat.left)/2+(rcText.right-rcText.left)/2,
																			rcStat.top-LocalHeight);
															Align = DT_NOPREFIX | DT_CENTER;
															if (RectInRegion(rgnLabels, &rcTest))	/* 2*top center is crowded, Give up and stack it! */
															{	rcTest = rcText;
																Align = DT_NOPREFIX | DT_LEFT;
															}
														}
													}
												}
											}
										}
									}
								}

								int tHeight = DrawText(hdc, Buffer, -1, &rcTest, Align | DT_NOPREFIX);
								rcTest.bottom = rcTest.top + tHeight;

								if (!ActiveConfig.View.LabelOverlap
								|| (ActiveConfig.Screen.Show.Tracks
									&& ActiveConfig.View.Altitude
									&& Station == cInfo->CenterStation
									&& Station->hadAltitude	/* If we've had an altitude */
									&& Station->TrackCount > 1))	/* Avoid altitude overlap regardless */
								{	HRGN rgnLabel = CreateRectRgnIndirect(&rcTest);
									CombineRgn(rgnLabels, rgnLabels, rgnLabel, RGN_OR);
									DeleteObject(rgnLabel);
								}

								Station->TInfo[tr].rclblvalid = TRUE;	/* And labelled */
								Station->TInfo[tr].rcLbl = rcTest;	/* And clickable label */
								if (cInfo->AutoZoomViewOut
								&& Station->TInfo[tr].inCircle)
								{	RECT rcTemp;
									if (!IntersectRect(&rcTemp, &rcTest, prcWin)
									|| !EqualRect(&rcTemp, &rcTest))
									{	Station->TInfo[tr].inCircle = FALSE;
										TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Station %s Label NOT InCircle\n",
												cInfo->Index, Station->Station);
									}
								}
							}
						}
						if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
					}
/*
	Add the altitude to the track
*/
					if (ActiveConfig.Screen.Show.Tracks)
					if (ActiveConfig.View.Altitude)
					if (cInfo->CenterStation
					&& cInfo->CenterStation->hadAltitude	/* If we've had an altitude */
					&& cInfo->CenterStation->TrackCount > 1)
					{	STATION_INFO_S *Station = cInfo->CenterStation;
						int wOffset = (SymbolHeight)/4;
						int hOffset = (SymbolHeight)/4;

						int width = (Info->Tracker[tr].rc.right-Info->Tracker[tr].rc.left);
						int height = (Info->Tracker[tr].rc.bottom-Info->Tracker[tr].rc.top);
						double xOffset = 0.5 + width/2 + Info->Tracker[tr].rc.left, xMult = width/2.0 / cInfo->Scale;
						double yOffset = 0.5 + height/2 + Info->Tracker[tr].rc.top, yMult = height/2.0 / cInfo->Scale;

						HFONT hOld = (HFONT) 0;

						if (SymbolHeight < TextHeight)
						{	HFONT hFont = LoadPaintFont(TEXT(""), max(8,SymbolHeight), FALSE);	/* 8 is as small as we go */
							if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
						}

						for (int t=Station->TrackCount-2; t>=0; t--)
						if (!Station->Tracks[t].Invalid)
						if (Station->Tracks[t].alt > 0)	/* Skip negatives */
						if (Station->Tracks[t].pCoord->lat || Station->Tracks[t].pCoord->lon)
						{	POINT p = {0};

							GetScreenPoint(cInfo, prcWin, DispHeading, Station->Tracks[t].pCoord->lat, Station->Tracks[t].pCoord->lon, &p, TRUE /*FALSE*/);
							if (PtInRect(prcWin, p))
							if (!Station->TInfo[tr].rcsymvalid
							|| !PtInRect(&Station->TInfo[tr].rcSym, p))
							{	size_t Remaining = BufSize;
								TCHAR *Next = Buffer;
								RECT rcTest, rcText/*, rcStat = cInfo->CenterStation->TInfo[tr].rc*/;

								if (ActiveConfig.View.Metric.Altitude)
									StringCbPrintfEx(Next, Remaining,
													&Next, &Remaining,
													STRSAFE_IGNORE_NULLS,
													TEXT("%ld"), (long) (Station->Tracks[t].alt/FeetPerMeter));
								else StringCbPrintfEx(Next, Remaining,
													&Next, &Remaining,
													STRSAFE_IGNORE_NULLS,
													TEXT("%ld"), (long) Station->Tracks[t].alt);
								if (ActiveConfig.View.Footprint.Enabled
								&& Station->Tracks[t].alt > 0
								&& Station->Tracks[t].alt >= (long) ActiveConfig.View.Footprint.MinAltitude
								&& Station->Tracks[t].alt <= (long) ActiveConfig.View.Footprint.MaxAltitude)
								{	double Range = 1.23*sqrt((double)Station->Tracks[t].alt);
									if (ActiveConfig.View.Metric.Distance)
										StringCbPrintfEx(Next, Remaining,
														&Next, &Remaining,
														STRSAFE_IGNORE_NULLS,
													TEXT("\n~%.0lf"),
													Range*KmPerMile);
									else StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
													TEXT("\n~%.0lf"),
													Range);
								}
								rcText = Info->Tracker[tr].rc;
								TextHeight = DrawText(hdc, Buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_CALCRECT);

								OffsetRect(&rcText, p.x-rcText.left+wOffset, p.y-rcText.top-TextHeight/2);	/* right of dot */
								rcTest = rcText;

	#ifdef FUTURE
								if (Station->Tracks[t].bearing >= 0 && Station->Tracks[t].bearing <= 45)	/* N to NE */
								{
								} else if (Station->Tracks[t].bearing >= 45 && Station->Tracks[t].bearing <= 90)	/* NE to E */
								{
								} else if (Station->Tracks[t].bearing >= 90 && Station->Tracks[t].bearing <= 135)	/* E to SE */
								{
								} else if (Station->Tracks[t].bearing >= 135 && Station->Tracks[t].bearing <= 180)	/* SE to S */
								{
								} else if (Station->Tracks[t].bearing >= 180 && Station->Tracks[t].bearing <= 225)	/* S to SW */
								{
								} else if (Station->Tracks[t].bearing >= 225 && Station->Tracks[t].bearing <= 270)	/* SW to W */
								{
								} else if (Station->Tracks[t].bearing >= 270 && Station->Tracks[t].bearing <= 315)	/* W to NW */
								{
								} else if (Station->Tracks[t].bearing >= 315 && Station->Tracks[t].bearing <= 360)	/* NW to N */
								{
								}
	#endif

								rcTest = rcText;	/* Start over with right of dot */
								if (RectInRegion(rgnLabels, &rcTest))
								{	OffsetRect(&rcTest, -((rcText.right-rcText.left)+wOffset*2), 0);
									if (RectInRegion(rgnLabels, &rcTest))
									{	OffsetRect(&rcTest, (rcText.right-rcText.left)/2+wOffset, -TextHeight/2);
										if (RectInRegion(rgnLabels, &rcTest))
										{	OffsetRect(&rcTest, 0, TextHeight);
										}
									}
								}

								if (!IsRectEmpty(&rcTest) && !RectInRegion(rgnLabels, &rcTest))
								{	int tHeight = DrawText(hdc, Buffer, -1, &rcTest, DT_NOPREFIX | DT_LEFT | DT_NOPREFIX);
									int rcHeight = rcTest.bottom-rcTest.top;

									if (tHeight != rcHeight)
									{	InflateRect(&rcTest, 0, (tHeight-rcHeight)/2);
									}
									{	HRGN rgnLabel = CreateRectRgnIndirect(&rcTest);
										CombineRgn(rgnLabels, rgnLabels, rgnLabel, RGN_OR);
										DeleteObject(rgnLabel);
									}
								}
							}
						}
						if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
					}

/*
	Add the cellular to the track
*/
#ifdef MONITOR_PHONE
					if (ActiveConfig.View.Cellular && CellularCount > 1)
					{	int wOffset = (SymbolHeight)/4;
						int hOffset = (SymbolHeight)/4;

						int width = (Info->Tracker[tr].rc.right-Info->Tracker[tr].rc.left);
						int height = (Info->Tracker[tr].rc.bottom-Info->Tracker[tr].rc.top);
						double xOffset = 0.5 + width/2 + Info->Tracker[tr].rc.left, xMult = width/2.0 / cInfo->Scale;
						double yOffset = 0.5 + height/2 + Info->Tracker[tr].rc.top, yMult = height/2.0 / cInfo->Scale;

						HFONT hOld = (HFONT) 0;

						POINT *Points = (POINT*)malloc(sizeof(*Points)*(CellularCount+1));
						int p = 0;

						if (SymbolHeight < TextHeight)
						{	HFONT hFont = LoadPaintFont(TEXT(""), max(8,SymbolHeight), FALSE);	/* 8 is as small as we go */
							if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
						}

						for (int c=CellularCount-1; c>=0; c--)
						if (Cellulars[c].pCoord->lat || Cellulars[c].pCoord->lon)
						{
							GetScreenPoint(cInfo, prcWin, DispHeading, Cellulars[c].pCoord->lat, Cellulars[c].pCoord->lon, &Points[p], FALSE);

							if (PtInRect(prcWin, Points[p]))
							if (!MyStation->TInfo[tr].rcsymvalid
							|| !PtInRect(&MyStation->TInfo[tr].rcSym, Points[p]))
							{
								RECT rcTest, rcText, rcStat = cInfo->CenterStation->TInfo[tr].rcSym;

								if (Cellulars[c].bFreeName)
									StringCbPrintf(Buffer, BufSize, TEXT("%s %ld%%"),
													Cellulars[c].szOperatorName, (long) Cellulars[c].dwSignalStrength);
								else StringCbPrintf(Buffer, BufSize, TEXT("%ld%%"),
													(long) Cellulars[c].dwSignalStrength);

								rcText = Info->Tracker[tr].rc;
								TextHeight = DrawText(hdc, Buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_CALCRECT);

								OffsetRect(&rcText, Points[p].x-rcText.left+wOffset, Points[p].y-rcText.top-TextHeight/2);	/* right of dot */
								rcTest = rcText;

								rcTest = rcText;	/* Start over with right of dot */
								if (RectInRegion(rgnLabels, &rcTest))
								{	OffsetRect(&rcTest, -((rcText.right-rcText.left)+wOffset*2), 0);
									if (RectInRegion(rgnLabels, &rcTest))
									{	OffsetRect(&rcTest, (rcText.right-rcText.left)/2+wOffset, -TextHeight/2);
										if (RectInRegion(rgnLabels, &rcTest))
										{	OffsetRect(&rcTest, 0, TextHeight);
										}
									}
								}

								if (!IsRectEmpty(&rcTest) && !RectInRegion(rgnLabels, &rcTest))
								{	int tHeight = DrawText(hdc, Buffer, -1, &rcTest, DT_NOPREFIX | DT_LEFT | DT_NOPREFIX);
									int rcHeight = rcTest.bottom-rcTest.top;
									if (tHeight != rcHeight)
									{	InflateRect(&rcTest, 0, (tHeight-rcHeight)/2);
									}
									{	HRGN rgnLabel = CreateRectRgnIndirect(&rcTest);
										CombineRgn(rgnLabels, rgnLabels, rgnLabel, RGN_OR);
										DeleteObject(rgnLabel);
									}
								}
							}
							p++;	/* Next point */
						}
						if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
						if (p > 1)
						{	COLORREF cRedGreen = RGB(0,0,192);
							HPEN hpen2 = CreatePen(PS_SOLID, 1, cRedGreen);
							HGDIOBJ hold2 = SelectObject(hdc, hpen2);
							Polyline(hdc, Points, p);
							SelectObject(hdc, hold2);
							DeleteObject(hpen2);
						}
						free(Points);
					}
#endif
					SetBkMode(hdc, prevBkMode);
					free(Buffer);
				}
{	char Temp[80];
sprintf(Temp,"Labels:%ld",(long)VisibleCount);
Start = DebugTimer("CirclePaint",Temp,Start,&msMax,NULL,hwnd);
}
			}
#endif

			if (CloseStationCount)
			if ((cInfo->CenterStation && cInfo->CenterStation->TInfo[tr].visible && cInfo->CenterStation->Ambiguity)	/* Do the center if ambiguous */
			|| (VisibleCount <= MAX_STATION_LABELS	/* Not too many visible */
			&& (ActiveConfig.View.Ambiguity || cInfo->viewBits&VIEW_AMBIGUOUS)))	/* and watching ambiguity */
			{	HPEN hpen2 = NULL;
				HGDIOBJ hold2 = NULL;
				STATION_INFO_S *Station;
				unsigned long ss=0, se=0;

				if (VisibleCount <= MAX_STATION_LABELS	/* Not too many visible */
				&& (ActiveConfig.View.Ambiguity || cInfo->viewBits&VIEW_AMBIGUOUS))
				{	ss = 0; se = CloseStationCount-1;	/* -1 for <= in for loop */
				} else	ss = se = cInfo->CenterStation?cInfo->CenterStation->Index:0;	/* CE ONLY does this one!  Win32 ALWAYS does this one! */

				for (s=ss; s<=se; s++)
				if (pCloseStations && pCloseStations[s])
				{	Station = pCloseStations[s];
#ifdef OLD_CE
				Station = cInfo->CenterStation;	/* CE ONLY does this one */
				if (Station)
				{
#endif
					if (Station->TInfo[tr].visible && Station->Ambiguity)
					{static double Ambiguity[] = { 0.1, 1.0, 10.0, 60.0 };	/* Nautical Miles */
						if (Station->Ambiguity > 0 && Station->Ambiguity <= ARRAYSIZE(Ambiguity))
						{	RECT rc = Station->TInfo[tr].rcSym;
							int radius = (rc.right-rc.left)/2;

							if (!hpen2)
							{	hpen2 = CreatePen(PS_SOLID, 1, RGB(255,128,255));
								hold2 = SelectObject(hdc, hpen2);
							}
#ifdef UNDER_CE
							if (Station != cInfo->CenterStation)
							{	POINT Pts[5];
								Pts[0].x = rc.left-1; Pts[0].y = rc.top-1;
								Pts[1].x = rc.right+1; Pts[1].y = rc.top-1;
								Pts[2].x = rc.right+1; Pts[2].y = rc.bottom+1;
								Pts[3].x = rc.left-1; Pts[3].y = rc.bottom+1;
								Pts[4].x = rc.left-1; Pts[4].y = rc.top-1;
								Polyline(hdc, Pts, 5);
							} else
#endif
							{	long Pixels = (long) ((rcSmaller.right-rcSmaller.left)/2.0 * Ambiguity[Station->Ambiguity-1]*MilePerNM / cInfo->Scale / 2);	/* final /2 is for +/- radius, I think... */
#define AMBIGUOUS_CIRCLE
#ifdef AMBIGUOUS_CIRCLE
#ifdef UNDER_CE
								{	POINT c;
									c.x = (rc.right+rc.left)/2;
									c.y = (rc.bottom+rc.top)/2;
									DrawCircle(hdc, radius+1, c, 0, 360);
									if (Pixels >= radius)
										DrawCircle(hdc, Pixels+1, c, 0, 360);
								}
#else
								Arc(hdc, rc.left-1, rc.top-1, rc.right+1, rc.bottom+1,
									rc.left, rc.top, rc.left, rc.top);
								{
static double LatWidths[] = { 0.0,
	/* A..R */		180.0/18.0,
	/* 0..9 */		180.0/18.0/10.0,
	/* A..X */		180.0/18.0/10.0/24.0,
	/* 0..9 */		180.0/18.0/10.0/24.0/10.0,
	/* A..X */		180.0/18.0/10.0/24.0/10.0/24.0,
	/* 0..9 */		180.0/18.0/10.0/24.0/10.0/24.0/10.0 };
									if (Station->gsAmbiguity	/* Draw grid square? */
									&& Station->gsAmbiguity/2 > 0
									&& Station->gsAmbiguity/2 < sizeof(LatWidths)/sizeof(LatWidths[0]))
									{	POINT Pts[5];
										double Offset = LatWidths[Station->gsAmbiguity/2]/2;
										GetScreenPoint(cInfo, prcWin, DispHeading, Station->pCoord->lat+Offset, Station->pCoord->lon-Offset*2, &Pts[4], TRUE);
										GetScreenPoint(cInfo, prcWin, DispHeading, Station->pCoord->lat-Offset, Station->pCoord->lon+Offset*2, &Pts[2], TRUE);

										Pts[0] = Pts[4];
										Pts[1].x = Pts[2].x; Pts[1].y = Pts[0].y;
										Pts[3].x = Pts[0].x; Pts[3].y = Pts[2].y;
										SplitPolyline(hdc, Pts, 5, MaxSegment);
										Pts[0].x = rc.right+1; Pts[0].y = rc.top-1;
										SplitPolyline(hdc, &Pts[0], 2, MaxSegment);
										Pts[1].x = rc.right+1; Pts[1].y = rc.bottom+1;
										SplitPolyline(hdc, &Pts[1], 2, MaxSegment);
										Pts[2].x = rc.left-1; Pts[2].y = rc.bottom+1;
										SplitPolyline(hdc, &Pts[2], 2, MaxSegment);
										Pts[3].x = rc.left-1; Pts[3].y = rc.top-1;
										SplitPolyline(hdc, &Pts[3], 2, MaxSegment);
									} else if (Pixels >= radius)
									{	InflateRect(&rc, Pixels-radius, Pixels-radius);
										Arc(hdc, rc.left, rc.top, rc.right, rc.bottom,
											rc.left, rc.top, rc.left, rc.top);
									}
								}
#endif
#else	/* ndef AMBIGUOUS_CIRCLE */
								{	POINT Pts[5];

									InflateRect(&rc, 1, 1);
									Pts[0].x = rc.left; Pts[0].y = rc.top;
									Pts[1].x = rc.right; Pts[1].y = rc.top;
									Pts[2].x = rc.right; Pts[2].y = rc.bottom;
									Pts[3].x = rc.left; Pts[3].y = rc.bottom;
									Pts[4].x = rc.left; Pts[4].y = rc.top;
									Polyline(hdc, Pts, 5);
	
									if (Pixels >= radius)
									{	InflateRect(&rc, Pixels-radius-1, Pixels-radius-1);
										Pts[0].x = rc.left; Pts[0].y = rc.top;
										Pts[1].x = rc.right; Pts[1].y = rc.top;
										Pts[2].x = rc.right; Pts[2].y = rc.bottom;
										Pts[3].x = rc.left; Pts[3].y = rc.bottom;
										Pts[4].x = rc.left; Pts[4].y = rc.top;
										Polyline(hdc, Pts, 5);
									}
								}
#endif	/* AMBIGUOUS_CIRCLE */
							}
						}
					}
				}

				if (hpen2)
				{	SelectObject(hdc, hold2);
					DeleteObject(hpen2);
				}
Start = DebugTimer("CirclePaint","Ambiguity",Start,&msMax,NULL,hwnd);
			}

			if (cInfo->viewBits & VIEW_GEOCACHES && GeocacheCount)
			{	unsigned long g;
				for (g=0; g<GeocacheCount; g++)
				{
					Geocaches[g].visible = FALSE;	/* First make it non-visible */
					SetRectEmpty(&Geocaches[g].rc);	/* And non-clickable */
					Geocaches[g].labelled = FALSE;	/* And non-labelled */
					Geocaches[g].rcLabel = Geocaches[g].rc;	/* And non-clickable label */

					{	POINT pt;
						if (GetScreenPoint(cInfo, prcWin, DispHeading, Geocaches[g].lat, Geocaches[g].lon, &pt, TRUE)
						&& ScaleSymbol2(hwnd, hdc, hMemDC, prcWin, Geocaches[g].symbol,
										pt.x, pt.y, cInfo->Scale*4, 100, &Geocaches[g].rc))
						{	Geocaches[g].visible = TRUE;
							VisibleGeoCaches++;
						}
					}
				}

				if (VisibleGeoCaches
				&& (VisibleGeoCaches < ActiveConfig.View.GeoCacheLabelsMax)
				&& (ActiveConfig.View.GeoCacheID || ActiveConfig.View.GeoCacheType
				|| ActiveConfig.View.GeoCacheCont || ActiveConfig.View.GeoCacheDT))
				{	int prevBkMode = SetBkMode(hdc, TRANSPARENT);
					size_t BufSize = sizeof(TCHAR)*80;
					TCHAR *Buffer=(TCHAR*)malloc(BufSize);
					BOOL NeedFont = (SymbolHeight < TextHeight);
					HFONT hOld = (HFONT) 0;

					for (g=0; g<GeocacheCount; g++)
					if (Geocaches[g].visible)
					{	size_t Remaining = BufSize;
						TCHAR *Next = Buffer;
						long LinesOfText;
						int LocalHeight;
						RECT rcTest, rcText, rcGeo = Geocaches[g].rc;

						if (NeedFont)
						{	HFONT hFont = LoadPaintFont(TEXT(""), max(10,SymbolHeight), FALSE);	/* 10 is as small as we go */
							if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
							NeedFont = FALSE;
						}

						LinesOfText = 0;
						if (ActiveConfig.View.GeoCacheID)
						{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%.*S"), STRING(Geocaches[g].ID));
							LinesOfText++;
						}

						if (ActiveConfig.View.GeoCacheType && Geocaches[g].Type && *Geocaches[g].Type)
						{	if (LinesOfText)
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%S"), Geocaches[g].Type);
							LinesOfText++;
						}

						if (ActiveConfig.View.GeoCacheCont && Geocaches[g].Container && *Geocaches[g].Container)
						{	if (LinesOfText)
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%S"), Geocaches[g].Container);
							LinesOfText++;
						}

						if (ActiveConfig.View.GeoCacheDT)
						{	if (LinesOfText)
								StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("\n"));
							StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
											TEXT("%.1lf/%.1lf"),
											(double)(Geocaches[g].difficulty)/2.0,
											(double)(Geocaches[g].terrain)/2.0);
							LinesOfText++;
						}

						if (LinesOfText)
						{
							SetRect(&rcText, rcGeo.right, rcGeo.top, Geocaches[g].rc.right, rcGeo.bottom);
							LocalHeight = DrawText(hdc, Buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_CALCRECT);

							if ((Geocaches[g].rc.bottom-Geocaches[g].rc.top) >= LocalHeight)
							{	rcText.top = rcGeo.top; rcText.bottom = rcGeo.bottom;
							} else
							{	rcGeo.top = rcText.top; rcGeo.bottom = rcText.bottom;
							}

							rcTest = rcText;	/* Start where we want */
							if (!ActiveConfig.View.LabelOverlap)
							if (RectInRegion(rgnLabels, &rcTest))	/* Preferred (right center) any good? */
							{	SetRect(&rcTest, rcGeo.left-(rcText.right-rcText.left), rcGeo.top,
												rcGeo.left, rcGeo.bottom);
								if (RectInRegion(rgnLabels, &rcTest))	/* left center is crowded */
								{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2+(rcGeo.right-rcGeo.left)/4,
													rcGeo.bottom,
													(rcGeo.right+rcGeo.left)/2+(rcGeo.right-rcGeo.left)/4+(rcText.right-rcText.left),
													rcGeo.bottom+LocalHeight);
									if (RectInRegion(rgnLabels, &rcTest))	/* bottom right is crowded */
									{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2+(rcGeo.right-rcGeo.left)/4, rcGeo.top-LocalHeight,
													(rcGeo.right+rcGeo.left)/2+(rcGeo.right-rcGeo.left)/4+(rcText.right-rcText.left),
													rcGeo.top);
										if (RectInRegion(rgnLabels, &rcTest))	/* top right is crowded */
										{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2-(rcGeo.right-rcGeo.left)/4-(rcText.right-rcText.left),
																rcGeo.bottom, (rcGeo.right+rcGeo.left)/2-(rcGeo.right-rcGeo.left)/4,
																rcGeo.bottom+LocalHeight);
											if (RectInRegion(rgnLabels, &rcTest))	/* bottom left is crowded */
											{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2-(rcGeo.right-rcGeo.left)/4-(rcText.right-rcText.left),
																rcGeo.top-LocalHeight, (rcGeo.right+rcGeo.left)/2-(rcGeo.right-rcGeo.left)/4,
																rcGeo.top);
												if (RectInRegion(rgnLabels, &rcTest))	/* top left is crowded */
												{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2-(rcText.right-rcText.left)/2,
																	rcGeo.bottom+LocalHeight,
																	(rcGeo.right+rcGeo.left)/2+(rcText.right-rcText.left)/2,
																	rcGeo.bottom+LocalHeight*2);
													if (RectInRegion(rgnLabels, &rcTest))	/* 2*bottom center is crowded */
													{	SetRect(&rcTest, (rcGeo.right+rcGeo.left)/2-(rcText.right-rcText.left)/2,
																		rcGeo.top-LocalHeight*2,
																		(rcGeo.right+rcGeo.left)/2+(rcText.right-rcText.left)/2,
																		rcGeo.top-LocalHeight);
														if (RectInRegion(rgnLabels, &rcTest))	/* 2*top center is crowded, Give up and stack it! */
														{	rcTest = rcText;
														}
													}
												}
											}
										}
									}
								}
							}

							int tHeight = DrawText(hdc, Buffer, -1, &rcTest, DT_NOPREFIX | DT_LEFT | DT_NOPREFIX);
							rcTest.bottom = rcTest.top + tHeight;

							if (!ActiveConfig.View.LabelOverlap)
							{	HRGN rgnLabel = CreateRectRgnIndirect(&rcTest);
								CombineRgn(rgnLabels, rgnLabels, rgnLabel, RGN_OR);
								DeleteObject(rgnLabel);
							}

							Geocaches[g].labelled = TRUE;	/* And non-labelled */
							Geocaches[g].rcLabel = rcTest;	/* And non-clickable label */
						}
					}
					if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
				}
			
{	char Temp[80];
sprintf(Temp,"GeoCaches:%ld/%ld",(long)VisibleGeoCaches, (long)GeocacheCount);
Start = DebugTimer("CirclePaint",Temp,Start,&msMax,NULL,hwnd);
}
			}
			free(LabelNeeded);
		}
//else TraceLog("CirclePaint", TRUE, hwnd, "LastCenterPosition[%ld] Invalid %ld (0x%lX) @ %.4lf %.4lf\n", cInfo->Index, cInfo->LastCenterPosition.dwValidFields, cInfo->LastCenterPosition.dwValidFields, (double) cInfo->LastCenterPosition.dblLatitude, (double) cInfo->LastCenterPosition.dblLongitude);

#endif	/* BROKEN_CIRCLE_CONTENTS */

//		FrameRgn(hdc, rgnLabels, (HBRUSH)GetStockObject(DKGRAY_BRUSH), 1, 1);
		DeleteObject(rgnLabels);
		DeleteDC(hMemDC);	/* No more symbol drawing after this */

#ifdef CROP_CIRCLE
		int width = Info->rc.right-Info->rc.left;
		int height = Info->rc.bottom-Info->rc.top;
		HDC hdcShadow = CreateCompatibleDC(hdc);
		if (hdcShadow)
		{	HBITMAP hShadowMap = CreateCompatibleBitmap(hdc, width, height);
			if (hShadowMap)
			{	HGDIOBJ hOrgMap = SelectObject(hdcShadow, hShadowMap);
				COLORREF colorWindow = GetSysColor(COLOR_WINDOW);
				COLORREF colorTrans = RGB(GetRValue(colorWindow)+128,GetGValue(colorWindow)+128,GetBValue(colorWindow)+128);
				HBRUSH hbrTrans = CreateSolidBrush(colorTrans);
				HGDIOBJ hold = SelectObject(hdcShadow, hbrTrans);
				RECT rc;
				SetRect(&rc, 0, 0, width, height);
			    FillRect(hdcShadow, &rc, GetSysColorBrush(COLOR_WINDOW));
				Ellipse(hdcShadow, rc.left, rc.top, rc.right, rc.bottom);
				SelectObject(hdc, hold);
				DeleteObject(hbrTrans);

				TransparentBlt(hdc, Info->rc.left, Info->rc.top, width, height,
								hdcShadow, 0, 0, width, height, colorTrans);

				SelectObject(hdcShadow, hOrgMap);
				DeleteObject(hShadowMap);
			} else MessageBox(hwnd, TEXT("NULL hShadowMap"), TEXT("CropCircle"), MB_OK | MB_ICONERROR);
			DeleteDC(hdcShadow);
		} else MessageBox(hwnd, TEXT("NULL hdcShadow"), TEXT("CropCircle"), MB_OK | MB_ICONERROR);
Start = DebugTimer("CirclePaint","CropCircle",Start,&msMax,NULL,hwnd);
#endif

#ifdef CLIP_RECTRGN
		RestoreDC(hdc, -1);
		DeleteObject(hrgn);
#endif
#ifdef CLIP_CIRCLE
		RestoreDC(hdc, -1);
#endif

		cInfo->Circle.DeadReckoning = (DeadReckonCount > 0);

#ifdef SHADOW_CIRCLE
	SelectObject(hdc, prevBrush);
	SetTextColor(hdc, prevText);
	SetBkColor(hdc, prevBack);
#undef hdc

			if (cInfo->AutoZoomViewOut)
			{	unsigned long s;
				int tr = cInfo->Index;
//				RECT rcTest = *prcWin;
				RECT rcCover;
				BOOL misses = 0;
				BOOL GotOne = FALSE;
				double minlat=0, minlon=0, maxlat=0, maxlon=0;
				SetRectEmpty(&rcCover);
				for (s=cInfo->AutoZoomME?0:1; s<CloseStationCount; s++)
				{	if (pCloseStations[s]->TInfo[tr].viewed)
					{	STATION_INFO_S *Station = pCloseStations[s];
						if (Station->pCoord->lat || Station->pCoord->lon)
						{
							if (Station->TInfo[tr].rcsymvalid) UnionRect(&rcCover, &rcCover, &Station->TInfo[tr].rcSym);
							if (Station->TInfo[tr].rclblvalid) UnionRect(&rcCover, &rcCover, &Station->TInfo[tr].rcLbl);
							if (IsValidLatLon(Station->pCoord->lat, Station->pCoord->lon))
							{	if (!GotOne)
								{	minlat = maxlat = Station->pCoord->lat;
									minlon = maxlon = Station->pCoord->lon;
									GotOne = TRUE;
								} else
								{	double lat = Station->pCoord->lat;
									double lon = Station->pCoord->lon;
									if (lat < minlat) minlat = lat;
									if (lat > maxlat) maxlat = lat;
									if (lon < minlon) minlon = lon;
									if (lon > maxlon) maxlon = lon;
								}
								if (!Station->TInfo[tr].inCircle)
								{	misses++;
									if (misses < 10)
										TraceLog("AutoZoom", FALSE, hwnd, "[%ld] Station %s Not InCircle!\n", cInfo->Index, Station->Station);
						// Temporarily (maybe)			break;
								}
							}
						}
					}
				}
				double cLat = (minlat+maxlat)/2;
				double cLon = (minlon+maxlon)/2;
				BOOL ReCenter = GotOne
							&& (!cInfo->CenterTracking || !cInfo->Locked)
							&& (cLat != cInfo->LastCenterPosition.dblLatitude
							|| cLon != cInfo->LastCenterPosition.dblLongitude);
				TraceLog("AutoZoom", FALSE && ReCenter, hwnd, "%sMove to %.4lf %.4lf From %.4lf %.4lf Move %lf %lf (%.4lf %.4lf -> %.4lf %.4lf)\n",
										ReCenter?"":"No",
										cLat, cLon,
										cInfo->LastCenterPosition.dblLatitude,
										cInfo->LastCenterPosition.dblLongitude,
										fabs(cInfo->LastCenterPosition.dblLatitude-cLat),
										fabs(cInfo->LastCenterPosition.dblLongitude-cLon),
										minlat, minlon, maxlat, maxlon);
				long wCover = rcCover.right-rcCover.left;
				long hCover = rcCover.bottom-rcCover.top;
				long wWin = prcWin->right-prcWin->left;
				long hWin = prcWin->bottom-prcWin->top;
				float wRatio = wCover?((float)wWin/(float)wCover):-1;
				float hRatio = hCover?((float)hWin/(float)hCover):-1;
				BOOL ZoomIn = (wRatio > 2.2 && hRatio >= 2.2 && cInfo->zoom < MAX_REASONABLE_ZOOM && !cInfo->Locked);
				TraceLog("AutoZoom", FALSE && ZoomIn, hwnd, "[%ld] %s IN from %ld with x%.2lf x%.2lf %ldx%ld <=? %ldx%ld or rcCover:%ld %ld -> %ld %ld rcWin:%ld %ld -> %ld %ld\n",
						(long) tr, ZoomIn?"AutoZoom":"NoZoom", cInfo->zoom,
						(double) wRatio, (double) hRatio,
						(rcCover.right-rcCover.left), (rcCover.bottom-rcCover.top),
						(prcWin->right-prcWin->left), (prcWin->bottom-prcWin->top),
						rcCover.left, rcCover.top, rcCover.right, rcCover.bottom,
						prcWin->left, prcWin->top, prcWin->right, prcWin->bottom);
				if (ReCenter && cInfo->AutoZoomViewCtr)	/* Need to get visible or shift? */
				{
					SetCenterLatLon(hwnd, cLat, cLon);
				} else if (misses && cInfo->AutoZoomViewOut)
				{	PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);
				} else if (ZoomIn && cInfo->AutoZoomViewIn)
				{	PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);
				}
			}
		}	/* end of painting a new shadow circle */
		
		if (hdc != hdcShadow)	/* Did we really shadow? */
		{
			if (!BitBlt(hdc, prcWin->left, prcWin->top, width, height,
				hdcShadow, prcWin->left, prcWin->top, SRCCOPY))
			{	TCHAR Buffer[256];
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("BitBlt Failed at line %ld"), (long) __LINE__);
				MessageBox(hwnd, Buffer, TEXT("BitBlt"), MB_OK | MB_ICONERROR);
			}
#ifdef VERBOSE
			else TraceLog("CirclePaint", FALSE, hwnd, "BitBlt Shadow(%p) %ld %ld to Real(%p) %ld %ld %ldx%ld\n",
						hdcShadow, prcWin->left, prcWin->top,
						hdc, prcWin->left, prcWin->top, width, height);
#endif
		}
#ifdef VERBOSE
		else TraceLog("CirclePaint", FALSE, hwnd, "Didn't really Shadow %p == %p\n", hdcShadow, hdc);
#endif
Start = DebugTimer("CirclePaint","UnShadow",Start,&msMax,NULL,hwnd);
#endif	/* SHADOW_CIRCLE */

		DrawOSMQueueCircle(rcSmaller, hwnd, hdc);
Start = DebugTimer("CirclePaint","OSMQueue",Start,&msMax,NULL,hwnd);

		if (ActiveConfig.Screen.Show.CrossHairs < 0	/* Always visible */
		|| cInfo->CrossHairs)						/* Or timing */
		if (!IsPreferredView(hwnd,cInfo,TRUE)
		&& (cInfo->LastCenterPosition.dblLatitude
					!= LastGoodPosition.dblLatitude
			|| cInfo->LastCenterPosition.dblLongitude 
					!= LastGoodPosition.dblLongitude))
		{	long w2 = (rcSmaller.right-rcSmaller.left)/2/2;
			long h2 = (rcSmaller.bottom-rcSmaller.top)/2/2;
			long cx = (rcSmaller.left+rcSmaller.right)/2;
			long cy = (rcSmaller.bottom+rcSmaller.top)/2;

			MoveToEx(hdc, rcSmaller.left + w2, cy, NULL);
			LineTo(hdc, rcSmaller.right - w2, cy);
			MoveToEx(hdc, cx, rcSmaller.bottom - h2, NULL);
			LineTo(hdc, cx, rcSmaller.top + h2);
Start = DebugTimer("CirclePaint","CrossHair",Start,&msMax,NULL,hwnd);
		}

		if (ActiveConfig.Screen.Show.RedDot	/* Is the RedDot visible? */
		&& CloseStationCount && GPSEnabled)	/* Am I Defined? */
		{	RECT rcDot;
			GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
			if (Genius->projDistance)	/* Don't draw dot if it hasn't moved */
			{	HDC hMemDC = CreateCompatibleDC(hdc);	/* For symbols */
				ScaleSymbol(hwnd, hdc, hMemDC, prcWin, '/',
						Genius->projBearing-DispHeading,
						min(Genius->projDistance,Genius->ForecastError), 
						Genius->ForecastError, 100, &rcDot);	/* Hard coded red dot */
				DeleteDC(hMemDC);	/* No more symbol drawing after this */
			}
Start = DebugTimer("CirclePaint","RedDot",Start,&msMax,NULL,hwnd);
		}

		if (GPSEnabled)
		if (ActiveConfig.Screen.Show.Satellites)
		if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW)
		if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_PRNS)
		if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_AZIMUTH)
		if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_ELEVATION)
		{	DWORD s;
			COLORREF prevColor = SetTextColor(hdc, RGB(128,128,128));
			int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			HFONT hFont = LoadPaintFont(TEXT(""), g_dwFontSize*3/4, FALSE), hOld = (HFONT) 0;
			if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);

			for (s=0; s<gpsPosition.dwSatellitesInView; s++)
			if (gpsPosition.rgdwSatellitesInViewPRNs[s] != 255	/* Not a valid PRN */
			&& (gpsPosition.rgdwSatellitesInViewElevation[s] >= 0	/* Has Elevation */
				|| gpsPosition.rgdwSatellitesInViewAzimuth[s] >= 0))	/* OR Azimuth (0,0 are suppressed) */
			{	double range = cos(DegToRad(gpsPosition.rgdwSatellitesInViewElevation[s])) * (rcSmaller.right-rcSmaller.left)/2 + 0.5;
				TCHAR Buffer[16];

				if (gpsPosition.dwValidFields & GPS_VALID_SATELLITES_IN_VIEW_SIGNAL_TO_NOISE_RATIO)
					SetTextColor(hdc, ScaleSatelliteColor(gpsPosition.rgdwSatellitesInViewSignalToNoiseRatio[s]));

				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld"), (long) gpsPosition.rgdwSatellitesInViewPRNs[s]);
				DrawCompassLabel(hdc, prcWin, gpsPosition.rgdwSatellitesInViewAzimuth[s]-DispHeading, range, Buffer);
			}

			if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
			SetBkMode(hdc, prevBkMode);
			SetTextColor(hdc, prevColor);
Start = DebugTimer("CirclePaint","Satellites",Start,&msMax,NULL,hwnd);
		}

		if (cInfo->Circle.DeadReckoning)
		{	SetNextCirclePaint(cInfo, 1000, "DeadReckon");
			InvalidateCircle(hwnd, FALSE, FALSE, 1000);	/* Propagate the painting! */
		}
		if (cInfo->Circle.StormSpinning)
		{	SetNextCirclePaint(cInfo, STORM_SPIN_MSEC, "StormSpin");
			InvalidateCircle(hwnd, FALSE, FALSE, STORM_SPIN_MSEC);	/* Propagate the painting! */
		}
		if (cInfo->Circle.msPathExpire >= 0)
		{	if (cInfo->Circle.msPathExpire < 500)
				cInfo->Circle.msPathExpire = 500;
			SetNextCirclePaint(cInfo, (long) cInfo->Circle.msPathExpire, "PathExpire");
			InvalidateCircle(hwnd, FALSE, FALSE, (long) cInfo->Circle.msPathExpire);	/* Propagate the painting! */
		}
		if (cInfo->Circle.msNotAllExpire > 0)
		{	cInfo->Circle.msNotAllExpire = (cInfo->Circle.msNotAllStart+5000L)-msNow;
			if (cInfo->Circle.msNotAllExpire > 0)
			{	SetNextCirclePaint(cInfo, (long) cInfo->Circle.msNotAllExpire, "NotAllExpire");
				InvalidateCircle(hwnd, FALSE, FALSE, (long) cInfo->Circle.msNotAllExpire);	/* Propagate the painting! */
			}
		}

#ifdef DEBUG_CIRCLE_PAINT
		if (VisibleCount || DeadReckonCount || VisibleGeoCaches
		|| DRCount || DFCount || PHGCount || AmbCount
		|| InvisibleCount || ValidCount || NoShowCount)
			TraceLog("CirclePaint", FALSE, hwnd, "%d:%s Stations %ld/%ld (%ld Calc %ld Valid %ld NoShow %ld Invisible) DR:%ld/%ld@%ld DF:%ld/%ld@%ld PHG:%ld/%ld@%ld Amb:%ld GeoCaches %ld/%ld %I64d msec",cInfo->Index, Shadowed?"Shadowed":"Painted", (long)VisibleCount, (long)CloseStationCount, (long) ReCalcCount, (long) ValidCount, (long) NoShowCount, (long) InvisibleCount, (long) didDR, (long) DRCount, (long) tDR, (long) didDF, (long) DFCount, (long) tDF, (long) didPHG, (long) PHGCount, (long) tPHG, (long) AmbCount, (long) VisibleGeoCaches, (long) GeocacheCount, (__int64) llMsecSince(oStart, llGetMsec()));
#endif

		//if (!cInfo->Index)	/* Only the main window */
		{	if (Shadowed)
			{	cInfo->Circle.ShadowCount++;
				cInfo->Circle.msShadowTotal += llMsecSince(msPaintStart, llGetMsec());
			} else
			{
				cInfo->Circle.PaintCount++;
				cInfo->Circle.msPaintTotal += llMsecSince(msPaintStart, llGetMsec());
			}
		}
		break;
	}
	}	/* End of WM_PAINT */
	}
	return TRUE;
}

LRESULT SpeedHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{	HFONT hFont = (HFONT) 0, hOld = (HFONT) 0;

	switch (msg)
	{
	case WM_PAINT:
	{	hFont = LoadPaintFont(TEXT("7 Segment"), ActiveConfig.Screen.SpeedSize*g_dwFontSize, FALSE);
		if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
		if (GPSEnabled && gpsPosition.dwValidFields & GPS_VALID_SPEED)
		{	double dSpeed = gpsPosition.flSpeed*MilePerNM+0.5;
			TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);

			if (ActiveConfig.View.Metric.Distance)
				dSpeed *= (double) KmPerMile;

			StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld"), (long) dSpeed);
			DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#ifdef SEPARATE_DIGITS
			int r;
			for (r=0; r<3; r++)
			{	int w = Info->rc.right - Info->rc.left;
				int x = Info->rc.left + w * r / 3;
				MoveToEx(hdc, x, Info->rc.top, NULL);
				LineTo(hdc, x, Info->rc.bottom);
			}
#endif
			free(Buffer);
		} else DrawText(hdc, TEXT("--"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
		break;
	}
	}
	return TRUE;
}

LRESULT OdometerHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
		BOOL DidOne = FALSE;
		if (MyStation->TrackSize)
		{	if (ActiveConfig.View.Metric.Distance)
				StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Odometer: %.2lf km\nTrack Points: %ld/%ld\n\nClear them?"),
						(double) Odometer*KmPerMile, (long) MyStation->TrackCount, (long) MyStation->TrackSize);
			else StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Odometer: %.2lf miles\nTrack Points: %ld/%ld\n\nClear them?"),
						(double) Odometer, (long) MyStation->TrackCount, (long) MyStation->TrackSize);
			if (MessageBox(hwnd, Buffer, TEXT("Reset Odometer"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	if (CSVEnabled)	/* If we're CSV-ing, close and re-open a new file */
				{	EnableCSV(hwnd, FALSE, FALSE);
					EnableCSV(hwnd, TRUE, FALSE);
				}
				FreeTracks(MyStation, FALSE);
				DidOne = TRUE;
				if (!ActiveConfig.Beacon.Why
				|| TransmitOdometer(hwnd, cInfo, "Reset")
				|| MessageBox(hwnd, TEXT("Failed To Transmit Odometer, Still Clear?"), TEXT("Clear Odometer"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1) == IDYES)
				{	Odometer = 0;
					if (GPSEnabled) InvalidateOdometer(FALSE);
					else ShuffleScreenElements(hwnd);	/* Remove Odometer from display */
				}
			}
		}
		{	unsigned int s;
			long TotalCount=0, TotalSize=0;
			for (s=1; s<CloseStationCount; s++)
			{	TotalCount += pCloseStations[s]->TrackCount;
				TotalSize += pCloseStations[s]->TrackSize;
			}
			if (TotalSize)
			{	StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Total Points: %ld/%ld\n\nClear All Tracks?"),
							(long) TotalCount, (long) TotalSize);
				if (MessageBox(hwnd, Buffer, TEXT("Clear Tracks"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1) == IDYES)
				{	for (s=1; s<CloseStationCount; s++)
					if (pCloseStations[s]->TrackCount)
					{	FreeTracks(pCloseStations[s], FALSE);
						DidOne = TRUE;
					}
				}
			}
		}
		if (DidOne)
		{	PurgeFreeCoords("ClearTracks","Odometer");
			InvalidateStatUsage(FALSE);
			InvalidateCircle(NULL, TRUE, TRUE);
		}
#ifdef USING_SIP
//		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
		free(Buffer);
		break;
	}
	case WM_PAINT:
	{	double Actual = Odometer;
		TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
		if (ActiveConfig.View.Metric.Distance) Actual *= KmPerMile;
		if (Odometer <= 999.9)
			StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%.1lf"), (double) Actual);
		else	StringCbPrintf(Buffer, sizeof(*Buffer)*8, TEXT("%ld"), (long) Actual);
		DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		free(Buffer);
		break;
	}
	}
	return TRUE;
}

LRESULT AltitudeHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{

	case WM_LBUTTONDBLCLK:
	{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
		StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("HDOP: %.2lf\nVDOP: %.2lf\nPDOP: %.2lf"),
						(double) gpsPosition.flHorizontalDilutionOfPrecision,
						(double) gpsPosition.flVerticalDilutionOfPrecision,
						(double) gpsPosition.flPositionDilutionOfPrecision);
		MessageBox(hwnd, Buffer, TEXT("Dilution Of Precision"), MB_OK | MB_ICONINFORMATION);
#ifdef USING_SIP
//		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
		free(Buffer);
		break;
	}

	case WM_PAINT:
		RECT rc;

		if (GPSEnabled)
		{
/*
	Note:  Per Steve:G6UIM on 8/20/2013
	17:43:54> Right I see then from what I see DOP below 1 very good, between 1+
	17:43:55> and 2 good. between 2 and 5 ok and above 5 bad
*/
			rc = Info->Tracker[cInfo->Index].rc;
			rc.bottom = rc.top + (rc.bottom-rc.top)/2;
			if (gpsPosition.dwValidFields & GPS_VALID_VERTICAL_DILUTION_OF_PRECISION)
				DrawRGRectangle(hdc, &rc, FALSE, gpsPosition.flVerticalDilutionOfPrecision, 8, 0.5, FALSE);
			else DrawRGRectangle(hdc, &rc, FALSE, 0, 50, 1, TRUE);	// Effectively a white rectangle

			rc = Info->Tracker[cInfo->Index].rc;
			rc.top = rc.top + (rc.bottom-rc.top)/2;
			if (gpsPosition.dwValidFields & GPS_VALID_HORIZONTAL_DILUTION_OF_PRECISION)
				DrawRGRectangle(hdc, &rc, FALSE, gpsPosition.flHorizontalDilutionOfPrecision, 8, 0.5, FALSE);
			else DrawRGRectangle(hdc, &rc, FALSE, 0, 50, 1, TRUE);	// Effectively a white rectangle

			int prevBkMode = SetBkMode(hdc, TRANSPARENT);
			rc = Info->Tracker[cInfo->Index].rc;
			rc.left += 2;
			rc.bottom = rc.top + (rc.bottom-rc.top)/2;
			DrawText(hdc, TEXT("V"), -1, &rc, DT_LEFT | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

			rc = Info->Tracker[cInfo->Index].rc;
			rc.left += 2;
			rc.top = rc.top + (rc.bottom-rc.top)/2;
			DrawText(hdc, TEXT("H"), -1, &rc, DT_LEFT | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

			rc = Info->Tracker[cInfo->Index].rc;
			rc.left += (rc.right-rc.left)/6;
			if (gpsPosition.dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL)
			{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
				if (ActiveConfig.View.Metric.Altitude)
					StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ldm"), (long) (gpsPosition.flAltitudeWRTSeaLevel));
				else StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld'"), (long) (gpsPosition.flAltitudeWRTSeaLevel * FeetPerMeter));
				DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				free(Buffer);
			} else DrawText(hdc, TEXT("N/A"), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			SetBkMode(hdc, prevBkMode);
		} else
		{	DrawText(hdc, TEXT("Disabled"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		}
		break;
#undef BAR_HEIGHT
}
	return TRUE;
}

LRESULT LatLonHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	size_t Remaining = 1024;
		TCHAR *Buffer = (TCHAR*)malloc(Remaining);
		TCHAR *Next = Buffer;
#ifndef UNDER_CE
		{
			HANDLE hProc = GetCurrentProcess();
			DWORD nGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
			DWORD nUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS, TEXT("Objects: %ld GDI %ld User"),
						(long) nGDIObjects, (long) nUserObjects);
		}
		MessageBoxW(hwnd, Buffer, TEXT("Objects"), MB_OK | MB_ICONINFORMATION);
		free(Buffer);
#endif
	}

	case WM_PAINT:
		RECT rc;
		rc = Info->Tracker[cInfo->Index].rc;
		if ((cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))==(GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
		{	TCHAR *LatLon = APRSLatLon(cInfo->LastCenterPosition.dblLatitude,
										cInfo->LastCenterPosition.dblLongitude,
										' ', ' ', ActiveConfig.Beacon.Precision);
			DrawText(hdc, LatLon, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			free(LatLon);
		} else DrawText(hdc, TEXT("N/A"), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

		break;
	}
	return TRUE;
}

LRESULT DestinationHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	if (MessageBox(hwnd, TEXT("Clear Destination?"), TEXT("Destination"), MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
		{	memset(&MyDestination, 0, sizeof(MyDestination));
			ShuffleScreenElements(hwnd);
		}
		break;
	}

	case WM_PAINT:
		RECT rc;
		rc = Info->Tracker[cInfo->Index].rc;
		if (MyStation)
		{	TCHAR Buffer[80];
			char *Units = "mi";
			double distance, bearing;
			if (cInfo->Driving)
				AprsHaversineLatLon(cInfo->LastCenterPosition.dblLatitude,
								cInfo->LastCenterPosition.dblLongitude,
								MyDestination.lat, MyDestination.lon,
								&distance, &bearing);
			else AprsHaversineLatLon(MyStation->pCoord->lat, MyStation->pCoord->lon,
							MyDestination.lat, MyDestination.lon,
							&distance, &bearing);
			if (ActiveConfig.View.Metric.Distance)
			{	distance *= KmPerMile;
				Units = "km";
			}
			if (distance >= 100.0)
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld%S@%.0lf"), (long) distance, Units, bearing);
			else if (distance >= 10.0)
				StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.1lf%S@%.0lf"), (double) distance, Units, bearing);
			else if (ActiveConfig.View.Metric.Distance)
			{	if (distance > (999.0/1000.0))
					StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.2lf%S@%.0lf"), (double) distance, Units, bearing);
				else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ldm@%.0lf"), (long) (distance*1000.0), bearing);
			} else
			{	if (distance > (999.0/5280.0))
					StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%.2lf%S@%.0lf"), (double) distance, Units, bearing);
				else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld'@%.0lf"), (long) (distance*5280.0), bearing);
			}
			DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		} else DrawText(hdc, TEXT("N/A"), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

		break;
	}
	return TRUE;
}

LRESULT GridSquareHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{

	case WM_PAINT:
		RECT rc;
		rc = Info->Tracker[cInfo->Index].rc;
		if ((cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))==(GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
		{	char *myGrid = GridSquare(cInfo->LastCenterPosition.dblLatitude,
										cInfo->LastCenterPosition.dblLongitude, 3+max(ActiveConfig.Beacon.Precision,0));
			size_t Size = sizeof(TCHAR)*(strlen(myGrid)+1);
			TCHAR *Buffer = (TCHAR*)malloc(Size);
			StringCbPrintf(Buffer, Size, TEXT("%S"), myGrid);
			DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			free(Buffer);
		} else DrawText(hdc, TEXT("N/A"), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);

		break;
	}
	return TRUE;
}

LRESULT HeadingHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	HFONT hFont = (HFONT) 0, hOld = (HFONT) 0;
static TCHAR *Headings[] = { TEXT("N"), TEXT("NNE"), TEXT("NE"), TEXT("ENE"),
							TEXT("E"), TEXT("ESE"), TEXT("SE"), TEXT("SSE"),
							TEXT("S"), TEXT("SSW"), TEXT("SW"), TEXT("WSW"),
							TEXT("W"), TEXT("WNW"), TEXT("NW"), TEXT("NNW") };
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
	{	cInfo->Awaiting = FALSE;	/* Cancel any active watcher */
		if ((cInfo->CenterStation!=MyStation || !cInfo->CenterTracking)
		/*&& MessageBox(hwnd,TEXT("Return Center To ME?"),TEXT("Clear Center"),MB_YESNO | MB_ICONQUESTION) == IDYES*/)
		{	SetCenterTracking(hwnd, cInfo->CenterTracking?MyStation:cInfo->CenterStation);
		}
		break;
	}
	case WM_PAINT:
		RECT rc = Info->Tracker[cInfo->Index].rc;
		hFont = LoadPaintFont(TEXT("Tahoma Bold"), g_dwFontSize*3/2, FALSE);
		if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
		if (GPSEnabled && gpsPosition.dwValidFields & GPS_VALID_HEADING)
		{
#ifdef RAW_HEADING
			TCHAR Buffer[80];
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ld"), (long) cInfo->gpsPosition.flHeading);
			DrawText(hdc, Buffer, -1, &Info->rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
#else
			int Heading = (int) (gpsPosition.flHeading + 360.0/ARRAYSIZE(Headings)/2);
			if (Heading >= 360) Heading -= 360;
			Heading = Heading * ARRAYSIZE(Headings) / 360;
			if (Heading >= 0 && Heading < ARRAYSIZE(Headings))
				DrawText(hdc, Headings[Heading], -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			else
			{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
				StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld"), (long) gpsPosition.flHeading);
				DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				free(Buffer);
			}
#endif
		} else DrawText(hdc, TEXT("---"), -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		if (hOld != (HFONT) 0) SelectObject(hdc, hOld);
		break;
	}
	return TRUE;
}

LRESULT DrawSat(INFO_BLOCK *Info, CLIENT_INFO_S *cInfo, HDC hdc,
					DWORD Valid, DWORD CountMask, DWORD ArrayMask, int Count, DWORD *Array,
					GPS_POSITION *gpsPos)
{	int r;
	HFONT hFont = LoadPaintFont(TEXT(""), g_dwFontSize*3/4, FALSE), hOld = (HFONT) 0;
	if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
	if (GPSEnabled)
	{static int MaxSatellites = 12;
		if (Count > MaxSatellites) MaxSatellites = Count;
#ifdef VERBOSE
		TraceError(cInfo->hwnd,"DrawSat(%S) Valid:%lX Count:%s(%lX) Array:%s(%lX) Count %ld [0]=%ld\n",
					Info->Label, (long) Valid,
					Valid&CountMask?"Valid":"No", (long) CountMask,
					Valid&ArrayMask?"Valid":"No", (long) ArrayMask,
					(long) Count, (long) *Array);
#endif
		if (Valid & CountMask)
		{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
			if ((Valid & ArrayMask) && (Count > 0))
			{	RECT rc = Info->Tracker[cInfo->Index].rc;
				int prevBkMode = SetBkMode(hdc, TRANSPARENT);
				int w = Info->Tracker[cInfo->Index].rc.right - Info->Tracker[cInfo->Index].rc.left;
				for (r=0; r<min(Count,GPS_MAX_SATELLITES); r++)
				if (Array[r] != 255)
				{	COLORREF satColor = GetSatelliteColor(Array[r], gpsPos);
					int x = Info->Tracker[cInfo->Index].rc.left + w * (r+1) / MaxSatellites;
					MoveToEx(hdc, x, Info->Tracker[cInfo->Index].rc.top, NULL);
					LineTo(hdc, x, Info->Tracker[cInfo->Index].rc.bottom);
					rc.left = Info->Tracker[cInfo->Index].rc.left + w * r / MaxSatellites;
					rc.right = Info->Tracker[cInfo->Index].rc.left + w * (r+1) / MaxSatellites;
					if (satColor)
					{	HBRUSH hbrBkGnd = CreateSolidBrush(satColor);
						FillRect(hdc, &rc, hbrBkGnd);
						DeleteObject(hbrBkGnd);
					}
					StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld"), (long) Array[r]);
					DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				}

				if (Count < MaxSatellites)
				{	rc.left = Info->Tracker[cInfo->Index].rc.left + w * (MaxSatellites-1) / MaxSatellites;
					rc.right = Info->Tracker[cInfo->Index].rc.left + w * MaxSatellites / MaxSatellites;
					StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld"), (long)Count);
					DrawText(hdc, Buffer, -1, &rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				}

				SetBkMode(hdc, prevBkMode);
			} else
			{	StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld %s"), (long) Count, Info->uLabel);
				DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			}
			free(Buffer);
		} else DrawText(hdc, TEXT("N/A"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
	} else DrawText(hdc, TEXT("GPS Disabled"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
	if (hOld != (HFONT) 0) SelectObject(hdc, hOld);

	return TRUE;
}

LRESULT SatUseHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_PAINT:
		DrawSat(Info, cInfo, hdc, gpsPosition.dwValidFields, GPS_VALID_SATELLITE_COUNT, GPS_VALID_SATELLITES_USED_PRNS,
				gpsPosition.dwSatelliteCount, gpsPosition.rgdwSatellitesUsedPRNs, &gpsPosition);
		break;
	}
	return TRUE;
}

LRESULT SatViewHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_PAINT:
		DrawSat(Info, cInfo, hdc, gpsPosition.dwValidFields, GPS_VALID_SATELLITES_IN_VIEW, GPS_VALID_SATELLITES_IN_VIEW_PRNS,
				gpsPosition.dwSatellitesInView, SatellitesInViewPRNs, &gpsPosition);
		break;
	}
	return TRUE;
}

LRESULT FixHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
	case WM_LBUTTONDBLCLK:
		if (!GPSEnabled || MessageBox(hwnd, TEXT("Really Disable GPS?"), TEXT("GPS Toggle"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			EnableGPS(hwnd, !GPSEnabled, FALSE);
		break;

	case WM_PAINT:
	{	TCHAR *Type = TEXT("");

		if (GPSEnabled)
		{	switch (gpsPosition.FixType)
			{
			case GPS_FIX_2D: Type = gpsPosition.FixQuality==GPS_FIX_QUALITY_DGPS?TEXT("2D(D)"):TEXT("2D"); break;
			case GPS_FIX_3D: Type = gpsPosition.FixQuality==GPS_FIX_QUALITY_DGPS?TEXT("3D(D)"):TEXT("3D"); break;
			default:
				if (gpsPosition.FixQuality!=GPS_FIX_QUALITY_UNKNOWN
				&& (gpsPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))==(GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
					Type = gpsPosition.FixQuality==GPS_FIX_QUALITY_DGPS?TEXT("Fix(D)"):TEXT("Fix"); 
				else Type = TEXT("No Fix");
				break;
			}
			RECT rc = Info->Tracker[cInfo->Index].rc;
			if (gpsPosition.dwValidFields & GPS_VALID_POSITION_DILUTION_OF_PRECISION)
				DrawRGRectangle(hdc, &rc, FALSE, gpsPosition.flPositionDilutionOfPrecision, 8, 0.5, FALSE);
			else DrawRGRectangle(hdc, &rc, FALSE, 0, 50, 1, TRUE);	// Effectively a white rectangle

		} else Type = TEXT("DSBL");
		int prevBkMode = SetBkMode(hdc, TRANSPARENT);
		DrawText(hdc, Type, -1, &Info->Tracker[cInfo->Index].rc,
					DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		SetBkMode(hdc, prevBkMode);
		break;
	}
	}
	return TRUE;
}

LRESULT MessageHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
static	int AckID = 0;

switch (msg)
	{
	case WM_LBUTTONUP:
		if (MessageCount)
		{	DisplayMessage(hwnd, cInfo, 0);
		}
		break;
	case WM_LBUTTONDBLCLK:
		if (!MessageCount)
		{	if (PendingMsgCount)
				PopupPendingMessages(hwnd);
			else if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)CALLSIGN) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("MessageHandler"), MB_OK | MB_ICONERROR);
#ifdef USING_SIP
			SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
		}
		break;
//	case WM_RBUTTONUP:
//	case WM_RBUTTONDBLCLK:
	case WM_CONTEXTMENU:
		PopupPendingMessages(hwnd);
		break;
	case WM_PAINT:
	{		COLORREF color;
//			COLORREF color = GetScaledRGColor(MessageCount, MessageSize, 1);

			if (MessageCount && PendingMsgCount)
				color = RGB(255,128,0);	// Orange
			else if (MessageCount)
				color = RGB(0,255,0);	// Green
			else if (PendingMsgCount)
				color = RGB(255,255,0);	// Bright yellow
			else color = GetSysColor(COLOR_WINDOW);
			HBRUSH hbr = CreateSolidBrush(color);
			HGDIOBJ oldBrush = SelectObject(hdc, hbr);
			int prevBkMode = SetBkMode(hdc, TRANSPARENT);

			Rectangle(hdc, Info->Tracker[cInfo->Index].rc.left, Info->Tracker[cInfo->Index].rc.top, Info->Tracker[cInfo->Index].rc.right, Info->Tracker[cInfo->Index].rc.bottom);

#ifdef NEW_WAY
			if (MessageCount)
			{	HBRUSH hbr = CreateSolidBrush(RGB(255,255,0));
				HGDIOBJ oldBrush = SelectObject(hdc, hbr);
				RECT rc = Info->rc;
				int width = rc.right-rc.left;
				int i;
				rc.bottom = (rc.top - rc.bottom) / 2;
				for (i=0; i<MessageCount; i++)
				{	rc.left = Info->rc.left + i*width/(MessageCount+1);
					rc.right = Info->rc.left + (i+1)*width/(MessageCount+1);
					Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
				}
				SelectObject(hdc, oldBrush);
				DeleteObject(hbr);
			}

			if (PendingMsgCount)
			{	HBRUSH hbr = CreateSolidBrush(RGB(0,255,0));
				HGDIOBJ oldBrush = SelectObject(hdc, hbr);
				RECT rc = Info->rc;
				int width = rc.right-rc.left;
				int i;
				rc.top = (rc.top - rc.bottom) / 2;
				for (i=0; i<PendingMsgCount; i++)
				{	rc.left = Info->rc.left + i*width/(PendingMsgCount+1);
					rc.right = Info->rc.left + (i+1)*width/(PendingMsgCount+1);
					Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
				}
				SelectObject(hdc, oldBrush);
				DeleteObject(hbr);
			}
#endif
		if (MessageCount)
		{	TCHAR Title[16];

			StringCbPrintf(Title, sizeof(Title), TEXT("%S"), Messages[0].From);
			DrawText(hdc, Title, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		} else
		{	DrawText(hdc, TEXT("No Msg"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		}

#define BAR_HEIGHT 4
		if (ActiveConfig.Messaging.AutoAnswer.Reply[0])	/* AutoReply Set? */
		if (ActiveConfig.Messaging.AutoAnswer.Delay != LONG_MAX)	/* And configured delay */
		{	RECT rc = Info->Tracker[cInfo->Index].rc;
			rc.bottom = rc.bottom - BAR_HEIGHT*0;
			rc.top = rc.bottom - BAR_HEIGHT;
			DrawRGRectangle(hdc, &rc, TRUE, (double) SecondsSince(&stLastActivity), max(1,ActiveConfig.Messaging.AutoAnswer.Delay*60), 0, TRUE);
		}
#undef BAR_HEIGHT

			SetBkMode(hdc, prevBkMode);
			SelectObject(hdc, oldBrush);
			DeleteObject(hbr);
		break;
	}
	}
	return TRUE;
}

#include <tlhelp32.h>
//#include <toolhelp.h>
// 	toolhelp.lib may be required

#ifndef UNDER_CE
void GetCurrentFT(FILETIME *pft)
{	SYSTEMTIME st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st,pft);
}
#endif

#ifdef OLD_WAY
BOOL GetThreadIDs(DWORD **IDs, unsigned long *IDCount)
{	DWORD myProcID = GetCurrentProcessId();


#ifdef UNDER_CE
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPNOHEAPS,0);
#else
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD,0);
#endif
//	TraceLogThread("CPU", TRUE, "GetCurrentProcess=%ld gcpID=%ld\n",
//					(long) GetCurrentProcess(), (long) GetCurrentProcessId());
	if (hSnap != INVALID_HANDLE_VALUE)
	{
#ifdef SHOW_PROCS
		PROCESSENTRY32 pe;
		pe.dwSize = sizeof(pe);
		if (Process32First(hSnap, &pe))
		{	do
			{	TraceLogThread("CPU", TRUE, "Proc: %ld Thds: %ld Exe: %S\n",
							(long) pe.th32ProcessID,
							(long) pe.cntThreads,
							pe.szExeFile?pe.szExeFile:TEXT("*NULL*"));
				pe.dwSize = sizeof(pe);
			} while (Process32Next(hSnap, &pe));
			if (GetLastError() != ERROR_NO_MORE_FILES)
				TraceLogThread("CPU", TRUE, "Process32Next Failed with %ld (expected %ld)\n", GetLastError(), ERROR_NO_MORE_FILES);
		} else TraceLogThread("CPU", TRUE, "Process32First returned FALSE, LastError=%ld\n", GetLastError());
#endif

		THREADENTRY32 te;
		te.dwSize = sizeof(te);
		if (Thread32First(hSnap, &te))
		{	unsigned long ulKernelD=0, ulKernelT=0, ulUserD=0, ulUserT=0;
			do
			{	if (te.th32OwnerProcessID == myProcID)
				{
				FILETIME ftCreate, ftExit, ftKernel, ftUser;
#ifdef UNDER_CE
				if (GetThreadTimes((HANDLE)te.th32ThreadID,
									&ftCreate, &ftExit, &ftKernel, &ftUser))
#else
				HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, te.th32ThreadID);
				if (hThread && GetThreadTimes(hThread,
									&ftCreate, &ftExit, &ftKernel, &ftUser))
#endif
				{
#ifdef VERBOSE
					TraceLogThread("CPU", TRUE, "Thread: %ld(%s) Proc: %ld Cre:%08lX %08lX Exi::%08lX %08lX Ker::%08lX %08lX Usr::%08lX %08lX\n",
							(long) te.th32ThreadID,
							GetThreadNameByID(te.th32ThreadID),
							(long) te.th32OwnerProcessID,
							(unsigned long) ftCreate.dwHighDateTime,
							(unsigned long) ftCreate.dwLowDateTime,
							(unsigned long) ftExit.dwHighDateTime,
							(unsigned long) ftExit.dwLowDateTime,
							(unsigned long) ftKernel.dwHighDateTime,
							(unsigned long) ftKernel.dwLowDateTime,
							(unsigned long) ftUser.dwHighDateTime,
							(unsigned long) ftUser.dwLowDateTime);
//								(long) te.th32CurrentProcessID);
#endif
#ifndef UNDER_CE
					CloseHandle(hThread);
#endif
					unsigned __int64 llCreate = FILETIME2ll(ftCreate);
					unsigned __int64 llUpTime = llNow-llCreate;
					unsigned __int64 llKernel = FILETIME2ll(ftKernel);
					unsigned __int64 llUser = FILETIME2ll(ftUser);

#ifdef VERBOSE
					TraceLogThread("CPU", TRUE, "Thread: %ld(%s) Up: %ldsec Kernel: %ldsec(%.1f%%) User: %ldsec(%.1f%%)\n",
							(long) te.th32ThreadID,
							GetThreadNameByID(te.th32ThreadID),
							(long) (llUpTime/10000000),
							(long) (llKernel/10000000),
							(float) (llUpTime?(llKernel/(llUpTime/1000)):0)/10.0,
							(long) (llUser/10000000),
							(float) (llUpTime?(llUser/(llUpTime/1000)):0)/10.0);
#endif

					if (llUpTime)
					{	ulKernelT += (unsigned long) (llKernel/(llUpTime/1000));
						ulUserT += (unsigned long) (llUser/(llUpTime/1000));
					}

					{	unsigned long t;
						for (t=0; t<PerfCount; t++)
						{	if (Perfs[t].th32ThreadID == te.th32ThreadID)
								break;
						}
						if (t >= PerfCount)
						{	t = PerfCount++;
							Perfs = (THREAD_PERF_S *)realloc(Perfs,sizeof(*Perfs)*PerfCount);
							memset(&Perfs[t], 0, sizeof(Perfs[t]));
							Perfs[t].th32ThreadID = te.th32ThreadID;
							Perfs[t].llCreate = llCreate;
							TraceLogThread("CPU", TRUE, "New Thread: %ld(%s) Up: %ldsec\n",
											(long) te.th32ThreadID,
											GetThreadNameByID(te.th32ThreadID),
											(long) (llUpTime/10000000));
						} else if (Perfs[t].llCreate != llCreate)
						{	TraceLogThread("CPU", TRUE, "ReCreated Thread: %ld(%s) Up: %ldsec\n",
											(long) te.th32ThreadID,
											GetThreadNameByID(te.th32ThreadID),
											(long) (llUpTime/10000000));
							Perfs[t].llCreate = llCreate;
						} else if (llNow != Perfs[t].llLast
						&& (llKernel != Perfs[t].llKernel
								|| llUser != Perfs[t].llUser))
						{	unsigned __int64 llDelta = llNow - Perfs[t].llLast;
							unsigned __int64 llDeltaK = llKernel - Perfs[t].llKernel;
							unsigned __int64 llDeltaU = llUser - Perfs[t].llUser;

					TraceLogThread("CPU", FALSE, "Thread: %ld(%s) Delta: %ldms Kernel: %ldms(%.1f/%.1f%%) User: %ldms(%.1f%/%.1f%%)\n",
							(long) te.th32ThreadID,
							GetThreadNameByID(te.th32ThreadID),
							(long) (llDelta/10000),
							(long) (llDeltaK/10000),
							(float) (llDelta?(llDeltaK/(llDelta/1000)):0)/10.0,
							(float) (llUpTime?(llKernel/(llUpTime/1000)):0)/10.0,
							(long) (llDeltaU/10000),
							(float) (llDelta?(llDeltaU/(llDelta/1000)):0)/10.0,
							(float) (llUpTime?(llUser/(llUpTime/1000)):0)/10.0);

							if (llDelta)
							{	ulKernelD += (unsigned long) (llDeltaK/(llDelta/1000));
								ulUserD += (unsigned long) (llDeltaU/(llDelta/1000));
							}
						}
						Perfs[t].llLast = llNow;
						Perfs[t].llCreate = llCreate;
						Perfs[t].llKernel = llKernel;
						Perfs[t].llUser = llUser;
					}



				} else TraceLogThread("CPU", TRUE, "Thread: %ld Proc: Own: %ld (OpenThread or GetThreadTimes returned %ld)\n",
							(long) te.th32ThreadID,
							(long) te.th32OwnerProcessID,
							(long) GetLastError());
//								(long) te.th32CurrentProcessID);

				}
				te.dwSize = sizeof(te);
			} while (Thread32Next(hSnap, &te));
			if (GetLastError() != ERROR_NO_MORE_FILES)
				TraceLogThread("CPU", TRUE, "Thread32Next Failed with %ld (expected %ld)\n", GetLastError(), ERROR_NO_MORE_FILES);

			TraceLogThread("CPU", FALSE, "Kernel: %.1f/%.1f%% User: %.1f/%.1f%%\n",
							(float) ulKernelD/10.0, (float) ulKernelT/10.0,
							(float) ulUserD/10.0, (float) ulUserT/10.0);

			fKernelT = *pKernelT = (float) (ulKernelT/10.0);
			fKernelD = *pKernelD = (float) (ulKernelD/10.0);
			fUserT = *pUserT = (float) (ulUserT/10.0);
			fUserD = *pUserD = (float) (ulUserD/10.0);
			llmsLast = llmsNow;
		} else TraceLogThread("CPU", TRUE, "Thread32First returned FALSE, LastError=%ld\n", GetLastError());

#ifdef UNDER_CE
		CloseToolhelp32Snapshot(hSnap);
#else
		CloseHandle(hSnap);
#endif
	} else TraceLogThread("CPU", TRUE, "CreateToolhelp32Snapshot Failed with %ld\n", GetLastError());
}
}

}
#endif


static void CalculateCPU(float *pKernelT, float *pUserT, float *pKernelD, float *pUserD)
{	__int64 llmsNow = llGetMsec();
static __int64 llmsLast = 0;
static float fKernelD=0, fKernelT=0, fUserD=0, fUserT=0;

	if (llMsecSince(llmsLast, llmsNow) < 1000)
	{	*pKernelT = fKernelT;
		*pKernelD = fKernelD;
		*pUserT = fUserT;
		*pUserD = fUserD;
	} else
	{	FILETIME ftNow;
		GetCurrentFT(&ftNow);
#define FILETIME2ll(ft) (((unsigned __int64) (ft).dwHighDateTime)<<32 | (ft).dwLowDateTime)
		unsigned __int64 llNow = FILETIME2ll(ftNow);

		*pKernelT = *pUserT = *pKernelD = *pUserD = 0.0;

typedef struct THREAD_PERF_S
{	DWORD th32ThreadID;
unsigned __int64 llCreate;
unsigned __int64 llKernel;
unsigned __int64 llUser;
unsigned __int64 llLast;
} THREAD_PERF_S;
static	unsigned long PerfCount = 0;
static THREAD_PERF_S *Perfs = {0};

		DWORD *IDs;
		unsigned long IDCount;

		if (GetThreadIDs(&IDs, &IDCount))
		{	unsigned long ulKernelD=0, ulKernelT=0, ulUserD=0, ulUserT=0;
			for (unsigned long i=0; i<IDCount; i++)
			{
				FILETIME ftCreate, ftExit, ftKernel, ftUser;
#ifdef UNDER_CE
				if (GetThreadTimes((HANDLE)IDs[i],
									&ftCreate, &ftExit, &ftKernel, &ftUser))
#else
				HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, IDs[i]);
				if (hThread && GetThreadTimes(hThread,
									&ftCreate, &ftExit, &ftKernel, &ftUser))
#endif
				{
#ifdef VERBOSE
					TraceLogThread("CPU", TRUE, "Thread: %ld(%s) Cre:%08lX %08lX Exi::%08lX %08lX Ker::%08lX %08lX Usr::%08lX %08lX\n",
							(long) IDs[i],
							GetThreadNameByID(IDs[i]),
							(unsigned long) ftCreate.dwHighDateTime,
							(unsigned long) ftCreate.dwLowDateTime,
							(unsigned long) ftExit.dwHighDateTime,
							(unsigned long) ftExit.dwLowDateTime,
							(unsigned long) ftKernel.dwHighDateTime,
							(unsigned long) ftKernel.dwLowDateTime,
							(unsigned long) ftUser.dwHighDateTime,
							(unsigned long) ftUser.dwLowDateTime);
#endif
#ifndef UNDER_CE
					CloseHandle(hThread);
#endif
					unsigned __int64 llCreate = FILETIME2ll(ftCreate);
					unsigned __int64 llUpTime = llNow-llCreate;
					unsigned __int64 llKernel = FILETIME2ll(ftKernel);
					unsigned __int64 llUser = FILETIME2ll(ftUser);

#ifdef VERBOSE
					TraceLogThread("CPU", TRUE, "Thread: %ld(%s) Up: %ldsec Kernel: %ldsec(%.1f%%) User: %ldsec(%.1f%%)\n",
							(long) IDs[i],
							GetThreadNameByID(IDs[i]),
							(long) (llUpTime/10000000),
							(long) (llKernel/10000000),
							(float) (llUpTime?(llKernel/(llUpTime/1000)):0)/10.0,
							(long) (llUser/10000000),
							(float) (llUpTime?(llUser/(llUpTime/1000)):0)/10.0);
#endif

					if (llUpTime > 1000)
					{	ulKernelT += (unsigned long) (llKernel/(llUpTime/1000));
						ulUserT += (unsigned long) (llUser/(llUpTime/1000));
					} else
						TraceLogThread("CPU", TRUE, "Huh?  Uptime(%lu) < 1000", (unsigned long) llUpTime);

					{	unsigned long t;
						for (t=0; t<PerfCount; t++)
						{	if (Perfs[t].th32ThreadID == IDs[i])
								break;
						}
						if (t >= PerfCount)
						{	t = PerfCount++;
							Perfs = (THREAD_PERF_S *)realloc(Perfs,sizeof(*Perfs)*PerfCount);
							memset(&Perfs[t], 0, sizeof(Perfs[t]));
							Perfs[t].th32ThreadID = IDs[i];
							Perfs[t].llCreate = llCreate;
							TraceLogThread("CPU", TRUE, "New Thread: %ld(%s) Up: %ldsec\n",
											(long) IDs[i],
											GetThreadNameByID(IDs[i]),
											(long) (llUpTime/10000000));
						} else if (Perfs[t].llCreate != llCreate)
						{	TraceLogThread("CPU", TRUE, "ReCreated Thread: %ld(%s) Up: %ldsec\n",
											(long) IDs[i],
											GetThreadNameByID(IDs[i]),
											(long) (llUpTime/10000000));
							Perfs[t].llCreate = llCreate;
						} else if (llNow != Perfs[t].llLast
						&& (llKernel != Perfs[t].llKernel
								|| llUser != Perfs[t].llUser))
						{	unsigned __int64 llDelta = llNow - Perfs[t].llLast;
							unsigned __int64 llDeltaK = llKernel - Perfs[t].llKernel;
							unsigned __int64 llDeltaU = llUser - Perfs[t].llUser;

#ifdef UNDER_CE
			TraceLogThread("CPU", FALSE, "Thread: %ld(%s) Delta: %ldms CPU: %ldms(%.1f%/%.1f%%)\n",
							(long) IDs[i],
							GetThreadNameByID(IDs[i]),
							(long) (llDelta/10000),
							(long) (llDeltaU/10000),
							(float) (__int64)(llDelta?(llDeltaU/(llDelta/1000)):0)/10.0,
							(float) (__int64)(llUpTime?(llUser/(llUpTime/1000)):0)/10.0);
#else
			TraceLogThread("CPU", FALSE, "Thread: %ld(%s) Delta: %ldms Kernel: %ldms(%.1f/%.1f%%) User: %ldms(%.1f%/%.1f%%)\n",
							(long) IDs[i],
							GetThreadNameByID(IDs[i]),
							(long) (llDelta/10000),
							(long) (llDeltaK/10000),
							(float) (llDelta>1000?(llDeltaK/(llDelta/1000)):0)/10.0,
							(float) (llUpTime>1000?(llKernel/(llUpTime/1000)):0)/10.0,
							(long) (llDeltaU/10000),
							(float) (llDelta>1000?(llDeltaU/(llDelta/1000)):0)/10.0,
							(float) (llUpTime>1000?(llUser/(llUpTime/1000)):0)/10.0);
#endif
							if (llDelta > 1000)
							{	ulKernelD += (unsigned long) (llDeltaK/(llDelta/1000));
								ulUserD += (unsigned long) (llDeltaU/(llDelta/1000));
							} else
								TraceLogThread("CPU", TRUE, "Huh?  Uptime(%lu) < 1000", (unsigned long) llUpTime);
						}
						Perfs[t].llLast = llNow;
						Perfs[t].llCreate = llCreate;
						Perfs[t].llKernel = llKernel;
						Perfs[t].llUser = llUser;
					}
				}
			}
#ifdef UNDER_CE
			TraceLogThread("CPU", FALSE, "CPU: %.1f/%.1f%%\n",
							(float) ulUserD/10.0, (float) ulUserT/10.0);
#else
			TraceLogThread("CPU", FALSE, "Kernel: %.1f/%.1f%% User: %.1f/%.1f%%\n",
							(float) ulKernelD/10.0, (float) ulKernelT/10.0,
							(float) ulUserD/10.0, (float) ulUserT/10.0);
			fKernelT = *pKernelT = (float) (ulKernelT/10.0);
			fKernelD = *pKernelD = (float) (ulKernelD/10.0);
#endif
			fUserT = *pUserT = (float) (ulUserT/10.0);
			fUserD = *pUserD = (float) (ulUserD/10.0);
			llmsLast = llmsNow;
			free(IDs);
		} else TraceLogThread("CPU", TRUE, "GetThreadIDs Failed\n");
	}
}

LRESULT TimeHandler(INFO_BLOCK *Info, HWND hwnd, CLIENT_INFO_S *cInfo, HDC hdc, UINT msg, WPARAM wp, LPARAM lp)
{
	switch (msg)
	{
#ifndef UNDER_CE	/* Not a good thing to enable on CE by accident */
	case WM_LBUTTONDBLCLK:
		ShowTraceLog("CPU", TRUE);
#endif
	case WM_PAINT:	/* LBUTTONDBLCLK falls through on purpose */
	{	RECT rc;
		float KernelT, UserT, KernelD, UserD;
		CalculateCPU(&KernelT, &UserT, &KernelD, &UserD);

		rc = Info->Tracker[cInfo->Index].rc;
		rc.bottom = rc.bottom - (rc.bottom-rc.top)/2;
		DrawRGRectangle(hdc, &rc, FALSE, KernelD+UserD, 100, 0.01, TRUE);

		rc = Info->Tracker[cInfo->Index].rc;
		rc.top = rc.top + (rc.bottom-rc.top)/2;
		DrawRGRectangle(hdc, &rc, FALSE, KernelT+UserT, 100, 0.01, TRUE);

		int prevBkMode = SetBkMode(hdc, TRANSPARENT);

		if (ActiveConfig.Screen.DateTimePerformance)
		{	SYSTEMTIME st;
			GetSystemTime(&st);
			if (!(st.wSecond%CLEAR_SECONDS)
			&& (cInfo->Time.stLast.wSecond%CLEAR_SECONDS))
			{	cInfo->Time.LastCount = cInfo->Circle.PaintCount;
				cInfo->Time.msLast = (long) (cInfo->Circle.PaintCount?(cInfo->Circle.msPaintTotal/cInfo->Circle.PaintCount):0);
				cInfo->Circle.PaintCount = 0;
				cInfo->Circle.msPaintTotal = 0;
				cInfo->Time.LastShadow = cInfo->Circle.ShadowCount;
				cInfo->Time.msLastShadow = (long) (cInfo->Circle.ShadowCount?(cInfo->Circle.msShadowTotal/cInfo->Circle.ShadowCount):0);
				cInfo->Circle.ShadowCount = 0;
				cInfo->Circle.msShadowTotal = 0;
			}
			cInfo->Time.stLast = st;

			{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);
#ifdef OLD_WAY
				if (cInfo->Time.LastCount || cInfo->Time.LastShadow)
				{	StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld+%ld/%ld*%ld+%ld"),
									(long) cInfo->Time.LastShadow,
									(long) cInfo->Time.LastCount,
									(long) CLEAR_SECONDS,
									(long) cInfo->Time.msLastShadow,
									(long) cInfo->Time.msLast);
				} else StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("No Paint"));
#else
				StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%ld %S"),
								(long) (cInfo->Circle.msNextPaint - llGetMsec()),
								cInfo->Circle.InvalidReason);
#endif
				DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
				free(Buffer);
			}
#undef CLEAR_SECONDS
		}
		else
		{
		if (GPSEnabled && !(gpsPosition.dwValidFields & GPS_VALID_UTC_TIME))
			DrawText(hdc, TEXT("N/A"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
		else
		{	SYSTEMTIME stTime;
			TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*80);

			if (GPSEnabled)
			{	if (gpsPosition.dwValidFields & GPS_VALID_UTC_TIME)
				{	stTime = gpsPosition.stUTCTime;
				} else memset(&stTime,0,sizeof(stTime));
			} else GetSystemTime(&stTime);

			switch (ActiveConfig.Screen.DateTime)
			{
			case -2:	/* GPS-Only */
				if (!GPSEnabled) { memset(&stTime,0,sizeof(stTime)); break; }
			case 2:		/* System Time */
				break;

			case -1:
				if (!GPSEnabled) { memset(&stTime,0,sizeof(stTime)); break; }
			case 1:		/* Local Time */
			if (GPSEnabled)
			{	if (stTime.wYear)
				{	FILETIME uctFile, lclFile;
					SystemTimeToFileTime(&gpsPosition.stUTCTime, &uctFile);
					FileTimeToLocalFileTime(&uctFile, &lclFile);
					FileTimeToSystemTime(&lclFile, &stTime);
				}
			} else GetLocalTime(&stTime);
			break;

			case 0:		/* None, should never see this! */
			default:
				memset(&stTime,0,sizeof(stTime));
			}		

			if (stTime.wYear == 0)
				DrawText(hdc, TEXT("N/A"), -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			else if (strchr(ActiveConfig.Screen.DateSeconds,(stTime.wSecond % 10)+'0'))
				StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%04ld/%02ld/%02ld"),
								(long) stTime.wYear,
								(long) stTime.wMonth,
								(long) stTime.wDay);
			else StringCbPrintf(Buffer, sizeof(*Buffer)*80, TEXT("%2ld:%02ld:%02ld"),
							(long) stTime.wHour,
							(long) stTime.wMinute,
							(long) stTime.wSecond);
			DrawText(hdc, Buffer, -1, &Info->Tracker[cInfo->Index].rc, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_SINGLELINE);
			free(Buffer);
		}
		}
		SetBkMode(hdc, prevBkMode);
		break;
	}
	}
	return TRUE;
}

void PaintMainWindow(HWND hwnd)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	PAINTSTRUCT ps;
	int			r;
	RECT        rcPaint;
	HRGN rgnPaint = CreateRectRgn(0,0,0,0);
	int rgnStat = GetUpdateRgn(hwnd, rgnPaint, FALSE);
	BOOL UseRect = (rgnStat==ERROR) || (rgnStat==SIMPLEREGION);
#ifndef UNDER_CE
	HANDLE hProc = GetCurrentProcess();
	DWORD cGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
	DWORD cUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
#endif
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;

// Start the paint operation
	if (!GetUpdateRect(hwnd, &rcPaint, FALSE)
	|| BeginPaint(hwnd, &ps) == NULL)
	{
//TraceLog("Activity", TRUE, hwnd, "NOOP WM_PAINT\n");
		DeleteObject(rgnPaint);
		return;
	}
//TraceLog("Activity", TRUE, hwnd,"Beginning paint\n");
Start = DebugTimer("Paint","BeginPaint",Start,&msMax,&msLast,hwnd);

//	ActualValidateRects(hwnd);	/* start a new invalidation deferral */

#ifdef SHADOW_SCREEN
		HDC hdcShadow = CreateCompatibleDC(ps.hdc);
		HGDIOBJ hOrgMap = 0;
		long width=0, height=0;
		if (hdcShadow)
		{	RECT rcClient;
			//GetWindowRect(hwnd, &rc);
			//width = rc.right - rc.left;
			//height = rc.bottom - rc.top;
			GetClientRect(hwnd, &rcClient);
			width = rcClient.right - rcClient.left;
			height = rcClient.bottom - rcClient.top;
			if (cInfo->hShadowMap
			&& (width != cInfo->shadowWidth || height != cInfo->shadowHeight))
			{	DeleteObject(cInfo->hShadowMap);
				TraceLog("Activity", TRUE, hwnd, "PaintMainWindow:Deleted ShadowMap(0x%lX) %ld!=%ld or %ld!=%ld\n",
							(long) cInfo->hShadowMap,
							(long) width, (long) cInfo->shadowWidth,
							(long) height, (long) cInfo->shadowHeight);
				cInfo->hShadowMap = 0;
			}
			if (!cInfo->hShadowMap)
			{	BITMAP bm = {0};
				cInfo->hShadowMap = CreateCompatibleBitmap(ps.hdc, width, height);
				cInfo->shadowWidth = width;
				cInfo->shadowHeight = height;
				GetObject(cInfo->hShadowMap, sizeof(bm), &bm);
				TraceLog("Activity", TRUE, hwnd, "PaintMainWindow:New ShadowMap(0x%lX) %ld x %ld (t:%ld %ldx%ld w:%ld pl:%ld bpp:%ld)\n",
							(long) cInfo->hShadowMap,
							(long) cInfo->shadowWidth,
							(long) cInfo->shadowHeight,
							bm.bmType, bm.bmWidth, bm.bmHeight,
							bm.bmWidthBytes, bm.bmPlanes, bm.bmBitsPixel);
			}
			if (cInfo->hShadowMap)
			{	hOrgMap = SelectObject(hdcShadow, cInfo->hShadowMap);
				FillRect(hdcShadow, &rcPaint, GetSysColorBrush(COLOR_WINDOW));
			} else
			{	DeleteDC(hdcShadow);
				hdcShadow = ps.hdc;
				TraceLog("Activity", TRUE, hwnd, "PaintMainWindow:NULL hShadowMap from CreateCompatibleBitmap, LastError = %ld\n", (long) GetLastError());
				MessageBeep(MB_ICONHAND);
			}
		} else
		{	hdcShadow = ps.hdc;
			MessageBox(hwnd, TEXT("NULL hdcShadow"), TEXT("CreateCompatibleDC"), MB_OK | MB_ICONERROR);
		}
Start = DebugTimer("Paint","Shadow",Start,&msMax,NULL,hwnd);
#define hdc hdcShadow
#else
#define hdc ps.hdc
#endif

//TraceActivityBegin(hwnd, "WM_PAINT: hdc=%p\n", hdc);

	COLORREF prevBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
	COLORREF prevText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	HBRUSH prevBrush = (HBRUSH) SelectObject(hdc, GetSysColorBrush(COLOR_WINDOW));
	for (r=0; r<ARRAYSIZE(rcs); r++)
	{	if (rcs[r].Handler && !IsRectEmpty(&rcs[r].Tracker[cInfo->Index].rc))
		{	RECT rc = rcs[r].Tracker[cInfo->Index].rc, rcIntersection;
			BOOL PaintIt = UseRect?IntersectRect(&rcIntersection, &rcs[r].Tracker[cInfo->Index].rc, &rcPaint):RectInRegion(rgnPaint,&rcs[r].Tracker[cInfo->Index].rc);
			if (PaintIt)
			{	__int64 Start = llGetMsec();
			static __int64 msMax=0, msLast=0;

				if (rcs[r].PaintRect)
				{	rc = rcs[r].Tracker[cInfo->Index].rc; rc.right++; rc.bottom++;
					Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
				}

#ifndef UNDER_CE
//#define TRACK_PAINT_GDI
#endif

#ifdef TRACK_PAINT_GDI
DWORD nGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
DWORD nUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
#endif
//TraceActivity(hwnd, "Painting %s (%ld %ld %ld %ld) vs (%ld %ld %ld %ld)", rcs[r].aLabel, (long) rc.left, (long) rc.top, (long) rc.right, (long) rc.bottom, (long) rcs[r].Tracker[cInfo->Index].rc.left, (long) rcs[r].Tracker[cInfo->Index].rc.top, (long) rcs[r].Tracker[cInfo->Index].rc.right, (long) rcs[r].Tracker[cInfo->Index].rc.bottom);
				//if (rcs[r].Handler != CircleHandler)
				rcs[r].Handler(&rcs[r], hwnd, cInfo, hdc, WM_PAINT, 0, 0);
//TraceActivity(hwnd, "Painted %s (%ld %ld %ld %ld) vs (%ld %ld %ld %ld)", rcs[r].aLabel, (long) rc.left, (long) rc.top, (long) rc.right, (long) rc.bottom, (long) rcs[r].Tracker[cInfo->Index].rc.left, (long) rcs[r].Tracker[cInfo->Index].rc.top, (long) rcs[r].Tracker[cInfo->Index].rc.right, (long) rcs[r].Tracker[cInfo->Index].rc.bottom);

#ifdef TRACK_PAINT_GDI
DWORD dGDI = GetGuiResources(hProc, GR_GDIOBJECTS) - nGDIObjects;
DWORD dUser = GetGuiResources(hProc, GR_USEROBJECTS) - nUserObjects;
if (dGDI || dUser) TraceError(hwnd, "Paint(%S) Consumed %ld GDI (%ld) and %ld User (%ld) Objects\n", rcs[r].Label, (long) dGDI, (long) nGDIObjects+dGDI, (long) dUser, (long) nUserObjects+dUser);
#endif

#ifdef DOESNT_WORK
				if (UseRect)
				{
					if (EqualRect(&rcIntersection, &rcs[r].rc))
					{	rcs[r].InvalidCount = 0;
						TraceError(hwnd, "%s Validated In Rectangle\n", rcs[r].aLabel);
					} else TraceError(hwnd, "%s Not Fully In Rectangle, not validated\n", rcs[r].aLabel);
				} else
				{
					if (PtInRegion(rgnPaint, rcs[r].rc.left, rcs[r].rc.top)
					&& PtInRegion(rgnPaint, rcs[r].rc.right, rcs[r].rc.top)
					&& PtInRegion(rgnPaint, rcs[r].rc.left, rcs[r].rc.bottom)
					&& PtInRegion(rgnPaint, rcs[r].rc.right, rcs[r].rc.bottom))
					{	rcs[r].InvalidCount = 0;
						TraceError(hwnd, "%s Validated In Region\n", rcs[r].aLabel);
					} else TraceError(hwnd, "%s Not Fully In Region, not validated %ld %ld %ld %ld\n", rcs[r].aLabel,
						(long) PtInRegion(rgnPaint, rcs[r].rc.left, rcs[r].rc.top),
						(long) PtInRegion(rgnPaint, rcs[r].rc.right, rcs[r].rc.top),
						(long) PtInRegion(rgnPaint, rcs[r].rc.left, rcs[r].rc.bottom),
						(long) PtInRegion(rgnPaint, rcs[r].rc.right, rcs[r].rc.bottom));
				}
#endif
{	char Buffer[80];
sprintf(Buffer,"%s:%ldx%ld", rcs[r].aLabel,
		(long)(rcs[r].Tracker[cInfo->Index].rc.right-rcs[r].Tracker[cInfo->Index].rc.left),
		(long)(rcs[r].Tracker[cInfo->Index].rc.bottom-rcs[r].Tracker[cInfo->Index].rc.top));
Start = DebugTimer("rcPaint",Buffer,Start,&msMax,&msLast,hwnd);
}
			}
//else TraceActivity(hwnd, "NOT Painting %s (%ld %ld %ld %ld)", rcs[r].aLabel, (long) rcs[r].Tracker[cInfo->Index].rc.left, (long) rcs[r].Tracker[cInfo->Index].rc.top, (long) rcs[r].Tracker[cInfo->Index].rc.right, (long) rcs[r].Tracker[cInfo->Index].rc.bottom);

		}
//else TraceActivity(hwnd, "NOT Painting %s RectIsEmpty(%ld %ld %ld %ld)", rcs[r].aLabel, (long) rcs[r].Tracker[cInfo->Index].rc.left, (long) rcs[r].Tracker[cInfo->Index].rc.top, (long) rcs[r].Tracker[cInfo->Index].rc.right, (long) rcs[r].Tracker[cInfo->Index].rc.bottom);
	}
	SelectObject(hdc, prevBrush);
	SetTextColor(hdc, prevText);
	SetBkColor(hdc, prevBack);
	#undef hdc
Start = DebugTimer("Paint","RCs",Start,&msMax,NULL,hwnd);

//TraceActivityEnd(hwnd, "WM_PAINT: Done\n");


#ifdef SHADOW_SCREEN
		if (hdcShadow != ps.hdc)
		{	if (!BitBlt(ps.hdc, 0, 0, width, height, hdcShadow, 0, 0, SRCCOPY))
			{	DWORD Error = GetLastError();
				__int64 msNow = llGetMsec();
			static DWORD LastError = 0;
			static __int64 msLastReport = 0;
				if (Error != LastError
				|| llMsecSince(msLastReport, msNow) >= 5*60*1000)
				{	LastError = Error;
					msLastReport = msNow;
				TraceError(hwnd, "PaintMainWindow:Shadow BitBlt Failed in %s line %ld Error %ld\n", __FILE__, (long) __LINE__, (long) Error);
				if (Error != ERROR_INVALID_HANDLE)
				{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
					StringCbPrintf(Buffer, sizeof(*Buffer)*256,
									TEXT("BitBlt Failed at line %ld Error %ld"),
									(long) __LINE__, (long) Error);
					MessageBox(hwnd, Buffer, TEXT("BitBlt"), MB_OK | MB_ICONERROR);
					free(Buffer);
				}
				}
			}
			SelectObject(hdcShadow, hOrgMap);
			DeleteDC(hdcShadow);
		}
Start = DebugTimer("Paint","UnShadow",Start,&msMax,NULL,hwnd);
#endif

	// Always need to finish!!
	DeleteObject(rgnPaint);
	EndPaint(hwnd, &ps);
Start = DebugTimer("Paint","EndPaint",Start,&msMax,NULL,hwnd);
#ifndef UNDER_CE
	DWORD dGDI = GetGuiResources(hProc, GR_GDIOBJECTS) - cGDIObjects;
	DWORD dUser = GetGuiResources(hProc, GR_USEROBJECTS) - cUserObjects;
	if (dGDI || dUser) TraceLog("Activity", dGDI>5||dUser>5, hwnd, "Paint Consumed %ld GDI and %ld User Objects\n", (long) dGDI, (long) dUser);
Start = DebugTimer("Paint","Resources",Start,&msMax,NULL,hwnd);
#endif
}

LRESULT SendMouseMessage(HWND hwnd, UINT msg, WPARAM wp, RECT *prc)
{	WORD x = (WORD) ((prc->right-prc->left)/2+prc->left);
	WORD y = (WORD) ((prc->bottom-prc->top)/2+prc->top);
TraceActivity(hwnd, "SendMouse(%ld) @ %ld,%ld", (long) msg, (long) x, (long) y);
	return SendMessage(hwnd, msg, wp, MAKELONG(x,y));
}

typedef struct VIEW_COUNTS_S
{	unsigned long Total;
		unsigned long RFAll, RFDirect, RFLocal, RF3rd;
		unsigned long RFOnly, RFIS, ISOnly;
		unsigned long RFDigi, IGate;
		unsigned long Ambig, Buddies, Dupes, Frequencies, FreqSpec, Invalids;
		unsigned long Msgable, NWSObj, Objs, Shrieks;
		unsigned long Telem, Path, Track, Nicks;
		unsigned long Alts;
} VIEW_COUNTS_S;

static void CalculateViewCounts(VIEW_COUNTS_S *Counts)
{	memset(Counts, 0, sizeof(*Counts));
	Counts->Total = CloseStationCount;
	for (unsigned long s=0; s<CloseStationCount; s++)
	{	STATION_INFO_S *Station = pCloseStations[s];
		if (Station->HeardOnRF) Counts->RFAll++;
		if (Station->HeardOnRF==1) Counts->RFDirect++;
		if (Station->HeardOnRF && Station->HeardOnRF<=LOCAL_MAX_HOPS+1) Counts->RFLocal++;
		if (Station->HeardAsThird) Counts->RF3rd++;
		if (!Station->HeardAsTCPIP
		&& (Station->HeardOnRF || Station->HeardRemoteRF)) Counts->RFOnly++;
		if (Station->HeardAsTCPIP
		&& (Station->HeardOnRF || Station->HeardRemoteRF)) Counts->RFIS++;
		if (Station->HeardAsTCPIP
		&& !Station->HeardOnRF && !Station->HeardRemoteRF) Counts->ISOnly++;
		if (Station->HeardAsDigi || Station->HeardAsRFDigi) Counts->RFDigi++;
		if (Station->HeardAsIGate) Counts->IGate++;
		if (Station->Ambiguity) Counts->Ambig++;
		if (Station->isBuddy) Counts->Buddies++;
		if (Station->TrackDupes) Counts->Dupes++;
		if (Station->Frequency && Station->Frequency->Issues) Counts->Frequencies++;
		if (Station->Frequency && !Station->Frequency->Issues) Counts->FreqSpec++;
		if (Station->TrackInvalids) Counts->Invalids++;
		if (Station->hasMessaging) Counts->Msgable++;
		if (Station->Nickname && Station->Nickname->Enabled) Counts->Nicks++;
		if (Station->isNWS) Counts->NWSObj++;
		if (Station->isObject) Counts->Objs++;
		if (Station->ShriekMask) Counts->Shrieks++;
		if (Station->hasTelemetry) Counts->Telem++;
		if (Station->PathCount) Counts->Path++;
		if (Station->TrackCount) Counts->Track++;
		if (Station->hadAltitude) Counts->Alts++;
	}
}

typedef struct VIEW_CHOOSER_DLG_INFO_S
{	HWND hwnd;
	int msgRefresh;
	BOOL Initialized;
	unsigned __int64 *pViewBits;	/* Pointer to live ViewBits */
//	PATH_CONFIG_INFO_S Original;
//	PATH_CONFIG_INFO_S *pLive;
} VIEW_CHOOSER_DLG_INFO_S;	

static void SetViewLastAccess(HWND hdlg, HWND hwndCheck, VIEW_COUNTS_S *pCounts, unsigned long *pValue)
{	TCHAR Buffer[80];
	TCHAR *Title = NULL;
	if (hwndCheck)
	{	int TitleLen = GetWindowTextLength(hwndCheck)+1;
		Title = (TCHAR*)malloc(sizeof(*Title)*TitleLen);
		GetWindowText(hwndCheck,Title,TitleLen);
	}
	if (pValue != &pCounts->Total)
	{	CalculateViewCounts(pCounts);
		StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%s:%ld/%ld"),
						Title?Title:TEXT(""), (long) *pValue, (long) CloseStationCount);
	} else StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%s:NA/%ld"),
						Title?Title:TEXT(""), (long) CloseStationCount);
	if (Title) free(Title);
	SetDlgItemText(hdlg, IDC_LAST_COUNT, Buffer);
}

static BOOL CALLBACK ViewChooserDlgProc(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
	VIEW_CHOOSER_DLG_INFO_S *DlgInfo = (VIEW_CHOOSER_DLG_INFO_S *) GetWindowLong(hdlg, DWL_USER);

	switch (msg)
	{
	case WM_INITDIALOG:
		DlgInfo = (VIEW_CHOOSER_DLG_INFO_S *) lp;
		SetWindowLong(hdlg, DWL_USER, (LONG) DlgInfo);
		SetDlgItemText(hdlg, IDC_LAST_COUNT, TEXT("Space 4 Rent"));	/* Blank it out to start */

//		CenterWindow(hdlg);
		AlignWindowLeft(hdlg);

	case WM_SET_CONTROLS:	/* WM_INITDIALOG falls into here */
		DlgInfo->Initialized = FALSE;

		{	int TitleLen = GetWindowTextLength(DlgInfo->hwnd)+1;
			TCHAR *Title = (TCHAR*)malloc(sizeof(*Title)*TitleLen);
			GetWindowText(DlgInfo->hwnd,Title,TitleLen);
			int MyTitleLen = TitleLen + 80;
			TCHAR *MyTitle = (TCHAR*)malloc(sizeof(*MyTitle)*MyTitleLen);
			StringCbPrintf(MyTitle, MyTitleLen, TEXT("View(%s)"), Title);
			SetWindowText(hdlg, MyTitle);
			free(MyTitle);
			free(Title);
		}

//		CheckDlgButton(hdlg, IDC_STATION_PACKET, Info->Station);

#define CHECK(cb,v,ct) CheckDlgButton(hdlg, IDC_##cb, (*DlgInfo->pViewBits&VIEW_##v)!=0)
		CHECK(SHOW_ALL, ALL, Total);
		CHECK(BUDDIES, BUDDIES, Buddies);
		// DUPLICATES
		// INVALIDS
		CHECK(ATTR_MSGS, MESSAGEABLE, Msgable);
		CHECK(ATTR_NWS, NWS, NWSObj);
		CHECK(ATTR_OBJECTS, OBJECTS, Objs);
		CHECK(ATTR_FREQUENCIES, FREQUENCIES, Frequencies);
		CHECK(ATTR_FREQSPEC, FREQSPEC, FreqSpecs);
		CHECK(ATTR_TELEMETRY, TELEMETRY, Telem);
		CHECK(ATTR_TRACKS, TRACKS, Track);
		// ECHOLINKS
		// GEOCACHES
		CHECK(RF_ALL, RF_ALL, RFAll);
		CHECK(RF_DIRECT, RF_DIRECT, RFDirect);
		CHECK(RF_LOCAL, RF_LOCAL, RFLocal);
		CHECK(RF_3RD, RF_THIRD, RF3rd);
		CHECK(XPORT_RF_ONLY, RF_ONLY, RFOnly);
		CHECK(NETWORK_DIGI, RF_DIGI, RFDigi);
		CHECK(XPORT_RF_IS, RF_INTERNET, RFIS);
		CHECK(NETWORK_IGATE, RF_IGATE, RFIGate);
		CHECK(XPORT_IS_ONLY, INTERNET_ONLY, RFISOnly);
		CHECK(SYM_RFID, RFID, Total);
		CHECK(SYM_MARINE, MARINE, Total);
		CHECK(SYM_MOBILE, MOBILE, Total);
		CHECK(SYM_WEATHER, WEATHER, Total);
		CHECK(SYM_FLIGHT, FLIGHT, Total);
		CHECK(SYM_CUSTOM, CUSTOM, Total);
		CHECK(ATTR_AMBIGUOUS, AMBIGUOUS, Ambig);
		CHECK(NICKNAMED, NICKNAMES, Nicks);
		// ANSRVR_MEMBERS
		// PLATFORMS
		// SYMBOLS
		CHECK(ATTR_ALTITUDES, ALTITUDES, Alts);
		CHECK(ATTR_PATHS, PATHS, Path);
#undef CHECK

		//if (*DlgInfo->pViewBits & VIEW_PLATFORMS)
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(DlgInfo->hwnd, GWL_USERDATA);
			if (cInfo)
			{	CheckDlgButton(hdlg, IDC_APRSISCE, cInfo->viewPlatforms[PLATFORM_APRSISCE]);
				CheckDlgButton(hdlg, IDC_APRSISDR, cInfo->viewPlatforms[PLATFORM_APRSISDR]);
				CheckDlgButton(hdlg, IDC_APRSIS32, cInfo->viewPlatforms[PLATFORM_APRSIS32]);
			}
		}

		DlgInfo->Initialized = TRUE;

		return TRUE;

	case WM_COMMAND:
#ifndef UNDER_CE
		if (DlgInfo && !IsWindow(DlgInfo->hwnd))
			DestroyWindow(hdlg);	/* Protect against my parent going away */
		else
#endif
		if (!MakeFocusControlVisible(hdlg, wp, lp))
		if (DlgInfo && DlgInfo->Initialized)
		switch (LOWORD(wp))
		{
#ifdef BUSTED
#define CHECK(cb,v,ct) case IDC_##cb: \
		if (HIWORD(wp)==BN_CLICKED) \
		{	VIEW_COUNTS_S Counts; \
			if (SendMessage((HWND)lp,BM_GETCHECK,0,0)==BST_CHECKED) \
			{	*DlgInfo->pViewBits |= VIEW_##v; \
				if (LOWORD(wp) != IDC_SHOW_ALL) \
					*DlgInfo->pViewBits &= ~VIEW_ALL; \
			} else *DlgInfo->pViewBits &= ~VIEW_##v; \
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.ct); \
		} \
		break
#else
#define CHECK(cb,v,ct) case IDC_##cb: \
		if (HIWORD(wp)==BN_CLICKED) \
		{	VIEW_COUNTS_S Counts; \
			*DlgInfo->pViewBits ^= VIEW_##v; \
			if (LOWORD(wp) != IDC_SHOW_ALL \
			&& *DlgInfo->pViewBits & VIEW_##v) \
				*DlgInfo->pViewBits &= ~VIEW_ALL; \
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.ct); \
		} \
		break
#endif
		CHECK(SHOW_ALL, ALL, Total);
		CHECK(BUDDIES, BUDDIES, Buddies);
		// DUPLICATES
		// INVALIDS
		CHECK(ATTR_MSGS, MESSAGEABLE, Msgable);
		CHECK(ATTR_NWS, NWS, NWSObj);
		CHECK(ATTR_OBJECTS, OBJECTS, Objs);
		CHECK(ATTR_TELEMETRY, TELEMETRY, Telem);
		CHECK(ATTR_TRACKS, TRACKS, Track);
		// ECHOLINKS
		// GEOCACHES
		CHECK(RF_ALL, RF_ALL, RFAll);
		CHECK(RF_DIRECT, RF_DIRECT, RFDirect);
		CHECK(RF_LOCAL, RF_LOCAL, RFLocal);
		CHECK(RF_3RD, RF_THIRD, RF3rd);
		CHECK(XPORT_RF_ONLY, RF_ONLY, RFOnly);
		CHECK(NETWORK_DIGI, RF_DIGI, RFDigi);
		CHECK(XPORT_RF_IS, RF_INTERNET, RFIS);
		CHECK(NETWORK_IGATE, RF_IGATE, IGate);
		CHECK(XPORT_IS_ONLY, INTERNET_ONLY, ISOnly);
		CHECK(SYM_RFID, RFID, Total);
		CHECK(SYM_MARINE, MARINE, Total);
		CHECK(SYM_MOBILE, MOBILE, Total);
		CHECK(SYM_WEATHER, WEATHER, Total);
		CHECK(SYM_FLIGHT, FLIGHT, Total);
		CHECK(SYM_CUSTOM, CUSTOM, Total);
		CHECK(ATTR_AMBIGUOUS, AMBIGUOUS, Ambig);
		CHECK(NICKNAMED, NICKNAMES, Nicks);
		// ANSRVR_MEMBERS
		// PLATFORMS
		// SYMBOLS
		CHECK(ATTR_ALTITUDES, ALTITUDES, Alts);
		CHECK(ATTR_PATHS, PATHS, Path);
		CHECK(ATTR_FREQUENCIES, FREQUENCIES, Frequencies);
		CHECK(ATTR_FREQSPEC, FREQSPEC, FreqSpec);
#undef CHECK
		if (HIWORD(wp)==BN_CLICKED)
		{	if (*DlgInfo->pViewBits & VIEW_FREQUENCIES)
				*DlgInfo->pViewBits |= VIEW_FREQSPEC;
			else *DlgInfo->pViewBits &= ~VIEW_FREQSPEC;
		}
		break;
		case IDC_APRSISCE:
		if (HIWORD(wp)==BN_CLICKED)
		{	VIEW_COUNTS_S Counts;
			CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(DlgInfo->hwnd, GWL_USERDATA);
			if (cInfo)
				if (cInfo->viewPlatforms[PLATFORM_APRSISCE] = !cInfo->viewPlatforms[PLATFORM_APRSISCE])
				{	cInfo->viewBits |= VIEW_PLATFORMS;
					cInfo->viewBits &= ~VIEW_ALL;
				}
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.Total);
		}
		break;
		case IDC_APRSISDR:
		if (HIWORD(wp)==BN_CLICKED)
		{	VIEW_COUNTS_S Counts;
			CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(DlgInfo->hwnd, GWL_USERDATA);
			if (cInfo)
				if (cInfo->viewPlatforms[PLATFORM_APRSISDR] = !cInfo->viewPlatforms[PLATFORM_APRSISDR])
				{	cInfo->viewBits |= VIEW_PLATFORMS;
					cInfo->viewBits &= ~VIEW_ALL;
				}
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.Total);
		}
		break;
		case IDC_APRSIS32:
		if (HIWORD(wp)==BN_CLICKED)
		{	VIEW_COUNTS_S Counts;
			CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(DlgInfo->hwnd, GWL_USERDATA);
			if (cInfo)
				if (cInfo->viewPlatforms[PLATFORM_APRSIS32] = !cInfo->viewPlatforms[PLATFORM_APRSIS32])
				{	cInfo->viewBits |= VIEW_PLATFORMS;
					cInfo->viewBits &= ~VIEW_ALL;
				}
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.Total);
		}
		break;
		case IDB_CLEAR:
		{	VIEW_COUNTS_S Counts;
			CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(DlgInfo->hwnd, GWL_USERDATA);
			*DlgInfo->pViewBits = 0;
			memset(cInfo->viewPlatforms, 0, sizeof(cInfo->viewPlatforms));
			memset(cInfo->viewSymbols, 0, sizeof(cInfo->viewSymbols));
			// PostMessage(hdlg, WM_SET_CONTROLS, 0, 0);
			SetViewLastAccess(hdlg,(HWND)lp,&Counts,&Counts.Total);
			break;
		}
		case IDB_CANCEL:
#ifdef UNDER_CE
			EndDialog(hdlg, IDCANCEL);
#else
			DestroyWindow(hdlg);
#endif
			return FALSE;
		}
		PostMessage(hdlg, WM_SET_CONTROLS, 0, 0);
		if (DlgInfo) PostMessage(DlgInfo->hwnd, DlgInfo->msgRefresh, 0, 0);
		break;
	case WM_CLOSE:
#ifdef UNDER_CE
		EndDialog(hdlg, IDCANCEL);
#else
		DestroyWindow(hdlg);
#endif
		return 0;
#ifndef UNDER_CE
	case WM_DESTROY:
		gModelessDialog = NULL;
		if (DlgInfo) free(DlgInfo);
		break;
	case WM_ACTIVATE:
		if (!wp) gModelessDialog = NULL;
		else gModelessDialog = hdlg;
		break;
#endif
	}
	return FALSE;
}

HWND PopupViewChooser(HWND hwnd, int msgRefresh, unsigned __int64 *pViewBits)
{	VIEW_CHOOSER_DLG_INFO_S *Working = (VIEW_CHOOSER_DLG_INFO_S *)calloc(1,sizeof(*Working));
	BOOL Result = FALSE;
	HWND hwndDlg = NULL;

	Working->hwnd = hwnd;
	Working->msgRefresh = msgRefresh;
	Working->Initialized = FALSE;
	Working->pViewBits = pViewBits;
//	Working->Original = *pPaths;
//	Working->pLive = pPaths;

#ifdef UNDER_CE
	DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_VIEW), hwnd, ViewChooserDlgProc, (LPARAM)Working);
#else
	hwndDlg = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_VIEW), hwnd, ViewChooserDlgProc, (LPARAM)Working);
	ShowWindow(hwndDlg, SW_SHOW);
#endif

	return hwndDlg;
}

static void FixUpViewMenu(CLIENT_INFO_S *cInfo, HMENU hmenu, UINT id)
{
	if (id == ID_VIEW_ALL)	/* This is also in the tracker window procedure */
	{	VIEW_COUNTS_S Counts;

		CalculateViewCounts(&Counts);

		NumberMenuItem(hmenu, ID_VIEW_ALL, CloseStationCount);
		NumberMenuItem(hmenu, ID_VIEW_AMBIGUOUS, Counts.Ambig);
		NumberMenuItem(hmenu, ID_VIEW_BUDDIES, Counts.Buddies);
		NumberMenuItem(hmenu, ID_VIEW_FREQSPEC, Counts.FreqSpec);
		NumberMenuItem(hmenu, ID_VIEW_FREQUENCIES, Counts.Frequencies);
		NumberMenuItem(hmenu, ID_VIEW_DUPLICATES, Counts.Dupes);
		NumberMenuItem(hmenu, ID_VIEW_ALTITUDES, Counts.Alts);
		NumberMenuItem(hmenu, ID_VIEW_INVALIDS, Counts.Invalids);
		NumberMenuItem(hmenu, ID_VIEW_MESSAGEABLE, Counts.Msgable);
		NumberMenuItem(hmenu, ID_VIEW_NICKNAMES, Counts.Nicks);
		NumberMenuItem(hmenu, ID_VIEW_NWS, Counts.NWSObj);
		NumberMenuItem(hmenu, ID_VIEW_OBJECTS, Counts.Objs);
		NumberMenuItem(hmenu, ID_VIEW_SHRIEKS, Counts.Shrieks);
		NumberMenuItem(hmenu, ID_VIEW_TELEMETRY, Counts.Telem);
		NumberMenuItem(hmenu, ID_VIEW_TRACKS, Counts.Track);
		NumberMenuItem(hmenu, ID_VIEW_PATHS, Counts.Path);

		CheckMenuItem (hmenu, ID_VIEW_ALL, cInfo->viewBits&VIEW_ALL?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_NONE, cInfo->viewBits==0?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_ALTITUDES, cInfo->viewBits&VIEW_ALTITUDES?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_AMBIGUOUS, cInfo->viewBits&VIEW_AMBIGUOUS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_BUDDIES, cInfo->viewBits&VIEW_BUDDIES?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_DUPLICATES, cInfo->viewBits&VIEW_DUPLICATES?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_FREQSPEC, cInfo->viewBits&VIEW_FREQSPEC?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_FREQUENCIES, cInfo->viewBits&VIEW_FREQUENCIES?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_INVALIDS, cInfo->viewBits&VIEW_INVALIDS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_MESSAGEABLE, cInfo->viewBits&VIEW_MESSAGEABLE?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_NICKNAMES, cInfo->viewBits&VIEW_NICKNAMES?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_NWS, cInfo->viewBits&VIEW_NWS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_OBJECTS, cInfo->viewBits&VIEW_OBJECTS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_SHRIEKS, cInfo->viewBits&VIEW_SHRIEKS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_TELEMETRY, cInfo->viewBits&VIEW_TELEMETRY?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_TRACKS, cInfo->viewBits&VIEW_TRACKS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_PATHS, cInfo->viewBits&VIEW_PATHS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_RFID, cInfo->viewBits&VIEW_RFID?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_ANSRVR_MEMBERS, cInfo->viewBits&VIEW_ANSRVR_MEMBERS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_MARINE, cInfo->viewBits&VIEW_MARINE?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_MOBILE, cInfo->viewBits&VIEW_MOBILE?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_WEATHER, cInfo->viewBits&VIEW_WEATHER?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_FLIGHT, cInfo->viewBits&VIEW_FLIGHT?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_CUSTOM, cInfo->viewBits&VIEW_CUSTOM?MF_CHECKED:MF_UNCHECKED);

#ifdef OLD_WAY
		{	TCHAR Buff[80];
			MENUITEMINFO mi = {0};
			mi.cbSize = sizeof(mi);
			mi.fMask = MIIM_TYPE;
			mi.fType = MFT_STRING;
			mi.dwTypeData = &Buff[0];
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("All (%d)"), (long) RFAll);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_ALL, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("Direct (%d)"), (long) RFDirect);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_DIRECT, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("Local (%d)"), (long) RFLocal);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_LOCAL, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("3rd Party (%d)"), (long) RF3rd);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_THIRD, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("RF Only (%d)"), (long) RFOnly);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_ONLY, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("RF + -IS (%d)"), (long) RFIS);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_INTERNET, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("-IS Only (%d)"), (long) ISOnly);
			SetMenuItemInfo(hmenu, ID_VIEW_INTERNET_ONLY, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("Digipeater (%d)"), (long) RFDigi);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_DIGI, FALSE, &mi);
			StringCbPrintf(Buff, sizeof(Buff),
							TEXT("IGate (%d)"), (long) IGate);
			SetMenuItemInfo(hmenu, ID_VIEW_RF_IGATE, FALSE, &mi);
#ifdef FOR_INFO_ONLY
		{	unsigned long RFAll=0, RFDirect=0, RFLocal=0, RF3rd=0;
		unsigned long RFOnly=0, RFIS=0, ISOnly=0;
		unsigned long RFDigi=0, IGate=0, 
    BEGIN
        MENUITEM "All",                         ID_VIEW_RF_ALL
        MENUITEM "Direct",                      ID_VIEW_RF_DIRECT
        MENUITEM "Local",                       ID_VIEW_RF_LOCAL
        MENUITEM "3rd Party",                   ID_VIEW_RF_THIRD
	END
#endif
		}
#endif
		NumberMenuItem(hmenu, ID_VIEW_RF_ALL, Counts.RFAll);
		NumberMenuItem(hmenu, ID_VIEW_RF_DIRECT, Counts.RFDirect);
		NumberMenuItem(hmenu, ID_VIEW_RF_LOCAL, Counts.RFLocal);
		NumberMenuItem(hmenu, ID_VIEW_RF_THIRD, Counts.RF3rd);
		if (ActiveConfig.RFPorts.Count)
		{	EnableMenuItem(hmenu, ID_VIEW_RF_ALL, MF_ENABLED);
			EnableMenuItem(hmenu, ID_VIEW_RF_DIRECT, MF_ENABLED);
			EnableMenuItem(hmenu, ID_VIEW_RF_LOCAL, MF_ENABLED);
			EnableMenuItem(hmenu, ID_VIEW_RF_THIRD, MF_ENABLED);
			CheckMenuItem (hmenu, ID_VIEW_RF_ALL, cInfo->viewBits&VIEW_RF_ALL?MF_CHECKED:MF_UNCHECKED);
			CheckMenuItem (hmenu, ID_VIEW_RF_DIRECT, cInfo->viewBits&VIEW_RF_DIRECT?MF_CHECKED:MF_UNCHECKED);
			CheckMenuItem (hmenu, ID_VIEW_RF_LOCAL, cInfo->viewBits&VIEW_RF_LOCAL?MF_CHECKED:MF_UNCHECKED);
			CheckMenuItem (hmenu, ID_VIEW_RF_THIRD, cInfo->viewBits&VIEW_RF_THIRD?MF_CHECKED:MF_UNCHECKED);
		} else
		{	EnableMenuItem(hmenu, ID_VIEW_RF_ALL, MF_GRAYED);
			EnableMenuItem(hmenu, ID_VIEW_RF_DIRECT, MF_GRAYED);
			EnableMenuItem(hmenu, ID_VIEW_RF_LOCAL, MF_GRAYED);
			EnableMenuItem(hmenu, ID_VIEW_RF_THIRD, MF_GRAYED);
		}

		NumberMenuItem(hmenu, ID_VIEW_RF_ONLY, Counts.RFOnly);
		NumberMenuItem(hmenu, ID_VIEW_RF_INTERNET, Counts.RFIS);
		NumberMenuItem(hmenu, ID_VIEW_INTERNET_ONLY, Counts.ISOnly);
		NumberMenuItem(hmenu, ID_VIEW_RF_DIGI, Counts.RFDigi);
		NumberMenuItem(hmenu, ID_VIEW_RF_IGATE, Counts.IGate);
		CheckMenuItem (hmenu, ID_VIEW_RF_ONLY, cInfo->viewBits&VIEW_RF_ONLY?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_RF_INTERNET, cInfo->viewBits&VIEW_RF_INTERNET?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_INTERNET_ONLY, cInfo->viewBits&VIEW_INTERNET_ONLY?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_RF_IGATE, cInfo->viewBits&VIEW_RF_IGATE?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_RF_DIGI, cInfo->viewBits&VIEW_RF_DIGI?MF_CHECKED:MF_UNCHECKED);
	}
	if (id == ID_VIEW_MICE_NONE)	/* First element of the sub menu */
	{	unsigned long p=0;
		int cMenuItems = GetMenuItemCount(hmenu); 
		for (p=cMenuItems-1; p>=1; p--)	/* Keep 1 entries */
			DeleteMenu(hmenu, p, MF_BYPOSITION);
		if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
		if (PopulateMicEMenu(cInfo, hmenu, 1))
			EnableMenuItem (hmenu, ID_VIEW_MICE_NONE, MF_ENABLED);
		else EnableMenuItem (hmenu, ID_VIEW_MICE_NONE, MF_GRAYED);
	}
	if (id == ID_VIEW_PLATFORMS_NONE)	/* First element of the sub menu */
	{	unsigned long p=0;
	    int cMenuItems = GetMenuItemCount(hmenu); 
		for (p=cMenuItems-1; p>=1; p--)	/* Keep one entry */
			DeleteMenu(hmenu, p, MF_BYPOSITION);
		if (PopulatePlatformMenu(cInfo, hmenu))
			EnableMenuItem (hmenu, ID_VIEW_PLATFORMS_NONE, MF_ENABLED);
		else EnableMenuItem (hmenu, ID_VIEW_PLATFORMS_NONE, MF_GRAYED);
	}
	if (id == ID_VIEW_SHRIEKS_NONE)	/* First element of the sub menu */
	{	unsigned long p=0;
	    int cMenuItems = GetMenuItemCount(hmenu); 
		for (p=cMenuItems-1; p>=1; p--)	/* Keep 1 entries */
			DeleteMenu(hmenu, p, MF_BYPOSITION);
		{	TCHAR Name[80];
			StringCbPrintf(Name, sizeof(Name), TEXT("None (%ld/%ld)"), ShriekCount, ARRAYSIZE(Shrieks));
			DeleteMenu(hmenu, 0, MF_BYPOSITION);
			InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING, ID_VIEW_SHRIEKS_NONE, Name);
		}
		if (PopulateShriekMenu(cInfo, hmenu, 1))
			EnableMenuItem (hmenu, ID_VIEW_SHRIEKS_NONE, MF_ENABLED);
		else EnableMenuItem (hmenu, ID_VIEW_SHRIEKS_NONE, MF_GRAYED);
	}
	if (id == ID_VIEW_SYMBOLS_NONE)	/* First element of the sub menu */
	{	unsigned long p=0;
	    int cMenuItems = GetMenuItemCount(hmenu); 
		for (p=cMenuItems-1; p>=7; p--)	/* Keep 7 entries */
			DeleteMenu(hmenu, p, MF_BYPOSITION);
		{	TCHAR Name[80];
			StringCbPrintf(Name, sizeof(Name), TEXT("None (%ld)"), CloseStationCount);
			DeleteMenu(hmenu, 0, MF_BYPOSITION);
			InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING, ID_VIEW_SYMBOLS_NONE, Name);
		}
		if (PopulateSymbolMenu(cInfo, hmenu, 7))
			EnableMenuItem (hmenu, ID_VIEW_SYMBOLS_NONE, MF_ENABLED);
		else EnableMenuItem (hmenu, ID_VIEW_SYMBOLS_NONE, MF_GRAYED);
	}

	EnableMenuItem(hmenu, ID_VIEW_ECHOLINKS, ActiveConfig.Enables.Internet?MF_ENABLED:MF_GRAYED);
	CheckMenuItem (cInfo->hMenu, ID_VIEW_ECHOLINKS, cInfo->viewBits&VIEW_ECHOLINKS?MF_CHECKED:MF_UNCHECKED);

}

static void ProcessViewMenu(HWND hwnd, CLIENT_INFO_S *cInfo, UINT id)
{	BOOL DidOne = TRUE;

	switch (id)
	{
	case ID_VIEW_CHOOSER:
		if (cInfo->hwndViewChooser && IsWindow(cInfo->hwndViewChooser))
			ShowWindow(cInfo->hwndViewChooser, SW_SHOW);
		else cInfo->hwndViewChooser = PopupViewChooser(hwnd, WM_REFRESH_CIRCLE, &cInfo->viewBits);
		break;
	case ID_VIEW_ALL:
		cInfo->viewBits ^= VIEW_ALL;
		break;
	case ID_VIEW_NONE:
	{	char *ViewString = MakeViewString(cInfo, cInfo->viewBits, TRUE);
		size_t Len = sizeof(TCHAR)*(strlen(ViewString)+80);
		TCHAR *Buffer = (TCHAR*)malloc(Len);
		StringCbPrintf(Buffer, Len, TEXT("Really clear the following?\n\n%S"), ViewString);
		if ((!cInfo->viewBits || cInfo->viewBits == VIEW_ALL)
		|| MessageBox(hwnd, Buffer, TEXT("View NONE"), MB_YESNO | MB_ICONQUESTION) == IDYES)
		{	cInfo->viewBits = 0;
			cInfo->viewShrieks = 0;
			memset(cInfo->viewMicE, 0, sizeof(cInfo->viewMicE));
			memset(cInfo->viewPlatforms, 0, sizeof(cInfo->viewPlatforms));
			memset(cInfo->viewSymbols, 0, sizeof(cInfo->viewSymbols));
		}
		free(Buffer); free(ViewString);
		break;
	}
#ifdef OLD_WAY
	case ID_VIEW_ALTITUDES:
		cInfo->viewBits ^= VIEW_ALTITUDES;
		if (cInfo->viewBits & VIEW_ALTITUDES) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_AMBIGUOUS:
		cInfo->viewBits ^= VIEW_AMBIGUOUS;
		if (cInfo->viewBits & VIEW_AMBIGUOUS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_BUDDIES:
		cInfo->viewBits ^= VIEW_BUDDIES;
		if (cInfo->viewBits & VIEW_BUDDIES) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_DUPLICATES:
		cInfo->viewBits ^= VIEW_DUPLICATES;
		if (cInfo->viewBits & VIEW_DUPLICATES) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_FREQSPEC:
		cInfo->viewBits ^= VIEW_FREQSPEC;
		if (cInfo->viewBits & VIEW_FREQSPEC) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_FREQUENCIES:
		cInfo->viewBits ^= VIEW_FREQUENCIES;
		if (cInfo->viewBits & VIEW_FREQUENCIES) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_INVALIDS:
		cInfo->viewBits ^= VIEW_INVALIDS;
		if (cInfo->viewBits & VIEW_INVALIDS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_MESSAGEABLE:
		cInfo->viewBits ^= VIEW_MESSAGEABLE;
		if (cInfo->viewBits & VIEW_MESSAGEABLE) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_NICKNAMES:
		cInfo->viewBits ^= VIEW_NICKNAMES;
		if (cInfo->viewBits & VIEW_NICKNAMES) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_NWS:
		cInfo->viewBits ^= VIEW_NWS;
		if (cInfo->viewBits & VIEW_NWS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_OBJECTS:
		cInfo->viewBits ^= VIEW_OBJECTS;
		if (cInfo->viewBits & VIEW_OBJECTS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_SKYWARN:
		cInfo->viewBits ^= VIEW_SKYWARN;
		if (cInfo->viewBits & VIEW_SKYWARN) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_TELEMETRY:
		cInfo->viewBits ^= VIEW_TELEMETRY;
		if (cInfo->viewBits & VIEW_TELEMETRY) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_TRACKS:
		cInfo->viewBits ^= VIEW_TRACKS;
		if (cInfo->viewBits & VIEW_TRACKS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_PATHS:
		cInfo->viewBits ^= VIEW_PATHS;
		if (cInfo->viewBits & VIEW_PATHS) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_RFID:
		cInfo->viewBits ^= VIEW_RFID;
		if (cInfo->viewBits & VIEW_RFID) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_MOBILE:
		cInfo->viewBits ^= VIEW_MOBILE;
		if (cInfo->viewBits & VIEW_MOBILE) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_WEATHER:
		cInfo->viewBits ^= VIEW_WEATHER;
		if (cInfo->viewBits & VIEW_WEATHER) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_FLIGHT:
		cInfo->viewBits ^= VIEW_FLIGHT;
		if (cInfo->viewBits & VIEW_FLIGHT) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_CUSTOM:
		cInfo->viewBits ^= VIEW_CUSTOM;
		if (cInfo->viewBits & VIEW_CUSTOM) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_RF_ALL:
		cInfo->viewBits ^= VIEW_RF_ALL;
		if (cInfo->viewBits & VIEW_RF_ALL) cInfo->viewBits &= ~VIEW_ALL;
		break;
	case ID_VIEW_RF_INTERNET:
	{	cInfo->viewBits ^= VIEW_RF_INTERNET;
		if (cInfo->viewBits & VIEW_RF_INTERNET) cInfo->viewBits &= ~VIEW_ALL;
		break;
	}
	case ID_VIEW_RF_IGATE:
	{	cInfo->viewBits ^= VIEW_RF_IGATE;
		if (cInfo->viewBits & VIEW_RF_IGATE) cInfo->viewBits &= ~VIEW_ALL;
		break;
	}
	case ID_VIEW_RF_DIGI:
	{	cInfo->viewBits ^= VIEW_RF_DIGI;
		if (cInfo->viewBits & VIEW_RF_DIGI) cInfo->viewBits &= ~VIEW_ALL;
		break;
	}
	case ID_VIEW_INTERNET_ONLY:
	{	cInfo->viewBits ^= VIEW_INTERNET_ONLY;
		if (cInfo->viewBits & VIEW_INTERNET_ONLY) cInfo->viewBits &= ~VIEW_ALL;
		break;
	}
#endif
	case ID_VIEW_RF_DIRECT:
		cInfo->viewBits ^= VIEW_RF_DIRECT;
		if (cInfo->viewBits & VIEW_RF_DIRECT) cInfo->viewBits &= ~VIEW_ALL;
		if (cInfo->viewBits & VIEW_RF_DIRECT) cInfo->viewBits &= ~VIEW_RF_ALL;
		if (cInfo->viewBits & VIEW_RF_DIRECT) cInfo->viewBits &= ~VIEW_RF_LOCAL;
		break;
	case ID_VIEW_RF_LOCAL:
		cInfo->viewBits ^= VIEW_RF_LOCAL;
		if (cInfo->viewBits & VIEW_RF_LOCAL) cInfo->viewBits &= ~VIEW_ALL;
		if (cInfo->viewBits & VIEW_RF_LOCAL) cInfo->viewBits &= ~VIEW_RF_ALL;
		break;
	case ID_VIEW_RF_THIRD:
	{	cInfo->viewBits ^= VIEW_RF_THIRD;
		if (cInfo->viewBits & VIEW_RF_THIRD) cInfo->viewBits &= ~VIEW_ALL;
		if (cInfo->viewBits & VIEW_RF_THIRD) cInfo->viewBits &= ~VIEW_RF_ALL;
		break;
	}
	case ID_VIEW_RF_ONLY:
	{	cInfo->viewBits ^= VIEW_RF_ONLY;
		if (cInfo->viewBits & VIEW_RF_ONLY) cInfo->viewBits &= ~VIEW_ALL;
		if (cInfo->viewBits & VIEW_RF_ONLY) cInfo->viewBits &= ~VIEW_RF_ALL;
		break;
	}
	case ID_VIEW_MICE_NONE:
	{	memset(cInfo->viewMicE, 0, sizeof(cInfo->viewMicE));
		cInfo->viewBits &= ~VIEW_MICE;
		break;
	}
	case ID_VIEW_PLATFORMS_NONE:
	{	memset(cInfo->viewPlatforms, 0, sizeof(cInfo->viewPlatforms));
		cInfo->viewBits &= ~VIEW_PLATFORMS;
		break;
	}
	case ID_VIEW_SYMBOLS_NONE:
	{	memset(cInfo->viewSymbols, 0, sizeof(cInfo->viewSymbols));
		cInfo->viewBits &= ~VIEW_SYMBOLS;
		break;
	}
	case ID_VIEW_SHRIEKS_NONE:
		cInfo->viewShrieks = 0;
		cInfo->viewBits &= ~VIEW_SHRIEKS;
		break;
	default:
		if (ProcessViewMicEMenu(hwnd, cInfo,id))
		{	InvalidateStationPoints(cInfo->Index, "ViewMicEChanged", TRUE);
//			cInfo->viewBitsPainted = ~cInfo->viewBitsPainted;
		} else if (ProcessViewPlatformMenu(hwnd, cInfo,id))
		{	InvalidateStationPoints(cInfo->Index, "ViewPlatformsChanged", TRUE);
//			cInfo->viewBitsPainted = ~cInfo->viewBitsPainted;
		} else if (ProcessViewSymbolMenu(hwnd, cInfo,id))
		{	InvalidateStationPoints(cInfo->Index, "ViewSymbolsChanged", TRUE);
//			cInfo->viewBitsPainted = ~cInfo->viewBitsPainted;
		} else if (ProcessViewShriekMenu(hwnd, cInfo,id))
		{	InvalidateStationPoints(cInfo->Index, "ViewShrieksChanged", TRUE);
//			cInfo->viewBitsPainted = ~cInfo->viewBitsPainted;
		} else
		{	int i;
			DidOne = FALSE;	/* Nothing to see here, move along */
			for (i=0; i<ARRAYSIZE(ViewMenuBits); i++)
			{	if (ViewMenuBits[i].menuID == id)
				{	cInfo->viewBits ^= ViewMenuBits[i].mask;
					if (cInfo->viewBits & ViewMenuBits[i].mask)
						cInfo->viewBits &= ~VIEW_ALL;
					DidOne = TRUE;
					break;
				}
			}
		}
	}
	if (DidOne)
	{	if (cInfo->hwndViewChooser && IsWindow(cInfo->hwndViewChooser))
			PostMessage(cInfo->hwndViewChooser, WM_SET_CONTROLS, 0, 0);
		InvalidateCircle(hwnd, TRUE, TRUE);
//		char *String = MakeViewString(cInfo->viewBits);
//		TraceLog("Menu", TRUE, hwnd, "View[%s]:%s\n", MakeViewBits(String)==cInfo->viewBits?"OK":"MISMATCH",String);
		{
#ifdef UNDER_CE
			RECT rc;
			GetWindowRect(hwnd, &rc);
			SaveMainWindowRect(hwnd, &rc);
#else
			WINDOWPLACEMENT wp;
			GetWindowPlacement(hwnd, &wp);
			if (wp.showCmd == 1)
			{	if (!cInfo->Index)	/* Main window, save position & views */
					SaveMainWindowRect(hwnd, &wp.rcNormalPosition);
				else SaveTrackerWindowRect(hwnd, cInfo);
			}
#endif
		}
	}
}

#ifndef UNDER_CE
static void CopyShadowToClipboard(HWND hwnd)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	InvalidateRect(hwnd, NULL, FALSE);
	UpdateWindow(hwnd);
	if (cInfo->hShadowMap)	// If we have a shadow of the main screen
	{	int Size = cInfo->shadowWidth * cInfo->shadowHeight * 4;	// Total bytes for bits
		HANDLE hMem = GlobalAlloc(GHND, sizeof(BITMAPINFO)+3+Size);	// Memory to hold bitmap info and bits
		if (hMem)
		{	BITMAPINFO *bmi = (BITMAPINFO *) GlobalLock(hMem);
			if (bmi)
			{	HDC hdcWin = GetDC(hwnd);
				HDC hdcShadow = CreateCompatibleDC(hdcWin);
				HGDIOBJ hOrgShadow = SelectObject(hdcShadow, cInfo->hShadowMap);
				HDC hdcBitmap = CreateCompatibleDC(hdcWin);
				HBITMAP hbm;
				VOID *pvBitsShadow;          // pointer to DIB section 

				bmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
				bmi->bmiHeader.biWidth = cInfo->shadowWidth;
				bmi->bmiHeader.biHeight = cInfo->shadowHeight;
				bmi->bmiHeader.biPlanes = 1;
				bmi->bmiHeader.biBitCount = 32;         // four 8-bit components 
				bmi->bmiHeader.biCompression = BI_RGB;
				bmi->bmiHeader.biSizeImage = Size;

				// create our DIB section and select the bitmap into the dc 
				hbm = CreateDIBSection(hdcBitmap, bmi, DIB_RGB_COLORS, &pvBitsShadow, NULL, 0x0);
				if (hbm)
				{	HGDIOBJ hOrgBitmap = SelectObject(hdcBitmap, hbm);
					if (BitBlt(hdcBitmap, 0, 0, cInfo->shadowWidth, cInfo->shadowHeight, hdcShadow, 0, 0, SRCCOPY))
					{	VOID *pvBitsBitmap = (VOID *)(bmi+1);
						memcpy(pvBitsBitmap, pvBitsShadow, Size);	// Move bits into global memory
						SelectObject(hdcBitmap, hOrgBitmap);
						GlobalUnlock(hMem);
						if (OpenClipboard(hwnd))
						{	EmptyClipboard();
							if (!SetClipboardData(CF_DIB, hMem))
								GlobalFree(hMem);
							CloseClipboard();
						} else GlobalFree(hMem);
					} else SelectObject(hdcBitmap, hOrgBitmap);
				}
				DeleteDC(hdcBitmap);
				SelectObject(hdcShadow, hOrgShadow);
				DeleteDC(hdcShadow);
				ReleaseDC(hwnd, hdcWin);
			}
		}
	}
}
#endif

static void ProcessWmChar(HWND hwnd, WPARAM wp)
{
	switch (wp)
	{
	case 1:	/* Ctrl-A (About) */
		PostMessage(hwnd, WM_COMMAND, ID_ABOUT, 0);
		break;
#ifndef UNDER_CE
	case 3:	/* Ctrl-C (Copy) */
		CopyShadowToClipboard(hwnd);
		break;
#endif
	case 6:	/* Ctrl-F - Find */
		PostMessage(hwnd, WM_COMMAND, ID_SCREEN_TRACK_FIND, 0);
		break;
	case 20:	/* Ctrl-T */
		PostMessage(hwnd, WM_COMMAND, ID_TRANSMIT, 0);
		break;
	case 24:	/* Ctrl-X */
		PostMessage(hwnd, WM_COMMAND, ID_EXIT, 0);
		break;
	case '<':
	case ',':
		PostMessage(hwnd, WM_COMMAND, ID_FADE_OUT, 0);
		break;
	case '>':
	case '.':
		PostMessage(hwnd, WM_COMMAND, ID_FADE_IN, 0);
		break;
	case '+':
	case '=':
		PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);
		break;
	case '-':
		PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);
		break;
	case 'c':
	case 'C':
		PostMessage(hwnd, WM_COMMAND, ID_SCREEN_CENTER_TRACKED, 0);
		break;
	case 'l':
	case 'L':
		PostMessage(hwnd, WM_COMMAND, ID_SCREEN_TRACK_LOCKED, 0);
		break;
	case 'm':
	case 'M':
		PostMessage(hwnd, WM_COMMAND, ID_SCREEN_TRACK_ME, 0);
		break;
	case 'p':
	case 'P':
		PostMessage(hwnd, WM_COMMAND, ID_VIEW_PREFERRED_RESTORE, 0);
		break;
	case 't':
	case 'T':	/* Transmit */
		PostMessage(hwnd, WM_COMMAND, ID_TRANSMIT, 0);
		break;
	}
}

static void ProcessSavedPosits(char *Phase, HWND hwnd, HWND hwndProgress,
								int Width, int Range,
								__int64 secDown, __int64 msNow,
								SYSTEMTIME stSystem)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
	int Last=0;
	unsigned long p;
	__int64 msStart = llGetMsec(), msElapsed;

	for (p=0; p<ActiveConfig.SavedPosits.Count; p++)
	{	__int64 Seconds = DeltaSeconds(&ActiveConfig.SavedPosits.Entries[p].time, &stSystem);
		if (Seconds > 14*24*60*60)	/* More than 2 weeks ago? */
		{	char Temp[80];
			TraceLogThread("SavedPosit", TRUE, "%s AGO for %s\n",
							FormatDeltaTime(Seconds, Temp, sizeof(Temp)),
							ActiveConfig.SavedPosits.Entries[p].string);
		} else if (Seconds > 0)	/* Nothing back in time */
		{	__int64 msWhen = msNow - Seconds*1000 - secDown*1000;	/* Back to msec */
			if (msWhen > 0)	/* Again, nothing back in time */
			{	int OrgLen = strlen(ActiveConfig.SavedPosits.Entries[p].string);
				if (!AprsLogPacket("SavedPosit", hwnd, cInfo, ActiveConfig.SavedPosits.Entries[p].string, FALSE, APRSISWP,
							msWhen, &ActiveConfig.SavedPosits.Entries[p].time, TRUE))
					TraceLogThread("SavedPosit", TRUE, "No Station Created for %s\n", ActiveConfig.SavedPosits.Entries[p].string);
				if (strlen(ActiveConfig.SavedPosits.Entries[p].string) != OrgLen)
					TraceLogThread("SavedPosit", TRUE, "%ld != %ld from %s\n",
									(long) strlen(ActiveConfig.SavedPosits.Entries[p].string), (long) OrgLen, ActiveConfig.SavedPosits.Entries[p].string);
			}
			else
			{	SYSTEMTIME *st = &ActiveConfig.SavedPosits.Entries[p].time;
				TraceLogThread("SavedPosit", TRUE, "%ldmsec from Sec(%ld)(%04ld-%02ld-%02ld %02ld:%02ld:%02ld) Down(%ld) for %s\n",
					(long) -msWhen, (long) Seconds,
					st->wYear, st->wMonth, st->wDay,
					st->wHour, st->wMinute, st->wSecond,
					(long) secDown,
					ActiveConfig.SavedPosits.Entries[p].string);
			}
		}
		else
		{	char Temp[80];
			TraceLogThread("SavedPosit", TRUE, "%s FUTURE for %s\n",
							FormatDeltaTime(-Seconds, Temp, sizeof(Temp)),
							ActiveConfig.SavedPosits.Entries[p].string);
		}

		if (hwndProgress)
		{	int This;
#ifndef UNDER_CE
//				COLORREF bar = GetScaledRGColor(p, 0, ActiveConfig.SavedPosits.Count);
//				SendMessage(hwndProgress, PBM_SETBARCOLOR, 0, bar);
#endif
			This = p+1;
			if (This*Width/Range != Last)
			{	SendMessage(hwndProgress, PBM_SETPOS, This, 0);
				if (This*Width/Range != Last)
				{	msElapsed = llGetMsec() - msStart;
					TraceLog("Config", FALSE, hwnd, "%sLoaded %ld SavedPosits in %ldmsec or %.2lf each (%ld Stations, %ld/%ld Coords)\n",
							 Phase, (long) p+1, (long) msElapsed,
							 ((double)msElapsed)/(p+1),
							 (long) CloseStationCount,
							 (long) CoordCount, (long) CoordSize);
				}
				Last = This*Width/Range;
				SpinMessages(hwnd);
			}
		}
	}
	msElapsed = llGetMsec() - msStart;
	TraceLog("Config", TRUE, hwnd, "%sLoaded %ld SavedPosits in %ldmsec or %.2lf each (%ld Stations, %ld/%ld Coords)\n",
			 Phase, (long) ActiveConfig.SavedPosits.Count, (long) msElapsed,
			 ((double)msElapsed)/ActiveConfig.SavedPosits.Count,
			 (long) CloseStationCount,
			 (long) CoordCount, (long) CoordSize);
}

void RestoreSavedPosits(HWND hwnd)
{
	if (ActiveConfig.SavedPosits.Count)
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		SYSTEMTIME stSystem;
		char DownTime[32];
		__int64 saveView = cInfo->viewBits;
		__int64 secDown = SecondsSince(&ActiveConfig.stLastSaved);
		__int64 msNow = llGetMsec();
		HWND hwndProgress = NULL;
		int Width, Range, Last=0;
		RECT rc;

		if (secDown < 0) secDown = 0;	/* Not allowed to go back in time */

TraceLog("Restore", TRUE, hwnd, "Loading %ld SavedPosits after %s downtime\n",
		(long) ActiveConfig.SavedPosits.Count, FormatDeltaTime(secDown, DownTime, sizeof(DownTime)));

		GetSystemTime(&stSystem);
		cInfo->viewBits = 0;
		PaintingStationsFrozen = TRUE;	/* Don't want to scroll */
		GetWindowRect(hwnd, &rc);
		Width = rc.right - rc.left;
		hwndProgress = CreateWindow(
						PROGRESS_CLASS,		/*The name of the progress class*/
						NULL, 			/*Caption Text*/
						CCS_TOP | WS_POPUP /*| WS_CHILD */| WS_VISIBLE
						| WS_BORDER /*| WS_CLIPSIBLINGS*/
						| WS_EX_STATICEDGE
						| PBS_SMOOTH,	/*Styles*/
						rc.left, 			/*X co-ordinates*/
						(rc.bottom+rc.top)/2-15+0*30, 			/*Y co-ordinates*/
						Width, 			/*Width*/
						30, 			/*Height*/
						NULL/*hwnd*/, 			/*Parent HWND*/
						(HMENU) NULL/*1*/, 	/*The Progress Bar's ID*/
						g_hInstance,		/*The HINSTANCE of your program*/ 
						NULL);			/*Parameters for main window*/
		if (!hwndProgress) TraceLogThread("OSM", TRUE, "CreateWindow(Progress) Failed with %ld\n", GetLastError());
		else
		{	GetWindowRect(hwndProgress,&rc);
			TraceError(hwnd, "Progress[%ld] window created %p @ %ld %ld %ld %ld\n", ActiveConfig.SavedPosits.Count, hwndProgress, (long) rc.left, (long) rc.top, (long) rc.right, (long) rc.bottom);
			Range = ActiveConfig.SavedPosits.Count;
			SendMessage(hwndProgress, PBM_SETRANGE32, 0, Range);
			SendMessage(hwndProgress, PBM_SETPOS, 0, 0);
			SetWindowPos(hwndProgress, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_DRAWFRAME);
		}
		ProcessSavedPosits("", hwnd, hwndProgress, Width, Range,
							secDown, msNow, stSystem);

		if (ActiveConfig.SavedPositPaths)
		{
			SendMessage(hwndProgress, PBM_SETPOS, 0, 0);	/* Reset progress */
			ProcessSavedPosits("Re", hwnd, hwndProgress, Width, Range,
								secDown, msNow, stSystem);
		} else
		{	for (unsigned long s=0; s<CloseStationCount; s++)
				FreePaths(pCloseStations[s]);
		}
		if (hwndProgress) DestroyWindow(hwndProgress);

		EmptyTimedStringList(&ActiveConfig.SavedPosits);	/* Don't need to sit on the RAM */
		PaintingStationsFrozen = FALSE;	/* OK to scroll now */
		if (PendingStationsCount)	/* Buffer any? */
		{	RecoverPendingStations(hwnd);
		}
		InvalidateStations(hwnd, FALSE);
		InvalidatePortStatus(FALSE);	/* Color it normal */
		cInfo->viewBits = saveView;
		UpdateWindow(hwnd);
TraceLogThread("Restore", TRUE, "Done Loading %ld Saved Posits\n", (long) ActiveConfig.SavedPosits.Count);
	}
}

static BOOL SaveAndClose(HWND hwnd, char *What, BOOL Quiet)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
static char Buffer[256];

TraceError(hwnd, "WM_CLOSE starting %s %s\n", What, Quiet?"QUIET!":"Interactive");

	if (!cInfo->CenterTracking || cInfo->CenterStation!=MyStation)	/* Dragged or Not centered on me */
	{	ActiveConfig.Center.Latitude = cInfo->LastCenterPosition.dblLatitude;
		ActiveConfig.Center.Longitude = cInfo->LastCenterPosition.dblLongitude;
	} else ActiveConfig.Center.Latitude = ActiveConfig.Center.Longitude = 0;

	if ((LastGoodPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) == (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)
	&& (LastGoodPosition.dblLatitude != 0.0 || LastGoodPosition.dblLongitude != 0.0))
	{	ActiveConfig.Latitude = LastGoodPosition.dblLatitude;
		ActiveConfig.Longitude = LastGoodPosition.dblLongitude;
		if (LastGoodPosition.dwValidFields & GPS_VALID_ALTITUDE_WRT_SEA_LEVEL)
			ActiveConfig.Altitude = LastGoodPosition.flAltitudeWRTSeaLevel;
		else ActiveConfig.Altitude = 0;
	} else if (ActiveConfig.Latitude == 0.0 && ActiveConfig.Longitude == 0.0
	|| !IsValidLatLon(ActiveConfig.Latitude, ActiveConfig.Longitude))
	{	ActiveConfig.Latitude = cInfo->LastCenterPosition.dblLatitude;
		ActiveConfig.Longitude = cInfo->LastCenterPosition.dblLongitude;
		ActiveConfig.Altitude = 0;
	}

TraceError(hwnd, "WM_CLOSE FirstRun\n");

	if (FirstRun
	&& ((!cInfo->LastCenterPosition.dblLatitude && !cInfo->LastCenterPosition.dblLongitude)
		|| cInfo->zoom < MIN_SETTABLE_ZOOM))
	{	MessageBox(hwnd, TEXT("Please zoom in closer to make sure you are in the right place."), TEXT("Set Home Location"), MB_OK | MB_ICONQUESTION);
		return 0;
	}

TraceError(hwnd, "WM_CLOSE Lat/Lon Valid\n");

	if (!IsValidLatLon(ActiveConfig.Latitude, ActiveConfig.Longitude))
	{	MessageBox(hwnd, TEXT("Drag and Zoom to Home\n\nthen Close to Save"), TEXT("Invalid Home Location"), MB_OK | MB_ICONQUESTION);
		return 0;
	}
		
#ifdef FUTURE
TraceError(hwnd, "WM_CLOSE bulletins\n");
	if (BulletinCount
	&& MessageBox(hwnd, TEXT("You have UNREAD bulletins, Really Close?"), TEXT("WM_CLOSE"), MB_YESNO | MB_ICONQUESTION) == IDNO)
	{	return 0;	/* Let's not close just yet */
	}
#endif

TraceError(hwnd, "WM_CLOSE messages\n");
	if (MessageCount)
	{	int m;
		for (m=0; m<MessageCount; m++)
		{	if (!strcmp(Messages[m].To, CALLSIGN))
				break;
		}
		if (m<MessageCount
		&& !Quiet	/* Allowing interaction */
		&& MessageBox(hwnd, TEXT("You have UNREAD messages, Really Close?"), TEXT("WM_CLOSE"), MB_YESNO | MB_ICONQUESTION) == IDNO)
		{	DisplayMessage(hwnd, cInfo, m);
			return 0;	/* Let's not close just yet */
		}
	}

TraceError(hwnd, "WM_CLOSE pending\n");
	if (PendingMsgCount
	&& !Quiet	/* Allowing interaction */
	&& MessageBox(hwnd, TEXT("You have UnAcknowledged messages, Really Close?"), TEXT("WM_CLOSE"), MB_YESNO | MB_ICONQUESTION) == IDNO)
	{	return 0;	/* Let's not close just yet */
	}

TraceError(hwnd, "WM_CLOSE Trackers\n");

	if (!CloseTrackers(hwnd, Quiet))
	{	return 0;
	}

	if (!Quiet	/* Allowing interaction */
	&& ActiveConfig.View.ConfirmOnClose && !RestartProgram)
	{	BUTTONS_S *Buttons = CreateButtons(-1);
		AddButton(Buttons, "Yes", IDYES);
		AddButton(Buttons, "Restart", IDRETRY);
		AddButton(Buttons, "No", IDNO);
		switch (LwdMessageBox2(hwnd, TEXT("Really Close ")TEXT(PROGNAME)TEXT("?"), TEXT("WM_CLOSE"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons))
		{
		case IDNO:
		{	TraceError(hwnd, "WM_CLOSE UnConfirmed, That was CLOSE!\n");
			return 0;	/* Let's not close just yet */
		}
		case IDRETRY:
		{	TCHAR Path[MAX_PATH];
			if (GetModuleFileName(NULL, Path, MAX_PATH))
				TraceLog("Version", TRUE, hwnd, "Restarting %S\n", Path);
			RestartProgram = TRUE;
		}
		}
	}

TraceError(hwnd, "WM_CLOSE SaveGPX\n");
	if (ActiveConfig.Enables.AutoSaveGPX
	&& MyStation && MyStation->TrackCount)
		SaveTrackToGPX(hwnd, MyStation);

TraceError(hwnd, "WM_CLOSE odometer\n");
	if (!ActiveConfig.Beacon.Why
	|| TransmitOdometer(hwnd, cInfo, "Close")
	|| MessageBox(hwnd, TEXT("Failed to Log Mileage, Really Close?"), TEXT("Odometer Failure"), MB_YESNO | MB_ICONQUESTION) == IDYES)
	{
TraceError(hwnd, "WM_CLOSE IGATE\n");
		if (LastIGateTransmitted)	/* Did we send any out?  If so, attempt a "CLOSED" */
		{	char Buffer[128];
			if (SUCCEEDED(StringCbPrintfA(Buffer, sizeof(Buffer), "%s>%s%s%s:<IGATE,CLOSED\n",
							CALLSIGN, DESTID, *PATH?",":"", PATH)))
			{	QueueToTransmit(CAPABILITY_PACKET, Buffer, FALSE, ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet);
				Sleep(500);	/* give it a chance to get transmitted at least */
			} else TraceError(hwnd, "IGATE Format Failed!\n");
		}

		if (/* RestartProgram && */ *ActiveConfig.SavedPositFilter)	/* Save last posits (was restarting) */
		{	APRS_PARSED_INFO_S *APRS = (APRS_PARSED_INFO_S *)malloc(sizeof(*APRS));
			FILTER_INFO_S SaveFilter = {0};
			__int64 msNow = llGetMsec();
			unsigned long s;
TraceError(hwnd, "WM_CLOSE Save (up to) %ld Posits\n", (long) CloseStationCount);
			EmptyTimedStringList(&ActiveConfig.SavedPosits);
			if (CheckOptimizedFilter(ActiveConfig.SavedPositFilter, &SaveFilter))
			{	for (s=1; s<CloseStationCount; s++)
				{	STATION_INFO_S *Station = pCloseStations[s];
					if (!Station->isKilled
					&& Station->lastMsec > 1	/* Not my local ones */
					&& Station->pLastPositPacket
					&& strcmp(CALLSIGN,Station->Owner))	/* Not my GPX objects */
					{	char *InBuf = _strdup(Station->pLastPositPacket);
						if (parse_full_aprs(InBuf, APRS))
						{	if (FilterPacket(&SaveFilter, APRS))
							{	long Age = (long)((msNow - Station->lastMsec)/1000/60);	/* Minutes */
								AddTimedStringEntry(&ActiveConfig.SavedPosits, Station->pLastPositPacket, &Station->stLast, Age);
							}
						}
						free(InBuf);
					}
				}
			} else TraceError(hwnd, "CheckOptimizedFilter(%s) FAILED!\n", ActiveConfig.SavedPositFilter);
			free(APRS);
		}

		if (ActiveConfig.AltNetChoices.Count)
		{	STRING_LIST_S *pList = &ActiveConfig.AltNetChoices;
TraceError(hwnd, "WM_CLOSE Purge (up to) %ld AltNets\n", (long) pList->Count);
			for (unsigned int p=0; p<pList->Count; p++)
			if (!pList->Entries[p].value)	/* Not used? */
			{	char *This = pList->Entries[p].string;
				if (_strnicmp(ActiveConfig.AltNet, This, sizeof(ActiveConfig.AltNet)))
					RemoveSimpleStringEntry(pList, p--);
			}
		}

TraceError(hwnd, "WM_CLOSE config\n");

		if (pCloseStations && cInfo->CenterStation)
		{	if (cInfo->Awaiting)	/* Waiting? */
			{	strncpy(ActiveConfig.Tracking.Call, cInfo->CenterID, sizeof(ActiveConfig.Tracking.Call));
				ActiveConfig.Tracking.Center = cInfo->Awaiting;
			} else	/* or Tracking? */
			{	strncpy(ActiveConfig.Tracking.Call, cInfo->CenterStation->Station, sizeof(ActiveConfig.Tracking.Call));
				ActiveConfig.Tracking.Center = cInfo->CenterTracking;
			}
		} else TraceError(hwnd, "WM_CLOSE CloseStations(%p)==NULL!  (or CenterStation %p)\n",
							pCloseStations, cInfo->CenterStation);

		ActiveConfig.Tracking.Locked = cInfo->Locked;
		ActiveConfig.Scale = cInfo->Scale;
		ActiveConfig.OSMZoom = cInfo->zoom;

		if (!ActiveConfig.Stations.AvgFixed)
		{	ActiveConfig.Stations.AvgIntervals = 0;
			ActiveConfig.Stations.AvgCount = 0;
			ActiveConfig.Stations.AvgFixed = TRUE;
		}
		if (CloseStationCount > 2
		&& llMsecSince(msStartRunning, llGetMsec()) >= ActiveConfig.Stations.MinAge*60*1000)
		{	unsigned __int64 NewCount = ActiveConfig.Stations.AvgCount;
			NewCount *= (unsigned __int64) ActiveConfig.Stations.AvgIntervals;
			NewCount += (unsigned __int64) (CloseStationCount+CloseStationSize)/2;	/* Average the two for reductions */
			NewCount /= (unsigned __int64) ++ActiveConfig.Stations.AvgIntervals;
			ActiveConfig.Stations.AvgCount = (unsigned long) NewCount;
		}

		CloseTraceLogs(hwnd, Quiet);

#ifndef UNDER_CE
		SaveSatellites();
#endif

		StringCbPrintfA(ActiveConfig.Version, sizeof(ActiveConfig.Version),
						"%s %s", PROGNAME, Timestamp);

		RealSaveConfiguration(hwnd, &ActiveConfig, "WM_CLOSE");

#ifndef UNDER_CE
TraceError(hwnd, "WM_CLOSE GPSStop\n");
		if (GPSRunning) GPSStop();
#endif
#ifdef OBSOLETE
TraceError(hwnd, "WM_CLOSE AGWStop\n");
		AGWStop();
TraceError(hwnd, "WM_CLOSE KISSStop\n");
		KISSStop();
TraceError(hwnd, "WM_CLOSE TEXTStop\n");
		TEXTStop();
#endif

TraceError(hwnd, "WM_CLOSE Stopping Ports\n");
		{	unsigned long p;
			TraceLog("Config", TRUE, hwndMain, "Closing %ld Ports\n", (long) ActiveConfig.RFPorts.Count);
			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			if (RFPortRunnable(&ActiveConfig.RFPorts.Port[p]))
			{	TraceLog("Config", TRUE, hwndMain, "RFPort[%ld] %s(%s) %ld via %s\n",
						(long) p,
						ActiveConfig.RFPorts.Port[p].Name, 
						ActiveConfig.RFPorts.Port[p].Protocol, 
						(long) ActiveConfig.RFPorts.Port[p].RfBaud, 
						ActiveConfig.RFPorts.Port[p].Device);
				PortStop(&ActiveConfig.RFPorts.Port[p], p);
			}
		}

TraceError(hwnd, "WM_CLOSE Done!\n");
		return TRUE;	/* Let the default window handler destroy the window */
	}
TraceError(hwnd, "WM_CLOSE returning\n");
	return 0;	/* Let's not close just yet! */
}

LRESULT CALLBACK MainWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
#ifdef USING_SHELL
static SHACTIVATEINFO sai;
#endif
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;
static BOOL PaintingDisabled = FALSE;

#ifdef TRACE_MESSAGES
if (TraceMessages) TraceLogThread("WinMsg", TRUE, "hwndMain: %lX msg: %s(%lX) wp: %lX lp: %lX\n", (long) hwnd, MsgToText(msg), (long) msg, (long) wp, (long) lp);
#endif
	switch (msg)
    {
    case WM_CREATE:
		// Initialize the static window state information. The shell helper functions
		// will use this buffer to store their state.
#ifdef USING_SHELL
		ZeroMemory(&sai, sizeof(sai));
		sai.cbSize = sizeof(sai);
#endif
		// Initialize the window (if we fail, return -1)
        return (OnCreateMainWindow(hwnd, (CREATESTRUCT*) lp) ? 0 : -1);
#ifdef USING_SHELL
	case WM_SETFOCUS:
		SHFullScreen(hwnd,SHFS_HIDESIPBUTTON);
		return 0;
	case WM_KILLFOCUS:
		SHFullScreen(hwnd,SHFS_SHOWSIPBUTTON);
		return 0;
#endif
	case WM_FINISH_STARTUP:

	if (ActiveConfig.SavedPosits.Count)
	{
TraceLogThread("Restore", TRUE, "WM_FINISH_STARTUP:before %ld Posits\n", (long) ActiveConfig.SavedPosits.Count);
		EnableWindow(hwnd, FALSE);
TraceLogThread("Restore", TRUE, "Disabling Painting for %ld Posits\n", (long) ActiveConfig.SavedPosits.Count);
		PaintingDisabled = TRUE;
		RestoreSavedPosits(hwnd);
		PaintingDisabled = FALSE;
TraceLogThread("Restore", TRUE, "Restored Painting after %ld Posits\n", (long) ActiveConfig.SavedPosits.Count);
		EnableWindow(hwnd, TRUE);
#ifdef UNDER_CE	/* Just in case RestoreSavedPosits called PeekMessage() */
		SetForegroundWindow((HWND)((UINT_PTR)hwnd | 0x01));
#else
		SetForegroundWindow(hwnd);
#endif
		InvalidateRect(hwnd, NULL, FALSE);
		UpdateWindow(hwnd);
TraceLogThread("Restore", TRUE, "WM_FINISH_STARTUP:after %ld Posits\n", (long) ActiveConfig.SavedPosits.Count);
	}
/*
	Now add back in any active overlays
*/
	if (ActiveConfig.Overlays.Count)
	{	for (unsigned long o=0; o<ActiveConfig.Overlays.Count; o++)
		{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[o];
			if (pOver->Enabled)
			switch (pOver->Type)
			{
			case 'P':	LoadPOSOverlay(hwndMain, pOver, TRUE); break;
			case 'G':	LoadGPXFile(hwndMain, pOver/*, WM_PORT_RECEIVED, RFPORT_INTERNAL*/); break;
			}
		}
	}
	if (ActiveConfig.POSOverlays.Count)
	{	TIMED_STRING_LIST_S *pList = &ActiveConfig.POSOverlays;
		for (unsigned long o=0; o<pList->Count; o++)
		{	OVERLAY_CONFIG_INFO_S *pOver = GetOrCreateOverlay(&ActiveConfig, pList->Entries[o].string, 'P', TRUE);
			if (LoadPOSOverlay(hwndMain, pOver, TRUE))
			{	pOver->Enabled = pList->Entries[o].value;
			} else RemoveOverlay(&ActiveConfig, pList->Entries[o].string);
		}
		EmptyTimedStringList(pList);
	}

	EnableAPRS(hwnd, ActiveConfig.Enables.APRSIS);
	if (ActiveConfig.Enables.RFPorts)
	{	unsigned long p;
		TraceLog("Activity", TRUE, hwnd, "Loaded %ld RFPorts\n", (long) ActiveConfig.RFPorts.Count);
		for (p=0; p<ActiveConfig.RFPorts.Count; p++)
		{	PORT_CONFIG_INFO_S *pPort = &ActiveConfig.RFPorts.Port[p];
			TraceLog("Activity", TRUE, hwnd, "RFPort[%ld] %s(%s) %ld via %s\n",
					(long) p,
					pPort->Name, 
					pPort->Protocol, 
					(long) pPort->RfBaud, 
					pPort->Device);
			IncrementXmitPackets(p, 0, pPort->Name);
			if (RFPortRunnable(pPort))
			{	if (!PortStart(pPort, hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, p))
				{
#ifdef USE_PORT_STATUS
					SetPortStatus(hwnd, p, pPort->Name, "Failed");
#endif

					TraceLog("Activity", TRUE, hwnd, "Failed To Start RFPort[%ld] %s(%s) %ld via %s\n",
					(long) p,
					pPort->Name, 
					pPort->Protocol, 
					(long) pPort->RfBaud, 
					pPort->Device);
				}
				FixIGateEnabled();
			}
#ifdef USE_PORT_STATUS
			else if (*pPort->Device)
				SetPortStatus(hwnd, MAKELONG(p,1), pPort->Name, "Disabled");
#endif
		}
	}

#ifdef UNDER_CE
		EnableGPS(hwnd, FALSE, TRUE);
#else
		EnableGPS(hwnd, ActiveConfig.Enables.GPS, TRUE);
#endif
		EnableCSV(hwnd, ActiveConfig.Enables.CSVFile, TRUE);
		EnableBeaconing(hwnd, ActiveConfig.Enables.Beacons);
		EnableTelemetry(hwnd, ActiveConfig.Enables.Telemetry);
		RestoreTrackers();
		if (ActiveConfig.SatelliteCount)
			PostMessage(hwnd, WM_CHAR, 15, 0);
//		if (ActiveConfig.FreqMon.Enabled)
//			CreateFrequencyWindow(hwnd);

		break;
	case WM_TILES_LOADED:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		BOOL Force = wp==-1 || cInfo->zoom==(int)wp;
		InvalidateCircle(OSMGetQueueStats(NULL,NULL)?hwnd:NULL, Force);
		break;
	}
	case WM_CENTER_STATION:	/* lp=text, wp=title */
	{	char *Station = (char*)wp;
		char *Owner = (char*)lp;
		STATION_INFO_S *pStation = FindStationCall(Station, Owner);
		if (pStation)
		{	SetCenterTracking(hwnd, pStation);
		}
		if (Owner) free(Owner);
		if (Station) free(Station);
		break;
	}
	case WM_REFRESH_CIRCLE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		InvalidateStationPoints(cInfo->Index, "RefreshCircle", FALSE);
		InvalidateCircle(wp?NULL:hwnd, TRUE, TRUE);
		break;
	}

	case WM_ASYNC_MSG_BOX:	/* lp=text, wp=title */
		MessageBox(hwnd, (LPCWSTR) lp, (LPCWSTR) wp, MB_OK | MB_ICONINFORMATION);
		free((void*)lp); free((void*)wp);
		break;

	case WM_REMEMBER_MESSAGE:	/* lp->REMEMBER_MESSAGE_S */
	{	REMEMBER_MESSAGE_S *rm = (REMEMBER_MESSAGE_S*) lp;
		RememberMessage(rm->From, rm->To, rm->Message, rm->Type);
		free(rm->From); free(rm->To); free(rm->Message);
		free(rm);
		break;
	}

	case WM_ADD_FRIEND:
	{	char *Friend = (char*)lp;
		STATION_INFO_S *Station = FindStationCall(Friend);
		if (Station)
		{	Station->isFriend = TRUE;
			SetFriendCoordinates(Friend, Station->pCoord->lat, Station->pCoord->lon);
		} else SetFriendCoordinates(Friend, 0, 0);
		free(Friend);
		break;
	}

	case WM_PORT_STATUS:	/* wp = Ports Index, lp = Status (0=dis 1=con */
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		unsigned long pIndex = (unsigned long) LOWORD(wp);	/* Index to ActiveConfig.Ports */
		char *text = (char*)lp;	/* Text status of port, need to figure out how to beep... */
		BOOL OK = !_strnicmp(text, "OK", 2);	/* Allow stuff after OK */

#ifdef USE_PORT_STATUS
		if (pIndex == APRSISWP)	/* APRS-IS connection */
		{	SoundConn(OK);	/* Beep on disconnect or reconnect */
			WasConnected = OK;	/* Track state of the connection */
			if (APRSEnabled	&& ActiveConfig.Enables.Internet && WasConnected)	/* Connected, send out the filter */
			{	TransmitFilter();
				ConnectionTransitionTransmit = TRUE;	/* Force beacon */
			} else if (_strnicmp(text, "OpenCmd", 7))/* OpenCmd is OK */
			{	if (APRSIS_Actual) free(APRSIS_Actual);
				APRSIS_Actual = NULL;
			}
			SetPortStatus(hwnd, wp, APRSISPort.Name, text);
		} else if (pIndex == GPSWP)
		{	if (!OK) SoundGps(hwnd, OK);	/* Only do LostFix from here */
			SetPortStatus(hwnd, wp, GPSPort.Name, text);
		} else if (pIndex >= 0 && pIndex < ActiveConfig.RFPorts.Count)
		{	SoundConn(OK);	/* Beep on disconnect or reconnect */
			SetPortStatus(hwnd, wp, ActiveConfig.RFPorts.Port[pIndex].Name, text);
		}
#endif
		free(text);
		break;
	}
	case WM_PORT_SUB_STATUS:	/* wp = Ports Index, lp = Status text */
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		char *text = (char*)lp;	/* Text status of port, need to figure out how to beep... */
		unsigned long pIndex = (unsigned long) LOWORD(wp);	/* Index to ActiveConfig.Ports */

		if (pIndex == APRSISWP)	/* APRS-IS connection */
		{	//TraceLog("APRS-IS", TRUE, hwnd, "APRS-IS SubStatus %s\n", text);
			if (APRSIS_Actual) free(APRSIS_Actual);
			APRSIS_Actual = _strdup(text);
			APRSIS_MSec = llGetMsec();
			SetPortSubStatus(hwnd, wp, APRSISPort.Name, text);
		} else if (pIndex >= 0 && pIndex < ActiveConfig.RFPorts.Count)
		{	SetPortSubStatus(hwnd, wp, ActiveConfig.RFPorts.Port[pIndex].Name, text);
		} else TraceError(hwnd, "Unrecognized PortSubStatus Source %ld Said %s\n", pIndex, text);
		free(text);
		break;
	}
	case WM_PORT_XMIT_COUNT:
	{	unsigned long pIndex = (unsigned long) wp;	/* Index to ActiveConfig.Ports */
		IncrementXmitPackets(pIndex, (long) lp, NULL);
		break;
	}
	case WM_PORT_RECEIVED:	/* wp = Ports Index, lp = Received Packet */
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		char *InBuf = (char *) lp;
		BOOL Validated = ((int)wp) >= 0;
		if (((int)wp) < 0) wp = -(int)wp;
		if (cInfo)
		{	unsigned long pIndex = (unsigned long) wp;	/* Index to ActiveConfig.Ports */
			BOOL pIndexValid = pIndex>=0 && pIndex<ActiveConfig.RFPorts.Count;
			PORT_CONFIG_INFO_S *pPort = pIndexValid?&ActiveConfig.RFPorts.Port[pIndex]:NULL;
			BOOL isRFPort = pIndexValid && !pPort->NotRF;
			__int64 Start = llGetMsec();
		static __int64 msMax=0, msLast=0;

			if (pIndex == APRSISWP)
			{	PacketsRecv++;
				LastAPRSReceive = llGetMsec();
			}

			if (InBuf)
			{
				if (Validated	/* Only gate from validated connections */
				&& IGateEnabled
				&& APRSEnabled && pIndexValid
				&& (isRFPort || pPort->RfBaud==-1)	/* -1 = IS-Server */
				&& pPort->RFtoISEnabled
				&& ActiveConfig.APRSIS.XmitEnabled
				&& ActiveConfig.APRSIS.RFtoISEnabled)
				{
					if (!strncmp(InBuf,"KJ4ERJ-63",9) && IsSameBaseCallsign(CALLSIGN,"KJ4ERJ"))
					{	TraceLog("IGate(NOT)", TRUE, hwnd, "RFtoIS:[%s]SUPPRESSING %s\n", pPort->Name, InBuf);
					} else if (pPort && pPort->NoGateME
					&& !strncmp(InBuf,CALLSIGN,strlen(CALLSIGN))
					&& InBuf[strlen(CALLSIGN)] == '>')
					{
						TraceLog("IGate(NOT)", TRUE, hwnd, "RFtoIS:[%s]SUPPRESSING ME's %s\n", pPort->Name, InBuf);
					} else
					{	char *q, *p = strchr(InBuf, ':');	/* Find payload */
						if (!p)
						{	TraceLog("IGate(NOT)", TRUE, hwnd, "RFtoIS:Missing Payload(:) In %s\n", InBuf);
						} else if (p[1] == '}')	/* Third party? */
						{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:NOT IGating 3rd Party %s\n", InBuf);
						} else if ((q=strstr(InBuf,",NOGATE")) && q<p)	/* NOGATE? */
						{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:NOGATE Found In %s\n", InBuf);
						} else if ((q=strstr(InBuf,",RFONLY")) && q<p)	/* RFONLY? */
						{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:RFONLY Found In %s\n", InBuf);
						} else
						{	q = strstr(InBuf, ",q");	/* Any q-construct? */
							if (q && q < p && pPort->RfBaud!=-1)
							{	TraceLog("IGate(NOT)", TRUE, hwnd, "RFtoIS:NOT IGating q-Constructed %s\n", InBuf);
								PacketsQNOT++;
							} else
							{	char *Packet = (char*)malloc(strlen(InBuf)+4+1+sizeof(CALLSIGN)+1);
								if (pPort->RfBaud == -1)
									strcpy(Packet, InBuf);	/* APRS-IS server passthrough */
								else 
								{	int Len = (p-InBuf);
									strncpy(Packet,InBuf,Len);
									Len += sprintf(Packet+Len,",qAR,%s",CALLSIGN);
									strcpy(Packet+Len,p);
								}
								if (!TransmitString(Packet))
								{	TraceLog("Transmit", TRUE, hwnd, "Error IGating %s\n", Packet);
									TraceLog("IGate", TRUE, hwnd, "RFtoIS:Error IGating %s\n", Packet);
				Start = DebugTimer("PortReceived","IGateFail",Start,&msMax,&msLast,hwnd);
								} else
								{	if (pPort->RfBaud == -1)
										PacketsPassed++;	/* IS-Server passthroughs */
									else PacketsIGated++;	/* RFtoIS gating */
									TraceLog("IGate", TRUE, hwnd, "RFtoIS:[%s]%s %s\n",
											pPort->Name, (pPort->RfBaud!=-1)?"IGated":"IStoIS", Packet);
				Start = DebugTimer("PortReceived","IGate",Start,&msMax,&msLast,hwnd);

									char *Buffer = (char *) malloc(strlen(Packet)+80);
									SYSTEMTIME stUTCTime;
									GetSystemTime(&stUTCTime);
									int Len = sprintf(Buffer,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld %s:%s:[%ld]%s",
														(long) stUTCTime.wYear, 
														(long) stUTCTime.wMonth, 
														(long) stUTCTime.wDay, 
														(long) stUTCTime.wHour, 
														(long) stUTCTime.wMinute, 
														(long) stUTCTime.wSecond,
														(pPort->RfBaud!=-1)?"IGated":"IStoIS",
														CALLSIGN, (long) UDPSeq++,
														Packet);
									if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Buffer, 1))	/* Single shot */
										TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Buffer);
									free(Buffer);
				Start = DebugTimer("PortReceived","IGateUDP",Start,&msMax,&msLast,hwnd);
								}
								free(Packet);
							}
						}
					}
				}
				else if (pIndex == APRSISWP || pIndex == RFPORT_INTERNAL)
					;	/* don't complain about APRS-IS or internals */
				else if (pIndex == -1)
					;	/* don't complain about internals (EchoLink) */
				else if (!Validated
				|| !IGateEnabled || !APRSEnabled
				|| !ActiveConfig.Enables.Internet
				|| !ActiveConfig.APRSIS.XmitEnabled
				|| !ActiveConfig.APRSIS.RFtoISEnabled)
				{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:%s %s %s %s %s %s (%s)\n",
							Validated?"":"NOT(Validated",
							IGateEnabled?"":"Disable(IGate)",
							APRSEnabled?"":"Disable(APRS-IS)",
							ActiveConfig.Enables.Internet?"":"Disable(Internet)",
							ActiveConfig.APRSIS.XmitEnabled?"":"!Xmit(APRS-IS)",
							ActiveConfig.APRSIS.RFtoISEnabled?"":"!RftoIS(APRS-IS)",
							InBuf);
				} else if (!pIndexValid)
				{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:[%ld/%ld] %s (%s)\n",
							(long) pIndex, (long) ActiveConfig.RFPorts.Count,
							pIndexValid?"Valid":"INVALID", InBuf);
				} else if (pIndexValid && pPort->XmitEnabled)
				{	TraceLog("IGate(NOT)", FALSE, hwnd, "RFtoIS:[%s] NOT IGating %s %s (%s)\n",
								pPort->Name,
								pPort->RFtoISEnabled?"Enabled":"RFtoIS DISABLED",
								isRFPort?"":"NON-RF",
								InBuf);
				}
				AprsLogPacket("Received", hwnd, cInfo, InBuf, isRFPort, pIndex);
Start = DebugTimer("PortReceived","LogPacket",Start,&msMax,&msLast,hwnd);
			}
		}
		if (InBuf) free(InBuf);
		break;
	}

#ifndef UNDER_CE
	case WM_MSG_NOTIFICATION:

		switch (lp)
		{
		case NIN_BALLOONUSERCLICK:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (MessageCount)
			{	if (IsIconic(hwnd))
				{	WINDOWPLACEMENT wd;
					wd.length = sizeof(wd);
					GetWindowPlacement(hwnd, &wd);
					switch (cInfo->prevSize)
					{
					case SIZE_MAXIMIZED:	wd.showCmd = SW_MAXIMIZE; break;
					case SIZE_RESTORED:		wd.showCmd = SW_RESTORE; break;
					default:				wd.showCmd = SW_RESTORE; break;
					}
					SetWindowPlacement(hwnd, &wd);
				}
	            SetForegroundWindow(hwnd);
#ifdef DOESNT_WORK
				int mNewest = 0;
				for (int m=1; m<MessageCount; m++)
				{	if (Messages[m].Index > Messages[mNewest].Index)
						mNewest = m;
				}
				DisplayMessage(hwnd, cInfo, mNewest);
#else
				DisplayMessage(hwnd, cInfo, 0);
#endif
			}
			break;
		}
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONUP:
		case WM_RBUTTONDBLCLK:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (IsIconic(hwnd))
			{	WINDOWPLACEMENT wd;
				wd.length = sizeof(wd);
				GetWindowPlacement(hwnd, &wd);
				switch (cInfo->prevSize)
				{
				case SIZE_MAXIMIZED:	wd.showCmd = SW_MAXIMIZE; break;
				case SIZE_RESTORED:		wd.showCmd = SW_RESTORE; break;
				default:				wd.showCmd = SW_RESTORE; break;
				}
				SetWindowPlacement(hwnd, &wd);
			}
			SetForegroundWindow(hwnd);
			//if (lp != WM_LBUTTONUP) MessageHandler(&rcs[rc_Message], hwnd, NULL, lp, 0, 0);
			break;
		}
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MOUSEMOVE:
			break;
#ifdef VERBOSE
		default:
		TraceLog("Messages", TRUE, hwnd, "WM_NOTIFICATION:wp=0x%lX lp=0x%lX\n", (long) wp, (long) lp);
		TraceLog("Messages", TRUE, hwnd, "WM_NOTIFICATION:Show(%lX) Hide(%lX) Time(%lX) Click(%lX) Move(%lX) LDOWN(%lX) LUP(%lX) RDOWN(%lX) RUP(%lX)\n", (long) NIN_BALLOONSHOW, (long) NIN_BALLOONHIDE, (long) NIN_BALLOONTIMEOUT, (long) NIN_BALLOONUSERCLICK, (long) WM_MOUSEMOVE, (long) WM_LBUTTONDOWN, (long) WM_LBUTTONUP, (long) WM_RBUTTONDOWN, (long) WM_RBUTTONUP);
#endif
		}

		break;

	case WM_BULL_NOTIFICATION:

		switch (lp)
		{
		case NIN_BALLOONUSERCLICK:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (BulletinCount)
			{
#ifdef NOT_NECESSARY
				if (IsIconic(hwnd))
				{	WINDOWPLACEMENT wd;
					wd.length = sizeof(wd);
					GetWindowPlacement(hwnd, &wd);
					switch (cInfo->prevSize)
					{
					case SIZE_MAXIMIZED:	wd.showCmd = SW_MAXIMIZE; break;
					case SIZE_RESTORED:		wd.showCmd = SW_RESTORE; break;
					default:				wd.showCmd = SW_RESTORE; break;
					}
					SetWindowPlacement(hwnd, &wd);
				}
	            SetForegroundWindow(hwnd);
#endif
				DisplayBulletins(cInfo, SW_SHOW);
			}
			break;
		}
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONUP:
		case WM_RBUTTONDBLCLK:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
#ifdef NOT_NECESSARY
			if (IsIconic(hwnd))
			{	WINDOWPLACEMENT wd;
				wd.length = sizeof(wd);
				GetWindowPlacement(hwnd, &wd);
				switch (cInfo->prevSize)
				{
				case SIZE_MAXIMIZED:	wd.showCmd = SW_MAXIMIZE; break;
				case SIZE_RESTORED:		wd.showCmd = SW_RESTORE; break;
				default:				wd.showCmd = SW_RESTORE; break;
				}
				SetWindowPlacement(hwnd, &wd);
			}
			SetForegroundWindow(hwnd);
#endif
			DisplayBulletins(cInfo, SW_SHOW);
			//if (lp != WM_LBUTTONUP) MessageHandler(&rcs[rc_Message], hwnd, NULL, lp, 0, 0);
			break;
		}
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MOUSEMOVE:
			break;
		}

		break;
#endif

#ifdef MONITOR_PHONE
	case WM_NOTIFY_SIGNAL_STRENGTH:
	{	BOOL Changed = dwOldSignalStrength != (DWORD) wp;
		TraceLog("Phone",FALSE,hwnd,"SignalStrength %ld->%ld on %S\n",
					dwOldSignalStrength, (long) wp, szOldOperatorName);
		dwOldSignalStrength = (DWORD) wp;
		if (Changed) TriggerTelemetry(hwnd);
#ifdef NOT_NECESSARY
	if (SUCCEEDED(RegistryGetDWORD(SN_PHONESIGNALSTRENGTH_ROOT,
						SN_PHONESIGNALSTRENGTH_PATH,
						SN_PHONESIGNALSTRENGTH_VALUE,
						&dwSignalStrength)))
	{	if (dwSignalStrength != dwOldSignalStrength)
		{	TraceLog("Phone",FALSE,hwnd,"SignalStrength %ld->%ld\n",
					dwOldSignalStrength, dwSignalStrength);
			dwOldSignalStrength = dwSignalStrength;
		}
	}
#endif
		// break;	/* Purposely fall through to update "Port" status */
	}
	case WM_NOTIFY_OPERATOR_NAME:
	{	TCHAR szOperatorName[(sizeof(szOldOperatorName)/sizeof(szOldOperatorName[0]))];
		if (SUCCEEDED(RegistryGetString(SN_PHONEOPERATORNAME_ROOT,
							SN_PHONEOPERATORNAME_PATH,
							SN_PHONEOPERATORNAME_VALUE,
							szOperatorName,
							(sizeof(szOperatorName)/sizeof(szOperatorName[0])))))
		{	if (wcscmp(szOldOperatorName, szOperatorName))
			{	TraceLog("Phone",FALSE,hwnd,"Operator %S->%S signal %ld\n",
						szOldOperatorName, szOperatorName, dwOldSignalStrength);
				wcscpy(szOldOperatorName, szOperatorName);
				if (ActiveConfig.Status.Cellular)
					TransmitStatusReport(TRUE);
			}
		}
		RecordCellularChange();
		{	char *Status = (char*)malloc(512);
			StringCbPrintfA(Status, 512, "%S %ld%%",
							szOldOperatorName, (long) dwOldSignalStrength);
			SetPortStatus(hwnd, 8888, "", Status);
			free(Status);
		}
		break;
	}
#ifdef HAS_CELL_BROADCAST
	case WM_NOTIFY_CELL_BROADCAST:
	{	HRESULT hr;
		TCHAR szCellBroadcast[(sizeof(szOldCellBroadcast)/sizeof(szOldCellBroadcast[0]))];
		if (SUCCEEDED(hr=RegistryGetString(SN_PHONECELLBROADCAST_ROOT,
							SN_PHONECELLBROADCAST_PATH,
							SN_PHONECELLBROADCAST_VALUE,
							szCellBroadcast,
							(sizeof(szCellBroadcast)/sizeof(szCellBroadcast[0])))))
		{	if (wcscmp(szOldCellBroadcast, szCellBroadcast))
			{	TraceLog("Phone",FALSE,hwnd,"CellBroadcast %S->%S\n",
						szOldCellBroadcast, szCellBroadcast);
				wcscpy(szOldCellBroadcast, szCellBroadcast);
			}
		} else TraceLog("Phone", FALSE, hwnd, "RegistryGetString(CellBroadcast) Failed, Error %ld (0x%lX)\n", (long) hr, (long) hr,
							(long) E_INVALIDARG, (long) E_INSUFFICIENT_BUFFER);

		{	char *Status = (char*)malloc(512);
			StringCbPrintfA(Status, 512, "%S",
							szOldCellBroadcast);
			SetPortStatus(hwnd, 88881, "Cell", Status);
			free(Status);
		}
		break;
	}
#endif	/* HAS_CELL_BROADCAST */
#endif	/* MONITOR_PHONE */

#ifdef USING_COMM_MGR
	case WM_CONNMGR_NOTIFICATION:
	{
#ifdef VERBOSE
		TCHAR Buffer[256], *StatusWord = GetConnMgrStatusWord(wp);
		StringCbPrintf(Buffer, sizeof(Buffer), TEXT("wp: 0x%lX lp: 0x%lX\nWord: %s"), (long) wp, (long) lp, StatusWord);
		MessageBox(hwnd, Buffer, TEXT("WM_CONNMGR_NOTIFICATION"), MB_OK | MB_ICONINFORMATION);
#ifdef USING_SIP
		SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
#endif
		if (wp != LastConnMgrStatus)
		{	char Buffer[80];
			TCHAR *StatusWord = GetConnMgrStatusWord(wp);
			StringCbPrintfA(Buffer, sizeof(Buffer), "%S", StatusWord);
			SetPortStatus(hwnd, 3333, "ConnMgr", Buffer);
			LastConnMgrStatus = wp;
		}
#ifdef OBSOLETE
		if (!IsConnMgrAttempting(wp))	/* Dropped the connection, force TCP to disconnect as well */
		{static	char Buffer[80];
			tcp_disconnect();
			StringCbPrintfA(Buffer, sizeof(Buffer), "Conn Mgr Status - %S", GetConnMgrStatusWord(wp));
			settcpstatus(Buffer, TRUE);
			WasConnected = FALSE;
			SoundConn(FALSE);
		}
		InvalidatePortStatus(hwnd, TRUE);
#endif
		break;
	}
#endif	/* USING_COMM_MGR */

#ifdef USING_POWER
	case WM_POWER_CHANGE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		BYTE BatteryLifePercent = wp;
		BYTE BatteryFlag = lp & 0xff;
		BYTE ACLineStatus = (lp >> 8) & 0xff;
		int p;

		if (PowerCount >= POWER_COUNT)
		{	p = ARRAYSIZE(Powers)-1;
			memmove(&Powers[0], &Powers[1], sizeof(Powers[0])*p);
		} else p = PowerCount++;
		GetLocalTime(&Powers[p].st);
		Powers[p].BatteryLifePercent = BatteryLifePercent;

		if (GetSystemPowerStatusEx2(&sps2, sizeof(sps2), FALSE))
			TransmitTelemetry(hwnd, BatteryLifePercent, ACLineStatus==AC_LINE_ONLINE, BatteryFlag&BATTERY_FLAG_CHARGING, GPSEnabled, dwOldSignalStrength, sps2.BatteryCurrent?sps2.BatteryCurrent:sps2.BatteryAverageCurrent);
		else TransmitTelemetry(hwnd, BatteryLifePercent, ACLineStatus==AC_LINE_ONLINE, BatteryFlag&BATTERY_FLAG_CHARGING, GPSEnabled, dwOldSignalStrength, 0);
		
		InvalidatePower(FALSE);
		break;
	}
#endif

	case WM_ACTIVATE:
	{
		// Calling this function when we get WM_ACTIVATE ensures that our
		// application will handle the SIP properly. This function does
		// nothing when we're running on Smartphone.
//		SHHandleWMActivate(hwnd, wp, lp, &sai, 0);
#ifdef UNDER_CE
#ifdef USING_COMM_MGR
		ConnInfo.dwPriority = (wp == WA_INACTIVE)? CONNMGR_PRIORITY_USERIDLE : CONNMGR_PRIORITY_USERINTERACTIVE;
#endif
#endif
		break;
	}

	case WM_SETTINGCHANGE:
		// This helper function will resize our main application window when the SIP
		// goes up and down. Try commenting out this function and see how it affects
		// our drawing code. This function is optional, so choose whichever behavior
		// you prefer. Again, this function does nothing on Smartphone.
//		SHHandleWMSettingChange(hwnd, wp, lp, &sai);
		break;

#ifdef UNDER_CE
	case WM_HIBERNATE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		// We get this message when the device is running low on memory. All
		// applications should free any memory and resources that they can. We'll
		// free our cached bitmap and font, since we can just re-create them the next
		// time we need them.
		QueueDebugMessage(llGetMsec(), "Processing WM_HIBERNATE!");
		TraceError(hwnd,"WM_HIBERNATE Processed!\n");
		FreePaintImage();
		FreePaintFont();
		OSMFlushTileCache(0);
		FlushShapeIndexes();
		FlushShapeCache();
#ifdef SHADOW_SCREEN
		if (cInfo->hShadowMap)
		{	DeleteObject(cInfo->hShadowMap);
			cInfo->hShadowMap = 0;
		}
#endif
		MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
		return TRUE;
	}
#endif


#ifdef FOR_INFO
    WM_INITMENUPOPUP
        WPARAM wParam
        LPARAM lParam;
Parameters
    wParam
        Handle to the drop-down menu or submenu. 
    lParam
        The low-order word specifies the zero-based relative position of the menu item that opens the drop-down menu or submenu.
        The high-order word indicates whether the drop-down menu is the window menu. If the menu is the window menu, this parameter is TRUE; otherwise, it is FALSE. 
#endif

	case WM_INITMENUPOPUP:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		HMENU hmenu = (HMENU) wp;
	    int  cMenuItems = GetMenuItemCount(hmenu); 
	    UINT id = GetMenuItemID(hmenu, 0);

		MarkActivity();

//TraceLog("Menu", FALSE, hwnd, "INITMENUPOPUP(%ld)\n", (long) id);

#ifdef UNDER_CE
		MENUITEMINFO mi = {0};
		mi.cbSize = sizeof(mi);
		mi.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU;
		GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
		if (mi.fType == MFT_STRING)
		{	mi.dwTypeData = (LPWSTR) malloc(sizeof(TCHAR)*++mi.cch);
			GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
#ifdef CE50
			TraceLog("Menu", FALSE, hwnd, "%p:INITMENUPOPUP(%ld)(%S) is fType(0x%lX) fState(0x%lX)\n", hmenu, id, mi.dwTypeData, mi.fType, mi.fState);
#endif
		}
#ifdef CE50
		else TraceLog("Menu", TRUE, hwnd, "%p:INITMENUPOPUP(%ld) is fType(0x%lX) fState(0x%lX)\n", hmenu, id, mi.fType, mi.fState);
#endif
		if (mi.fType == MFT_STRING) free(mi.dwTypeData);
#else
		MENUITEMINFO mi = {0};
		mi.cbSize = sizeof(mi);
		mi.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_FTYPE | MIIM_STATE | MIIM_STRING | MIIM_SUBMENU;
		GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
		if (mi.fType == MFT_STRING)
		{	mi.dwTypeData = (LPWSTR) malloc(sizeof(TCHAR)*++mi.cch);
			GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
			//TraceLog("Menu", FALSE, hwnd, "INITMENUPOPUP(%ld)(%S) is fType(0x%lX) fState(0x%lX)\n", id, mi.dwTypeData, mi.fType, mi.fState);
		} //else TraceLog("Menu", TRUE, hwnd, "INITMENUPOPUP(%ld) is fType(0x%lX) fState(0x%lX)\n", id, mi.fType, mi.fState);
		if (mi.fType == MFT_STRING) free(mi.dwTypeData);
#endif

		if (id == ID_CLEAR_ALTNETS)	/* Accumulated options */
		{
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_ALTNETS, ActiveConfig.AltNetChoices.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_BULLETINS, BulletinCount);
			ExtendMenuItem(hmenu, ID_RESET_MAX_WIDTH, ActiveConfig.MaxWidthStationID);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_TELEMETRY, ActiveConfig.TelemetryDefinitions.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_WEATHER, ActiveConfig.RcvdWeather.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_WINDOW_POSITIONS, ActiveConfig.WindowPositions.Count);
		}
		if (id == ID_CLEAR_AUTO_REPLIES)	/* Configured options */
		{
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_AUTO_REPLIES, ActiveConfig.Messaging.AutoAnswer.ReplyChoices.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_BEACON_COMMENTS, ActiveConfig.CommentChoices.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_STATUS_TEXTS, ActiveConfig.Status.Choices.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_SYMBOLS, ActiveConfig.SymbolChoices.Count);
		}

		if (id == ID_MESSAGES_PURGE_EAVESDROP)	/* need to update purge options */
		{
			int MeCount=0, MyCount=0;
			int EavesDrops=0, GrpCount=0, SpcCount=0, NWSCount=0, Others=0;
			for (int m=0; m<MessageCount; m++)
			{	switch (Messages[m].Type)
				{
				case MESSAGE_ME: MeCount++; break;
				case MESSAGE_MY: MyCount++; break;
				case MESSAGE_SPECIAL: SpcCount++; break;
				case MESSAGE_GROUP: GrpCount++; break;
				case MESSAGE_NWS: NWSCount++; break;
				case MESSAGE_RF: EavesDrops++; break;
				case MESSAGE_EAVESDROP: EavesDrops++; break;
				default: Others++;
				}
			}
			CheckEnableNumberMenuItem(hmenu, ID_MESSAGES_PURGE_SPECIAL, SpcCount);
			CheckEnableNumberMenuItem(hmenu, ID_MESSAGES_PURGE_GROUP, GrpCount);
			CheckEnableNumberMenuItem(hmenu, ID_MESSAGES_PURGE_MY, MyCount);
			CheckEnableNumberMenuItem(hmenu, ID_MESSAGES_PURGE_NWS, NWSCount);
			CheckEnableNumberMenuItem(hmenu, ID_MESSAGES_PURGE_EAVESDROP, EavesDrops);

#ifdef FOR_INFO
            MENUITEM "Clear Paths",                 ID_CLEAR_PATHS
            MENUITEM "Clear Track",                 ID_CLEAR_TRACK
#endif
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_STATIONS, CloseStationCount);
			{	unsigned long p, c=0;
				for (p=0; p<ActiveConfig.Nicknames.Count; p++)
					if (*ActiveConfig.Nicknames.Nick[p].DefinedBy)
						c++;
				CheckEnableNumberMenuItem(hmenu, ID_CLEAR_TACTICAL, c);
			}
		}

#ifdef SUPPORT_TRACE_LOGS
		if (id == ID_LOG_ALL)
		{	UpdateTraceLogViewMenu(hwnd, hmenu, cMenuItems);
		}
		if (id == ID_LOG_STARTUP)
		{	UpdateTraceLogEnableMenu(hwnd, hmenu, cMenuItems);
		}
#endif	/* SUPPORT_TRACE_LOGS */
		if (id == ID_RFPORTS_ENABLE)
		{	unsigned long p;
			for (p=cMenuItems-1; p>=4; p--)	/* 4 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.RFPorts.Count; p++)	/* Sensitive to menu pre-population */
			{	TCHAR Name[80];
				PORT_CONFIG_INFO_S *Port = &ActiveConfig.RFPorts.Port[p];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Port->Name);
				AppendMenu(hmenu, MF_STRING, ID_RFPORTS_ENABLE+(p+1), Name);
				EnableMenuItem(hmenu, ID_RFPORTS_ENABLE+(p+1), (ActiveConfig.Enables.RFPorts&&*Port->Device)?MF_ENABLED:MF_GRAYED);
				CheckMenuItem(hmenu, ID_RFPORTS_ENABLE+(p+1), (Port->IsEnabled?MF_CHECKED:MF_UNCHECKED));
			}
		}
		if (id == ID_CONFIGURE_NEW_RFPORT)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=3; p--)	/* 3 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			{	TCHAR Name[80];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S"), ActiveConfig.RFPorts.Port[p].Name);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NMEA+(p+1), Name);
			}
		}
		if (id == ID_BULLETINS_VIEW)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=3; p--)	/* 3 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.Bulletins.Count; p++)
			{	TCHAR Name[80+sizeof(ActiveConfig.Bulletins.Bull[0].Comment)];
				BULLETIN_CONFIG_INFO_S *Bull = &ActiveConfig.Bulletins.Bull[p];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S %S"), Bull->Name, Bull->Comment);
				AppendMenu(hmenu, MF_STRING, ID_BULLETINS_NEW+(p+1), Name);
				CheckMenuItem(hmenu, ID_BULLETINS_NEW+(p+1), 
							((Bull->ISEnabled || Bull->RFEnabled)&&Bull->Interval&&Bull->Enabled)?MF_CHECKED:MF_UNCHECKED);
			}
		}

		if (id == ID_CHAT_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=1; p--)	/* Keep one entry */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ChatCount; p++)
			if (Chats[p])
			{	TCHAR Name[80];
				CHAT_INFO_S *Chat = Chats[p];

				if (!_strnicmp(Chat->From, CALLSIGN, sizeof(Chat->From)))
					StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Chat->To);
				else if (!_strnicmp(Chat->To, CALLSIGN, sizeof(Chat->To)))
					StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Chat->From);
				else StringCbPrintf(Name, sizeof(Name), TEXT("%S<>%S"), Chat->From, Chat->To);
				AppendMenu(hmenu, MF_STRING, ID_CHAT_NEW+(p+1), Name);
				CheckMenuItem(hmenu, ID_CHAT_NEW+(p+1), 
							Chat->isActive?MF_CHECKED:MF_UNCHECKED);
			}
		}

		FixUpViewMenu(cInfo, hmenu, id);

		if (id == ID_COMPANIONS_ENABLED)	/* First element of the sub menu */
		{	unsigned long p;

			ClearMenuItems(cInfo, hmenu, ID_COMPANIONS_ENABLED, 3);
			if (!CloseStationFreeze) SortConfigCompanions(&ActiveConfig);

			int ObjCount = 0, EnaCount=0, ViaRCount=0, ViaICount=0;
			for (p=0; p<ActiveConfig.Companions.Count; p++)
			{	COMPANION_INFO_S *Obj = &ActiveConfig.Companions.Companion[p];
				TCHAR Name[80+sizeof(Obj->Comment)];
				ObjCount++;

				if (Obj->ISEnabled) ViaICount++;
				if (Obj->RFEnabled) ViaRCount++;
				if (Obj->Enabled) EnaCount++;

				if (!Obj->Enabled)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (Dis) %S"), Obj->Name, Obj->Comment);
				else if (Obj->ISEnabled && Obj->RFEnabled)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (I+R)%S"), Obj->Name, Obj->Comment);
				else if (Obj->ISEnabled)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (IS) %S"), Obj->Name, Obj->Comment);
				else if (Obj->RFEnabled)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (RF) %S"), Obj->Name, Obj->Comment);
				else
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (Lcl) %S"), Obj->Name, Obj->Comment);
				int ItemID = AddMenuItem(cInfo, hmenu, ID_COMPANIONS_NEW, p,
									MENU_POS_APPEND, MF_STRING, Name);
				CheckMenuItem(hmenu, ItemID, 
							((Obj->ISEnabled || Obj->RFEnabled)&&Obj->Enabled)?MF_CHECKED:MF_UNCHECKED);
			}
			NumberMenuItem(hmenu, ID_COMPANIONS_ENABLED, EnaCount,"");
			CheckMenuItem(hmenu, ID_COMPANIONS_ENABLED, 
						ActiveConfig.CompanionsEnabled?MF_CHECKED:MF_UNCHECKED);
			EnableMenuItem(hmenu, ID_COMPANIONS_ENABLED, ActiveConfig.Companions.Count?MF_ENABLED:MF_GRAYED);
		}

		if (id == ID_CQSRVR_ACTIVE_GROUPS)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=4; p--)	/* 4 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.CQGroups.Count; p++)
			{	TCHAR Name[80];
				CQSRVR_GROUP_INFO_S *CQGroup = &ActiveConfig.CQGroups.CQGroup[p];
				if (CQGroup->ViaCQSRVR)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (CQSRVR)"), CQGroup->Name);
				else if (CQGroup->QuietMonitor)
					StringCbPrintf(Name, sizeof(Name), TEXT("%S (Quiet)"), CQGroup->Name);
				else StringCbPrintf(Name, sizeof(Name), TEXT("%S"), CQGroup->Name);
				AppendMenu(hmenu, MF_STRING, ID_CQSRVR_JOIN_GROUP+(p+1), Name);
				CheckMenuItem(hmenu, ID_CQSRVR_JOIN_GROUP+(p+1), 
							(CQGroup->Interval&&CQGroup->KeepAlive)?MF_CHECKED:MF_UNCHECKED);
			}
		}
		if (id == ID_OBJECTS_NEW)	/* First element of the sub menu */
		{	BOOL *Used = (BOOL*)calloc(ActiveConfig.Objects.Count,sizeof(*Used));
			unsigned long p, q;
			ClearMenuItems(cInfo, hmenu, ID_OBJECTS_NEW, 6);
//			for (p=cMenuItems-1; p>=6; p--)	/* 6 original elements */
//				DeleteMenu(hmenu, p, MF_BYPOSITION);

			if (!CloseStationFreeze) SortConfigObjects(&ActiveConfig);

			for (q=0; q<ActiveConfig.Objects.Count; q++)
			if (!Used[q])
			{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[q];
				TCHAR uGrp[sizeof(Grp->Group)+1+1+33+1+1];
				HMENU hSub = CreatePopupMenu();
				int ObjCount = 0, EnaCount=0, ViaRCount=0, ViaICount=0, KillCount=0;
				char Path[sizeof(Grp->RFPath)]={0};
				BOOL IntMixed = FALSE;
				int IntTotal = 0;	/* Total intervals for averaging */
				for (p=q; p<ActiveConfig.Objects.Count; p++)
				if (!Used[p]
				&& !strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
				{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
					TCHAR Name[80+sizeof(Obj->Comment)];
					ObjCount++;
					Used[p] = TRUE;

					if (Obj->ISEnabled) ViaICount++;
					if (Obj->RFEnabled) ViaRCount++;
					if (Obj->Kill) KillCount++;
					if (Obj->Enabled)
					{	EnaCount++;
						IntTotal += Obj->Interval;
						if (Obj->Interval != ((double)IntTotal/(double)EnaCount))
							IntMixed = TRUE;
					}
					if (p==q) strncpy(Path, Obj->RFPath, sizeof(Path));
					else if (strncmp(Path, Obj->RFPath, sizeof(Path)))
						strncpy(Path,"*MIXED*",sizeof(Path));

					if (!Obj->Enabled)
						StringCbPrintf(Name, sizeof(Name), TEXT("%S (Dis:%d) %S"), Obj->Name, (int) Obj->Interval, Obj->Comment);
					else if (Obj->ISEnabled && Obj->RFEnabled)
						StringCbPrintf(Name, sizeof(Name), TEXT("%S (I+R:%d)%S"), Obj->Name, (int) Obj->Interval, Obj->Comment);
					else if (Obj->ISEnabled)
						StringCbPrintf(Name, sizeof(Name), TEXT("%S (I:%d) %S"), Obj->Name, (int) Obj->Interval, Obj->Comment);
					else if (Obj->RFEnabled)
						StringCbPrintf(Name, sizeof(Name), TEXT("%S (R:%d) %S"), Obj->Name, (int) Obj->Interval, Obj->Comment);
					else
						StringCbPrintf(Name, sizeof(Name), TEXT("%S (L:%d) %S"), Obj->Name, (int) Obj->Interval, Obj->Comment);
//					AppendMenu(hSub, MF_STRING, ID_OBJECTS_NEW+(p+1), Name);
					int ItemID = AddMenuItem(cInfo, hSub, ID_OBJECTS_NEW, p,
										MENU_POS_APPEND, MF_STRING, Name);
//					CheckMenuItem(hSub, ID_OBJECTS_NEW+(p+1), 
//								((Obj->ISEnabled || Obj->RFEnabled)&&Obj->Interval&&Obj->Enabled)?MF_CHECKED:MF_UNCHECKED);
					CheckMenuItem(hSub, ItemID, 
								((Obj->ISEnabled || Obj->RFEnabled)&&Obj->Interval&&Obj->Enabled)?MF_CHECKED:MF_UNCHECKED);
				}

				AddMenuItem(cInfo, hSub, 0, q,
								MENU_POS_FIRST, MF_SEPARATOR, NULL);

				if (Path[0])
				{	TCHAR uPath[sizeof(Path)];
					StringCbPrintf(uPath, sizeof(uPath), TEXT("%S"), Path);
					AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_PATH, q,
									MENU_POS_FIRST, MF_STRING, uPath);
				} else AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_PATH, q,
									MENU_POS_FIRST, MF_STRING, TEXT("*NoPath*"));

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("Interval %S(%ld)"),
								IntMixed?"Avg":"",
								(long) (IntTotal/(EnaCount?EnaCount:1)));
				AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_INTERVAL, q,
								MENU_POS_FIRST, MF_STRING, uGrp);

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("Via RF (%ld/%ld)"),
								(long) ViaRCount, (long) ObjCount);
				AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_VIA_RF, q,
					MENU_POS_FIRST, MF_STRING|(ViaRCount?MF_CHECKED:0), uGrp);

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("Via -IS (%ld/%ld)"),
								(long) ViaICount, (long) ObjCount);
				AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_VIA_IS, q,
								MENU_POS_FIRST, MF_STRING|(ViaICount?MF_CHECKED:0), uGrp);

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("Kill (%ld/%ld)"),
								(long) KillCount, (long) ObjCount);
				AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_KILL, q,
								MENU_POS_FIRST, MF_STRING|(KillCount?MF_CHECKED:0), uGrp);

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("Enabled (%ld/%ld)"),
								(long) EnaCount, (long) ObjCount);
				AddMenuItem(cInfo, hSub, ID_OBJECT_GROUP_ENABLE, q,
								MENU_POS_FIRST, MF_STRING|(EnaCount?MF_CHECKED:0), uGrp);

				StringCbPrintf(uGrp, sizeof(uGrp), TEXT("%S (%d)"),
								*Grp->Group?Grp->Group:"*Blank*",
								(int) ObjCount);
				AppendMenu(hmenu, MF_STRING | MF_POPUP, (UINT_PTR)hSub, uGrp);
			}


#ifdef OBJECT_COUNT_LIMITED
			{	char Parens[80];
				StringCbPrintfA(Parens, sizeof(Parens), "%d/%d Objs",
								(int)ActiveConfig.Objects.Count, (int) 999);
				ExtendMenuItem(hmenu, ID_OBJECTS_NEW, Parens);
//				EnableMenuItem(hmenu, ID_OBJECTS_NEW, ActiveConfig.Objects.Count<999?MF_ENABLED:MF_GRAYED);
//				EnableMenuItem(hmenu, ID_OBJECTS_NEW_WEATHER, ActiveConfig.Objects.Count<999?MF_ENABLED:MF_GRAYED);
			}
#else
			NumberMenuItem(hmenu, ID_OBJECTS_NEW, ActiveConfig.Objects.Count," Objs");
#endif
			NumberMenuItem(hmenu, ID_MAX_GROUP_OBJS, ActiveConfig.MaxGroupObjs," Objs");

			{	char *Groups = GetQRUGroups(&ActiveConfig, TRUE);
				CheckMenuItem (hmenu, ID_QRU_ENABLE, ActiveConfig.QRU.Enabled&&Groups?MF_CHECKED:MF_UNCHECKED);
				CheckMenuItem (hmenu, ID_QRU_RETRY_MESSAGES, ActiveConfig.QRU.RetryMessages?MF_CHECKED:MF_UNCHECKED);
				EnableMenuItem(hmenu, ID_QRU_ENABLE, Groups?MF_ENABLED:MF_GRAYED);
				NumberMenuItem(hmenu, ID_QRU_INTERVAL, ActiveConfig.QRU.Interval,"min");
				NumberMenuItem(hmenu, ID_QRU_MAX_OBJS, ActiveConfig.QRU.MaxObjs," Objs");
				NumberMenuItem(hmenu, ID_QRU_RANGE, ActiveConfig.QRU.Range,ActiveConfig.View.Metric.Distance?"km":"mi");
				if (Groups) free(Groups);
			}
		}

		if (id == ID_CONFIGURE_BEACON_MICE_NONE)	/* First element of the sub menu */
		{	unsigned long m;
			if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
			ClearMenuItems(cInfo, hmenu, ID_CONFIGURE_BEACON_MICE_NONE, 1);
			CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_MICE_NONE, !ActiveConfig.Beacon.MicETag[0]?MF_CHECKED:MF_UNCHECKED);
			for (m=0; m<ActiveConfig.MicEs.Count; m++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[m];
				if (Action->Tag[0])	/* Transmittable? */
				{	size_t Remain = 100*sizeof(TCHAR);
					TCHAR *Name = (TCHAR *) malloc(Remain);
					TCHAR *Next = Name;
					StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("%S"), Action->Tag);
					BOOL Checked = !_strnicmp(ActiveConfig.Beacon.MicETag, Action->Tag,
											sizeof(ActiveConfig.Beacon.MicETag));
					AddMenuItem(cInfo, hmenu, ID_CONFIGURE_BEACON_MICE_NONE, m,
								MENU_POS_APPEND, (Checked?MF_CHECKED:0) | MF_STRING, Name);
					free(Name);
				}
			}
		}

		if (id == ID_CONFIGURE_MICE_NOTIF_SUPPRESSED)	/* First element of the sub menu */
		{	unsigned long m;
			if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
			ClearMenuItems(cInfo, hmenu, ID_CONFIGURE_MICE_NOTIF_SUPPRESSED, 3);
			CheckMenuItem (hmenu, ID_CONFIGURE_MICE_NOTIF_SUPPRESSED, !ActiveConfig.Enables.MicENotification?MF_CHECKED:MF_UNCHECKED);
			CheckMenuItem (hmenu, ID_CONFIGURE_MICE_NOTIF_NO_EMERGENCY, !ActiveConfig.Enables.MicEEmergency?MF_CHECKED:MF_UNCHECKED);
			for (m=0; m<ActiveConfig.MicEs.Count; m++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[m];

				if (Action->InternalMessage
				|| Action->MultiTrackNew
				|| Action->MultiTrackActive
#ifndef UNDER_CE
				|| Action->FlashOnCenter
#endif
				|| Action->Highlight)
				{	size_t Remain = 100*sizeof(TCHAR);
					TCHAR *Name = (TCHAR *) malloc(Remain);
					TCHAR *Next = Name;
					StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("%S"), Action->Name);
					if (Action->InternalMessage)
						StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Msg"));
					if (Action->MultiTrackNew)
						StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" New"));
					if (Action->MultiTrackActive)
						StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Active"));
#ifndef UNDER_CE
					if (Action->FlashOnCenter)
						StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" Flash"));
#endif
					if (Action->Highlight)
					{	StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT(" %S"), Action->Color);
						if (!Action->ColorFixed)
						{	Action->RGB = GetColorRGB(&ActiveConfig, Action->Color, "MicE");
							Action->ColorFixed = TRUE;
						}
						if (!Action->RGB	/* Failed translation? */
						&& _stricmp(Action->Color,"black"))	/* and not really black? */
						{	StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("(*BLACK*)"));
						}
					}
					AddMenuItem(cInfo, hmenu, ID_CONFIGURE_MICE_NOTIF_SUPPRESSED, m,
								MENU_POS_APPEND, (Action->Enabled?MF_CHECKED:0) | MF_STRING, Name);
					free(Name);
				}
			}
		}

		if (id == ID_CLEAR_MICE_IGNORES)	/* First element of the sub menu */
		{	unsigned long m, c=0;
			if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
			ClearMenuItems(cInfo, hmenu, ID_CLEAR_MICE_IGNORES, 2);
			for (m=0; m<ActiveConfig.MicEs.Count; m++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[m];
				c += Action->Ignores.Count;
				if (Action->Ignores.Count)
				{	size_t Remain = 100*sizeof(TCHAR);
					TCHAR *Name = (TCHAR *) malloc(Remain);
					TCHAR *Next = Name;
					StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("%S (%ld)"), Action->Name, Action->Ignores.Count);
					AddMenuItem(cInfo, hmenu, ID_CLEAR_MICE_IGNORES, m,
								MENU_POS_APPEND, MF_STRING, Name);
					free(Name);
				}
			}
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_MICE_IGNORES, c);
		}

		if (id == ID_CLEAR_TACTICAL_ACCEPTS)	/* First element of the sub menu */
		{
#ifdef FUTURE
			unsigned long m, c=0;
			if (!ActiveConfig.MicEs.Count) GetMicEActionIndex(&ActiveConfig, "Off Duty", "MenuPrime");
			ClearMenuItems(cInfo, hmenu, ID_CLEAR_MICE_IGNORES, 2);
			for (m=0; m<ActiveConfig.MicEs.Count; m++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[m];
				c += Action->Ignores.Count;
				if (Action->Ignores.Count)
				{	size_t Remain = 100*sizeof(TCHAR);
					TCHAR *Name = (TCHAR *) malloc(Remain);
					TCHAR *Next = Name;
					StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS, TEXT("%S (%ld)"), Action->Name, Action->Ignores.Count);
					AddMenuItem(cInfo, hmenu, ID_CLEAR_MICE_IGNORES, m,
								MENU_POS_APPEND, MF_STRING, Name);
					free(Name);
				}
			}
#endif
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_TACTICAL_ACCEPTS, ActiveConfig.TacticalSources.Count);
			CheckEnableNumberMenuItem(hmenu, ID_CLEAR_TACTICAL_NEVERS, ActiveConfig.TacticalNevers.Count);
		}

		if (id == ID_CONFIGURE_NEW_TILE_SERVER)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=2; p--)	/* 2 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.TileServers.Count; p++)
			{	TCHAR Name[80+sizeof(ActiveConfig.TileServers.Server[0].Name)];
				TILE_SERVER_INFO_S *Server = &ActiveConfig.TileServers.Server[p];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Server->Name);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NEW_TILE_SERVER+(p+1), Name);
				CheckMenuItem(hmenu, ID_CONFIGURE_NEW_TILE_SERVER+(p+1), 
							!_strnicmp(Server->Name,ActiveConfig.OSM.Name,sizeof(Server->Name))?MF_CHECKED:MF_UNCHECKED);
			}
		}
		if (id == ID_SELECT_TILE_SERVER+1)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=0; p--)	/* 0 original elements */
			{	DeleteMenu(hmenu, p, MF_BYPOSITION);
				if (!p) break;	/* Unsigneds don't go negative */
			}
			for (p=0; p<ActiveConfig.TileServers.Count; p++)
			{	TCHAR Name[80+sizeof(ActiveConfig.TileServers.Server[0].Name)];
				TILE_SERVER_INFO_S *Server = &ActiveConfig.TileServers.Server[p];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Server->Name);
				AppendMenu(hmenu, MF_STRING, ID_SELECT_TILE_SERVER+(p+1), Name);
				CheckMenuItem(hmenu, ID_SELECT_TILE_SERVER+(p+1), 
							!_strnicmp(Server->Name,cInfo->tsInfo.Name,sizeof(Server->Name))?MF_CHECKED:MF_UNCHECKED);
			}
		}
		if (id == ID_CONFIGURE_BEACON_COMMENT_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			for (p=cMenuItems-1; p>=2; p--)	/* 2 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(&ActiveConfig.CommentChoices);
			for (p=0; p<ActiveConfig.CommentChoices.Count; p++)
			{	char *String;
#ifdef USE_TIMED_STRINGS
				String = ActiveConfig.CommentChoices.Entries[p].string;
#else
				String = ActiveConfig.CommentChoices.Strings[p];
#endif
				size_t Remaining = sizeof(TCHAR)*2*strlen(String);
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S"), String);
				for (TCHAR *pn=Name; *pn; pn++)
				{	if (*pn == TEXT('&'))
					{	memmove(&pn[1], &pn[0], (wcslen(pn)+1)*sizeof(TCHAR));
						*pn++ = TEXT('&');
					}
				}
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_BEACON_COMMENT_NONE+(p+1), Name);
				free(Name);

				if (ActiveConfig.Beacon.Comment)
				{	BOOL Matched = !strncmp(COMMENT, String, sizeof(COMMENT));
					CheckMenuItem(hmenu, ID_CONFIGURE_BEACON_COMMENT_NONE+(p+1), 
									Matched?MF_CHECKED:MF_UNCHECKED);
					if (Matched) FoundOne = TRUE;
				}
			}
			CheckMenuItem(hmenu, ID_CONFIGURE_BEACON_COMMENT_NEW, !FoundOne?MF_CHECKED:MF_UNCHECKED);
		}

		if (id == ID_CONFIGURE_SYMBOL_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			for (p=cMenuItems-1; p>=1; p--)	/* 1 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(&ActiveConfig.SymbolChoices);
			for (p=0; p<ActiveConfig.SymbolChoices.Count; p++)
			{	size_t Remaining = sizeof(TCHAR)*80;
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				char *String;
#ifdef USE_TIMED_STRINGS
				String = ActiveConfig.SymbolChoices.Entries[p].string;
#else
				String = ActiveConfig.SymbolChoices.Strings[p];
#endif
				char *symName = GetDisplayableSymbol(SymbolInt(String[0], String[1]));
				StringCbPrintf(Name, Remaining, TEXT("%S (%S)"),
					symName, String);
				free(symName);
				for (TCHAR *pn=Name; *pn; pn++)
				{	if (*pn == TEXT('&'))
					{	memmove(&pn[1], &pn[0], (wcslen(pn)+1)*sizeof(TCHAR));
						*pn++ = TEXT('&');
					}
				}
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_SYMBOL_NEW+(p+1), Name);
				free(Name);
				{	BOOL Matched = ActiveConfig.Symbol.Table == String[0]
								&& ActiveConfig.Symbol.Symbol == String[1];
					CheckMenuItem(hmenu, ID_CONFIGURE_SYMBOL_NEW+(p+1), 
									Matched?MF_CHECKED:MF_UNCHECKED);
					if (Matched) FoundOne = TRUE;
				}
			}
			CheckMenuItem(hmenu, ID_CONFIGURE_SYMBOL_NEW, !FoundOne?MF_CHECKED:MF_UNCHECKED);
		}
		if (id == ID_CONFIGURE_NICKNAME_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			size_t Remaining = sizeof(TCHAR)*80;
			TCHAR *Name = (TCHAR*)malloc(Remaining);
			for (p=cMenuItems-1; p>=4; p--)	/* 4 original elements */
			{
#ifndef UNDER_CE
				MENUITEMINFO mii = {0};
				mii.cbSize = sizeof(mii); 
				mii.fMask = MIIM_CHECKMARKS;
				if (GetMenuItemInfo(hmenu, p, TRUE, &mii))
				{	if (mii.hbmpChecked	/* If it has checked */
					&& !mii.hbmpUnchecked)	/* But no Unchecked */
					{	if (!DeleteObject(mii.hbmpChecked))
							TraceError(hwnd, "Failed To Delete Nickname[%ld] Bitmap\n", p);
					}
				}
#endif
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			}
			SortNicknames(&ActiveConfig);
			for (p=0; p<ActiveConfig.Nicknames.Count; p++)
			{	NICKNAME_INFO_S *pNick = &ActiveConfig.Nicknames.Nick[p];
				if (pNick->DefinedBy[0])
				StringCbPrintf(Name, Remaining, TEXT("%S (%S) @%S"),
								*pNick->Label?pNick->Label:"*BLANK*",
								*pNick->Station?pNick->Station:CALLSIGN,
								pNick->DefinedBy);
				else StringCbPrintf(Name, Remaining, TEXT("%S (%S)"),
								*pNick->Label?pNick->Label:"*BLANK*",
								*pNick->Station?pNick->Station:CALLSIGN);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NICKNAME_NEW+(p+1), Name);
#ifndef UNDER_CE
				HBITMAP hbm = MakeSymbolBitmap(hwndMain,
									SymbolInt(pNick->Symbol.Table,
												pNick->Symbol.Symbol),
									GetSystemMetrics(SM_CXMENUCHECK),
									GetSystemMetrics(SM_CYMENUCHECK),
									COLOR_MENU);
				if (hbm) SetMenuItemBitmaps(hmenu, ID_CONFIGURE_NICKNAME_NEW+(p+1), MF_BYCOMMAND, NULL, hbm);
#endif
				CheckMenuItem(hmenu, ID_CONFIGURE_NICKNAME_NEW+(p+1), pNick->Enabled?MF_CHECKED:MF_UNCHECKED);
			}
			free(Name);
			CheckEnableNumberMenuItem(hmenu, ID_SCREEN_LABEL_NICKNAME_DELETE, ActiveConfig.Nicknames.Count-1);
#ifdef OBSOLETE
		if (ActiveConfig.Tacticals.Count)
		{	unsigned long p;
			AppendMenu(hmenu, MF_SEPARATOR, NULL, NULL);
			STRING_LIST_S *pList = &ActiveConfig.Tacticals;
			SortTacticals(&ActiveConfig);
			for (p=0; p<pList->Count; p++)
			{	size_t Remaining = sizeof(TCHAR)*80;
				char *String = pList->Entries[p].string;
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S => %.20S"),
								String+21, String);
				AddMenuItem(cInfo, hmenu, ID_TACTICAL_ENABLE, p,
								MENU_POS_APPEND, MF_STRING|(pList->Entries[p].value?MF_CHECKED:0), Name);
				free(Name);
			}
		}
#endif
		}

		if (id == ID_SCREEN_TRACKS_OTHER_COLOR)
		{	if (ActiveConfig.TrackColors.Count)
			{	unsigned long p;
				unsigned long c=0;
				char *color = NULL;
				STRING_LIST_S *pList = &ActiveConfig.TrackColors;
				for (p=0; p<pList->Count; p++)
				if (pList->Entries[p].value)
				{	c++;
					color = pList->Entries[p].string;
				}
				if (c==1)
				{	strncpy(ActiveConfig.Screen.Track.Other.Color,
							color,
							sizeof(ActiveConfig.Screen.Track.Other.Color));
					ActiveConfig.Screen.Track.Other.RGB = GetColorRGB(&ActiveConfig, color, "Menu:Other:Color");
				}
				CheckMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER_COLOR, ActiveConfig.Screen.Track.Other.Color[0]?MF_CHECKED:MF_UNCHECKED);
				ExtendMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER_COLOR, ActiveConfig.Screen.Track.Other.Color);
			}
		}
#ifdef ID_TRACK_COLOR_SELECT
		if (id == ID_SCREEN_TRACKS_OTHER_ADD_COLOR)
		{
			ClearMenuItems(cInfo, hmenu, ID_TRACK_COLOR_SELECT, -1);
			if (ActiveConfig.TrackColors.Count)
			{	unsigned long p;
				STRING_LIST_S *pList = &ActiveConfig.TrackColors;
				SortStringList(pList);
				for (p=0; p<pList->Count; p++)
				{	size_t Remaining = sizeof(TCHAR)*80;
					char *String = pList->Entries[p].string;
					TCHAR *Name = (TCHAR*)malloc(Remaining);
					StringCbPrintf(Name, Remaining, TEXT("%S"), String);
					AddMenuItem(cInfo, hmenu, ID_TRACK_COLOR_SELECT, p,
									MENU_POS_APPEND, MF_STRING|(pList->Entries[p].value?MF_CHECKED:0), Name);
					free(Name);
				}
			}
		}
#endif

		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW, cInfo->AutoZoomViewOut&&cInfo->AutoZoomViewIn?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_CTR, cInfo->AutoZoomViewCtr?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_AUTOZOOM_VIEW_CTR, cInfo->AutoZoomViewOut?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_OUT, cInfo->AutoZoomViewOut?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_IN, cInfo->AutoZoomViewOut&&cInfo->AutoZoomViewIn?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_AUTOZOOM_VIEW_IN, cInfo->AutoZoomViewOut?MF_ENABLED:MF_GRAYED);

		NumberMenuItem(hmenu, ID_SCREEN_TRACKS_FOLLOW, ActiveConfig.Screen.Track.Follow.Count);
		ExtendMenuItem(hmenu, ID_SCREEN_TRACKS_FOLLOW_COLOR, ActiveConfig.Screen.Track.Follow.Color);
		NumberMenuItem(hmenu, ID_SCREEN_TRACKS_FOLLOW_WIDTH,
						ActiveConfig.Screen.Track.Follow.Width, "pxl");

		NumberMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER, ActiveConfig.Screen.Track.Other.Count);
		CheckMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER_COLOR, ActiveConfig.Screen.Track.Other.Color[0]?MF_CHECKED:MF_UNCHECKED);
		ExtendMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER_COLOR, ActiveConfig.Screen.Track.Other.Color);
		NumberMenuItem(hmenu, ID_SCREEN_TRACKS_OTHER_WIDTH,
						ActiveConfig.Screen.Track.Other.Width, "pxl");

		{	unsigned long Count=0, StormCount=0;
			for (unsigned long s=0; s<CloseStationCount; s++)
			{	STATION_INFO_S *Station = pCloseStations[s];
				if (Station->Weather && Station->Weather->windspeed)
					Count++;
				else if (Station->Storm && Station->Storm->windspeed)
					StormCount++;
			}
			NumberMenuItem(hmenu, ID_SCREEN_WINDBARBS_ENABLED, Count);
			NumberMenuItem(hmenu, ID_SCREEN_WINDBARBS_ROTATE, StormCount);
		}
		CheckMenuItem (hmenu, ID_SCREEN_WINDBARBS_ENABLED, ActiveConfig.Screen.WindBarbs.Enabled?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_WINDBARBS_ROTATE, ActiveConfig.Screen.WindBarbs.RotateStorm?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_WINDBARBS_ROTATE, ActiveConfig.Screen.WindBarbs.Enabled?MF_ENABLED:MF_GRAYED);
		ExtendMenuItem(hmenu, ID_SCREEN_WINDBARBS_COLOR, ActiveConfig.Screen.WindBarbs.Color);
		NumberMenuItem(hmenu, ID_SCREEN_WINDBARBS_WIDTH,
						ActiveConfig.Screen.WindBarbs.Width, "pxl");

/*??????????????????????????*/

		if (id == ID_ALIASES_KNOWN_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			STRING_LIST_S *pList = &ActiveConfig.PathAliases;
			for (p=cMenuItems-1; p>=1; p--)	/* 1 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);

			for (p=0; p<pList->Count; p++)
			{	char Delta[80];
				char *String = pList->Entries[p].string;
				size_t Remaining = sizeof(TCHAR)*(strlen(String)+sizeof(Delta));
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S (%S)"),
								String,
								FormatIgnoreStringDelta(pList, String,
														Delta, sizeof(Delta)));
				AddMenuItem(cInfo, hmenu, ID_ALIASES_KNOWN_NEW, p, MENU_POS_APPEND,
							MF_STRING|(pList->Entries[p].value?0:MF_CHECKED), Name);
				free(Name);
			}
			EnableMenuItem(hmenu, ID_ALIASES_KNOWN_NEW, ActiveConfig.Update.Development?MF_ENABLED:MF_GRAYED);
		}
#ifndef UNDER_CE
		CheckMenuItem (hmenu, ID_ALIASES_ACCUMULATE, ActiveConfig.AccumulateAliases?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_ALIASES_ACCUMULATE, ActiveConfig.Update.Development?MF_ENABLED:MF_GRAYED);
		if (id == ID_ALIASES_POSSIBLE_CLEAR)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			STRING_LIST_S *pList = &ActiveConfig.NewAliases;
			for (p=cMenuItems-1; p>=1; p--)	/* 1 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);

			for (p=0; p<pList->Count; p++)
			{	char Delta[80];
				char *String = pList->Entries[p].string;
				size_t Remaining = sizeof(TCHAR)*(strlen(String)+sizeof(Delta));
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S (%S)"),
								String,
								FormatIgnoreStringDelta(pList, String,
														Delta, sizeof(Delta)));
				AddMenuItem(cInfo, hmenu, ID_ALIASES_POSSIBLE_CLEAR, p, MENU_POS_APPEND,
							MF_STRING, Name);
				free(Name);
			}
			EnableMenuItem(hmenu, ID_ALIASES_POSSIBLE_CLEAR, pList->Count?MF_ENABLED:MF_GRAYED);
		}
#endif
#ifndef UNDER_CE
		if (id == ID_ALIASES_0_CLEAR)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			STRING_LIST_S *pList = &ActiveConfig.ZeroAliases;
			for (p=cMenuItems-1; p>=1; p--)	/* 1 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);

			for (p=0; p<pList->Count; p++)
			{	char Delta[80];
				char *String = pList->Entries[p].string;
				size_t Remaining = sizeof(TCHAR)*(strlen(String)+sizeof(Delta));
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S (%S)"),
								String,
								FormatIgnoreStringDelta(pList, String,
														Delta, sizeof(Delta)));
				AddMenuItem(cInfo, hmenu, ID_ALIASES_0_CLEAR, p, MENU_POS_APPEND,
							MF_STRING, Name);
				free(Name);
			}
			EnableMenuItem(hmenu, ID_ALIASES_0_CLEAR, pList->Count?MF_ENABLED:MF_GRAYED);
		}
#endif
#ifdef FUTURE
static TIMED_STRING_LIST_S NewAliases = {0};
static TIMED_STRING_LIST_S ZeroAliases = {0};
			POPUP "Known"
			BEGIN
				MENUITEM "New...",				ID_ALIASES_KNOWN_NEW
			END
			POPUP "Gleaned"
			BEGIN
				MENUITEM "PlaceHolder",			ID_ALIASES_GLEANED
			END
			POPUP "Unused-0"
			BEGIN
				MENUITEM "PlaceHolder",			ID_ALIASES_0_PLACEHOLDER
			END
#endif

/*??????????????????????????*/

		if (id == ID_CONFIGURE_ALTNET_NONE)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			STRING_LIST_S *pList = &ActiveConfig.AltNetChoices;
			for (p=cMenuItems-1; p>=2; p--)	/* 2 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);
#ifdef OLD_WAY
			for (p=0; p<pList->Count; p++)
			{	size_t Remaining = sizeof(TCHAR)*80;
#ifdef USE_TIMED_STRINGS
				char *String = pList->Entries[p].string;
#else
				char *String = pList->Strings[p];
#endif
				char *This = String+(*String=='*'?1:0);
				int Count = strcmp(ActiveConfig.AltNet, This)?0:1;
				unsigned int s;
				for (s=1; s<CloseStationCount; s++)
					if (!strcmp(pCloseStations[s]->dstCall, This))
						Count++;
				if (Count || *String=='*')
				{	TCHAR *Name = (TCHAR*)malloc(Remaining);
					StringCbPrintf(Name, Remaining, TEXT("%S (%ld)"),
							String, Count);
					AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_ALTNET_NEW+(p+1), Name);
					if (!_strnicmp(ActiveConfig.AltNet, This, sizeof(ActiveConfig.AltNet)))
					{	CheckMenuItem(hmenu, ID_CONFIGURE_ALTNET_NEW+(p+1), MF_CHECKED);
						FoundOne = TRUE;
					}
					free(Name);
				}
			}
#else
			for (p=0; p<pList->Count; p++)
			if (pList->Entries[p].value)	/* Used? */
			{	size_t Remaining = sizeof(TCHAR)*80;
				char *String = pList->Entries[p].string;
				int Count = strcmp(ActiveConfig.AltNet, String)?0:1;
				for (unsigned int s=1; s<CloseStationCount; s++)
					if (!strcmp(pCloseStations[s]->dstCall, String))
						Count++;
				{	TCHAR *Name = (TCHAR*)malloc(Remaining);
					StringCbPrintf(Name, Remaining, TEXT("%S (%ld)"),
							String, Count);
					AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_ALTNET_NEW+(p+1), Name);
					if (!_strnicmp(ActiveConfig.AltNet, String, sizeof(ActiveConfig.AltNet)))
					{	CheckMenuItem(hmenu, ID_CONFIGURE_ALTNET_NEW+(p+1), MF_CHECKED);
						FoundOne = TRUE;
					}
					free(Name);
				}
			}
			for (p=0; p<pList->Count; p++)
			if (!pList->Entries[p].value)	/* Used? */
			{	size_t Remaining = sizeof(TCHAR)*80;
				char *String = pList->Entries[p].string;
				int Count = strcmp(ActiveConfig.AltNet, String)?0:1;
				for (unsigned int s=1; s<CloseStationCount; s++)
					if (!strcmp(pCloseStations[s]->dstCall, String))
						Count++;
				if (Count)
				{	TCHAR *Name = (TCHAR*)malloc(Remaining);
					StringCbPrintf(Name, Remaining, TEXT("%S (%ld)"),
							String, Count);
					AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_ALTNET_NEW+(p+1), Name);
					if (!_strnicmp(ActiveConfig.AltNet, String, sizeof(ActiveConfig.AltNet)))
					{	CheckMenuItem(hmenu, ID_CONFIGURE_ALTNET_NEW+(p+1), MF_CHECKED);
						FoundOne = TRUE;
					}
					free(Name);
				}
			}
#endif
			CheckMenuItem(hmenu, ID_CONFIGURE_ALTNET_NONE, !FoundOne?MF_CHECKED:MF_UNCHECKED);
		}
		if (id == ID_CONFIGURE_NWS_NEW_OFFICE)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			size_t Remaining = sizeof(TCHAR)*80;
			TCHAR *Name = (TCHAR*)malloc(Remaining);
			STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
#ifdef UNDER_CE	/* No multi-track here */
			for (p=cMenuItems-1; p>=9; p--)	/* 9 original elements */
#else
			for (p=cMenuItems-1; p>=10; p--)	/* 10 original elements */
#endif
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);
			for (p=0; p<pList->Count; p++)
			{	char *String = pList->Entries[p].string;
				if (*String == '*')
					StringCbPrintf(Name, Remaining, TEXT("*ALL*"));
				else StringCbPrintf(Name, Remaining, TEXT("%S"), String);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NWS_NEW_OFFICE+(p+1), Name);
				CheckMenuItem(hmenu, ID_CONFIGURE_NWS_NEW_OFFICE+(p+1), !pList->Entries[p].value?MF_CHECKED:MF_UNCHECKED);
			}
			free(Name);

			{	int eCount=0;
				unsigned long o;
				TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
				for (o=0; o<pList->Count; o++)
					if (pList->Entries[o].value)
						eCount++;
				EnableMenuItem(hmenu, ID_CONFIGURE_NWS_SHOW_OFFICES, ActiveConfig.NWS.ShapesEnabled&&ActiveConfig.NWS.ShapeFiles.Count&&eCount&&(int)eCount<=GetFreeTrackerCount()?MF_ENABLED:MF_GRAYED);
				EnableMenuItem(hmenu, ID_CONFIGURE_NWS_SHOW_OFFICES_ALL, ActiveConfig.NWS.ShapesEnabled&&ActiveConfig.NWS.ShapeFiles.Count&&ActiveConfig.NWS.Offices.Count&&GetFreeTrackerCount()?MF_ENABLED:MF_GRAYED);
			}
		}
		if (id == ID_CONFIGURE_NWS_ENTRY_SERVER)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			size_t Remaining = sizeof(TCHAR)*(80+sizeof(ActiveConfig.NWSServers.Srv->EntryCall)+sizeof(ActiveConfig.NWSServers.Srv->Desc));
			TCHAR *Name = (TCHAR*)malloc(Remaining);

			if (!ActiveConfig.NWSServers.Count)
				GetNWSServer(&ActiveConfig, NULL, "Menu", "", FALSE);	/* Prime it */

			for (p=cMenuItems-1; p>=0; p--)	/* NO original elements */
			{	DeleteMenu(hmenu, p, MF_BYPOSITION);
				if (!p) break;	/* unsigneds don't go negative */
			}
			for (p=0; p<ActiveConfig.NWSServers.Count; p++)
			{	StringCbPrintf(Name, Remaining, TEXT("%S %S"),
								ActiveConfig.NWSServers.Srv[p].EntryCall,
								ActiveConfig.NWSServers.Srv[p].Desc);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NWS_ENTRY_SERVER+(p), Name);
				CheckMenuItem(hmenu, ID_CONFIGURE_NWS_ENTRY_SERVER+(p), !ActiveConfig.NWSServers.Srv[p].Disabled?MF_CHECKED:MF_UNCHECKED);
			}
			free(Name);
		}
		if (id == ID_CONFIGURE_MULTILINE_STYLE)	/* First element of the sub menu */
		{
			if (!ActiveConfig.LineStyles.Count)	/* Prime the pump */
				GetMultiLineStyle(&ActiveConfig, 'a', "Menu");
			if (!ActiveConfig.NWSProducts.Count)	/* Prime the pump */
				GetNWSProduct(&ActiveConfig, "???", "Menu", "GUI");

			if (ActiveConfig.LineStyles.Count)
			{	unsigned long p;
				BOOL FoundOne = FALSE;
				size_t Remaining = sizeof(TCHAR)*(80+sizeof(ActiveConfig.LineStyles.Style->sLineType)+sizeof(ActiveConfig.LineStyles.Style->Desc));
				TCHAR *Name = (TCHAR*)malloc(Remaining);

				for (p=cMenuItems-1; p>=0; p--)	/* 0 original elements */
				{	DeleteMenu(hmenu, p, MF_BYPOSITION);
					if (!p) break;	/* unsigned's never go negative! */
				}

				for (p=0; p<ActiveConfig.LineStyles.Count; p++)
				{	MULTILINE_STYLE_S *Style = &ActiveConfig.LineStyles.Style[p];
					int Count = 0, Match = 0;
					for (unsigned long x=0; x<ActiveConfig.NWSProducts.Count; x++)
					{	NWS_PRODUCT_S *Prod = &ActiveConfig.NWSProducts.Prod[x];
						if (Prod->LineType == *Style->sLineType)
						{		Count++;
								if (Prod->ActionEnabled == Style->ActionEnabled)
									Match++;
						}
					}

					StringCbPrintf(Name, Remaining, TEXT("%S %S (%ld/%ld Prods)"),
									Style->sLineType, Style->Desc, Match, Count);
					AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_MULTILINE_STYLE+(p), Name);
					CheckMenuItem(hmenu, ID_CONFIGURE_MULTILINE_STYLE+(p), Style->ActionEnabled?MF_CHECKED:MF_UNCHECKED);
				}
				free(Name);
			} else
			{	for (unsigned long p=0; p<ActiveConfig.LineStyles.Count; p++)
				{	MULTILINE_STYLE_S *Style = &ActiveConfig.LineStyles.Style[p];
					CheckMenuItem(hmenu, ID_CONFIGURE_MULTILINE_STYLE+(p), Style->ActionEnabled?MF_CHECKED:MF_UNCHECKED);
				}
			}
		}
		if (id == ID_CONFIGURE_NWS_PRODUCTS)	/* First element of the sub menu */
		{	if (!ActiveConfig.NWSProducts.Count)	/* Prime the pump */
				GetNWSProduct(&ActiveConfig, "???", "Menu", "GUI");
			else SortNWSProducts(&ActiveConfig);
			if (ActiveConfig.NWSProducts.Count)
			{	unsigned long p, q;
				BOOL FoundOne = FALSE;
				size_t Remaining = sizeof(TCHAR)*(80+sizeof(ActiveConfig.NWSProducts.Prod->PID)+sizeof(ActiveConfig.NWSProducts.Prod->Desc));
				TCHAR *Name = (TCHAR*)malloc(Remaining);

				for (p=cMenuItems-1; p>=1; p--)	/* 0 original elements */
				{
#ifndef UNDER_CE
					MENUITEMINFO mii = {0};
					mii.cbSize = sizeof(mii); 
					mii.fMask = MIIM_CHECKMARKS;
					if (GetMenuItemInfo(hmenu, p, TRUE, &mii))
					{	if (mii.hbmpChecked	/* If it has checked */
						&& !mii.hbmpUnchecked)	/* But no Unchecked */
						{	if (!DeleteObject(mii.hbmpChecked))
								TraceError(hwnd, "Failed To Delete NWSProduct[%ld] Bitmap\n", p);
						}
					}
#endif
					DeleteMenu(hmenu, p, MF_BYPOSITION);
					if (!p) break;	/* unsigned's never go negative! */
				}
				EnableMenuItem(hmenu, ID_CONFIGURE_NWS_PRODUCTS, MF_GRAYED);
				NumberMenuItem(hmenu, ID_CONFIGURE_NWS_PRODUCTS,
							(long) ActiveConfig.NWSProducts.Count);
				BOOL *DidIt = (BOOL*)calloc(ActiveConfig.NWSProducts.Count,sizeof(*DidIt));
				for (q=0; q<ActiveConfig.NWSProducts.Count; q++)
				if (!DidIt[q])
				{	NWS_PRODUCT_S *qProd = &ActiveConfig.NWSProducts.Prod[q];
					HMENU hSub = CreatePopupMenu();
static struct
{	char LineType;
	char *Color;
	char *Usage;
} Types[] = { { 'a', "red solid", "Tornado Warning" },
				{ 'b', "red dashed", "Tornado Watch" },
				{ 'c', "red double-dashed", NULL },
				{ 'd', "yellow solid", "Severe Thunderstorm Warning" },
				{ 'e', "yellow dashed", "Severe Thunderstorm Watch" },
				{ 'f', "yellow double-dashed", NULL },
				{ 'g', "blue solid", "Test Warning" },
				{ 'h', "blue dashed", "Test Watch" },
				{ 'i', "blue double-dashed", NULL },
				{ 'j', "green solid", NULL },
				{ 'k', "green dashed", "Mesoscale Discussion" },
				{ 'l', "green double-dashed", NULL },
				{ '*', "Undefined", "Undefined" } };	/* MUST be LAST */

					int t;
					for (t=0; t<ARRAYSIZE(Types)-1; t++)
						if (Types[t].LineType == qProd->LineType)
							break;
					StringCbPrintf(Name, Remaining, TEXT("%.1S %S"), &qProd->LineType, Types[t].Usage?Types[t].Usage:Types[t].Color);
					AppendMenu(hmenu, MF_POPUP, (UINT_PTR) hSub, Name);

					for (p=q; p<ActiveConfig.NWSProducts.Count; p++)
					if (!DidIt[p]
					&& ActiveConfig.NWSProducts.Prod[p].LineType == qProd->LineType)
					{	NWS_PRODUCT_S *Prod = &ActiveConfig.NWSProducts.Prod[p];
						StringCbPrintf(Name, Remaining, TEXT("%S %S (%.1S)"), Prod->PID, Prod->Desc, &Prod->LineType);
						AppendMenu(hSub, MF_STRING | (Prod->ActionEnabled?MF_CHECKED:MF_UNCHECKED), ID_CONFIGURE_NWS_PRODUCTS+(p+1), Name);

#ifndef UNDER_CE
						HBITMAP hbm = MakeSymbolBitmap(hwndMain,
											SymbolInt(Prod->Symbol.Table,
														Prod->Symbol.Symbol),
											GetSystemMetrics(SM_CXMENUCHECK),
											GetSystemMetrics(SM_CYMENUCHECK),
											COLOR_MENU);
						if (hbm) SetMenuItemBitmaps(hSub, ID_CONFIGURE_NWS_PRODUCTS+(p+1), MF_BYCOMMAND, NULL, hbm);
#endif
						DidIt[p] = TRUE;
					}
				}
				free(DidIt);
				free(Name);
			}
		}
#ifdef SUPPORT_SHAPEFILES
		if (id == ID_CONFIGURE_NWS_NEW_SHAPEFILE)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			size_t Remaining = sizeof(TCHAR)*80;
			TCHAR *Name = (TCHAR*)malloc(Remaining);
			TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.ShapeFiles;
			for (p=cMenuItems-1; p>=6; p--)	/* 6 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);
			for (p=0; p<pList->Count; p++)
			{	StringCbPrintf(Name, Remaining, TEXT("%S"), pList->Entries[p].string);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_NWS_NEW_SHAPEFILE+(p+1), Name);
				if (ProbeShapeFile(pList->Entries[p].string))
				{	CheckMenuItem(hmenu, ID_CONFIGURE_NWS_NEW_SHAPEFILE+(p+1), !pList->Entries[p].value?MF_CHECKED:MF_UNCHECKED);
				} else EnableMenuItem(hmenu, ID_CONFIGURE_NWS_NEW_SHAPEFILE+(p+1), MF_GRAYED);
			}
			free(Name);
#ifdef SUPPORT_SHAPEFILES
			CheckMenuItem (hmenu, ID_CONFIGURE_NWS_SHAPES_ENABLED, ActiveConfig.NWS.ShapesEnabled?MF_CHECKED:MF_UNCHECKED);
			EnableMenuItem(hmenu, ID_CONFIGURE_NWS_SHAPE_OPACITY, ActiveConfig.NWS.ShapesEnabled?MF_ENABLED:MF_GRAYED);
			NumberMenuItem(hmenu, ID_CONFIGURE_NWS_SHAPE_OPACITY, ActiveConfig.NWS.Opacity,"%");
			EnableMenuItem(hmenu, ID_CONFIGURE_NWS_SHAPE_QUALITY, ActiveConfig.NWS.ShapesEnabled?MF_ENABLED:MF_GRAYED);
			NumberMenuItem(hmenu, ID_CONFIGURE_NWS_SHAPE_QUALITY, ActiveConfig.NWS.Quality,"%");
#endif

			EnableMenuItem(hmenu, ID_CONFIGURE_NWS_SHAPE_TEST, ActiveConfig.NWS.ShapesEnabled&&ActiveConfig.NWS.ShapeFiles.Count&&GetFreeTrackerCount()?MF_ENABLED:MF_GRAYED);
		}
#endif

		if (id == ID_CONFIGURE_GPX_NEW)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			size_t Remaining = sizeof(TCHAR)*MAX_PATH;
			TCHAR *Name = (TCHAR*)malloc(Remaining);
			for (p=cMenuItems-1; p>=3; p--)	/* 3 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			for (p=0; p<ActiveConfig.Overlays.Count; p++)
			{	OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[p];
				StringCbPrintf(Name, Remaining, TEXT("%S"), pOver->FileName);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_GPX_NEW+(p+1), Name);
				FILE *Test = fopen(pOver->FileName,"r");
				if (Test)
				{	CheckMenuItem(hmenu, ID_CONFIGURE_GPX_NEW+(p+1), pOver->Enabled?MF_CHECKED:MF_UNCHECKED);
					fclose(Test);
				} else EnableMenuItem(hmenu, ID_CONFIGURE_GPX_NEW+(p+1), MF_GRAYED);
			}
			free(Name);
		}

		if (id == ID_CONFIGURE_AUTO_REPLY_NONE)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
			STRING_LIST_S *pList = &ActiveConfig.Messaging.AutoAnswer.ReplyChoices;
			for (p=cMenuItems-1; p>=2; p--)	/* 2 original elements */
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(pList);
			for (p=0; p<pList->Count; p++)
			{	size_t Remaining = sizeof(TCHAR)*80;
#ifdef USE_TIMED_STRINGS
				char *This = pList->Entries[p].string;
#else
				char *This = pList->Strings[p];
#endif
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S"), This);
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_AUTO_REPLY_NEW+(p+1), Name);
				if (!_strnicmp(ActiveConfig.Messaging.AutoAnswer.Reply, This, sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)))
				{	CheckMenuItem(hmenu, ID_CONFIGURE_AUTO_REPLY_NEW+(p+1), MF_CHECKED);
					FoundOne = TRUE;
				}
				free(Name);
			}
			CheckMenuItem(hmenu, ID_CONFIGURE_AUTO_REPLY_NONE, !FoundOne?MF_CHECKED:MF_UNCHECKED);
		}

		if (id == ID_CONFIGURE_STATUS_TEXT_ENABLED)	/* First element of the sub menu */
		{	unsigned long p;
			BOOL FoundOne = FALSE;
#ifdef UNDER_CE
			for (p=cMenuItems-1; p>=8; p--)	/* 8 original elements */
#else
			for (p=cMenuItems-1; p>=7; p--)	/* 7 original elements */
#endif
				DeleteMenu(hmenu, p, MF_BYPOSITION);
			SortStringList(&ActiveConfig.Status.Choices);
			for (p=0; p<ActiveConfig.Status.Choices.Count; p++)
			{
#ifdef USE_TIMED_STRINGS
				char *String = ActiveConfig.Status.Choices.Entries[p].string;
#else
				char *String = ActiveConfig.Status.Choices.Strings[p];
#endif
				size_t Remaining = sizeof(TCHAR)*2*strlen(String);
				TCHAR *Name = (TCHAR*)malloc(Remaining);
				StringCbPrintf(Name, Remaining, TEXT("%S"), String);
				for (TCHAR *pn=Name; *pn; pn++)
				{	if (*pn == TEXT('&'))
					{	memmove(&pn[1], &pn[0], (wcslen(pn)+1)*sizeof(TCHAR));
						*pn++ = TEXT('&');
					}
				}
				AppendMenu(hmenu, MF_STRING, ID_CONFIGURE_STATUS_TEXT_NONE+(p+1), Name);
				free(Name);

				if (ActiveConfig.Status.Enabled && ActiveConfig.Status.Interval)
				{	BOOL Matched = !strncmp(ActiveConfig.Status.Text, String, sizeof(ActiveConfig.Status.Text));
					CheckMenuItem(hmenu, ID_CONFIGURE_STATUS_TEXT_NONE+(p+1), 
									Matched?MF_CHECKED:MF_UNCHECKED);
					if (Matched) FoundOne = TRUE;
				}
			}

			CheckMenuItem(hmenu, ID_CONFIGURE_STATUS_TEXT_NEW, !FoundOne?MF_CHECKED:MF_UNCHECKED);

			CheckMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_ENABLED, ActiveConfig.Status.Enabled?MF_CHECKED:MF_UNCHECKED);
#ifdef MONITOR_PHONE
			CheckMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_CELLULAR, ActiveConfig.Status.Cellular?MF_CHECKED:MF_UNCHECKED);
#endif
			EnableMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_GRIDSQ, !ActiveConfig.Status.Timestamp&&!ActiveConfig.Status.DX?MF_ENABLED:MF_GRAYED);
			CheckMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_GRIDSQ, ActiveConfig.Status.GridSquare?MF_CHECKED:MF_UNCHECKED);
			EnableMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_TIME, !ActiveConfig.Status.GridSquare&&!ActiveConfig.Status.DX?MF_ENABLED:MF_GRAYED);
			CheckMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_TIME, ActiveConfig.Status.Timestamp?MF_CHECKED:MF_UNCHECKED);
			EnableMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_TIME, !ActiveConfig.Status.GridSquare&&!ActiveConfig.Status.DX?MF_ENABLED:MF_GRAYED);
			EnableMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_DX, ActiveConfig.RFPorts.Count&&!ActiveConfig.Status.GridSquare?MF_ENABLED:MF_GRAYED);
			CheckMenuItem (hmenu, ID_CONFIGURE_STATUS_TEXT_DX, ActiveConfig.Status.DX?MF_CHECKED:MF_UNCHECKED);

			{	double MaxDist = 0;	// Trigger for DX formatting
				unsigned long MaxPPC = 0;	// Which PortPackets[] is MaxDist
				if (ActiveConfig.Status.DX)
				{	unsigned long ppc;
					for (ppc=0; ppc<PortPacketCount; ppc++)
					if (PortPackets[ppc].DXCount)
					{	if (MaxDist < PortPackets[ppc].DXList[0].Distance)
						{	MaxDist = PortPackets[ppc].DXList[0].Distance;
							MaxPPC = ppc;
						}
					}
				}
				if (MaxDist)
				{	char Buffer[80];
					StringCbPrintfA(Buffer, sizeof(Buffer),
									"%.*s %.1lf%s %ld",
										STRING(PortPackets[MaxPPC].DXList[0].Station),
										(double) (PortPackets[MaxPPC].DXList[0].Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
										ActiveConfig.View.Metric.Distance?"km":"mi",
										(long) PortPackets[MaxPPC].DXList[0].Bearing);
					ExtendMenuItem(hmenu, ID_CONFIGURE_STATUS_TEXT_DX, Buffer);
				} else ExtendMenuItem(hmenu, ID_CONFIGURE_STATUS_TEXT_DX, "");
			}
		}

		if (id == ID_CONFIGURE_DX_MIN_DIST)	/* First element of the sub menu */
		{	NumberMenuItem(hmenu, ID_CONFIGURE_DX_MIN_DIST, ActiveConfig.DX.MinDist, ActiveConfig.View.Metric.Distance?"km":"mi");
			NumberMenuItem(hmenu, ID_CONFIGURE_DX_MIN_TRIGGER, ActiveConfig.DX.MinTrigger, ActiveConfig.View.Metric.Distance?"km":"mi");
			NumberMenuItem(hmenu, ID_CONFIGURE_DX_MIN_INTERVAL, ActiveConfig.DX.MinInterval, "min");
			NumberMenuItem(hmenu, ID_CONFIGURE_DX_WINDOW, ActiveConfig.DX.Window, "min");
			EnableMenuItem (hmenu, ID_CONFIGURE_DX_MAXEVER, ActiveConfig.DX.MaxEver.Station[0]?MF_ENABLED:MF_GRAYED);
			if (ActiveConfig.DX.MaxEver.Station[0])
			{	char Buffer[80];
				StringCbPrintfA(Buffer, sizeof(Buffer),
								"%ld*%.*s %.1lf%s %ld",
								ActiveConfig.DX.MaxEver.Count,
								STRING(ActiveConfig.DX.MaxEver.Station),
									(double) (ActiveConfig.DX.MaxEver.Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
									ActiveConfig.View.Metric.Distance?"km":"mi",
									(long) ActiveConfig.DX.MaxEver.Bearing);
				ExtendMenuItem(hmenu, ID_CONFIGURE_DX_MAXEVER, Buffer);
			} else ExtendMenuItem(hmenu, ID_CONFIGURE_DX_MAXEVER, "");
		}
		if (id == ID_CONFIGURE_DX_IGNORE_NONE)
		{	TIMED_STRING_LIST_S *pList = &ActiveConfig.DX.Excluded;
			unsigned long m;
			SortStringList(pList);
			ClearMenuItems(cInfo, hmenu, ID_CONFIGURE_DX_IGNORE_NONE, 1);
			for (m=0; m<pList->Count; m++)
			{	TIMED_STRING_S *pString = &pList->Entries[m];
				size_t Remain = 100*sizeof(TCHAR);
				TCHAR *Name = (TCHAR *) malloc(Remain);
				TCHAR *Next = Name;
				char Buffer[80];
				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
								TEXT("%S (%S)"), pString->string,
								FormatDeltaTime(SecondsSince(&pString->time),
												Buffer, sizeof(Buffer)));
				AddMenuItem(cInfo, hmenu, ID_CONFIGURE_DX_IGNORE_NONE, m,
							MENU_POS_APPEND, MF_STRING|MF_CHECKED, Name);
				free(Name);
			}
			CheckEnableNumberMenuItem(hmenu, ID_CONFIGURE_DX_IGNORE_NONE, pList->Count);
		}

		if (id == ID_CONFIGURE_POSITS_PATHS)
		{	CheckMenuItem (hmenu, ID_CONFIGURE_POSITS_PATHS, ActiveConfig.SavedPositPaths?MF_CHECKED:MF_UNCHECKED);
			CheckMenuItem (hmenu, ID_CONFIGURE_POSITS_FILTER, *ActiveConfig.SavedPositFilter?MF_CHECKED:MF_UNCHECKED);
			{	APRS_PARSED_INFO_S *APRS = (APRS_PARSED_INFO_S *)malloc(sizeof(*APRS));
				FILTER_INFO_S SaveFilter = {0};
				long Hits = 0;
				unsigned long s;
				if (CheckOptimizedFilter(ActiveConfig.SavedPositFilter, &SaveFilter))
				{	for (s=1; s<CloseStationCount; s++)
					{	STATION_INFO_S *Station = pCloseStations[s];
						if (!Station->isKilled
						&& Station->lastMsec > 1	/* Not my local ones */
						&& Station->pLastPositPacket)
						{	char *InBuf = _strdup(Station->pLastPositPacket);
							if (parse_full_aprs(InBuf, APRS))
							{	if (FilterPacket(&SaveFilter, APRS))
								{	Hits++;
								}
							}
							free(InBuf);
						}
					}
				} else TraceError(hwnd, "CheckOptimizedFilter(%s) FAILED!\n", ActiveConfig.SavedPositFilter);
				FreeFilter(&SaveFilter);
				free(APRS);
				NumberOfMenuItem(hmenu, ID_CONFIGURE_POSITS_FILTER, Hits, CloseStationCount-1);
			}
		}

		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_FILTER, *ActiveConfig.Scroller.Filter?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_HIDE_NOPARSE, ActiveConfig.Scroller.HideNoParse?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_NO_INTERNALS, ActiveConfig.Scroller.NoInternals?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_NOT_ME, ActiveConfig.Scroller.NotME?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_NOT_MINE, ActiveConfig.Scroller.NotMine?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_RF_ONLY, ActiveConfig.Scroller.RFOnly?MF_CHECKED:MF_UNCHECKED);
		if (!*ActiveConfig.Scroller.Filter
		&& !ActiveConfig.Scroller.HideNoParse
		&& !ActiveConfig.Scroller.NoInternals
		&& !ActiveConfig.Scroller.NotME
		&& !ActiveConfig.Scroller.NotMine
		&& !ActiveConfig.Scroller.RFOnly)
			ActiveConfig.Scroller.ShowAll = TRUE;	/* Turn it back on */
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_SHOW_ALL, ActiveConfig.Scroller.ShowAll?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_SHOW_IGATE, ActiveConfig.Scroller.ShowIGateOrDigi?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_SCROLLER_CLICK_FREEZE, ActiveConfig.Scroller.FreezeOnClick?MF_CHECKED:MF_UNCHECKED);

		{	int Queued = OSMGetQueueStats();
			EnableMenuItem(hmenu, ID_CONFIG_MAP_PREFETCH, (cInfo->zoom<MAX_REASONABLE_ZOOM && Queued<=10000) ? MF_ENABLED:MF_GRAYED);
			NumberMenuItem(hmenu, ID_CONFIG_MAP_PREFETCH, Queued);
		}

		EnableMenuItem(hmenu, ID_PENDING_MESSAGES, PendingMsgCount?MF_ENABLED:MF_GRAYED);

		CheckMenuItem (hmenu, ID_LOG_FILE, (ActiveConfig.Enables.DebugFile?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_LOG_GENERAL, (ActiveConfig.Enables.DebugGeneral?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_LOG_STARTUP, (ActiveConfig.Enables.DebugStartup?MF_CHECKED:MF_UNCHECKED));

		CheckMenuItem (hmenu, ID_OBJECTS_SHOW, cInfo->ShowMyObjects?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_AUTOSAVE_GPX, ActiveConfig.Enables.AutoSaveGPX?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_BULLETINS_NOTIFY_NEW, ActiveConfig.Enables.NotifyOnNewBulletin?MF_CHECKED:MF_UNCHECKED);


		EnableMenuItem (hmenu, ID_RFPORTS_ENABLE, ActiveConfig.RFPorts.Count>0?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_RFPORTS_ENABLE,
					(ActiveConfig.RFPorts.Count>0 && ActiveConfig.Enables.RFPorts
												? MF_CHECKED:MF_UNCHECKED));
		EnableMenuItem (hmenu, ID_RFPORTS_LOG_ALL, ActiveConfig.RFPorts.Count>0?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_RFPORTS_LOG_ALL,
					(ActiveConfig.RFPorts.Count>0 && ActiveConfig.Enables.RFPktLog
												? MF_CHECKED:MF_UNCHECKED));
		EnableMenuItem (hmenu, ID_RFPORTS_NO_XMIT, ActiveConfig.RFPorts.Count>0?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_RFPORTS_NO_XMIT,
					(ActiveConfig.RFPorts.Count>0 && ActiveConfig.Enables.RFReceiveOnly
												? MF_CHECKED:MF_UNCHECKED));
	
		CheckMenuItem (hmenu, ID_SCREEN_CENTER_TRACKED, (cInfo->CenterTracking && cInfo->CenterStation!=MyStation?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_SCREEN_TRACK_ME, (cInfo->CenterTracking && cInfo->CenterStation==MyStation?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_SCREEN_TRACK_LOCKED, cInfo->Locked?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DIM, ActiveConfig.Screen.Dim?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_BRIGHT, !ActiveConfig.Screen.Dim?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_VIEW_METRIC_ALTITUDE, ActiveConfig.View.Metric.Altitude?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_METRIC_DISTANCE, ActiveConfig.View.Metric.Distance?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_METRIC_PRESSURE, ActiveConfig.View.Metric.Pressure?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_METRIC_RAINFALL, ActiveConfig.View.Metric.Rainfall?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_METRIC_TEMPERATURE, ActiveConfig.View.Metric.Temperature?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_VIEW_METRIC_WINDSPEED, ActiveConfig.View.Metric.Windspeed?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MESSAGES, ActiveConfig.NWS.Messages?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MESSAGES_NO_ALL, ActiveConfig.NWS.MessagesNotAll?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_NOTIFY, ActiveConfig.NWS.Notify?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK, ActiveConfig.NWS.MultiTrack?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_NEW, ActiveConfig.NWS.MultiTrackNew?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_LINES, ActiveConfig.NWS.MultiTrackLinesOnly?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_ME, ActiveConfig.NWS.MultiTrackMe?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_RANGE, ActiveConfig.NWS.MultiTrackRange&&ActiveConfig.Range>0?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_RANGE, ActiveConfig.Range>0?MF_ENABLED:MF_GRAYED);
		if (ActiveConfig.View.Metric.Distance)
			NumberMenuItem(hmenu, ID_CONFIGURE_NWS_MULTITRACK_RANGE,
							(long) (ActiveConfig.Range/10.0*KmPerMile), "km");
		else NumberMenuItem(hmenu, ID_CONFIGURE_NWS_MULTITRACK_RANGE,
							(long) (ActiveConfig.Range/10.0), "mi");
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_MOVING, ActiveConfig.NWS.MultiTrackMoving?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_SPECIFIC, ActiveConfig.NWS.MultiTrackPreferML?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_NWS_MULTITRACK_CLOSE, ActiveConfig.NWS.MultiTrackCloseOnExpire?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_AFTER_TRANSMIT, ActiveConfig.Beacon.AfterTransmit?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_TIMESTAMP, ActiveConfig.Beacon.Timestamp?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_CONFIGURE_BEACON_HHMMSS, ActiveConfig.Beacon.Timestamp?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_HHMMSS, ActiveConfig.Beacon.Timestamp&&ActiveConfig.Beacon.HHMMSS?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_COMPRESSED, ActiveConfig.Beacon.Compressed?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_CSESPD, ActiveConfig.Beacon.CourseSpeed?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_ALTITUDE, ActiveConfig.Beacon.Altitude?MF_CHECKED:MF_UNCHECKED);
#ifdef MONITOR_PHONE
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_CELLULAR, ActiveConfig.Beacon.Cellular?MF_CHECKED:MF_UNCHECKED);
#endif
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_PRESSURE, ActiveConfig.Beacon.Why?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_COMMENT_NONE, ActiveConfig.Beacon.Comment?MF_UNCHECKED:MF_CHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_DAO_0, ActiveConfig.Beacon.Precision==0?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_DAO_1, ActiveConfig.Beacon.Precision==1?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_DAO_2, ActiveConfig.Beacon.Precision==2?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_AMBIG_1, ActiveConfig.Beacon.Precision==-1?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_AMBIG_2, ActiveConfig.Beacon.Precision==-2?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_AMBIG_3, ActiveConfig.Beacon.Precision==-3?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_BEACON_AMBIG_4, ActiveConfig.Beacon.Precision==-4?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIG_MAP_PURGER, !ActiveConfig.OSMPurgeDisabled?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_CONFIGURE_WHOIS_BRIEF, ActiveConfig.WhoIsFull?MF_UNCHECKED:MF_CHECKED);
		CheckMenuItem (hmenu, ID_CONFIGURE_WHOIS_FULL, ActiveConfig.WhoIsFull?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_BATTERY, ActiveConfig.Screen.Show.Battery?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_PERFORMANCE, ActiveConfig.Screen.DateTimePerformance?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_NONE, ActiveConfig.Screen.DateTime==0?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_LOCAL, abs(ActiveConfig.Screen.DateTime)==1?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_GMT, abs(ActiveConfig.Screen.DateTime)==2?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_GPS_ONLY, ActiveConfig.Screen.DateTime<0?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_DATETIME_GPS_ONLY, ActiveConfig.Screen.DateTime?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_DEFAULT, !strcmp(ActiveConfig.Screen.DateSeconds,"2367")?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_DATE_ONLY, !strcmp(ActiveConfig.Screen.DateSeconds,"0123456789")?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_TIME_ONLY, !strcmp(ActiveConfig.Screen.DateSeconds,"")?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_0, strchr(ActiveConfig.Screen.DateSeconds,'0')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_1, strchr(ActiveConfig.Screen.DateSeconds,'1')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_2, strchr(ActiveConfig.Screen.DateSeconds,'2')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_3, strchr(ActiveConfig.Screen.DateSeconds,'3')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_4, strchr(ActiveConfig.Screen.DateSeconds,'4')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_5, strchr(ActiveConfig.Screen.DateSeconds,'5')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_6, strchr(ActiveConfig.Screen.DateSeconds,'6')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_7, strchr(ActiveConfig.Screen.DateSeconds,'7')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_8, strchr(ActiveConfig.Screen.DateSeconds,'8')?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_DATETIME_9, strchr(ActiveConfig.Screen.DateSeconds,'9')?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_CROSSHAIRS_NEVER, ActiveConfig.Screen.Show.CrossHairs==0?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CROSSHAIRS_ALWAYS, ActiveConfig.Screen.Show.CrossHairs<0?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CROSSHAIRS_TIMED, ActiveConfig.Screen.Show.CrossHairs>0?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_ALTITUDE, ActiveConfig.Screen.Show.Altitude?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CIRCLE, ActiveConfig.Screen.Show.Circle?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_GRIDSQUARE, ActiveConfig.Screen.Show.GridSquare?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_LATLON, ActiveConfig.Screen.Show.LatLon?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_RED_DOT, ActiveConfig.Screen.Show.RedDot?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_SATELLITES, ActiveConfig.Screen.Show.Satellites?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_SPEED_FONT, ActiveConfig.Screen.SpeedSize?MF_CHECKED:MF_UNCHECKED);
		NumberMenuItem(hmenu, ID_SCREEN_SPEED_FONT, ActiveConfig.Screen.SpeedSize);
		CheckMenuItem (hmenu, ID_SCREEN_SYMBOL_SIZE_ADJUST, ActiveConfig.Screen.SymbolSizeAdjust?MF_CHECKED:MF_UNCHECKED);
		NumberMenuItem(hmenu, ID_SCREEN_SYMBOL_SIZE_ADJUST, ActiveConfig.Screen.SymbolSizeAdjust);

		CheckMenuItem (hmenu, ID_SCREEN_DEAD_RECKON, ActiveConfig.Screen.Show.Reckoning?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_FILTER_CIRCLE, ActiveConfig.Screen.FilterCircle?MF_CHECKED:MF_UNCHECKED);
		{	char Buffer[33];
			sprintf(Buffer,"r///%ldkm",(long)(cInfos[0].Scale*1.609344));
			ExtendMenuItem(hmenu, ID_SCREEN_FILTER_CIRCLE, Buffer);
		}
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_NETWORK, cInfo->Paths.Network?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_STATION, cInfo->Paths.Station?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_MYSTATION, cInfo->Paths.MyStation?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_RFONLY, cInfo->Paths.LclRF?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_TRACKS, ActiveConfig.Screen.Show.Tracks?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_LABEL_ALTITUDE, ActiveConfig.View.Altitude?MF_CHECKED:MF_UNCHECKED);
#ifdef MONITOR_PHONE
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_CELLULAR, ActiveConfig.View.Cellular?MF_CHECKED:MF_UNCHECKED);
#endif
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_AMBIGUITY, ActiveConfig.View.Ambiguity?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_NWS, ActiveConfig.View.LabelNWS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_WEATHER, ActiveConfig.View.LabelWeather?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_OVERLAP, ActiveConfig.View.LabelOverlap?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CALLSIGN, ActiveConfig.View.Callsign?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CALLSIGN_NOT_ME, ActiveConfig.View.CallsignNotMe?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_CALLSIGN_NOT_MINE, ActiveConfig.View.CallsignNotMine?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_LABEL_NICKNAMES, ActiveConfig.View.Nicknames?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem (hmenu, ID_SCREEN_LABEL_NICKNAMES, ActiveConfig.Nicknames.Count>0?MF_ENABLED:MF_GRAYED);

		CheckMenuItem (hmenu, ID_SCREEN_GEOCACHE_ID, ActiveConfig.View.GeoCacheID?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_GEOCACHE_TYPE, ActiveConfig.View.GeoCacheType?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_GEOCACHE_CONT, ActiveConfig.View.GeoCacheCont?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_GEOCACHE_DT, ActiveConfig.View.GeoCacheDT?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_SPEED_BEACONED, ActiveConfig.View.Speed.Beaconed?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_SPEED_CALCULATED, ActiveConfig.View.Speed.Calculated?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_SPEED_AVERAGED, ActiveConfig.View.Speed.Averaged?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_SPEED_ALL, ActiveConfig.View.Speed.All?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_SCREEN_RANGE_FULL, ActiveConfig.View.Range.Enabled&&!ActiveConfig.View.Range.Half?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_RANGE_HALF, ActiveConfig.View.Range.Enabled&&ActiveConfig.View.Range.Half?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_RANGE_OPACITY, ActiveConfig.View.Range.Enabled?MF_ENABLED:MF_GRAYED);
		NumberMenuItem(hmenu, ID_SCREEN_RANGE_OPACITY, ActiveConfig.View.Range.Opacity,"%");

		CheckMenuItem (hmenu, ID_SCREEN_FOOTPRINT, ActiveConfig.View.Footprint.Enabled?MF_CHECKED:MF_UNCHECKED);
		NumberMenuItem(hmenu, ID_SCREEN_FOOTPRINT_MIN, ActiveConfig.View.Footprint.MinAltitude,"ft");
		NumberMenuItem(hmenu, ID_SCREEN_FOOTPRINT_MAX, ActiveConfig.View.Footprint.MaxAltitude,"ft");

		CheckMenuItem (hmenu, ID_SCREEN_DF_ENABLED, ActiveConfig.View.DF.Enabled?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_DF_OPACITY, ActiveConfig.View.DF.Enabled?MF_ENABLED:MF_GRAYED);
		NumberMenuItem(hmenu, ID_SCREEN_DF_OPACITY, ActiveConfig.View.DF.Opacity,"%");

		CheckMenuItem (hmenu, ID_VIEW_PREFERRED_MULTITRACK_NONE, ActiveConfig.MultiTrack.ViewNone?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_MESSAGES_EAVESDROP, ActiveConfig.Messaging.AllMessages?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_RF_MESSAGES, ActiveConfig.Messaging.RFMessages?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MY_MESSAGES, ActiveConfig.Messaging.MyMessages?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MESSAGES_HIDE_QUERIES, ActiveConfig.Messaging.HideQueries?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MESSAGES_HIDE_NWS, ActiveConfig.Messaging.HideNWS?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MESSAGES_NOTIFY_ON_QUERY, ActiveConfig.Messaging.NotifyOnQuery?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MESSAGES_NOTIFY_ON_NEW, ActiveConfig.Messaging.NotifyOnNewMessage?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_MESSAGES_MULTITRACK_ITEM, ActiveConfig.Messaging.MultiTrackItemInMessage?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_FREQ_TOGGLE, ActiveConfig.FreqMon.Enabled?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_INTERNET_TOGGLE, ActiveConfig.Enables.Internet?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SOUND_TOGGLE, ActiveConfig.Enables.Sound?MF_CHECKED:MF_UNCHECKED);

#define ENABLE_VIEW_SYMBOLS(x,X)	\
		EnableMenuItem(hmenu, ID_VIEW_##X, *ActiveConfig.View.x.Primary||*ActiveConfig.View.x.Alternate?MF_ENABLED:MF_GRAYED)
		ENABLE_VIEW_SYMBOLS(Custom,CUSTOM);
		ENABLE_VIEW_SYMBOLS(Flight,FLIGHT);
		ENABLE_VIEW_SYMBOLS(Mobile,MOBILE);
		ENABLE_VIEW_SYMBOLS(Marine,MARINE);
		ENABLE_VIEW_SYMBOLS(Weather,WEATHER);
#undef ENABLE_VIEW_SYMBOLS

		EnableMenuItem(hmenu, ID_APRS_TOGGLE, ActiveConfig.Enables.Internet?MF_ENABLED:MF_GRAYED);
		EnableMenuItem(hmenu, ID_OSM_TOGGLE, ActiveConfig.Enables.Internet?MF_ENABLED:MF_GRAYED);

		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_ALWAYS, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_1_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_5_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_10_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_30_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_FOREVER, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_LONGER, MF_UNCHECKED);
		EnableMenuItem (hmenu, ID_AUTO_REPLY_DELAY_LONGER, MF_GRAYED);
		if (ActiveConfig.Messaging.AutoAnswer.Delay == 0)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_ALWAYS, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Delay <= 1)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_1_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Delay <= 5)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_5_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Delay <= 10)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_10_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Delay <= 30)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_30_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Delay == LONG_MAX)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_FOREVER, MF_CHECKED);
		else
			CheckMenuItem (hmenu, ID_AUTO_REPLY_DELAY_LONGER, MF_CHECKED);

		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_10_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_30_MIN, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_HOUR, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_DAY, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_YEAR, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_FOREVER, MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_LONGER, MF_UNCHECKED);
		EnableMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_LONGER, MF_GRAYED);
		if (ActiveConfig.Messaging.AutoAnswer.Interval <= 1)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval <= 10)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_10_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval <= 30)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_30_MIN, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval <= 1*60)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_HOUR, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval <= 24*60)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_DAY, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval <= 1*365*24*60)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_1_YEAR, MF_CHECKED);
		else if (ActiveConfig.Messaging.AutoAnswer.Interval == LONG_MAX)
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_FOREVER, MF_CHECKED);
		else 
			CheckMenuItem (hmenu, ID_AUTO_REPLY_INTERVAL_LONGER, MF_CHECKED);

#ifdef CE50	/* Hack for lack of INITMENUPOPUP for sub menus */
		{	MENUITEMINFO mii = {0};
			mii.cbSize = sizeof(mii); 
			mii.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
			for (UINT i=0; GetMenuItemInfo(hmenu, i, TRUE, &mii); i++)
			{
				if (mii.hSubMenu)
				{
					if (mii.fType == MFT_STRING)
					{	mii.dwTypeData = (TCHAR*)malloc(sizeof(TCHAR)*++mii.cch);
						if (GetMenuItemInfo(hmenu, i, TRUE, &mii))
							TraceLogThread("Menu", FALSE, "%p:mii[%ld](%ld) is SubMenu(%S)\n", hmenu, (long) i, (long) mii.wID, mii.dwTypeData);
						free(mii.dwTypeData);
						mii.dwTypeData = NULL;
					}
					SendMessage(hwnd, WM_INITMENUPOPUP, (WPARAM) mii.hSubMenu, lp);
				}
			}
		}
#endif
		break;
	}

	case WM_COMMAND:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

		MarkActivity();

		switch (LOWORD(wp))
		{
		case ID_EXIT:
			SendMessage(hwnd, WM_CLOSE, 0, 0);
			break;
		case ID_TRANSMIT:
		{	if (FirstRun || BeaconSuspended)
			{	if (!cInfo->LastCenterPosition.dblLatitude
				&& !cInfo->LastCenterPosition.dblLongitude)
					MessageBox(hwnd, TEXT("Please move away from 0,0 before pressing Transmit."), TEXT("Set Home Location"), MB_OK | MB_ICONWARNING);
				else if (cInfo->zoom < MIN_SETTABLE_ZOOM)
					MessageBox(hwnd, TEXT("Please zoom in closer to make sure you are in the right place."), TEXT("Set Home Location"), MB_OK | MB_ICONWARNING);
				else
				{	FirstRun = FALSE;	/* Hopefully it will stick until we exit */
					BeaconSuspended = FALSE;	/* Clear to transmit */
					DestroyWindow(hwndFirstRun);
					GetSystemTime(&cInfo->LastCenterPosition.stUTCTime);
					cInfo->LastCenterPosition.dwValidFields = GPS_VALID_UTC_TIME | GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE;	/* Only these */
					SetMyPosition(hwnd, cInfo, &cInfo->LastCenterPosition);
					SetMyPosition(hwnd, cInfo, &cInfo->LastCenterPosition);	/* Clear the deltas */

					if (ActiveConfig.Beacon.AfterTransmit)	/* Put the screen back */
					{	cInfo->LastCenterPosition.dblLatitude = OriginalScreen.lat;
						cInfo->LastCenterPosition.dblLongitude = OriginalScreen.lon;
						cInfo->LastCenterPosition.dwValidFields |= (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE);	/* Mark them valid */
						cInfo->zoom = OriginalScreen.zoom;
						cInfo->CenterTracking = FALSE;	/* No longer tracking ME */
						TransmitFilter();
						InvalidateStationPoints(cInfo->Index,"SetCenter",TRUE);
						InvalidateCenter(hwnd, TRUE);
						cInfo->msLastSigChange = llGetMsec();
					}
				}
			} else
			{	__int64 Now = llGetMsec();
				if (LastForce+ActiveConfig.ForceMinTime*1000.0 <= Now
				|| MessageBox(hwnd, TEXT("Transmit Too Fast, Really FORCE It?"), TEXT("Transmit"),
								MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
				{	LastForce = Now;	/* Remember when they last forced */

					if (GPSEnabled)
					{	if ((gpsPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)) != (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))
						{	if (ForceTransmit)
								MessageBox(hwnd, TEXT("Forced Beacon Will Be Sent Whenever GPS Fix Is Acquired"), TEXT("Transmit"), MB_OK | MB_ICONINFORMATION);
							else MessageBox(hwnd, TEXT("Requested Beacon Will Be Sent Whenever GPS Fix Is Acquired"), TEXT("Transmit"), MB_OK | MB_ICONINFORMATION);
						}
						ForceTransmit = TRUE;
					} else	/* GPS is disabled, use manual location */
					{	if (cInfo->zoom >= MIN_SETTABLE_ZOOM	/* Must be zoomed in close enough */
						&& ((cInfo->LastCenterPosition.dblLatitude == LastGoodPosition.dblLatitude
							&& cInfo->LastCenterPosition.dblLongitude == LastGoodPosition.dblLongitude)
						|| MessageBox(hwnd, TEXT("Move ME To Center?"), TEXT("Transmit"),
									MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES))
						{	GENIUS_INFO_S *Genius = &ActiveConfig.MyGenius;
							ForceTransmit = TRUE;
							if (Genius->LastAPRSUpdate) Genius->LastAPRSUpdate -= MINIMUM_APRS_DELTA*2;	/* Allow the FORCE */

							GetSystemTime(&cInfo->LastCenterPosition.stUTCTime);
							cInfo->LastCenterPosition.dwValidFields = GPS_VALID_UTC_TIME | GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE;	/* Only these */
							SetMyPosition(hwnd, cInfo, &cInfo->LastCenterPosition);
							SetMyPosition(hwnd, cInfo, &cInfo->LastCenterPosition);	/* Clear the deltas */
			TraceError(hwnd, "LastCenterPosition:Transmit:MoveToCenter:%.6lf x %.6lf %s\n", (double) cInfo->LastCenterPosition.dblLatitude, (double) cInfo->LastCenterPosition.dblLongitude, (cInfo->LastCenterPosition.dwValidFields & (GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE))==(GPS_VALID_LATITUDE | GPS_VALID_LONGITUDE)?"valid":"INVALID");
						} else ForceTransmit = TRUE;	/* Transmit anyway */
					}
				}
			}

			break;
		}
		case ID_ABOUT:
		{
#ifdef TRAKVIEW
		TCHAR Title1[] = TEXT("TrakView32 Upgrade");
#else
		TCHAR Title1[] = TEXT("APRSISCE/32 Upgrade");
#endif
		if (NewVersionDownloaded
		&& MessageBox(hwnd, TEXT("New Version Already Downloaded, Restart Program?"), Title1, MB_YESNO | MB_ICONQUESTION) == IDYES)
		{	if (OriginalPath[0]
			|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
				TraceLog("Version", TRUE, hwnd, "Delayed Restarting %S\n", OriginalPath);
			RestartProgram = TRUE;
			SendMessage(hwnd, WM_CLOSE, 0, 0);
		} else
		{	char *NewVersion = ActiveConfig.Enables.Internet?Check4Version():NULL;
			size_t Remaining = sizeof(TCHAR)*256;
			TCHAR *Buffer = (TCHAR *) malloc(Remaining);
			TCHAR *Next = Buffer;

#ifdef TRAKVIEW
			TCHAR Title2[] = TEXT("About TrakView32");
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
				TEXT("TrakView32 Client by KJ4ERJ\nBuilt: %S\n\n 2009, 2015\nAll Rights Reserved\nHomeside Software, Inc\nLynn W. Deffenbaugh"),
							VERSION);
#else
			TCHAR Title2[] = TEXT("About APRSISCE/32");
			StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
				TEXT("APRS-IS Client by KJ4ERJ\nBuilt: %S\n\n 2009, 2015\nAll Rights Reserved\nHomeside Software, Inc\nLynn W. Deffenbaugh"),
							VERSION);
#endif

			if (NewVersion && strcmp(Timestamp,NewVersion) != 0)
			{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\n%S %SVersion Available!\nBuilt: %S\n\nDownload it?"),
								strcmp(Timestamp,NewVersion)<0?"New":"OLD",
								ActiveConfig.Update.Development?"Development ":"",
								NewVersion);
				BUTTONS_S *Buttons = CreateButtons(-1);
				AddButton(Buttons, "Yes", IDYES);
				if (IsSameBaseCallsign(CALLSIGN,"KJ4ERJ") || ActiveConfig.View.AboutRestart)
					AddButton(Buttons, "Restart", IDRETRY);
				AddButton(Buttons, "No", IDNO);
				switch (LwdMessageBox2(hwnd, Buffer, Title1, MB_YESNO | MB_ICONQUESTION, Buttons))
				{
				case IDYES:
				{	BOOL Result = GetNewEXE(hwnd, NewVersion);
					if (!Result)
						MessageBox(hwnd, TEXT("Download Failed"), TEXT("APRSISCE/32 Upgrade"), MB_OK | MB_ICONERROR);
					else
					{	NewVersionDownloaded = TRUE;
						if (MessageBox(hwnd, TEXT("New Version Downloaded, Restart Program?"), Title1, MB_YESNO | MB_ICONQUESTION) == IDYES)
						{	if (OriginalPath[0]
							|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
								TraceLog("Version", TRUE, hwnd, "Download Restarting %S\n", OriginalPath);
							RestartProgram = TRUE;
							SendMessage(hwnd, WM_CLOSE, 0, 0);
						}
					}
					break;
				}
				case IDRETRY:
				{	if (OriginalPath[0]
					|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
						TraceLog("Version", TRUE, hwnd, "Manually Restarting %S\n", OriginalPath);
					RestartProgram = TRUE;
					SendMessage(hwnd, WM_CLOSE, 0, 0);
					break;
				}
				}
			} else
			{
				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\nSee the Support Wiki at:\nhttp://aprsisce.wikidot.com/"));
				if (NewVersion)
				{	if (ActiveConfig.Update.Development)
						StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\nDevelopment Version Verified!"));
					else	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\nCurrent Version Verified!"));
				} else if (!ActiveConfig.Enables.Internet)
					StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
								TEXT("\n\nEnable Internet Access for Version Check"));

				if (!IsSameBaseCallsign(CALLSIGN,"KJ4ERJ") && !ActiveConfig.View.AboutRestart)
					MessageBox(hwnd, Buffer, Title2, MB_OK | MB_ICONINFORMATION);
				else
				{	BUTTONS_S *Buttons = CreateButtons(-1);
//					AddButton(Buttons, "Yes", IDYES);
					AddButton(Buttons, "Restart", IDRETRY);
//					AddButton(Buttons, "No", IDNO);
					if (LwdMessageBox2(hwnd, Buffer, Title2, MB_OK | MB_ICONINFORMATION, Buttons) == IDRETRY)
					{	if (OriginalPath[0]
						|| GetModuleFileName(NULL, OriginalPath, MAX_PATH))
							TraceLog("Version", TRUE, hwnd, "Manually(2) Restarting %S\n", OriginalPath);
						RestartProgram = TRUE;
						SendMessage(hwnd, WM_CLOSE, 0, 0);
					}
				}
			}
			free(Buffer);
			if (NewVersion) free(NewVersion);
		}
		break;
		}
		case ID_INTERNET_TOGGLE:
		{	unsigned int p;
			ActiveConfig.Enables.Internet = !ActiveConfig.Enables.Internet;
			if (ActiveConfig.Enables.Internet)
			{	if (ActiveConfig.Enables.APRSIS) APRSISStart(ActiveConfig.APRSIS.Port);
			} else
			{	APRSISStop();
			}
			OSMSetFetchEnable(ActiveConfig.Enables.OSMFetch && ActiveConfig.Enables.Internet);

			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			{	PORT_CONFIG_INFO_S *pP = &ActiveConfig.RFPorts.Port[p];
				if (pP->IsEnabled && pP->RequiresInternet)
				{	if (ActiveConfig.Enables.Internet)
						PortStart(pP, hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, p);
					else if (PortStop(pP, p))
						PostMessage(hwnd, WM_PORT_STATUS, MAKELONG(p,1), (LPARAM) _strdup("Disabled"));
				}
			}
			FixIGateEnabled();
		
			break;
		}
		case ID_APRS_TOGGLE:
			EnableAPRS(hwnd, !APRSEnabled);
            break;
		case ID_OSM_TOGGLE:
			EnableOSMFetch(hwnd, !OSMFetchEnabled, FALSE);
            break;

		case ID_FREQ_TOGGLE:
			if (ActiveConfig.FreqMon.Enabled && !hwndFreq)
				CreateFrequencyWindow(hwnd);
			else
			{	ActiveConfig.FreqMon.Enabled = !ActiveConfig.FreqMon.Enabled;
				if (ActiveConfig.FreqMon.Enabled)
					CreateFrequencyWindow(hwnd);
				else if (hwndFreq)
					SendMessage(hwndFreq, WM_CLOSE, 0, 0);
			}
			break;

		case ID_GPS_TOGGLE:
			EnableGPS(hwnd, !GPSEnabled, FALSE);
            break;
		case ID_CSV_TOGGLE:
			EnableCSV(hwnd, !CSVEnabled, FALSE);
            break;
#ifdef OBSOLETE
		case ID_AGW_TOGGLE:
			EnableAGW(hwnd, !AGWEnabled, FALSE);
            break;
		case ID_KISS_TOGGLE:
			EnableKISS(hwnd, !KISSEnabled, FALSE);
            break;
		case ID_TEXT_TOGGLE:
			EnableTEXT(hwnd, !TEXTEnabled, FALSE);
            break;
#endif
		case ID_AUTOSAVE_GPX:
			ActiveConfig.Enables.AutoSaveGPX = !ActiveConfig.Enables.AutoSaveGPX;
            break;
		case ID_SOUND_TOGGLE:
			ActiveConfig.Enables.Sound = !ActiveConfig.Enables.Sound;
            break;
		case ID_BEACON_TOGGLE:
			EnableBeaconing(hwnd, !BeaconEnabled);
            break;
		case ID_TELEMETRY_TOGGLE:
			EnableTelemetry(hwnd, !TelemetryEnabled);
            break;
		case ID_SCREEN_LABEL_ALTITUDE:
			ActiveConfig.View.Altitude = !ActiveConfig.View.Altitude;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
#ifdef MONITOR_PHONE
		case ID_SCREEN_LABEL_CELLULAR:
			ActiveConfig.View.Cellular = !ActiveConfig.View.Cellular;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
#endif

		case ID_SCREEN_LABEL_MAX:
			ActiveConfig.View.VisibleLabelsMax = NumberPrompt(hwnd, "Visible Labels Max", "Large Numbers can Hurt Performance", "Stations", "View.VisibleLabelsMax", ActiveConfig.View.VisibleLabelsMax);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_LABEL_AMBIGUITY:
			ActiveConfig.View.Ambiguity = !ActiveConfig.View.Ambiguity;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_LABEL_NWS:
			ActiveConfig.View.LabelNWS = !ActiveConfig.View.LabelNWS;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_LABEL_WEATHER:
			ActiveConfig.View.LabelWeather = !ActiveConfig.View.LabelWeather;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_LABEL_OVERLAP:
			ActiveConfig.View.LabelOverlap = !ActiveConfig.View.LabelOverlap;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_CALLSIGN:
			ActiveConfig.View.Callsign = !ActiveConfig.View.Callsign;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_CALLSIGN_NOT_ME:
			ActiveConfig.View.CallsignNotMe = !ActiveConfig.View.CallsignNotMe;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_CALLSIGN_NOT_MINE:
			ActiveConfig.View.CallsignNotMine = !ActiveConfig.View.CallsignNotMine;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;

		case ID_SCREEN_GEOCACHE_ID:
			ActiveConfig.View.GeoCacheID = !ActiveConfig.View.GeoCacheID;
			if (cInfo->viewBits & VIEW_GEOCACHES)
				InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_GEOCACHE_TYPE:
			ActiveConfig.View.GeoCacheType = !ActiveConfig.View.GeoCacheType;
			if (cInfo->viewBits & VIEW_GEOCACHES)
				InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_GEOCACHE_CONT:
			ActiveConfig.View.GeoCacheCont = !ActiveConfig.View.GeoCacheCont;
			if (cInfo->viewBits & VIEW_GEOCACHES)
				InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_GEOCACHE_DT:
			ActiveConfig.View.GeoCacheDT = !ActiveConfig.View.GeoCacheDT;
			if (cInfo->viewBits & VIEW_GEOCACHES)
				InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_GEOCACHE_LABEL_MAX:
			ActiveConfig.View.GeoCacheLabelsMax = NumberPrompt(hwnd, "GeoCache Labels Max", "Large Numbers can Hurt Performance", "GeoCaches", "View.GeoCache.LabelsMax", ActiveConfig.View.GeoCacheLabelsMax);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_SCREEN_SPEED_BEACONED:
			ActiveConfig.View.Speed.Beaconed = !ActiveConfig.View.Speed.Beaconed;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_SPEED_CALCULATED:
			ActiveConfig.View.Speed.Calculated = !ActiveConfig.View.Speed.Calculated;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_SPEED_AVERAGED:
			ActiveConfig.View.Speed.Averaged = !ActiveConfig.View.Speed.Averaged;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_SPEED_ALL:
			ActiveConfig.View.Speed.All = !ActiveConfig.View.Speed.All;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_ALTITUDE:
			ActiveConfig.Screen.Show.Altitude = !ActiveConfig.Screen.Show.Altitude;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_CIRCLE:
			ActiveConfig.Screen.Show.Circle = !ActiveConfig.Screen.Show.Circle;
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_BATTERY:
			ActiveConfig.Screen.Show.Battery = !ActiveConfig.Screen.Show.Battery;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_PERFORMANCE:
			ActiveConfig.Screen.DateTimePerformance = !ActiveConfig.Screen.DateTimePerformance;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_NONE:
			ActiveConfig.Screen.DateTime = 0;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_LOCAL:	
			ActiveConfig.Screen.DateTime = ActiveConfig.Screen.DateTime<0?-1:1;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_GMT:
			ActiveConfig.Screen.DateTime = ActiveConfig.Screen.DateTime<0?-2:2;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_GPS_ONLY:
			ActiveConfig.Screen.DateTime = -ActiveConfig.Screen.DateTime;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_DATETIME_DEFAULT:
			strncpy(ActiveConfig.Screen.DateSeconds, "2367", sizeof(ActiveConfig.Screen.DateSeconds));
			break;
		case ID_SCREEN_DATETIME_DATE_ONLY:
			strncpy(ActiveConfig.Screen.DateSeconds, "0123456789", sizeof(ActiveConfig.Screen.DateSeconds));
			break;
		case ID_SCREEN_DATETIME_TIME_ONLY:
			strncpy(ActiveConfig.Screen.DateSeconds, "", sizeof(ActiveConfig.Screen.DateSeconds));
			break;
		case ID_SCREEN_DATETIME_0:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '0')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "0");
			break;
		case ID_SCREEN_DATETIME_1:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '1')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "1");
			break;
		case ID_SCREEN_DATETIME_2:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '2')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "2");
			break;
		case ID_SCREEN_DATETIME_3:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '3')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "3");
			break;
		case ID_SCREEN_DATETIME_4:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '4')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "4");
			break;
		case ID_SCREEN_DATETIME_5:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '5')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "5");
			break;
		case ID_SCREEN_DATETIME_6:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '6')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "6");
			break;
		case ID_SCREEN_DATETIME_7:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '7')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "7");
			break;
		case ID_SCREEN_DATETIME_8:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '8')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "8");
			break;
		case ID_SCREEN_DATETIME_9:
			if (!strchr(ActiveConfig.Screen.DateSeconds, '9')
			&& strlen(ActiveConfig.Screen.DateSeconds)
						< sizeof(ActiveConfig.Screen.DateSeconds)-1)
				strcat(ActiveConfig.Screen.DateSeconds, "9");
			break;

		case ID_SCREEN_CROSSHAIRS_ALWAYS:
			ActiveConfig.Screen.Show.CrossHairs = -1;
			InvalidateCircle(NULL, TRUE);
			break;
		case ID_SCREEN_CROSSHAIRS_NEVER:
			ActiveConfig.Screen.Show.CrossHairs = 0;
			InvalidateCircle(NULL, TRUE);
			break;
		case ID_SCREEN_CROSSHAIRS_TIMED:
			ActiveConfig.Screen.Show.CrossHairs = 1;
			InvalidateCircle(NULL, TRUE);
			break;
		case ID_SCREEN_GRIDSQUARE:
			ActiveConfig.Screen.Show.GridSquare = !ActiveConfig.Screen.Show.GridSquare;
			ShuffleScreenElements(hwnd);
//			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_LATLON:
			ActiveConfig.Screen.Show.LatLon = !ActiveConfig.Screen.Show.LatLon;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_RED_DOT:
			ActiveConfig.Screen.Show.RedDot = !ActiveConfig.Screen.Show.RedDot;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_SATELLITES:
			ActiveConfig.Screen.Show.Satellites = !ActiveConfig.Screen.Show.Satellites;
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_SPEED_FONT:
			ActiveConfig.Screen.SpeedSize = NumberPrompt(hwnd, "Speed Font", "5=Default, 0=Off", "Number", "Screen.SpeedSize", ActiveConfig.Screen.SpeedSize);
			ShuffleScreenElements(hwnd);
			break;
		case ID_SCREEN_SYMBOL_SIZE_ADJUST:
			ActiveConfig.Screen.SymbolSizeAdjust = SignedNumberPrompt(hwnd, "Symbol Size", "+=Bigger 0=Default -=Smaller", "Number", "Screen.SymbolSizeAdjust", ActiveConfig.Screen.SymbolSizeAdjust);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_SCREEN_PATHS_NETWORK:
			cInfo->Paths.Network = !cInfo->Paths.Network;
			ActiveConfig.Screen.Paths.Network = cInfo->Paths.Network;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_STATION:
			cInfo->Paths.Station = !cInfo->Paths.Station;
			ActiveConfig.Screen.Paths.Station = cInfo->Paths.Station;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_MYSTATION:
			cInfo->Paths.MyStation = !cInfo->Paths.MyStation;
			ActiveConfig.Screen.Paths.MyStation = cInfo->Paths.MyStation;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_RFONLY:
			cInfo->Paths.LclRF = !cInfo->Paths.LclRF;
			ActiveConfig.Screen.Paths.LclRF = cInfo->Paths.LclRF;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_SCREEN_WINDBARBS_ENABLED:
			ActiveConfig.Screen.WindBarbs.Enabled = !ActiveConfig.Screen.WindBarbs.Enabled;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_WINDBARBS_ROTATE:
			ActiveConfig.Screen.WindBarbs.RotateStorm = !ActiveConfig.Screen.WindBarbs.RotateStorm;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_WINDBARBS_WIDTH:
			ActiveConfig.Screen.WindBarbs.Width = NumberPrompt(hwnd, "WindBarb Width", "1=Normal, Large=Slow Performance", "Pixels", "Screen.WindBarbs.Width", ActiveConfig.Screen.WindBarbs.Width);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_WINDBARBS_COLOR:
		{	char *NewColor = ColorPrompt(hwnd, "Follow Color",
								ActiveConfig.Screen.WindBarbs.Color,
								COLORS_TRACKS);
			if (NewColor)
			{	strncpy(ActiveConfig.Screen.WindBarbs.Color, NewColor,
					sizeof(ActiveConfig.Screen.WindBarbs.Color));
				ActiveConfig.Screen.WindBarbs.RGB = GetColorRGB(&ActiveConfig, NewColor, "FollowColor");
				free(NewColor);
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		}

		case ID_SCREEN_TRACKS:
			ActiveConfig.Screen.Show.Tracks = !ActiveConfig.Screen.Show.Tracks;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_TRACKS_FOLLOW:
			ActiveConfig.Screen.Track.Follow.Count = NumberPrompt(hwnd, "Follow Tracks", "0=ALL, Large=Slow Performance", "Blocks", "Screen.Tracks.Follow", ActiveConfig.Screen.Track.Follow.Count);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_TRACKS_FOLLOW_WIDTH:
			ActiveConfig.Screen.Track.Follow.Width = NumberPrompt(hwnd, "Follow Track Width", "1=Normal, Large=Slow Performance", "Pixels", "Screen.Tracks.Follow.Width", ActiveConfig.Screen.Track.Follow.Width);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_TRACKS_FOLLOW_COLOR:
			/* ActiveConfig.Screen.Tracks.Follow.Color & .RGB */
		{	char *NewColor = ColorPrompt(hwnd, "Follow Color",
								ActiveConfig.Screen.Track.Follow.Color,
								COLORS_AVAILABLE);
			if (NewColor)
			{	strncpy(ActiveConfig.Screen.Track.Follow.Color, NewColor,
					sizeof(ActiveConfig.Screen.Track.Follow.Color));
				ActiveConfig.Screen.Track.Follow.RGB = GetColorRGB(&ActiveConfig, NewColor, "FollowColor");
				free(NewColor);
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		}
		case ID_SCREEN_TRACKS_OTHER:
			ActiveConfig.Screen.Track.Other.Count = NumberPrompt(hwnd, "NonFollowed Line", "0=ALL, Large=Slow Performance", "Points", "Screen.Tracks.Others", ActiveConfig.Screen.Track.Other.Count);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_TRACKS_OTHER_WIDTH:
			ActiveConfig.Screen.Track.Other.Width = NumberPrompt(hwnd, "Other Track Width", "1=Normal, Large=Slow Performance", "Pixels", "Screen.Tracks.Others.Width", ActiveConfig.Screen.Track.Other.Width);
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_TRACKS_OTHER_COLOR:
		{	char *NewColor = ColorPrompt(hwnd, "Other Color",
								ActiveConfig.Screen.Track.Other.Color,
								COLORS_AVAILABLE);
			if (NewColor)
			{	unsigned long p;
				unsigned long c=0;
				char *color = NULL;
				STRING_LIST_S *pList = &ActiveConfig.TrackColors;
				for (p=0; p<pList->Count; p++)
				if (pList->Entries[p].value)
				{	c++;
					color = pList->Entries[p].string;
				}
				if (c==1
				&& !strncmp(ActiveConfig.Screen.Track.Other.Color, color,
							sizeof(ActiveConfig.Screen.Track.Other.Color)))
				{	p = LocateTimedStringEntry(pList, color);
					if (p != -1)
					{	pList->Entries[p].value = 0;
						p = LocateTimedStringEntry(pList, NewColor);
						if (p != -1) pList->Entries[p].value = 1;
					}
				}
				strncpy(ActiveConfig.Screen.Track.Other.Color, NewColor,
					sizeof(ActiveConfig.Screen.Track.Other.Color));
				ActiveConfig.Screen.Track.Other.RGB = GetColorRGB(&ActiveConfig, NewColor, "OtherColor");
				free(NewColor);
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		}
		case ID_SCREEN_TRACKS_OTHER_ADD_COLOR:
		{	char *NewColor = ColorPrompt(hwnd, "Add Track Color",
								"",
								COLORS_NO_TRACKS);
			if (NewColor)
			{	TIMED_STRING_LIST_S *pList = &ActiveConfig.TrackColors;
				if (LocateTimedStringEntry(pList, NewColor) == -1)
				{	AddTimedStringEntry(pList, NewColor, NULL, TRUE);
				}
				free(NewColor);
			}
			break;
		}
		case ID_SCREEN_DEAD_RECKON:
			ActiveConfig.Screen.Show.Reckoning = !ActiveConfig.Screen.Show.Reckoning;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_FILTER_CIRCLE:
			ActiveConfig.Screen.FilterCircle = !ActiveConfig.Screen.FilterCircle;
			TransmitFilter();
			break;

		case ID_SCREEN_RANGE_FULL:
			if (ActiveConfig.View.Range.Half)
			{	ActiveConfig.View.Range.Half = FALSE;
			} else ActiveConfig.View.Range.Enabled = ! ActiveConfig.View.Range.Enabled;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_RANGE_HALF:
			ActiveConfig.View.Range.Half = !ActiveConfig.View.Range.Half;
			ActiveConfig.View.Range.Enabled = ActiveConfig.View.Range.Half;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_RANGE_OPACITY:
			ActiveConfig.View.Range.Opacity = NumberPrompt(hwnd, "Range Circle Opacity", "0 is Not Filled, 100=Opaque", "Percent", "View.Range.Opacity", ActiveConfig.View.Range.Opacity);
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;

		case ID_SCREEN_FOOTPRINT:
			ActiveConfig.View.Footprint.Enabled = !ActiveConfig.View.Footprint.Enabled;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_FOOTPRINT_MIN:
			ActiveConfig.View.Footprint.MinAltitude = NumberPrompt(hwnd, "Altitude Footprint Minimum", "Show Footprint Above This Altitude", "Feet", "View.Footprint.MinAltitude", ActiveConfig.View.Footprint.MinAltitude);
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;
		case ID_SCREEN_FOOTPRINT_MAX:
			ActiveConfig.View.Footprint.MaxAltitude = NumberPrompt(hwnd, "Altitude Footprint Maximum", "Show Footprint Below This Altitude", "Feet", "View.Footprint.MaxAltitude", ActiveConfig.View.Footprint.MaxAltitude);
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;

		case ID_SCREEN_DF_ENABLED:
			ActiveConfig.View.DF.Enabled = !ActiveConfig.View.DF.Enabled;
			InvalidateCircle(NULL, TRUE, TRUE);
            break;
		case ID_SCREEN_DF_OPACITY:
			ActiveConfig.View.DF.Opacity = NumberPrompt(hwnd, "DF Plot Opacity", "0 is Not Filled, 100=Opaque", "Percent", "View.DF.Opacity", ActiveConfig.View.DF.Opacity);
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;


		case ID_CONFIGURE_DX_MIN_DIST:
			ActiveConfig.DX.MinDist = NumberPrompt(hwnd, "Minimum DX Distance", "0=Any (Kind of Stupid)", ActiveConfig.View.Metric.Distance?"km":"mi", "DX.MinDist", ActiveConfig.DX.MinDist);
			break;
		case ID_CONFIGURE_DX_MIN_TRIGGER:
			ActiveConfig.DX.MinTrigger = NumberPrompt(hwnd, "Minimum DX Trigger", "Trigger Immediate (Status or Cluster) DX Report", ActiveConfig.View.Metric.Distance?"km":"mi", "DX.MinTrigger", ActiveConfig.DX.MinTrigger);
			break;
		case ID_CONFIGURE_DX_MIN_INTERVAL:
			ActiveConfig.DX.MinInterval = NumberPrompt(hwnd, "Minimum DX Interval", "Suppress Triggers Sooner Than", "min", "DX.MinInterval", ActiveConfig.DX.MinInterval);
			break;
		case ID_CONFIGURE_DX_WINDOW:
			ActiveConfig.DX.Window = NumberPrompt(hwnd, "DX Window", "Forget DX After", "min", "DX.Window", ActiveConfig.DX.Window);
			break;
		case ID_CONFIGURE_DX_IGNORE_NONE:
			if (ActiveConfig.DX.Excluded.Count
			&& MessageBox(hwnd, TEXT("Really Clear DX Exclusions?"), TEXT("Clear DX"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	EmptyTimedStringList(&ActiveConfig.DX.Excluded);
			}
			break;
		case ID_CONFIGURE_DX_MAXEVER:
			if (ActiveConfig.DX.MaxEver.Station[0])
			{static TCHAR Buffer[256];
				TCHAR *Next = Buffer;
				size_t Remain = sizeof(Buffer);

				StringCbPrintfEx(Next, Remain, &Next, &Remain,
								STRSAFE_IGNORE_NULLS,
					TEXT("Station: %.*S\nWhen: %04ld-%02ld-%02ld %02ld:%02ld:%02ldz\n"),
								STRING(ActiveConfig.DX.MaxEver.Station),
								(long) ActiveConfig.DX.MaxEver.st.wYear,
								(long) ActiveConfig.DX.MaxEver.st.wMonth,
								(long) ActiveConfig.DX.MaxEver.st.wDay,
								(long) ActiveConfig.DX.MaxEver.st.wHour,
								(long) ActiveConfig.DX.MaxEver.st.wMinute,
								(long) ActiveConfig.DX.MaxEver.st.wSecond);

				StringCbPrintfEx(Next, Remain, &Next, &Remain,
								STRSAFE_IGNORE_NULLS,
								TEXT("Distance: %.1lf%S @ %ld (%s)\n"),
								(double) (ActiveConfig.DX.MaxEver.Distance*(ActiveConfig.View.Metric.Distance?KmPerMile:1)),
								ActiveConfig.View.Metric.Distance?"km":"mi",
								(long) ActiveConfig.DX.MaxEver.Bearing,
								GetCompassPoint((int)ActiveConfig.DX.MaxEver.Bearing));
				if (ActiveConfig.DX.MaxEver.Count > 1)
					StringCbPrintfEx(Next, Remain, &Next, &Remain,
									STRSAFE_IGNORE_NULLS,
					TEXT("%ld Since %04ld-%02ld-%02ld %02ld:%02ld:%02ldz\n"),
							(long) ActiveConfig.DX.MaxEver.Count,
							(long) ActiveConfig.DX.MaxEver.stFirst.wYear,
							(long) ActiveConfig.DX.MaxEver.stFirst.wMonth,
							(long) ActiveConfig.DX.MaxEver.stFirst.wDay,
							(long) ActiveConfig.DX.MaxEver.stFirst.wHour,
							(long) ActiveConfig.DX.MaxEver.stFirst.wMinute,
							(long) ActiveConfig.DX.MaxEver.stFirst.wSecond);

				StringCbPrintfEx(Next, Remain, &Next, &Remain, STRSAFE_IGNORE_NULLS,
					TEXT("\nReally Reset?"));
				if (MessageBox(hwnd, Buffer, TEXT("Reset MaxEver DX"), MB_ICONQUESTION | MB_YESNO) == IDYES)
				{	memset(&ActiveConfig.DX.MaxEver, 0, sizeof(ActiveConfig.DX.MaxEver));
					SaveConfiguration(hwnd, &ActiveConfig, "ResetDX");
				}
			}
			break;

		case ID_MAX_GROUP_OBJS:
			ActiveConfig.MaxGroupObjs = NumberPrompt(hwnd, "Max Group Objects", "Max Objects per Query, 0 is Unlimited", "Objects", "MaxGroupObjects", ActiveConfig.MaxGroupObjs);
			break;

		case ID_QRU_ENABLE:
			ActiveConfig.QRU.Enabled = !ActiveConfig.QRU.Enabled;
			memset(&ActiveConfig.QRU.LastTransmit,0,sizeof(ActiveConfig.QRU.LastTransmit));
            break;
		case ID_QRU_RETRY_MESSAGES:
			ActiveConfig.QRU.RetryMessages = !ActiveConfig.QRU.RetryMessages;
            break;
		case ID_QRU_INTERVAL:
			ActiveConfig.QRU.Interval = NumberPrompt(hwnd, "QRU Object Interval", "0 is Never, Recommend Net Cycle Time (10)", "Minutes", "QRU.Interval", ActiveConfig.QRU.Interval);
			break;
		case ID_QRU_MAX_OBJS:
			ActiveConfig.QRU.MaxObjs = NumberPrompt(hwnd, "QRU Max Objects", "Max Objects per Query, 0 is Unlimited", "Objects", "QRU.MaxObjects", ActiveConfig.QRU.MaxObjs);
			break;
		case ID_QRU_RANGE:
			ActiveConfig.QRU.Range = NumberPrompt(hwnd, "QRU Response Range", "0 is None, Should Be Less Than Configure/General/Range", ActiveConfig.View.Metric.Distance?"Kilometers":"Miles", "QRU.Range", ActiveConfig.QRU.Range);
			break;

		case ID_MESSAGES_HIDE_NWS:
			ActiveConfig.Messaging.HideNWS = !ActiveConfig.Messaging.HideNWS;
			break;
		case ID_MESSAGES_HIDE_QUERIES:
			ActiveConfig.Messaging.HideQueries = !ActiveConfig.Messaging.HideQueries;
			break;
		case ID_MESSAGES_NOTIFY_ON_QUERY:
			ActiveConfig.Messaging.NotifyOnQuery = !ActiveConfig.Messaging.NotifyOnQuery;
			break;
		case ID_MESSAGES_NOTIFY_ON_NEW:
			ActiveConfig.Messaging.NotifyOnNewMessage = !ActiveConfig.Messaging.NotifyOnNewMessage;
			break;
		case ID_MESSAGES_MULTITRACK_ITEM:
			ActiveConfig.Messaging.MultiTrackItemInMessage = !ActiveConfig.Messaging.MultiTrackItemInMessage;
			break;
		case ID_MESSAGES_EAVESDROP:
			ActiveConfig.Messaging.AllMessages = !ActiveConfig.Messaging.AllMessages;
			break;
		case ID_RF_MESSAGES:
			ActiveConfig.Messaging.RFMessages = !ActiveConfig.Messaging.RFMessages;
			break;
		case ID_MY_MESSAGES:
			ActiveConfig.Messaging.MyMessages = !ActiveConfig.Messaging.MyMessages;
			TransmitFilter();
			break;
		case ID_MESSAGES_PURGE_MY:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			for (int m=MessageCount-1; m>=0; m--)
			if (Messages[m].Type == MESSAGE_MY)
			{	RemoveMessage(m);
			}
			InvalidateMessage(TRUE);
			break;
		}
		case ID_MESSAGES_PURGE_NWS:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			for (int m=MessageCount-1; m>=0; m--)
			if (Messages[m].Type == MESSAGE_NWS)
			{	RemoveMessage(m);
			}
			InvalidateMessage(TRUE);
			break;
		}
		case ID_MESSAGES_PURGE_EAVESDROP:
		{	for (int m=MessageCount-1; m>=0; m--)
			if (Messages[m].Type == MESSAGE_RF
			|| Messages[m].Type == MESSAGE_EAVESDROP)
			{	RemoveMessage(m);
			}
			InvalidateMessage(TRUE);
			break;
		}
		case ID_MESSAGES_PURGE_SPECIAL:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			for (int m=MessageCount-1; m>=0; m--)
			if (Messages[m].Type == MESSAGE_SPECIAL)
			{	RemoveMessage(m);
			}
			InvalidateMessage(TRUE);
			break;
		}
		case ID_MESSAGES_PURGE_GROUP:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			for (int m=MessageCount-1; m>=0; m--)
			if (Messages[m].Type == MESSAGE_GROUP)
			{	RemoveMessage(m);
			}
			InvalidateMessage(TRUE);
			break;
		}

		case ID_VIEW_ANSRVR_MEMBERS:
		{	cInfo->viewBits ^= VIEW_ANSRVR_MEMBERS;
			if (cInfo->viewBits & VIEW_ANSRVR_MEMBERS) cInfo->viewBits &= ~VIEW_ALL;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		}

		case ID_VIEW_ECHOLINKS:
		if (ActiveConfig.Enables.Internet)
		{	BOOL Refresh = FALSE;
			cInfo->viewBits ^= VIEW_ECHOLINKS;
			if (!(cInfo->viewBits & VIEW_ECHOLINKS))	/* Turned off?  Ask if they want it refreshed */
			{	BUTTONS_S *Buttons = CreateButtons(-1);
				AddButton(Buttons, "Refresh", IDYES, TRUE);
				AddButton(Buttons, "Remove", IDNO);

				FreeEchoLinks(hwnd);
				for (unsigned long s=0; s<CloseStationCount; s++)
				{	STATION_INFO_S *Station = pCloseStations[s];
					if (Station->Station[0]=='E' && Station->Station[1]=='L'
					&& (Station->Station[2]=='-' || isdigit(Station->Station[2]&0xff))
					&& !strcmp(Station->Owner, "ECHOLINK"))
						Station->lastMsec = 0;
				}
				PurgeCloseStations(hwnd);

				if (LwdMessageBox2(hwnd, TEXT("Refresh or Remove EchoLink Objects?"), TEXT("View EchoLinks"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1, Buttons) == IDYES)
				{	cInfo->viewBits |= VIEW_ECHOLINKS;
					Refresh = TRUE;
				} else if (!cInfo->viewBits)
					cInfo->viewBits = VIEW_ALL;	/* Turn ALL back on if nothing left */
			}

			if (cInfo->viewBits & VIEW_ECHOLINKS)	/* Turned on? */
			if (RANGE > 0
			|| MessageBox(hwnd, TEXT("No Range set in Configure / General, EchoLinks may not appear depending on your other filters.  Continue anyway?"), TEXT("View EchoLinks"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	unsigned long Count=-1;
				__int64 msStart;
				if ((Refresh
				|| MessageBox(hwnd, TEXT("Loading EchoLinks can take a REALLY LONG time\nduring which time your system may be non-responsive.\n\nDo you really want to see them?"), TEXT("View EchoLinks"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
#ifdef UNDER_CE
				&& MessageBox(hwnd, TEXT("This is completely EXPERIMENTAL under Windows Mobile.\n\nIt may hang your device requiring a warm boot.\n\nAre you SURE you want to do this?"), TEXT("View EchoLinks"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES
#endif
				&& (msStart = llGetMsec())
				&& (Count = LoadEchoLinks(hwnd, WM_PORT_RECEIVED, RFPORT_INTERNAL)))
				{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
					if (!Refresh) cInfo->viewBits &= ~VIEW_ALL;	/* Turn ALL off the first time */
					StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Loaded %lu Links in %ldmsec"), (unsigned long) Count, (long) llMsecSince(msStart, llGetMsec()));
					MessageBox(hwnd, Buffer, TEXT("View EchoLinks"), MB_OK);
					free(Buffer);
				} else
				{	if (Count == 0) MessageBox(hwnd, TEXT("No EchoLinks Match Filter"), TEXT("View EchoLinks"), MB_OK);
					cInfo->viewBits &= ~VIEW_ECHOLINKS;	/* Force the flag off */
				}
			} else cInfo->viewBits &= ~VIEW_ECHOLINKS;	/* Turn it back off */
			CheckMenuItem (cInfo->hMenu, ID_VIEW_ECHOLINKS, cInfo->viewBits&VIEW_ECHOLINKS?MF_CHECKED:MF_UNCHECKED);
		}
			break;

		case ID_VIEW_GEOCACHES:
		{	BOOL LoadMore = FALSE;
			cInfo->viewBits ^= VIEW_GEOCACHES;

			if (!(cInfo->viewBits & VIEW_GEOCACHES))	/* Turned off?  Ask if they want to load more */
			{	BUTTONS_S *Buttons = CreateButtons(-1);
				AddButton(Buttons, "Load", IDYES, TRUE);
				AddButton(Buttons, "Hide", IDNO);
				if (LwdMessageBox2(hwnd, TEXT("Load More or Hide GeoCaches?"), TEXT("View GeoCaches"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1, Buttons) == IDYES)
				{	LoadMore = TRUE;
					cInfo->viewBits |= VIEW_GEOCACHES;
				}
			}
		
			if (cInfo->viewBits & VIEW_GEOCACHES)	/* Turned on? */
			{	if (LoadMore || !GeocacheCount)	/* Prompt if none or loading more */
				{	unsigned long Count;
#ifdef SUPPORT_TRACE_LOGS
					UnlockTraceLog(GetTraceLog("GeoCaches"),__LINE__);
#endif
					cInfo->viewBits &= ~VIEW_GEOCACHES;	/* Off while loading */
					if (Count = LoadGeocaches(hwnd))
					{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
						cInfo->viewBits |= VIEW_GEOCACHES;	/* And back on when done */
						StringCbPrintf(Buffer, sizeof(*Buffer)*256, TEXT("Loaded %lu/%lu Caches in %luKB"), (unsigned long) Count, (unsigned long) GeocacheCount, (unsigned long) GeocacheRAM/1024);
						MessageBox(hwnd, Buffer, TEXT("View GeoCaches"), MB_OK);
						free(Buffer);
					} else if (!GeocacheCount)
						cInfo->viewBits &= ~VIEW_GEOCACHES;	/* Force the flag off */
				}
			}
			//else FreeGeocaches(hwnd);
			CheckMenuItem (cInfo->hMenu, ID_VIEW_GEOCACHES, cInfo->viewBits&VIEW_GEOCACHES?MF_CHECKED:MF_UNCHECKED);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		}

		case ID_CONFIG_MAP_PURGER:
			ActiveConfig.OSMPurgeDisabled = !ActiveConfig.OSMPurgeDisabled;
			OSMSetPurgeEnable(!ActiveConfig.OSMPurgeDisabled);
			break;

		case ID_CONFIG_MAP_PREFETCH:
		{	int Tiles = OSMPrefetchTiles(hwnd, &rcCircle(cInfo->Index),
											&cInfo->tsInfo,
											cInfo->zoom, cInfo->zoom+3,
											cInfo->LastCenterPosition.dblLatitude,
											cInfo->LastCenterPosition.dblLongitude, TRUE);
			TCHAR Buffer[80];
			StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Really Prefetch %ld Tiles?"), (long) Tiles);
			if (MessageBox(hwnd, Buffer, TEXT("OSM Prefetch"), MB_ICONQUESTION | MB_YESNO) == IDYES)
			{	int Queued = OSMPrefetchTiles(hwnd, &rcCircle(cInfo->Index), 
											&cInfo->tsInfo,
											cInfo->zoom, cInfo->zoom+3,
											cInfo->LastCenterPosition.dblLatitude,
											cInfo->LastCenterPosition.dblLongitude, FALSE);
				if (Queued)
				{	StringCbPrintf(Buffer, sizeof(Buffer), TEXT("Queued %ld/%ld Tiles"), (long) Queued, (long) Tiles);
					MessageBox(hwnd, Buffer, TEXT("OSM Prefetch"), MB_ICONINFORMATION);
				} else MessageBox(hwnd, TEXT("Nothing Queued!"), TEXT("OSM Prefetch"), MB_ICONERROR);
			}
			break;
		}

		case ID_FADE_IN:
		case ID_FADE_OUT:
			if (LOWORD(wp) == ID_FADE_OUT) cInfo->Percent -= 5;
			if (LOWORD(wp) == ID_FADE_IN) cInfo->Percent += 5;
			if (((int)cInfo->Percent) < 0) cInfo->Percent = 0;
			if (cInfo->Percent > 100) cInfo->Percent = 100;
			ActiveConfig.OSMPercent = cInfo->Percent;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_SCREEN_AUTOZOOM_VIEW:
			if (cInfo->AutoZoomViewIn && cInfo->AutoZoomViewOut)
			{	cInfo->AutoZoomViewIn = cInfo->AutoZoomViewOut = cInfo->AutoZoomViewCtr = FALSE;
				cInfo->Locked = TRUE;	/* Maybe should have saved this */
			} else
			{	cInfo->AutoZoomViewIn = cInfo->AutoZoomViewOut = TRUE;
				cInfo->Locked = FALSE;
				if (!cInfo->Locked) cInfo->AutoZoomViewCtr = TRUE;
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			}
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_CTR:
			if (cInfo->AutoZoomViewCtr = !cInfo->AutoZoomViewCtr)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_IN:
			if (cInfo->AutoZoomViewIn = !cInfo->AutoZoomViewIn)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_OUT:
			if (cInfo->AutoZoomViewOut = !cInfo->AutoZoomViewOut)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;

		case ID_ZOOM_IN:
		case ID_ZOOM_OUT:
#ifdef DO_OSM
		{	int OrgZoom = cInfo->zoom;
			if (LOWORD(wp) == ID_ZOOM_IN) cInfo->zoom++;
			if (LOWORD(wp) == ID_ZOOM_OUT) cInfo->zoom--;
			if (cInfo->zoom < ActiveConfig.View.ZoomMin) cInfo->zoom = ActiveConfig.View.ZoomMin;
			if (cInfo->zoom > ActiveConfig.View.ZoomMax) cInfo->zoom = ActiveConfig.View.ZoomMax;
			if (cInfo->zoom != OrgZoom)
			{
				if (ActiveConfig.Screen.Show.CrossHairs > 0)
				{	cInfo->CrossHairs = TRUE;
					SetTimer(hwnd, CROSSHAIR_TIMER, ActiveConfig.Screen.Show.CrossHairTime,NULL);
				}
				cInfo->msLastSigChange = llGetMsec();
				InvalidateScale(hwnd, FALSE);
				InvalidateCircle(hwnd, FALSE);
#ifdef UNDER_CE
				InvalidateStations(hwnd, TRUE);
#else
				InvalidateStations(hwnd, GetInputState()?FALSE:TRUE);	/* Force if no more input */
#endif
			}
			break;
		}
#else
		{	double OrgScale = cInfo->Scale;
			if (LOWORD(wp) == ID_ZOOM_out) cInfo->Scale *= 2;
			if (LOWORD(wp) == ID_ZOOM_IN) cInfo->Scale /= 2;
			if (cInfo->Scale < MIN_SCALE) cInfo->Scale = MIN_SCALE;
			if (cInfo->Scale > MAX_SCALE) cInfo->Scale = MAX_SCALE;
			if (cInfo->Scale != OrgScale)
			{	InvalidateScale(hwnd, FALSE);
				InvalidateCircle(hwnd, FALSE);
#ifdef UNDER_CE
				InvalidateStations(hwnd, TRUE);
#else
				InvalidateStations(hwnd, GetInputState()?FALSE:TRUE);	/* Force if no more input */
#endif
			}
	        break;
		}
#endif
		case ID_VIEW_PREFERRED_RESTORE:
		{	RestorePreferredView(hwnd, cInfo);
			break;
		}
		case ID_VIEW_PREFERRED_SAVE:
		{	SavePreferredView(hwnd, cInfo);
			InvalidateCircle(hwnd,TRUE,TRUE);
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_NONE:
		{	ActiveConfig.MultiTrack.ViewNone = !ActiveConfig.MultiTrack.ViewNone;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_SIZE:
		{	ActiveConfig.MultiTrack.width = ActiveConfig.OrgWindowPlacement.width;
			ActiveConfig.MultiTrack.height = ActiveConfig.OrgWindowPlacement.width;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_ZOOM:
		{	ActiveConfig.MultiTrack.Zoom = cInfo->zoom;
			ActiveConfig.MultiTrack.Scale = cInfo->Scale;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_PERCENT:
		{	ActiveConfig.MultiTrack.Percent = cInfo->Percent;
			break;
		}

		case ID_SCREEN_TRACK_FIND:
		{	unsigned long s = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_FIND_STATION),
											hwnd, FindStationDlgProc, (LPARAM) cInfo);
			if (s >= 0 && s < CloseStationCount) SetCenterTracking(hwnd,pCloseStations[s]);
			break;
		}
		case ID_SCREEN_TRACK_ME:
			SetCenterTracking(hwnd, MyStation);
			break;
		case ID_SCREEN_CENTER_TRACKED:
		{	SetCenterTracking(hwnd, cInfo->CenterStation);
			break;
		}
		case ID_SCREEN_DIM:
			ActiveConfig.Screen.Dim = TRUE;
			InvalidateCircle(hwnd, TRUE, TRUE, 0);
			break;
		case ID_SCREEN_BRIGHT:
			ActiveConfig.Screen.Dim = FALSE;
			InvalidateCircle(hwnd, TRUE, TRUE, 0);
			break;
		case ID_SCREEN_TRACK_LOCKED:
			cInfo->Locked = !cInfo->Locked;
			if (cInfo->Locked && cInfo->CenterStation)
				SetCenterTracking(hwnd, cInfo->CenterStation);
			else InvalidateCircle(hwnd, TRUE, TRUE, 0);
			break;

//		CheckMenuItem (cInfo->hMenu, ID_LOGGING_TOGGLE, (LoggingEnabled?MF_CHECKED:MF_UNCHECKED));

		case ID_CLEAR_STATUS_TEXTS:
			if (MessageBox(hwnd, TEXT("Really Clear All Status Texts?"),
							TEXT("Clear Status"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	STRING_LIST_S *pList = &ActiveConfig.Status.Choices;
				unsigned long a = LocateSimpleStringEntry(pList,ActiveConfig.Status.Text);
				for (unsigned int p=0; p<pList->Count; p++)
				if (p != a)
				{	RemoveSimpleStringEntry(pList, p--);
				}
			}
			break;
		case ID_CLEAR_BEACON_COMMENTS:
			if (MessageBox(hwnd, TEXT("Really Clear All Comments?"),
							TEXT("Clear Comments"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	STRING_LIST_S *pList = &ActiveConfig.CommentChoices;
				unsigned long a = LocateSimpleStringEntry(pList, COMMENT);
				for (unsigned int p=0; p<pList->Count; p++)
				if (p != a)
				{	RemoveSimpleStringEntry(pList, p--);
				}
			}
			break;
		case ID_CLEAR_SYMBOLS:
			if (MessageBox(hwnd, TEXT("Really Clear All Symbols?"),
							TEXT("Clear Symbols"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	STRING_LIST_S *pList = &ActiveConfig.SymbolChoices;
				char aSym[3] = {ActiveConfig.Symbol.Table, ActiveConfig.Symbol.Symbol, 0};
				unsigned long a = LocateSimpleStringEntry(pList, aSym);
				for (unsigned int p=0; p<pList->Count; p++)
				if (p != a)
				{	RemoveSimpleStringEntry(pList, p--);
				}
			}
			break;
		case ID_CLEAR_ALTNETS:
			if (MessageBox(hwnd, TEXT("Really Clear All AltNets?"),
							TEXT("Clear AltNets"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	STRING_LIST_S *pList = &ActiveConfig.AltNetChoices;
				for (unsigned int p=0; p<pList->Count; p++)
				{	char *This = pList->Entries[p].string;
					if (_strnicmp(ActiveConfig.AltNet, This, sizeof(ActiveConfig.AltNet)))
						RemoveSimpleStringEntry(pList, p--);
				}
			}
			break;
		case ID_CLEAR_AUTO_REPLIES:
			if (MessageBox(hwnd, TEXT("Really Clear All Auto-Replies?"),
							TEXT("Clear Auto-Replies"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	STRING_LIST_S *pList = &ActiveConfig.Messaging.AutoAnswer.ReplyChoices;
				unsigned long a = LocateSimpleStringEntry(pList, ActiveConfig.Messaging.AutoAnswer.Reply);
				for (unsigned int p=0; p<pList->Count; p++)
				if (p != a)
				{	RemoveSimpleStringEntry(pList, p--);
				}
			}
			break;
		case ID_CLEAR_BULLETINS:
			if (MessageBox(hwnd, TEXT("Really Clear All Bulletins?"),
							TEXT("Clear Bulletins"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	PurgeBulletins(TRUE);
			}
			break;
		case ID_CLEAR_STATIONS:
			if (MessageBox(hwnd, TEXT("Really Clear All Stations?"),
							TEXT("Clear Stations"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	PurgeCloseStations(hwnd, TRUE);
				InvalidateStatUsage(FALSE);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			break;
		case ID_CLEAR_TACTICAL:
			if (MessageBox(hwnd, TEXT("Really Clear All Tacticals?"),
							TEXT("Clear Tactical"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	ClearTacticalNicknames(hwnd, &ActiveConfig);
				FixNicknames();
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		case ID_RESET_MAX_WIDTH:
			strncpy(ActiveConfig.MaxWidthStationID, "KJ4ERJ-12", sizeof(ActiveConfig.MaxWidthStationID));
			wcsncpy(MaxWidthIGateID,TEXT(""),sizeof(MaxWidthIGateID));
			MaxWidthIGateLength = wcslen(MaxWidthIGateID);
			MaxWidthIGateWidth = 0;
			FixMaxWidthStation(hwnd);
			ShuffleScreenElements(hwnd);
			break;
		case ID_CLEAR_TELEMETRY:
			if (MessageBox(hwnd, TEXT("Really Clear All Telemetry Definitions?"),
							TEXT("Clear Telemetry"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	PurgeTelemetry(TRUE);
			}
			break;
		case ID_CLEAR_WEATHER:
			if (MessageBox(hwnd, TEXT("Really Clear All Weather?"),
							TEXT("Clear Weather"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	PurgeRcvdWeather(TRUE);
			}
			break;
		case ID_CLEAR_WINDOW_POSITIONS:
			if (MessageBox(hwnd, TEXT("Really Clear All Remembered Window Positions?"),
							TEXT("Clear Window Positions"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	EmptyTimedStringList(&ActiveConfig.WindowPositions);
			}
			break;
		case ID_CLEAR_PATHS:
		{	TCHAR *Text=(TCHAR*)malloc(sizeof(*Text)*256), *Title;
			unsigned int s;
			long TotalCount=0, TotalSize=0;
			for (s=0; s<CloseStationCount; s++)
			{	TotalCount += pCloseStations[s]->PathCount;
				TotalSize += pCloseStations[s]->PathSize;
			}
			StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Paths?"),
							(long) TotalCount, (long) TotalSize);
			Title = TEXT("Clear Paths?");
			if (TotalCount && MessageBox(hwnd, Text, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	for (s=0; s<CloseStationCount; s++)
					FreePaths(pCloseStations[s]);
				PurgeFreeCoords("ClearPaths","Menu");
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			free(Text);
			break;
		}

		case ID_CLEAR_TRACK:
		{	TCHAR *Text=(TCHAR*)malloc(sizeof(*Text)*256), *Title;
			unsigned int s;
			long TotalCount=0, TotalSize=0;
			for (s=0; s<CloseStationCount; s++)
			{	TotalCount += pCloseStations[s]->TrackCount;
				TotalSize += pCloseStations[s]->TrackSize;
			}
			if (Odometer)
			{	if (ActiveConfig.View.Metric.Distance)
					StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Track Points and %.1lf km?"),
							(long) TotalCount, (long) TotalSize, (double) Odometer*KmPerMile);
				else StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Track Points and %.1lf miles?"),
							(long) TotalCount, (long) TotalSize, (double) Odometer);
				Title = TEXT("Clear Tracks and Odometer?");
			} else
			{	StringCbPrintf(Text, sizeof(*Text)*256, TEXT("Clear %ld/%ld Track Points?"),
							(long) TotalCount, (long) TotalSize);
				Title = TEXT("Clear Tracks?");
			}
			if ((TotalCount || Odometer) && MessageBox(hwnd, Text, Title, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
			{	if (CSVEnabled)	/* If we're CSV-ing, close and re-open a new file */
				{	EnableCSV(hwnd, FALSE, FALSE);
					EnableCSV(hwnd, TRUE, FALSE);
				}
				if (ActiveConfig.Enables.AutoSaveGPX
				&& MyStation && MyStation->TrackCount)
					SaveTrackToGPX(hwnd, MyStation);
				for (s=0; s<CloseStationCount; s++)
					FreeTracks(pCloseStations[s], FALSE);
				if (Odometer
				&& (!ActiveConfig.Beacon.Why
				|| TransmitOdometer(hwnd, cInfo, "Reset")
				|| MessageBox(hwnd, TEXT("Failed To Transmit Odometer, Still Clear?"), TEXT("Clear Odometer"), MB_YESNO | MB_ICONQUESTION) == IDYES))
				{	Odometer = 0;
					InvalidateOdometer(FALSE);
				}
				PurgeFreeCoords("ClearTracks","Menu");
				InvalidateStatUsage(FALSE);
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			free(Text);
//			LwdMessageBox(hwnd, TEXT("Testing Multi-Line, Scrollable MessageBox with a very long introductory line to force horizontal scrolling\nNext Line\nThisLineHasANonBreakableWord\n\nSkipped Line\nAnd even more lines\nto make the box\nget really\nreally\nREALLY\ntall\nto test the scrolling\non all of the various\nscreen sizes\n\nanother blank back there\nLast Line..."), TEXT("LwdMessageBox Test"), MB_OK | MB_ICONQUESTION);

//#define DUMP_HEAP
#ifdef DUMP_HEAP
#ifdef _DEBUG
{	unsigned long oldMax = ActiveConfig.Stations.MaxAge;
static BOOL First = TRUE;
static _CrtMemState statePrevious = {0};
	if (First)
	{	First = FALSE;
		_CrtMemCheckpoint(&statePrevious);
	}
	PurgeCloseStations(hwnd,TRUE);
	PurgeTraceLogs(0,0,0,0,0);
	OSMFlushTileCache(0);
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
	_CrtMemDumpAllObjectsSince(&statePrevious);
}
#endif
#endif
			break;
		}

		case ID_VIEW_METRIC_ALTITUDE:
		{	ActiveConfig.View.Metric.Altitude = !ActiveConfig.View.Metric.Altitude;
			InvalidateCircle(NULL, TRUE, TRUE);
			InvalidateGPS(TRUE);	/* Actually only the Altitude */
			break;
		}
		case ID_VIEW_METRIC_DISTANCE:
		{	ActiveConfig.View.Metric.Distance = !ActiveConfig.View.Metric.Distance;
			InvalidateCircle(NULL, TRUE, TRUE);
			InvalidateScale(NULL, TRUE);
			InvalidateOdometer(TRUE);
			break;
		}
		case ID_VIEW_METRIC_PRESSURE:
		{	ActiveConfig.View.Metric.Pressure = !ActiveConfig.View.Metric.Pressure;
			break;
		}
		case ID_VIEW_METRIC_RAINFALL:
		{	ActiveConfig.View.Metric.Rainfall = !ActiveConfig.View.Metric.Rainfall;
			break;
		}
		case ID_VIEW_METRIC_TEMPERATURE:
		{	ActiveConfig.View.Metric.Temperature = !ActiveConfig.View.Metric.Temperature;
			if (ActiveConfig.View.LabelWeather)
				InvalidateCircle(NULL, TRUE, TRUE);
			break;
		}
		case ID_VIEW_METRIC_WINDSPEED:
		{	ActiveConfig.View.Metric.Windspeed = !ActiveConfig.View.Metric.Windspeed;
			if (ActiveConfig.View.LabelWeather)
				InvalidateCircle(NULL, TRUE, TRUE);
			break;
		}

		case ID_VIEW_LANDSCAPE:
			SetOrientation(hwnd,0);
			break;
	
		case ID_VIEW_PORTRAIT:
			SetOrientation(hwnd,1);
			break;
	
		case ID_VIEW_AUTOMATIC:
			SetOrientation(hwnd,2);
			break;

		case ID_CONFIGURE_BEACON_AFTER_TRANSMIT:	ActiveConfig.Beacon.AfterTransmit = !ActiveConfig.Beacon.AfterTransmit; break;
		case ID_CONFIGURE_BEACON_TIMESTAMP:	ActiveConfig.Beacon.Timestamp = !ActiveConfig.Beacon.Timestamp; break;
		case ID_CONFIGURE_BEACON_HHMMSS:	ActiveConfig.Beacon.HHMMSS = !ActiveConfig.Beacon.HHMMSS;
											if (ActiveConfig.Beacon.HHMMSS) ActiveConfig.Beacon.Timestamp = TRUE; break;
		case ID_CONFIGURE_BEACON_COMPRESSED:	ActiveConfig.Beacon.Compressed = !ActiveConfig.Beacon.Compressed; break;
		case ID_CONFIGURE_BEACON_CSESPD:	ActiveConfig.Beacon.CourseSpeed = !ActiveConfig.Beacon.CourseSpeed; break;
		case ID_CONFIGURE_BEACON_ALTITUDE:	ActiveConfig.Beacon.Altitude = !ActiveConfig.Beacon.Altitude; break;
#ifdef MONITOR_PHONE
		case ID_CONFIGURE_BEACON_CELLULAR:	ActiveConfig.Beacon.Cellular = !ActiveConfig.Beacon.Cellular; break;
#endif
		case ID_CONFIGURE_BEACON_PRESSURE:	ActiveConfig.Beacon.Why = !ActiveConfig.Beacon.Why; break;

		case ID_CONFIGURE_BEACON_COMMENT_NONE:
			ActiveConfig.Beacon.Comment = FALSE;
			break;

		case ID_CONFIGURE_BEACON_COMMENT_NEW:
		{	char *New = StringPromptA(hwnd, "Beacon Comment", "Enter Comment", sizeof(COMMENT)-1, COMMENT, FALSE, FALSE);
			if (New)
			{	if (strncmp(COMMENT, New, sizeof(COMMENT)))
				{	strncpy(COMMENT, New, sizeof(COMMENT));
					ActiveConfig.Beacon.Comment = TRUE;
					ForceTransmit = TRUE;
					if (MyStation)
						UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
					if (LocateSimpleStringEntry(&ActiveConfig.CommentChoices, New) == -1
					&& MessageBox(hwnd, TEXT("Remember New Comment For Later?"), TEXT("New Comment"), MB_ICONQUESTION | MB_YESNO) == IDYES)
					{	RememberCommentChoice(hwnd, &ActiveConfig, New);
						SaveConfiguration(hwnd, &ActiveConfig, "CommentChoice");
					}
				}
				free(New);
			}
		}
		break;

		case ID_CONFIGURE_BEACON_MICE_NONE:
			if (ActiveConfig.Beacon.MicETag[0]
			&& MessageBox(hwnd, TEXT("Dropping a Mic-E Notification may leave your last status on other stations, Really Clear?"), TEXT("Beacon Mic-E"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	memset(&ActiveConfig.Beacon.MicETag,0,sizeof(ActiveConfig.Beacon.MicETag));
				if (MyStation) MyStation->MicEIndex = 0;
				InvalidateCircle(NULL, TRUE, TRUE);
				ForceTransmit = TRUE;
			}
			break;

		case ID_CONFIGURE_MICE_NOTIF_SUPPRESSED:
			ActiveConfig.Enables.MicENotification = !ActiveConfig.Enables.MicENotification;
			break;
		case ID_CONFIGURE_MICE_NOTIF_NO_EMERGENCY:
			if (!ActiveConfig.Enables.MicEEmergency
			|| MessageBox(hwnd, TEXT("Really Disable EMERGENCY Notifications?"), TEXT("Mic-E Notifications"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				ActiveConfig.Enables.MicEEmergency = !ActiveConfig.Enables.MicEEmergency;
			break;

		case ID_CLEAR_MICE_IGNORES:
		{	unsigned long m;
			for (m=0; m<ActiveConfig.MicEs.Count; m++)
			{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[m];
				EmptyTimedStringList(&Action->Ignores);
			}
			SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Ignore Mic-E");
			break;
		}
		case ID_CLEAR_TACTICAL_ACCEPTS:
		{	EmptyTimedStringList(&ActiveConfig.TacticalSources);
			SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Tactical Accepts");
			break;
		}
		case ID_CLEAR_TACTICAL_NEVERS:
		{	EmptyTimedStringList(&ActiveConfig.TacticalNevers);
			SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Tactical Nevers");
			break;
		}

		case ID_CONFIGURE_SYMBOL_NEW:
		{	SYMBOL_INFO_S Working = ActiveConfig.Symbol;
			if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SYMBOL), hwnd, SymbolDlgProc, (LPARAM)&Working) == IDOK)
			{	if (ActiveConfig.Symbol.Table != Working.Table
				|| ActiveConfig.Symbol.Symbol != Working.Symbol)
				{	ActiveConfig.Symbol = Working;
					ForceTransmit = TRUE;
					if (MyStation)
					{	char Symbol[2] = { SYMBOL };
						MyStation->isymbol = SymbolInt(Symbol[0], Symbol[1]);
						if (MyStation->Nickname
						&& !MyStation->Nickname->OverrideSymbol)
						{	MyStation->Nickname->Symbol = Working;
							SetNicknameSymbol(&ActiveConfig, MyStation->Station, &Working);
						}

						InvalidateCircle(NULL, TRUE, TRUE);
					}
					if (RememberSymbolChoice(hwnd, &ActiveConfig, &ActiveConfig.Symbol))
						SaveConfiguration(hwnd, &ActiveConfig, "SymbolChoice");
				}
			}
		}
		break;

		case ID_SCREEN_LABEL_NICKNAMES:
			ActiveConfig.View.Nicknames = !ActiveConfig.View.Nicknames;
			InvalidateCircle(NULL, TRUE, TRUE);
			break;
		case ID_SCREEN_LABEL_NICKNAME_DELETE:
			if (MessageBox(hwnd, TEXT("Really Delete All Nicknames?"), TEXT("Delete All Nicknames"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	unsigned long p;
				for (p = 0; p < ActiveConfig.Nicknames.Count; p++)
				{	if (RemoveNickname(&ActiveConfig, ActiveConfig.Nicknames.Nick[p].Station)) p--;	/* Do this entry again */
				}
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		case ID_CONFIGURE_NICKNAME_NEW:
		{	char *Changed = PromptNewNickname(hwnd, &ActiveConfig, NULL);
			if (Changed)
			{	FixNicknames(Changed);
				InvalidateCircle(NULL, TRUE, TRUE);
			}
			break;
		}

#ifndef UNDER_CE
		case ID_ALIASES_ACCUMULATE:
			ActiveConfig.AccumulateAliases = !ActiveConfig.AccumulateAliases;
			PrimeAliasTraces();
			break;
		case ID_ALIASES_POSSIBLE_CLEAR:
			EmptyTimedStringList(&ActiveConfig.NewAliases);
			break;
		case ID_ALIASES_0_CLEAR:
			EmptyTimedStringList(&ActiveConfig.ZeroAliases);
			break;
#endif
		case ID_ALIASES_KNOWN_NEW:
		{	char *New = StringPromptA(hwnd, "Alias ID", "Enter Path Alias ID", 6, "", TRUE, FALSE);
			if (New)
			{	SpaceCompress(-1,New);
				ZeroSSID(New);
				if (!CheckIgnoreString(hwnd, &ActiveConfig.PathAliases, New))
					if (IsValidPathAlias(New))
					{	DefineIgnoreString(hwnd, &ActiveConfig.PathAliases, New);
#ifndef UNDER_CE
						DeleteIgnoreString(hwnd, &ActiveConfig.NewAliases, New);
#endif
						SaveConfiguration(hwnd, &ActiveConfig, "PathAlias");
					} else MessageBox(hwnd, TEXT("Invalid Path Alias ID"), TEXT("Invalid Alias"), MB_OK | MB_ICONERROR);
				free(New);
			}
			break;
		}

		case ID_CONFIGURE_ALTNET_NONE:
			memset(ActiveConfig.AltNet,0,sizeof(ActiveConfig.AltNet));
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_CONFIGURE_ALTNET_NEW:
		{	char *New = StringPromptA(hwnd, "AltNet ID", "Enter Alternate Network ID", sizeof(ActiveConfig.AltNet)-1, ActiveConfig.AltNet, TRUE, FALSE);
			if (New)
			{	SpaceCompress(-1,New);
				ZeroSSID(New);
				if (_strnicmp(ActiveConfig.AltNet,New,sizeof(ActiveConfig.AltNet)))
				{	if (IsValidAltNet(New))
					{	strncpy(ActiveConfig.AltNet, New, sizeof(ActiveConfig.AltNet));
						ForceTransmit = TRUE;
						InvalidateCircle(hwnd, TRUE, TRUE);
						RememberAltNetChoice(hwnd, &ActiveConfig, New, TRUE);
						SaveConfiguration(hwnd, &ActiveConfig, "AltNetChoice");
					} else MessageBox(hwnd, TEXT("Invalid Alternate Network ID"), TEXT("Invalid AltNet"), MB_OK | MB_ICONERROR);
				}
				free(New);
			}
			break;
		}

		case ID_CONFIGURE_NWS_MESSAGES:
			ActiveConfig.NWS.Messages = !ActiveConfig.NWS.Messages;
			break;
		case ID_CONFIGURE_NWS_MESSAGES_NO_ALL:
			ActiveConfig.NWS.MessagesNotAll = !ActiveConfig.NWS.MessagesNotAll;
			break;
		case ID_CONFIGURE_NWS_NOTIFY:
			ActiveConfig.NWS.Notify = !ActiveConfig.NWS.Notify;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK:
			if (ActiveConfig.NWS.MultiTrack = !ActiveConfig.NWS.MultiTrack)
				ActiveConfig.NWS.MultiTrackNew = FALSE;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_NEW:
			if (ActiveConfig.NWS.MultiTrackNew = !ActiveConfig.NWS.MultiTrackNew)
				ActiveConfig.NWS.MultiTrack = FALSE;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_LINES:
			ActiveConfig.NWS.MultiTrackLinesOnly = !ActiveConfig.NWS.MultiTrackLinesOnly;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_ME:
			ActiveConfig.NWS.MultiTrackMe = !ActiveConfig.NWS.MultiTrackMe;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_RANGE:
			ActiveConfig.NWS.MultiTrackRange = !ActiveConfig.NWS.MultiTrackRange;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_MOVING:
			ActiveConfig.NWS.MultiTrackMoving = !ActiveConfig.NWS.MultiTrackMoving;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_SPECIFIC:
			ActiveConfig.NWS.MultiTrackPreferML = !ActiveConfig.NWS.MultiTrackPreferML;
			break;
		case ID_CONFIGURE_NWS_MULTITRACK_CLOSE:
			ActiveConfig.NWS.MultiTrackCloseOnExpire = !ActiveConfig.NWS.MultiTrackCloseOnExpire;
			break;
		case ID_CONFIGURE_NWS_NEW_OFFICE:
		{	char *New = StringPromptA(hwnd, "NWS Office", "Enter NWS Office to Monitor (* for all)", 3, "", TRUE, FALSE);
			if (New)
			{	SpaceCompress(-1,New);
				if (!strcmp(New,"*")
				|| (strlen(New) == 3 && isalpha(New[0]&0xff)
					&& isalpha(New[1]&0xff) && isalpha(New[2]&0xff)))
				{	RememberNWSOffice(hwnd, &ActiveConfig, New, FALSE);
					SaveConfiguration(hwnd, &ActiveConfig, "NWSOffice");
					TransmitFilter();
				} else MessageBox(hwnd, TEXT("Invalid NWS Office, Must be 3 Alphas or *"), TEXT("NWS Office"), MB_OK | MB_ICONERROR);
				free(New);
			}
		}
		break;

#ifdef SUPPORT_SHAPEFILES
		case ID_CONFIGURE_NWS_SHOW_OFFICES_ALL:
			if (!ActiveConfig.NWS.ShapeFiles.Count)
				MessageBox(hwnd, TEXT("No Shape Files Configured"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else if (!ActiveConfig.NWS.Offices.Count)
				MessageBox(hwnd, TEXT("No NWS Offices Configured"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else if (!ShapeFileEnabledCount())
				MessageBox(hwnd, TEXT("No Shape Files Enabled or Accessible"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else PopupEnabledCWAs(hwnd, FALSE);
			break;

		case ID_CONFIGURE_NWS_SHOW_OFFICES:
			if (!ActiveConfig.NWS.ShapeFiles.Count)
				MessageBox(hwnd, TEXT("No Shape Files Configured"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else if (!ActiveConfig.NWS.Offices.Count)
				MessageBox(hwnd, TEXT("No NWS Offices Configured"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else if (!ShapeFileEnabledCount())
				MessageBox(hwnd, TEXT("No Shape Files Enabled or Accessible"), TEXT("Show Offices"), MB_OK | MB_ICONWARNING);
			else PopupEnabledCWAs(hwnd, TRUE);
			break;

		case ID_CONFIGURE_NWS_SHAPES_ENABLED:
			ActiveConfig.NWS.ShapesEnabled = !ActiveConfig.NWS.ShapesEnabled;
			if (!ActiveConfig.NWS.ShapesEnabled)
			{	FlushShapeCache();
				FlushShapeIndexes();
			}
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;
		case ID_CONFIGURE_NWS_SHAPE_OPACITY:
			ActiveConfig.NWS.Opacity = NumberPrompt(hwnd, "Shape Opacity", "0 is Not Filled, 100=Opaque", "Percent", "NWS.Opacity", ActiveConfig.NWS.Opacity);
			InvalidateCircle(NULL, TRUE, TRUE);	/* Refresh all windows */
			break;
		case ID_CONFIGURE_NWS_SHAPE_QUALITY:
			ActiveConfig.NWS.Quality = NumberPrompt(hwnd, "Shape Quality", "100 is Original, 0=Worst", "Percent", "NWS.Quality", ActiveConfig.NWS.Quality);
			break;
		case ID_CONFIGURE_NWS_SHAPE_TEST:
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (!ActiveConfig.NWS.ShapeFiles.Count)
				MessageBox(hwnd, TEXT("No Shape Files Configured"), TEXT("ShowMe"), MB_OK | MB_ICONWARNING);
			else if (!ShapeFileEnabledCount())
				MessageBox(hwnd, TEXT("No Shape Files Enabled or Accessible"), TEXT("ShowMe"), MB_OK | MB_ICONWARNING);
			else if (cInfo)
			{	int GotOne = 0;
				SHAPEFILE_OBJECT_S **Objs;
				Objs = GetLatLonZones(cInfo->LastCenterPosition.dblLatitude,
								cInfo->LastCenterPosition.dblLongitude);
				if (Objs)
				{	for (int i=0; Objs[i]; i++)
					{	if (strlen(Objs[i]->Code) == 6)
						{	//SpinMessages(hwnd);
							PopupTestShape(hwnd, Objs[i]->Code);
							GotOne++;
						} else TraceLog("ShapeFile", TRUE, hwnd, "Invalid Code(%s)\n", Objs[i]->Code);
					}
					FreeLatLonZones(Objs);
				}
				if (!GotOne)
					MessageBox(hwnd, TEXT("Failed To Locate Shapes for Screen Center"), TEXT("ShowMe"), MB_OK | MB_ICONWARNING);
			}
			break;
		}
		case ID_CONFIGURE_NWS_NEW_SHAPEFILE:
		{	OPENFILENAME ofn = {0};

			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = hwnd;
			ofn.lpstrFilter = TEXT("shp Files\0*.shp\0\0");
			ofn.nFilterIndex = 1;	/* Default to all */
			ofn.nMaxFile = MAX_PATH-2;
			ofn.lpstrFile = (LPWSTR) calloc(ofn.nMaxFile,sizeof(*ofn.lpstrFile));
			ofn.lpstrTitle = TEXT("Shape File");
			ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

//			StringCbPrintf(ofn.lpstrFile, ofn.nMaxFile*sizeof(*ofn.lpstrFile), TEXT("WxNow.TXT"));

			while (GetOpenFileName(&ofn))
			{	char *File;
				File = (char*)malloc(MAX_PATH);
				StringCbPrintfA(File, MAX_PATH, "%S", ofn.lpstrFile);
				if (ProbeShapeFile(File))
				{	RememberNWSShapeFile(hwnd,&ActiveConfig,File,FALSE);
				} else MessageBox(hwnd, TEXT("ShapeFile Cannot Be Accessed, Possibly Corrupt or Incomplete"), TEXT("Shape File"), MB_OK | MB_ICONERROR);
				free(File);
			}
			free(ofn.lpstrFile);
		}
		break;
#endif

		case ID_CONFIGURE_OVERLAY_NEW:
		{	OPENFILENAME ofn = {0};
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = hwnd;
			ofn.lpstrFilter = TEXT("Overlay Files\0*.POS\0\0");
			ofn.nFilterIndex = 1;	/* Default to all */
			ofn.nMaxFile = MAX_PATH-2;
			ofn.lpstrFile = (LPWSTR) calloc(ofn.nMaxFile,sizeof(*ofn.lpstrFile));
			ofn.lpstrTitle = TEXT("Overlay File");
			ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
			/* while */ if (GetOpenFileName(&ofn))
			{	char *FileName = (char*)malloc(MAX_PATH);
				StringCbPrintfA(FileName, MAX_PATH, "%S", ofn.lpstrFile);
				OVERLAY_CONFIG_INFO_S *pInfo = GetOrCreateOverlay(&ActiveConfig, FileName, 'P', TRUE);
				if (LoadPOSOverlay(hwnd, pInfo, TRUE))
				{	PromptOverlayConfig(hwnd, WM_REFRESH_CIRCLE, pInfo, FALSE);
				} else
				{	RemoveOverlay(&ActiveConfig, FileName);
					MessageBox(hwnd, TEXT("Overlays Cannot Be Loaded, Possibly Corrupt or Incomplete"), TEXT("Overlay File"), MB_OK | MB_ICONERROR);
				}
				free(FileName);
			}
		}
		break;

		case ID_CONFIGURE_GPX_NEW:
		{	OPENFILENAME ofn = {0};
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = hwnd;
			ofn.lpstrFilter = TEXT("GPX Files\0*.gpx\0All Files\0*.*\0\0");
			ofn.nFilterIndex = 1;	/* Default to GPX */
			ofn.nMaxFile = 256;
			ofn.lpstrFile = (LPWSTR) calloc(ofn.nMaxFile,sizeof(*ofn.lpstrFile));
			ofn.lpstrTitle = TEXT("GPX File");
			ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;
			ofn.lpstrDefExt = TEXT("gpx");
			if (GetOpenFileName(&ofn))
			{	char *FileName = (char*)malloc(MAX_PATH);
				StringCbPrintfA(FileName, MAX_PATH, "%.*S", ofn.nMaxFile, ofn.lpstrFile);
				OVERLAY_CONFIG_INFO_S *pOver=GetOrCreateOverlay(&ActiveConfig, FileName, 'G', TRUE);
				if (LoadGPXFile(hwnd, pOver/*, WM_PORT_RECEIVED, RFPORT_INTERNAL*/))
				{	PromptOverlayConfig(hwnd, WM_REFRESH_CIRCLE, pOver, FALSE);
				} else
				{	RemoveOverlay(&ActiveConfig, FileName);
				}
				free(FileName);
			}
		}
		break;

		case ID_AUTO_REPLY_DELAY_ALWAYS:
			ActiveConfig.Messaging.AutoAnswer.Delay = 0;
			break;
		case ID_AUTO_REPLY_DELAY_1_MIN:
			ActiveConfig.Messaging.AutoAnswer.Delay = 1;
			break;
		case ID_AUTO_REPLY_DELAY_5_MIN:
			ActiveConfig.Messaging.AutoAnswer.Delay = 5;
			break;
		case ID_AUTO_REPLY_DELAY_10_MIN:
			ActiveConfig.Messaging.AutoAnswer.Delay = 10;
			break;
		case ID_AUTO_REPLY_DELAY_30_MIN:
			ActiveConfig.Messaging.AutoAnswer.Delay = 30;
			break;
		case ID_AUTO_REPLY_DELAY_LONGER:
		case ID_AUTO_REPLY_DELAY_FOREVER:
			ActiveConfig.Messaging.AutoAnswer.Delay = LONG_MAX;
			break;

		case ID_AUTO_REPLY_INTERVAL_1_MIN:
			ActiveConfig.Messaging.AutoAnswer.Interval = 1;
			break;
		case ID_AUTO_REPLY_INTERVAL_10_MIN:
			ActiveConfig.Messaging.AutoAnswer.Interval = 10;
			break;
		case ID_AUTO_REPLY_INTERVAL_30_MIN:
			ActiveConfig.Messaging.AutoAnswer.Interval = 30;
			break;
		case ID_AUTO_REPLY_INTERVAL_1_HOUR:
			ActiveConfig.Messaging.AutoAnswer.Interval = 1*60;
			break;
		case ID_AUTO_REPLY_INTERVAL_1_DAY:
			ActiveConfig.Messaging.AutoAnswer.Interval = 24*60;
			break;
		case ID_AUTO_REPLY_INTERVAL_1_YEAR:
			ActiveConfig.Messaging.AutoAnswer.Interval = 1*365*24*60;
			break;
		case ID_AUTO_REPLY_INTERVAL_LONGER:
		case ID_AUTO_REPLY_INTERVAL_FOREVER:
			ActiveConfig.Messaging.AutoAnswer.Interval = LONG_MAX;
			break;

		case ID_CONFIGURE_AUTO_REPLY_NONE:
			memset(ActiveConfig.Messaging.AutoAnswer.Reply,0,sizeof(ActiveConfig.Messaging.AutoAnswer.Reply));
			break;

		case ID_CONFIGURE_AUTO_REPLY_NEW:
		{	char *New = StringPromptA(hwnd, "Auto-Reply", "Enter Automatic Reply Text", sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)-1, ActiveConfig.Messaging.AutoAnswer.Reply, FALSE, FALSE);
			if (New)
			{	SpaceTrim(-1,New);
				if (_strnicmp(ActiveConfig.Messaging.AutoAnswer.Reply,New,sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)))
				{	strncpy(ActiveConfig.Messaging.AutoAnswer.Reply, New, sizeof(ActiveConfig.Messaging.AutoAnswer.Reply));
					RememberAutoAnswerChoice(hwnd, &ActiveConfig, New);
					PurgeAutoAnswerStations(hwnd, &ActiveConfig);	/* We haven't sent this to anyone */
					SaveConfiguration(hwnd, &ActiveConfig, "AutoAnswerChoice");
				}
				free(New);
			}
		}
		break;

		case ID_CONFIGURE_BEACON_DAO_0:
			ActiveConfig.Beacon.Precision = 0;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 0;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_DAO_1:
			ActiveConfig.Beacon.Precision = 1;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 0;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_DAO_2:
			ActiveConfig.Beacon.Precision = 2;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 0;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_AMBIG_1:
			ActiveConfig.Beacon.Precision = -1;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 1;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_AMBIG_2:
			ActiveConfig.Beacon.Precision = -2;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 2;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_AMBIG_3:
			ActiveConfig.Beacon.Precision = -3;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 3;
			ForceTransmit = TRUE;
			break;
		case ID_CONFIGURE_BEACON_AMBIG_4:
			ActiveConfig.Beacon.Precision = -4;
			ShuffleScreenElements(hwnd);
			pCloseStations[0]->Ambiguity = 4;
			ForceTransmit = TRUE;
			break;

#ifdef FUTURE
                MENUITEM "+/- 0.1nm", ID_CONFIGURE_BEACON_AMBIG_1
                MENUITEM "+/- 1nm", ID_CONFIGURE_BEACON_AMBIG_2
                MENUITEM "+/- 10nm", ID_CONFIGURE_BEACON_AMBIG_3
                MENUITEM "+/- 60nm", ID_CONFIGURE_BEACON_AMBIG_4
#endif

#ifdef FUTURE
                MENUITEM "+/- 0.1nm", ID_CONFIGURE_BEACON_AMBIG_1
                MENUITEM "+/- 1nm", ID_CONFIGURE_BEACON_AMBIG_2
                MENUITEM "+/- 10nm", ID_CONFIGURE_BEACON_AMBIG_3
                MENUITEM "+/- 60nm", ID_CONFIGURE_BEACON_AMBIG_4
#endif

		case ID_CONFIGURE_BEACON_PATH:
		{	char *New = StringPromptA(hwnd, "Beacon Path", "Enter Path", sizeof(PATH)-1, PATH, TRUE, FALSE);
			if (New)
			{	strncpy(PATH, New, sizeof(PATH));
				free(New);
			}
			break;
		}

		case ID_CONFIGURE_WHOIS_BRIEF:
			ActiveConfig.WhoIsFull = FALSE;
			break;
		case ID_CONFIGURE_WHOIS_FULL:
			ActiveConfig.WhoIsFull = TRUE;
			break;

		case ID_CONFIGURE_STATUS_TEXT_ENABLED:
			ActiveConfig.Status.Enabled = !ActiveConfig.Status.Enabled;
			TransmitStatusReport(TRUE);
			break;
		case ID_CONFIGURE_STATUS_TEXT_DX:
			ActiveConfig.Status.DX = !ActiveConfig.Status.DX;
			TransmitStatusReport(TRUE);
			break;
#ifdef MONITOR_PHONE
		case ID_CONFIGURE_STATUS_TEXT_CELLULAR:
			ActiveConfig.Status.Cellular = !ActiveConfig.Status.Cellular;
			TransmitStatusReport(TRUE);
			break;
#endif
		case ID_CONFIGURE_STATUS_TEXT_GRIDSQ:
			ActiveConfig.Status.GridSquare = !ActiveConfig.Status.GridSquare;
			TransmitStatusReport(TRUE);
			break;
		case ID_CONFIGURE_STATUS_TEXT_TIME:
			ActiveConfig.Status.Timestamp = !ActiveConfig.Status.Timestamp;
			TransmitStatusReport(TRUE);
			break;
		case ID_CONFIGURE_STATUS_TEXT_NONE:
			ActiveConfig.Status.Enabled = FALSE;
			memset(ActiveConfig.Status.Text, 0, sizeof(ActiveConfig.Status.Text));
			if (MyStation)
				UTF8Save(&MyStation->sStatusReport, &MyStation->pStatusReport, ActiveConfig.Status.Text HERE);
			break;
		case ID_CONFIGURE_STATUS_TEXT_NEW:
		{	char *New = StringPromptA(hwnd, "Status Text", "Text", sizeof(ActiveConfig.Status.Text)-1, ActiveConfig.Status.Text, FALSE, FALSE);
			if (New)
			{	if (strncmp(ActiveConfig.Status.Text, New, sizeof(ActiveConfig.Status.Text)))
				{	strncpy(ActiveConfig.Status.Text, New, sizeof(ActiveConfig.Status.Text));
					ActiveConfig.Status.Enabled = TRUE;
					if (MyStation)
						UTF8Save(&MyStation->sStatusReport, &MyStation->pStatusReport, ActiveConfig.Status.Text HERE);
					if (LocateSimpleStringEntry(&ActiveConfig.Status.Choices, New) == -1
					&& MessageBox(hwnd, TEXT("Remember New Status For Later?"), TEXT("New Status"), MB_ICONQUESTION | MB_YESNO) == IDYES)
					{	RememberStatusChoice(hwnd, &ActiveConfig, New);
						SaveConfiguration(hwnd, &ActiveConfig, "StatusChoice");
					}
					TransmitStatusReport(TRUE);
				}
				free(New);
			}
		}
		break;

		case ID_CONFIGURE_POSITS_PATHS:
			ActiveConfig.SavedPositPaths = !ActiveConfig.SavedPositPaths;
			break;
		case ID_CONFIGURE_POSITS_FILTER:
		{	char *New = StringPromptA(hwnd, "Save Posit Filter - CaSe SeNsItIvE", "Enter Filter", sizeof(ActiveConfig.SavedPositFilter), ActiveConfig.SavedPositFilter, FALSE, FALSE);
			if (New)
			{	FILTER_INFO_S CheckFilter={0};
				if (CheckOptimizedFilter(New, &CheckFilter))
				{	strncpy(ActiveConfig.SavedPositFilter, New,
							sizeof(ActiveConfig.SavedPositFilter));
					SaveConfiguration(hwnd, &ActiveConfig, "PositsFilter");
					if (*New)	/* Actual filter? */
						ActiveConfig.Scroller.ShowAll = FALSE;
				} else
				{	ShowTraceLog("FilterError");
					MessageBox(hwnd, TEXT("Invalid Filter Specification, Filter Not Saved"), TEXT("Filter Error"), MB_ICONERROR | MB_OK);
				}
				FreeFilter(&CheckFilter);
				free(New);
			}
			break;
		}

		case ID_CONFIGURE_SCROLLER_FILTER:
		{	char *New = StringPromptA(hwnd, "Scroller Filter - CaSe SeNsItIvE", "Enter Filter", sizeof(ActiveConfig.Scroller.Filter), ActiveConfig.Scroller.Filter, FALSE, FALSE);
			if (New)
			{	if (CheckOptimizedFilter(New, &ScrollerFilter))
				{	strncpy(ActiveConfig.Scroller.Filter, New,
							sizeof(ActiveConfig.Scroller.Filter));
					SaveConfiguration(hwnd, &ActiveConfig, "ScrollerFilter");
					if (*New)	/* Actual filter? */
						ActiveConfig.Scroller.ShowAll = FALSE;
				} else
				{	ShowTraceLog("FilterError");
					MessageBox(hwnd, TEXT("Invalid Filter Specification, Filter Not Saved"), TEXT("Filter Error"), MB_ICONERROR | MB_OK);
				}
				free(New);
			}
			break;
		}
		case ID_CONFIGURE_SCROLLER_HIDE_NOPARSE:
			if (ActiveConfig.Scroller.HideNoParse = !ActiveConfig.Scroller.HideNoParse)
				ActiveConfig.Scroller.ShowAll = FALSE;
			break;
		case ID_CONFIGURE_SCROLLER_NO_INTERNALS:
			if (ActiveConfig.Scroller.NoInternals = !ActiveConfig.Scroller.NoInternals)
				ActiveConfig.Scroller.ShowAll = FALSE;
			break;
		case ID_CONFIGURE_SCROLLER_NOT_ME:
			if (ActiveConfig.Scroller.NotME = !ActiveConfig.Scroller.NotME)
				ActiveConfig.Scroller.ShowAll = FALSE;
			break;
		case ID_CONFIGURE_SCROLLER_NOT_MINE:
			if (ActiveConfig.Scroller.NotMine = !ActiveConfig.Scroller.NotMine)
				ActiveConfig.Scroller.ShowAll = FALSE;
			break;
		case ID_CONFIGURE_SCROLLER_RF_ONLY:
			if (ActiveConfig.Scroller.RFOnly = !ActiveConfig.Scroller.RFOnly)
				ActiveConfig.Scroller.ShowAll = FALSE;
			break;
		case ID_CONFIGURE_SCROLLER_SHOW_ALL:
			ActiveConfig.Scroller.ShowAll = !ActiveConfig.Scroller.ShowAll;
			break;
		case ID_CONFIGURE_SCROLLER_SHOW_IGATE:
			ActiveConfig.Scroller.ShowIGateOrDigi = !ActiveConfig.Scroller.ShowIGateOrDigi;
			ShuffleScreenElements(hwnd);
			break;
		case ID_CONFIGURE_SCROLLER_CLICK_FREEZE:
			ActiveConfig.Scroller.FreezeOnClick = !ActiveConfig.Scroller.FreezeOnClick;
			break;

		case ID_CONFIGURE_PATHS:
			if (cInfo->hwndPathConfig && IsWindow(cInfo->hwndPathConfig))
				ShowWindow(cInfo->hwndPathConfig, SW_SHOW);
			else cInfo->hwndPathConfig = PromptPathConfig(hwnd, WM_REFRESH_CIRCLE, &cInfo->Paths, TRUE);
			break;

		case ID_CONFIGURE_GENERAL:
		{CONFIG_INFO_S *Original = (CONFIG_INFO_S *)malloc(sizeof(*Original));
			*Original = ActiveConfig;
			if (PromptConfiguration(hwnd, &ActiveConfig))
			{	if (strncmp(ActiveConfig.CallSign, Original->CallSign, sizeof(ActiveConfig.CallSign)))
				{	UpdateCallsign(hwnd);
					set_message_handler(CALLSIGN, myMessageCallback, cInfo);
				}
				if (ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
				{
					if (strncmp(ActiveConfig.CallSign, Original->CallSign, sizeof(ActiveConfig.CallSign))
					|| strncmp(ActiveConfig.Password, Original->Password, sizeof(ActiveConfig.Password)))
					{	SoundConn(FALSE);
						APRSISStop();
						APRSISStart(ActiveConfig.APRSIS.Port);
						SoundConn(TRUE);
						InvalidatePortStatus(TRUE);
					}
					else if (strncmp(ActiveConfig.Filter, Original->Filter, sizeof(ActiveConfig.Filter))
					|| ActiveConfig.Range != Original->Range)
						TransmitFilter(strncmp(ActiveConfig.Filter, Original->Filter, sizeof(ActiveConfig.Filter)));
				}
				if (ActiveConfig.Comment[0]
				&& !strncmp(ActiveConfig.Comment, Original->Comment, sizeof(ActiveConfig.Comment)))
				{	RememberCommentChoice(hwnd, &ActiveConfig, ActiveConfig.Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "CommentChoice");
				}
				if (MyStation)
				{	char Symbol[2] = { SYMBOL };
					MyStation->isymbol = SymbolInt(Symbol[0], Symbol[1]);
					if (MyStation->Nickname
					&& !MyStation->Nickname->OverrideSymbol)
					{	MyStation->Nickname->Symbol = ActiveConfig.Symbol;
						SetNicknameSymbol(&ActiveConfig, MyStation->Station, &ActiveConfig.Symbol);
					}
					if (RememberSymbolChoice(hwnd, &ActiveConfig, &ActiveConfig.Symbol))
						SaveConfiguration(hwnd, &ActiveConfig, "SymbolChoice");
					strncpy(MyStation->Station, CALLSIGN, sizeof(MyStation->Station));
					UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
					StrSave(&MyStation->sPath, &MyStation->pPath, ActiveConfig.APRSIS.Port HERE);
					MyStation->SeenIndex = GetSeenStationIndex(MyStation->Station);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
			}
			free(Original);
			break;
		}
		case ID_CONFIGURE_STATUS_TEXT:
		{CONFIG_INFO_S *Original = (CONFIG_INFO_S *)malloc(sizeof(*Original));
			*Original = ActiveConfig;
			if (PromptStatusReport(hwnd, &ActiveConfig))
			{
				if (ActiveConfig.Comment[0]
				&& strncmp(ActiveConfig.Comment, Original->Comment, sizeof(ActiveConfig.Comment)))
				{	RememberCommentChoice(hwnd, &ActiveConfig, ActiveConfig.Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "CommentChoice");
				}

				if (ActiveConfig.Status.Text[0]
				&& strncmp(ActiveConfig.Status.Text, Original->Status.Text, sizeof(ActiveConfig.Status.Text)))
				{	RememberStatusChoice(hwnd, &ActiveConfig, ActiveConfig.Status.Text);
					SaveConfiguration(hwnd, &ActiveConfig, "StatusChoice");
				}

				if (ActiveConfig.CommentInterval != Original->CommentInterval
				|| strncmp(ActiveConfig.Comment, Original->Comment, sizeof(ActiveConfig.Comment)))
					ForceTransmit = TRUE;

				if (ActiveConfig.Status.Interval != Original->Status.Interval
				|| strncmp(ActiveConfig.Status.Text, Original->Status.Text, sizeof(ActiveConfig.Status.Text)))
					TransmitStatusReport(TRUE);

				if (MyStation)
				{	UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
					UTF8Save(&MyStation->sStatusReport, &MyStation->pStatusReport, ActiveConfig.Status.Text HERE);
				}
			}
			free(Original);
			break;
		}
		case ID_CONFIGURE_GENIUS:
			if (PromptGenius(hwnd, &ActiveConfig))
			{	/* Nothing dynamic here */
			}
			break;

		case ID_CONFIGURE_APRSIS:
		{CONFIG_INFO_S *Original = (CONFIG_INFO_S *)malloc(sizeof(*Original));
			*Original = ActiveConfig;
			if (PromptConfigAPRSIS(hwnd, &ActiveConfig))
			{
				if (strncmp(ActiveConfig.CallSign, Original->CallSign, sizeof(ActiveConfig.CallSign)))
				{	UpdateCallsign(hwnd);
					set_message_handler(CALLSIGN, myMessageCallback, cInfo);
				}

				if (ActiveConfig.Enables.APRSIS != Original->Enables.APRSIS)
				{	EnableAPRS(hwnd, ActiveConfig.Enables.APRSIS);
				} else if (ActiveConfig.Enables.APRSIS
				&& ActiveConfig.Enables.Internet)
				{
					if (strncmp(ActiveConfig.CallSign, Original->CallSign, sizeof(ActiveConfig.CallSign))
					|| strncmp(ActiveConfig.APRSIS.Port, Original->APRSIS.Port, sizeof(ActiveConfig.APRSIS.Port))
					|| ActiveConfig.QuietTime != Original->QuietTime)
					{	SoundConn(FALSE);
						APRSISStop();
						APRSISStart(ActiveConfig.APRSIS.Port);
						SoundConn(TRUE);
						InvalidatePortStatus(TRUE);
					}
				}

				if (ActiveConfig.Comment[0]
				&& !strncmp(ActiveConfig.Comment, Original->Comment, sizeof(ActiveConfig.Comment)))
				{	RememberCommentChoice(hwnd, &ActiveConfig, ActiveConfig.Comment);
					SaveConfiguration(hwnd, &ActiveConfig, "CommentChoice");
				}

				if (MyStation)
				{	strncpy(MyStation->Station, CALLSIGN, sizeof(MyStation->Station));
					UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
					StrSave(&MyStation->sPath, &MyStation->pPath, ActiveConfig.APRSIS.Port HERE);
					MyStation->SeenIndex = GetSeenStationIndex(MyStation->Station);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
				FixIGateEnabled();
			}
			free(Original);
			break;
		}
		case ID_CONFIGURE_NMEA:
		{	char *Before = _strdup(ActiveConfig.GPSPort);
			if (PromptNMEA(hwnd, &ActiveConfig))
			{	if (!*ActiveConfig.GPSPort)
				{	EnableMenuItem(cInfo->hMenu, ID_GPS_TOGGLE, (ActiveConfig.GPSPort[0]?MF_ENABLED:MF_GRAYED));
					ShuffleScreenElements(hwnd);
				} else if (strcmp(ActiveConfig.GPSPort,Before))
				{	if (ActiveConfig.Enables.GPS) EnableGPS(hwnd, FALSE, FALSE);
					EnableGPS(hwnd, TRUE, FALSE);
				}
			}
			break;
		}
		case ID_CONFIGURE_NEW_RFPORT:
		{	int id = PromptNewRFPort(hwnd, &ActiveConfig);
			if (id>=0 && id<(int)ActiveConfig.RFPorts.Count)
			{	if (ActiveConfig.Enables.RFPorts && RFPortRunnable(&ActiveConfig.RFPorts.Port[id]))
				{	IncrementXmitPackets(id, 0, ActiveConfig.RFPorts.Port[id].Name);
					PortStart(&ActiveConfig.RFPorts.Port[id], hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, id);
					FixIGateEnabled();
				}
			}
			break;
		}

		case ID_BULLETINS_VIEW:
		{	DisplayBulletins(cInfo, SW_SHOW);
			break;
		}
		case ID_BULLETINS_NOTIFY_NEW:
			ActiveConfig.Enables.NotifyOnNewBulletin = !ActiveConfig.Enables.NotifyOnNewBulletin;
			ShowHideBulletinIcon(hwnd,ActiveConfig.Enables.NotifyOnNewBulletin);
			break;
		case ID_BULLETINS_NEW:
		{	if (PromptNewBulletin(hwnd, &ActiveConfig))
			{	TransmitBulletins(hwnd);
			}
			break;
		}

		case ID_CQSRVR_ACTIVE_GROUPS:
			SendAPRSMessage(/*hwnd,*/ "ANSRVR", 0, TEXT("?"), TRUE);
			SendAPRSMessage(/*hwnd,*/ "CQSRVR", 0, TEXT("?"), TRUE);
			break;
		case ID_CQSRVR_DESCRIBE_GROUPS:
			if ((ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
			|| MessageBox(hwnd, TEXT("Not Recommended Over RF, Procede Anyway?"), TEXT("Describe Groups"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	SendAPRSMessage(/*hwnd,*/ "ANSRVR", 0, TEXT("D"), TRUE);
			}
			break;
		case ID_CQSRVR_MEMBER_GROUPS:
			SendAPRSMessage(/*hwnd,*/ "ANSRVR", 0, TEXT("L"), TRUE);
			SendAPRSMessage(/*hwnd,*/ "CQSRVR", 0, TEXT("L"), TRUE);
			break;
		case ID_CQSRVR_JOIN_GROUP:
		{	if (PromptNewCQGroup(hwnd, &ActiveConfig))
			{	TransmitCQGroups(hwnd);
			}
			break;
		}

		case ID_CONFIGURE_NEW_TILE_SERVER:
		{	if (PromptNewTileServer(hwnd, &ActiveConfig))
			{	cInfo->tsInfo = ActiveConfig.OSM = ActiveConfig.TileServers.Server[ActiveConfig.TileServers.Count-1];
				InvalidateCircle(hwnd, TRUE, TRUE);
			}
			break;
		}

		case ID_COMPANIONS_ENABLED:
		{	ActiveConfig.CompanionsEnabled = !ActiveConfig.CompanionsEnabled;
			if (ActiveConfig.Companions.Count)
			{	TraceLog("Companions", TRUE, hwnd, "%ld Companions %s gpsPosition:%04ld-%02ld-%02ld %02ld:%02ld:%02ld %s %s %s\n",
							(long) ActiveConfig.Companions.Count,
							ActiveConfig.CompanionsEnabled?"Enabled":"Disabled",
							(long) gpsPosition.stUTCTime.wYear, 
							(long) gpsPosition.stUTCTime.wMonth, 
							(long) gpsPosition.stUTCTime.wDay, 
							(long) gpsPosition.stUTCTime.wHour, 
							(long) gpsPosition.stUTCTime.wMinute, 
							(long) gpsPosition.stUTCTime.wSecond,
							gpsPosition.dwValidFields&GPS_VALID_UTC_TIME?"Time":"NO-Time",
							gpsPosition.dwValidFields&GPS_VALID_LATITUDE?"Lat":"NO-Lat",
							gpsPosition.dwValidFields&GPS_VALID_LONGITUDE?"Lon":"NO-Lon");
				if (ActiveConfig.CompanionsEnabled) TransmitCompanions();
			}
			break;
		}
		case ID_COMPANIONS_NEW:
		{	COMPANION_INFO_S *Obj;
			if (MessageBox(hwnd, TEXT("Create New Tracking Companion?"), TEXT("New Companion"), MB_ICONQUESTION | MB_YESNO) == IDYES
			&& (Obj=PromptNewCompanion(hwnd, &ActiveConfig)))
			{	if (ActiveConfig.Companions.Count == 1
				&& ActiveConfig.Companions.Companion[0].Enabled)
				{	ActiveConfig.CompanionsEnabled = TRUE;
					TraceLog("Companions", TRUE, hwnd, "%ld Companions %s gpsPosition:%04ld-%02ld-%02ld %02ld:%02ld:%02ld %s %s %s\n",
							(long) ActiveConfig.Companions.Count,
							ActiveConfig.CompanionsEnabled?"Enabled":"Disabled",
							(long) gpsPosition.stUTCTime.wYear, 
							(long) gpsPosition.stUTCTime.wMonth, 
							(long) gpsPosition.stUTCTime.wDay, 
							(long) gpsPosition.stUTCTime.wHour, 
							(long) gpsPosition.stUTCTime.wMinute, 
							(long) gpsPosition.stUTCTime.wSecond,
							gpsPosition.dwValidFields&GPS_VALID_UTC_TIME?"Time":"NO-Time",
							gpsPosition.dwValidFields&GPS_VALID_LATITUDE?"Lat":"NO-Lat",
							gpsPosition.dwValidFields&GPS_VALID_LONGITUDE?"Lon":"NO-Lon");
					TransmitCompanions();
				}
#ifdef FUTURE
				if (Obj && Obj->Enabled)
				{	TransmitObject(Obj);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
#endif
			}
			break;
		}

		case ID_OBJECTS_SHOW:
		{	cInfo->ShowMyObjects = !cInfo->ShowMyObjects;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		}

		case ID_OBJECTS_NEW:
		{	OBJECT_CONFIG_INFO_S *Obj;
			if (MessageBox(hwnd, TEXT("Create Object At Screen Center?"), TEXT("New Object"), MB_ICONQUESTION | MB_YESNO) == IDYES
			&& (Obj=PromptNewObject(hwnd, &ActiveConfig, cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude)))
			{	if (Obj && Obj->Enabled)
				{	TransmitObject(Obj);
					InvalidateCircle(hwnd, TRUE, TRUE);
				}
			}
			break;
		}

		case ID_OBJECTS_NEW_WEATHER:
		{	if (MessageBox(hwnd, TEXT("Create Weather Object At Screen Center?"), TEXT("New Weather Object"), MB_ICONQUESTION | MB_YESNO) == IDYES)
			{	OPENFILENAME ofn = {0};

				ofn.lStructSize = sizeof(ofn);
				ofn.hwndOwner = hwnd;
				ofn.lpstrFilter = TEXT("Text Files\0*.txt\0\0");
				ofn.nFilterIndex = 1;	/* Default to all */
				ofn.nMaxFile = sizeof(ActiveConfig.Objects.Obj->WeatherPath)-2;
				ofn.lpstrFile = (LPWSTR) calloc(ofn.nMaxFile,sizeof(*ofn.lpstrFile));
				ofn.lpstrTitle = TEXT("Weather File");
				ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

				StringCbPrintf(ofn.lpstrFile, ofn.nMaxFile*sizeof(*ofn.lpstrFile), TEXT("WxNow.TXT"));

				while (GetOpenFileName(&ofn))
				{	char *File, *Packet;
					File = (char*)malloc(MAX_PATH);
					StringCbPrintfA(File, MAX_PATH, "%S", ofn.lpstrFile);
					Packet = ParseWeatherFile("CheckWeatherFile", File, NULL);
					if (!Packet)
					{	if (MessageBox(hwnd, TEXT("Failed To Parse Weather from File, Try Again?"), TEXT("New Weather Object"), MB_YESNO | MB_ICONQUESTION) == IDYES)
							continue;
						else break;
					} else free(Packet);
					if (PromptNewWeatherObject(hwnd, &ActiveConfig, cInfo->LastCenterPosition.dblLatitude, cInfo->LastCenterPosition.dblLongitude, File))
					{	TransmitObjects(hwnd);
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
					free(File);
					break;
				}
				free(ofn.lpstrFile);
			}
			break;
		}

#ifndef UNDER_CE
		case ID_OBJECTS_NEW_JT65:
		{	if (MessageBox(hwnd, TEXT("Create JT65 Object At ME?"), TEXT("New JT65 Object"), MB_ICONQUESTION | MB_YESNO) == IDYES)
			{	OPENFILENAME ofn = {0};

				ofn.lStructSize = sizeof(ofn);
				ofn.hwndOwner = hwnd;
				ofn.lpstrFilter = TEXT("CSV Files\0*.csv\0\0");
				ofn.nFilterIndex = 1;	/* Default to all */
				ofn.nMaxFile = sizeof(ActiveConfig.Objects.Obj->WeatherPath)-2;
				ofn.lpstrFile = (LPWSTR) calloc(ofn.nMaxFile,sizeof(*ofn.lpstrFile));
				ofn.lpstrTitle = TEXT("JT65 CSV File");
				ofn.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

				StringCbPrintf(ofn.lpstrFile, ofn.nMaxFile*sizeof(*ofn.lpstrFile), TEXT("JT65hf-log.csv"));

				while (GetOpenFileName(&ofn))
				{	char *File;
					File = (char*)malloc(MAX_PATH);
					StringCbPrintfA(File, MAX_PATH, "%S", ofn.lpstrFile);
					if (!ParseJT65File(NULL, File, NULL))
					{	if (MessageBox(hwnd, TEXT("Failed To Parse JT65 Logs, Try Again?"), TEXT("New JT65 Object"), MB_YESNO | MB_ICONQUESTION) == IDYES)
							continue;
						else break;
					}
					if (PromptNewJT65Object(hwnd, &ActiveConfig, MyStation->pCoord->lat, MyStation->pCoord->lon, File))
					{	TransmitObjects(hwnd);
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
					free(File);
					break;
				}
				free(ofn.lpstrFile);
			}
			break;
		}
#endif

		case ID_SEND_EMAIL:
			if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SEND_EMAIL), hwnd, SendEMailDlgProc) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_EMAIL) Failed"), TEXT("ID_SEND_EMAIL"), MB_OK | MB_ICONERROR);
#ifdef USING_SIP
			SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
			break;
		case ID_CHAT_NEW:	/* Same as Send Message */
		case ID_SEND_MESSAGE:
			if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)CALLSIGN) == -1)
				MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("ID_SEND_MESSAGE"), MB_OK | MB_ICONERROR);
#ifdef USING_SIP
			SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
			break;
		case ID_READ_MESSAGE:
		{	if (MessageCount)
				SendMouseMessage(hwnd, WM_LBUTTONUP, 0, &rcMessage(cInfo->Index));
			break;
		}
		case ID_PENDING_MESSAGES:
			PopupPendingMessages(hwnd);
			break;

#ifdef USING_SHELL
		case ID_MENU_REPLY:
		{	for (int i=0; i<MessageCount; i++)
			{	if (Messages[i].pNotification
				&& Messages[i].pNotification->dwID == lp)
				{
#ifdef USING_CHAT
					DisplayChat(Messages[i].From, Messages[i].To);
#else
					if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SEND_MESSAGE), hwnd, SendMessageDlgProc, (LPARAM)Messages[i].From) == -1)
						MessageBox(hwnd, TEXT("DialogBoxParm(IDD_SEND_MESSAGE) Failed"), TEXT("ID_MENU_REPLY"), MB_OK | MB_ICONERROR);
#endif
#ifdef USING_SIP
					SipShowIM(SIPF_OFF);	/* Shut down the SIP */
#endif
					break;	/* Only do the first ID match */
				}
			}
		}
		case ID_MENU_DISMISS:	/* REPLY falls through to HERE! */
		{	for (int i=0; i<MessageCount; i++)
			{	if (Messages[i].pNotification
				&& Messages[i].pNotification->dwID == lp)
				{	RemoveMessage(i);
					InvalidateMessage(TRUE);
					break;	/* Only do the first ID match */
				}
			}
			break;
		}
#endif
		case ID_LOG_FILE:
			if (ActiveConfig.Enables.DebugFile) TraceActivity(hwnd, "File Logging Disabled\n");
			ActiveConfig.Enables.DebugFile = !ActiveConfig.Enables.DebugFile;
			if (ActiveConfig.Enables.DebugFile) TraceActivity(hwnd, "File Logging Enabled\n");
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:LogFile");
			break;
		case ID_LOG_GENERAL:
		{	TRACE_LOG_S *Log = GetTraceLog("Activity");
			ActiveConfig.Enables.DebugGeneral = !ActiveConfig.Enables.DebugGeneral;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:LogGeneral");
			if (Log)
			{	Log->Enabled = ActiveConfig.Enables.DebugGeneral;
				UnlockTraceLog(Log,__LINE__);
			}
			break;
		}
		case ID_LOG_STARTUP:
			ActiveConfig.Enables.DebugStartup = !ActiveConfig.Enables.DebugStartup;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:LogStartup");
			break;
#ifdef SUPPORT_TRACE_LOGS
		case ID_LOG_NONE:
		{	ActiveConfig.Enables.DebugGeneral = FALSE;
			UnShowTraceLog(NULL);
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:LogNone");
			break;
		}
		case ID_LOG_ALL:
		{	CreateLockWindow();
			ShowTraceLog(NULL, TRUE);
			break;
		}
#endif
		case ID_RFPORTS_NO_XMIT:
		{	ActiveConfig.Enables.RFReceiveOnly = !ActiveConfig.Enables.RFReceiveOnly;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:NoXmit");
			break;
		}
		case ID_RFPORTS_LOG_ALL:
		{	ActiveConfig.Enables.RFPktLog = !ActiveConfig.Enables.RFPktLog;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:PktLog");
			break;
		}
		case ID_RFPORTS_ENABLE:
		{	unsigned long p;
			ActiveConfig.Enables.RFPorts = !ActiveConfig.Enables.RFPorts;
			SaveConfiguration(hwnd, &ActiveConfig, "Enables:RFPorts");
			for (p=0; p<ActiveConfig.RFPorts.Count; p++)
			{	if (ActiveConfig.Enables.RFPorts && RFPortRunnable(&ActiveConfig.RFPorts.Port[p]))
				{	IncrementXmitPackets(p, 0, ActiveConfig.RFPorts.Port[p].Name);
					PortStart(&ActiveConfig.RFPorts.Port[p], hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, p);
				} else
				{	if (PortStop(&ActiveConfig.RFPorts.Port[p], p))
						PostMessage(hwnd, WM_PORT_STATUS, MAKELONG(p,1), (LPARAM) _strdup("Disabled"));
				}
			}
			FixIGateEnabled();
			break;
		}
		default:
		{	UINT id = LOWORD(wp);
#ifdef SUPPORT_TRACE_LOGS
			ProcessTraceLogEnableMenu(id);
			ProcessTraceLogViewMenu(id);
#endif
			ProcessViewMenu(hwnd, cInfo,id);

			if (id > ID_RFPORTS_ENABLE && id <= ID_RFPORTS_ENABLE+ActiveConfig.RFPorts.Count)
			{	id -= ID_RFPORTS_ENABLE+1;
				if (id>=0 && id<ActiveConfig.RFPorts.Count)
				{	ActiveConfig.RFPorts.Port[id].IsEnabled = !ActiveConfig.RFPorts.Port[id].IsEnabled;
					if (ActiveConfig.Enables.RFPorts && RFPortRunnable(&ActiveConfig.RFPorts.Port[id]))
					{	PortStart(&ActiveConfig.RFPorts.Port[id], hwnd, WM_PORT_STATUS, WM_PORT_SUB_STATUS, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, id);
					} else
					{	if (PortStop(&ActiveConfig.RFPorts.Port[id], id))
							PostMessage(hwnd, WM_PORT_STATUS, MAKELONG(id,1), (LPARAM) _strdup("Disabled"));
					}
					FixIGateEnabled();
				}
			}

			if (id > ID_CONFIGURE_NMEA && id <= ID_CONFIGURE_NMEA+ActiveConfig.RFPorts.Count)
			{	id -= ID_CONFIGURE_NMEA+1;
				if (id>=0 && id<ActiveConfig.RFPorts.Count)
				{	BOOL Running = ActiveConfig.Enables.RFPorts && RFPortRunnable(&ActiveConfig.RFPorts.Port[id]);
					if (PromptConfigRFPort(hwnd, &ActiveConfig, id))
					{	if (Running) PortStop(&ActiveConfig.RFPorts.Port[id], id);
						if (ActiveConfig.Enables.RFPorts && RFPortRunnable(&ActiveConfig.RFPorts.Port[id]))
							PortStart(&ActiveConfig.RFPorts.Port[id], hwnd, WM_PORT_STATUS, 0, WM_PORT_RECEIVED, WM_PORT_XMIT_COUNT, id);
						FixIGateEnabled();
					}
				}
			}

			if (id > ID_BULLETINS_NEW && id <= ID_BULLETINS_NEW+ActiveConfig.Bulletins.Count)
			{	id -= ID_BULLETINS_NEW+1;
				if (id>=0 && id<ActiveConfig.Bulletins.Count)
				{	if (PromptConfigBulletin(hwnd, &ActiveConfig, id))
					{	TransmitBulletins(hwnd);
					}
				}
			}

			if (id > ID_CHAT_NEW && id <= ID_CHAT_NEW+ChatCount)
			{	id -= ID_CHAT_NEW+1;
				if (id>=0 && id<ChatCount && Chats[id])
				{	DisplayChat(Chats[id]->From, Chats[id]->To);
				}
			}

			if (id > ID_CQSRVR_JOIN_GROUP && id <= ID_CQSRVR_JOIN_GROUP+ActiveConfig.CQGroups.Count)
			{	id -= ID_CQSRVR_JOIN_GROUP+1;
				if (id>=0 && id<ActiveConfig.CQGroups.Count)
				{	if (PromptConfigCQGroup(hwnd, &ActiveConfig, id))
					{	TransmitCQGroups(hwnd);
					}
				}
			}

#ifdef OLD_WAY
			if (id > ID_OBJECTS_NEW && id <= ID_OBJECTS_NEW+ActiveConfig.Objects.Count)
			{	id -= ID_OBJECTS_NEW+1;
				if (id>=0 && id<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[id];
					char OldName[sizeof(Obj->Name)];
					strncpy(OldName, Obj->Name, sizeof(OldName));
					Obj = PromptConfigObject(hwnd, &ActiveConfig, id);
					if (Obj && Obj->Enabled)
					{	TransmitObject(Obj);
					}
					Obj = FindConfigObject(&ActiveConfig, OldName);
					if (!Obj || !Obj->Enabled)	/* Gone or disabled */
					{	STATION_INFO_S *Station = FindStationCall(OldName,CALLSIGN);
						if (Station) Station->isKilled = TRUE;
					}
					InvalidateCircle(NULL, TRUE, TRUE);
				}
			}
#else
			if (id >= ID_DYNAMIC_BASE && id < ID_DYNAMIC_BASE+cInfo->MenuCount)
			{	unsigned int mi = id - ID_DYNAMIC_BASE;
				if (mi < cInfo->MenuCount
				&& cInfo->MenuItems[mi].Active)
				{	UINT index = cInfo->MenuItems[mi].Index;
				switch (cInfo->MenuItems[mi].BaseID)
				{
				case ID_CONFIGURE_BEACON_MICE_NONE:
					if (index>=0 && index<ActiveConfig.MicEs.Count)
					{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[index];
						if (index != 1			/* Non-emergency doesn't warn */
						|| MessageBox(hwnd, TEXT("Really Transmit EMERGENCY Notification?"), TEXT("Mic-E Notification"), MB_YESNO | MB_ICONQUESTION) == IDYES)
						{	strncpy(ActiveConfig.Beacon.MicETag, Action->Tag, sizeof(ActiveConfig.Beacon.MicETag));
							if (MyStation) MyStation->MicEIndex = index;
							InvalidateCircle(NULL, TRUE, TRUE);
							ForceTransmit = TRUE;
						}
					}
					break;

				case ID_CONFIGURE_MICE_NOTIF_SUPPRESSED:
					if (index>=0 && index<ActiveConfig.MicEs.Count)
					{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[index];
						if (!Action->Enabled	/* Always allowed to enable */
						|| index != 1			/* Non-emergency doesn't warn */
						|| MessageBox(hwnd, TEXT("Really Disable EMERGENCY Notifications?"), TEXT("Mic-E Notifications"), MB_YESNO | MB_ICONQUESTION) == IDYES)
						Action->Enabled = !Action->Enabled;
						InvalidateCircle(NULL, TRUE, TRUE);
					}
					break;

				case ID_CLEAR_MICE_IGNORES:
					if (index>=0 && index<ActiveConfig.MicEs.Count)
					{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[index];
						if (Action->Ignores.Count)
						{	EmptyTimedStringList(&Action->Ignores);
							SaveConfiguration(cInfo->hwnd, &ActiveConfig, "Ignore Mic-E");
						}
					}
					break;

				case ID_CONFIGURE_DX_IGNORE_NONE:
					if (index>=0 && index<ActiveConfig.DX.Excluded.Count)
					{	DeleteIgnoreString(cInfo->hwnd, &ActiveConfig.DX.Excluded,
											ActiveConfig.DX.Excluded.Entries[index].string);
					}
					break;

#ifdef FUTURE
#define ID_ALIASES_KNOWN_NEW			40040
#define ID_ALIASES_POSSIBLE_CLEAR		40042
#define ID_ALIASES_0_CLEAR				40043
#endif

				case ID_ALIASES_KNOWN_NEW:
					if (index>=0 && index<ActiveConfig.PathAliases.Count)
					{	size_t Size = sizeof(TCHAR)*(strlen(ActiveConfig.PathAliases.Entries[index].string)+80);
						TCHAR *Buffer = (TCHAR*) malloc(Size);
						StringCbPrintf(Buffer, Size, TEXT("Really %S Alias %S?"),
										ActiveConfig.PathAliases.Entries[index].value?"Enable":"Disable",
										ActiveConfig.PathAliases.Entries[index].string);
						if (MessageBox(hwnd, Buffer, TEXT("Known Alias"), MB_YESNO | MB_ICONQUESTION) == IDYES)
						{	ActiveConfig.PathAliases.Entries[index].value = !ActiveConfig.PathAliases.Entries[index].value;
						}
					}
					break;

#ifndef UNDER_CE
				case ID_ALIASES_POSSIBLE_CLEAR:
					if (index>=0 && index<ActiveConfig.NewAliases.Count)
					{	size_t Size = sizeof(TCHAR)*(strlen(ActiveConfig.NewAliases.Entries[index].string)+80);
						TCHAR *Buffer = (TCHAR*) malloc(Size);
						StringCbPrintf(Buffer, Size, TEXT("Convert %S to Known Alias?"), ActiveConfig.NewAliases.Entries[index].string);
						if (MessageBox(hwnd, Buffer, TEXT("Possible Alias"), MB_YESNO | MB_ICONQUESTION) == IDYES)
						{	DefineIgnoreString(cInfo->hwnd, &ActiveConfig.PathAliases,
												ActiveConfig.NewAliases.Entries[index].string);
							DeleteIgnoreString(cInfo->hwnd, &ActiveConfig.NewAliases,
												ActiveConfig.NewAliases.Entries[index].string);
						}
					}
					break;

				case ID_ALIASES_0_CLEAR:
					if (index>=0 && index<ActiveConfig.ZeroAliases.Count)
					{	size_t Size = sizeof(TCHAR)*(strlen(ActiveConfig.ZeroAliases.Entries[index].string)+80);
						TCHAR *Buffer = (TCHAR*) malloc(Size);
						StringCbPrintf(Buffer, Size, TEXT("Really Forget:\n%S"), ActiveConfig.ZeroAliases.Entries[index].string);
						if (MessageBox(hwnd, Buffer, TEXT("Unused-0 Alias"), MB_YESNO | MB_ICONQUESTION) == IDYES)
							DeleteIgnoreString(cInfo->hwnd, &ActiveConfig.ZeroAliases,
												ActiveConfig.ZeroAliases.Entries[index].string);
					}
					break;
#endif

				case ID_COMPANIONS_NEW:
					if (index>=0 && index<ActiveConfig.Companions.Count)
					{	COMPANION_INFO_S *Obj = &ActiveConfig.Companions.Companion[index];
						char OldName[sizeof(Obj->Name)];
						strncpy(OldName, Obj->Name, sizeof(OldName));
						Obj = PromptConfigCompanion(hwnd, &ActiveConfig, index);
						TransmitCompanions();
#ifdef FUTURE
						if (Obj && Obj->Enabled)
						{	TransmitObject(Obj);
						}
						Obj = FindConfigCompanion(&ActiveConfig, OldName);
						if (!Obj || !Obj->Enabled)	/* Gone or disabled */
						{	STATION_INFO_S *Station = FindStationCall(OldName,CALLSIGN);
							if (Station) Station->isKilled = TRUE;
						}
						InvalidateCircle(NULL, TRUE, TRUE);
#endif
					}
					break;

				case ID_OBJECTS_NEW:
					if (index>=0 && index<ActiveConfig.Objects.Count)
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[index];
						char OldName[sizeof(Obj->Name)];
						strncpy(OldName, Obj->Name, sizeof(OldName));
						Obj = PromptConfigObject(hwnd, &ActiveConfig, index);
						if (Obj && Obj->Enabled)
						{	TransmitObject(Obj);
						}
						Obj = FindConfigObject(&ActiveConfig, OldName);
						if (!Obj || !Obj->Enabled)	/* Gone or disabled */
						{	STATION_INFO_S *Station = FindStationCall(OldName,CALLSIGN);
							if (Station) Station->isKilled = TRUE;
						}
						InvalidateCircle(NULL, TRUE, TRUE);
					}
					break;
				case ID_OBJECT_GROUP_ENABLE:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					BOOL DidOne = FALSE;
					unsigned long p;

					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						if (Obj->Enabled)
						{	DidOne = TRUE;
							Obj->Enabled = FALSE;
						}
					}
					if (!DidOne)
					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						Obj->Enabled = TRUE;
						memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					}
					SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:Enable");
				}
				break;
				case ID_OBJECT_GROUP_KILL:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					BOOL DidOne = FALSE;
					unsigned long p;

					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						if (Obj->Kill) DidOne = TRUE;
						Obj->KillXmitCount = 0;
						Obj->Kill = FALSE;
					}
					if (!DidOne)
					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						Obj->Kill = TRUE;
						memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					}
					SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:Kill");
				}
				break;
				case ID_OBJECT_GROUP_VIA_RF:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					BOOL DidOne = FALSE;
					unsigned long p;

					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						if (Obj->RFEnabled) DidOne = TRUE;
						Obj->RFEnabled = FALSE;
					}
					if (!DidOne)
					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						Obj->RFEnabled = TRUE;
						memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					}
					SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:ViaRF");
				}
				break;
				case ID_OBJECT_GROUP_VIA_IS:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					BOOL DidOne = FALSE;
					unsigned long p;

					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						if (Obj->ISEnabled) DidOne = TRUE;
						Obj->ISEnabled = FALSE;
					}
					if (!DidOne)
					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						Obj->ISEnabled = TRUE;
						memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					}
					SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:ViaIS");
				}
				break;
				case ID_OBJECT_GROUP_INTERVAL:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					unsigned long p;
					unsigned long interval = NumberPrompt(hwnd, "Group Interval", "Object Interval", "Mins", "Object.Interval", Grp->Interval);

					for (p=0; p<ActiveConfig.Objects.Count; p++)
					if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
					{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
						Obj->Interval = interval;
						memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
					}
					SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:Interval");
				}
				break;
				case ID_OBJECT_GROUP_PATH:
				if (index>=0 && index<ActiveConfig.Objects.Count)
				{	OBJECT_CONFIG_INFO_S *Grp = &ActiveConfig.Objects.Obj[index];
					char *New = StringPromptA(hwnd, "Object RF Path", "Enter Path", sizeof(Grp->RFPath)-1, Grp->RFPath, TRUE, FALSE);

					if (New)
					{	unsigned long p;
						for (p=0; p<ActiveConfig.Objects.Count; p++)
						if (!strcmp(Grp->Group, ActiveConfig.Objects.Obj[p].Group))
						{	OBJECT_CONFIG_INFO_S *Obj = &ActiveConfig.Objects.Obj[p];
							strncpy(Obj->RFPath, New, sizeof(Obj->RFPath));
							memset(&Obj->LastTransmit, 0, sizeof(Obj->LastTransmit));
						}
						SaveConfiguration(hwnd, &ActiveConfig, "ObjGroup:RFPath");
						free(New);
					}
				}
				break;

#ifdef ID_TRACK_COLOR_SELECT
				case ID_TRACK_COLOR_SELECT:
				if (index>=0 && index<ActiveConfig.TrackColors.Count)
				{	ActiveConfig.TrackColors.Entries[index].value =
							!ActiveConfig.TrackColors.Entries[index].value;
					InvalidateCircle(NULL, TRUE, TRUE);
					unsigned long p;
					unsigned long c=0;
					char *color = NULL;
					STRING_LIST_S *pList = &ActiveConfig.TrackColors;
					for (p=0; p<pList->Count; p++)
					if (pList->Entries[p].value)
					{	c++;
						color = pList->Entries[p].string;
					}
					if (c==1)
					{	strncpy(ActiveConfig.Screen.Track.Other.Color,
								color,
								sizeof(ActiveConfig.Screen.Track.Other.Color));
						ActiveConfig.Screen.Track.Other.RGB = GetColorRGB(&ActiveConfig, color, "Menu:Other:Color");
					} else if (c>1)
						memset(ActiveConfig.Screen.Track.Other.Color, 0,
								sizeof(ActiveConfig.Screen.Track.Other.Color));
				}
				break;
#endif

				default:
					TraceLogThread("Menu", TRUE, "Unrecognized Menu[%ld] Base[%ld]\n", (long) mi, (long) cInfo->MenuItems[mi].BaseID);
				}
				}
			}
#endif
			if (id > ID_CONFIGURE_NEW_TILE_SERVER && id <= ID_CONFIGURE_NEW_TILE_SERVER+ActiveConfig.TileServers.Count)
			{	id -= ID_CONFIGURE_NEW_TILE_SERVER+1;
				if (id>=0 && id<ActiveConfig.TileServers.Count)
				{	if (PromptConfigTileServer(hwnd, &ActiveConfig, id))
					{	cInfo->tsInfo = ActiveConfig.OSM = ActiveConfig.TileServers.Server[id];
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
				}
			}

			if (id > ID_SELECT_TILE_SERVER && id <= ID_SELECT_TILE_SERVER+ActiveConfig.TileServers.Count)
			{	id -= ID_SELECT_TILE_SERVER+1;
				if (id>=0 && id<ActiveConfig.TileServers.Count)
				{	if (VerifyOSMPath(hwnd, &ActiveConfig.TileServers.Server[id], FALSE, NULL))
					{	cInfo->tsInfo = ActiveConfig.TileServers.Server[id];
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
				}
			}

			if (id > ID_CONFIGURE_BEACON_COMMENT_NONE && id <= ID_CONFIGURE_BEACON_COMMENT_NONE+ActiveConfig.CommentChoices.Count)
			{	id -= ID_CONFIGURE_BEACON_COMMENT_NONE+1;
				if (id>=0 && id<ActiveConfig.CommentChoices.Count)
				{
#ifdef USE_TIMED_STRINGS
					char *String = ActiveConfig.CommentChoices.Entries[id].string;
#else
					char *String = ActiveConfig.CommentChoices.Strings[id];
#endif
					if (!ActiveConfig.Beacon.Comment
					|| strncmp(COMMENT, String, sizeof(COMMENT)))
					{	strncpy(COMMENT, String, sizeof(COMMENT));
						if (MyStation)
							UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
						ActiveConfig.Beacon.Comment = TRUE;
						ForceTransmit = TRUE;
					} else
					{	size_t Remaining = (sizeof(COMMENT)+80)*sizeof(TCHAR);
						TCHAR *Buffer = (TCHAR*) malloc(Remaining);
						BUTTONS_S *Buttons = CreateButtons(-1);
						AddButton(Buttons, "Edit", IDRETRY);
						AddButton(Buttons, "Delete", IDNO);
						AddButton(Buttons, "Accept", IDYES);
						StringCbPrintf(Buffer, Remaining, TEXT("%S"), COMMENT);
						switch (LwdMessageBox2(hwnd, Buffer, TEXT("Beacon Comment"), MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON3, Buttons))
						{
						case IDRETRY:
						{	char *New = StringPromptA(hwnd, "Beacon Comment", "Enter Comment", sizeof(COMMENT)-1, COMMENT, FALSE, FALSE);
							if (New)
							{	if (strncmp(COMMENT, New, sizeof(COMMENT)))
								{	strncpy(COMMENT, New, sizeof(COMMENT));
									ActiveConfig.Beacon.Comment = TRUE;
									ForceTransmit = TRUE;
									if (MyStation)
										UTF8Save(&MyStation->sComment, &MyStation->pComment, COMMENT HERE);
									UpdateTimedStringEntryAt(&ActiveConfig.CommentChoices, id, New);
									RememberCommentChoice(hwnd, &ActiveConfig, New);
									SaveConfiguration(hwnd, &ActiveConfig, "CommentChoice");
								}
								free(New);
							}
							break;
						}
						case IDNO:
							ActiveConfig.Beacon.Comment = FALSE;	/* No longer transmitting */
							RemoveTimedStringEntry(&ActiveConfig.CommentChoices, id);
							ForceTransmit = TRUE;
							break;
						}
						free(Buffer);
					}
				}
			}

			if (id > ID_CONFIGURE_SYMBOL_NEW && id <= ID_CONFIGURE_SYMBOL_NEW+ActiveConfig.SymbolChoices.Count)
			{	id -= ID_CONFIGURE_SYMBOL_NEW+1;
				if (id>=0 && id<ActiveConfig.SymbolChoices.Count)
				{
#ifdef USE_TIMED_STRINGS
					char *String = ActiveConfig.SymbolChoices.Entries[id].string;
#else
					char *String = ActiveConfig.SymbolChoices.Strings[id];
#endif
					if (ActiveConfig.Symbol.Table != String[0]
					|| ActiveConfig.Symbol.Symbol != String[1])
					{	ActiveConfig.Symbol.Table = String[0];
						ActiveConfig.Symbol.Symbol = String[1];
						ActiveConfig.Beacon.Comment = TRUE;
						ForceTransmit = TRUE;
						if (MyStation)
						{	char Symbol[2] = { SYMBOL };
							MyStation->isymbol = SymbolInt(Symbol[0], Symbol[1]);
							if (MyStation->Nickname
							&& !MyStation->Nickname->OverrideSymbol)
							{	MyStation->Nickname->Symbol.Table = Symbol[0];
								MyStation->Nickname->Symbol.Table = Symbol[1];
								SetNicknameSymbol(&ActiveConfig, MyStation->Station, &MyStation->Nickname->Symbol);
							}
							InvalidateCircle(hwnd, TRUE, TRUE);
						}
					}
				}
			}

			if (id > ID_CONFIGURE_NICKNAME_NEW && id <= ID_CONFIGURE_NICKNAME_NEW+ActiveConfig.Nicknames.Count)
			{	id -= ID_CONFIGURE_NICKNAME_NEW+1;
				char *Changed = PromptConfigNickname(hwnd, &ActiveConfig, ActiveConfig.Nicknames.Nick[id].Station);
				if (Changed)
				{	FixNicknames(Changed);
					InvalidateCircle(NULL, TRUE, TRUE);
				}
			}

			if (id > ID_CONFIGURE_ALTNET_NEW && id <= ID_CONFIGURE_ALTNET_NEW+ActiveConfig.AltNetChoices.Count)
			{	id -= ID_CONFIGURE_ALTNET_NEW+1;
				if (id>=0 && id<ActiveConfig.AltNetChoices.Count)
				{	TIMED_STRING_LIST_S *pList = &ActiveConfig.AltNetChoices;
					char *String = pList->Entries[id].string;
					if (_strnicmp(ActiveConfig.AltNet, String, sizeof(ActiveConfig.AltNet)))
					{	strncpy(ActiveConfig.AltNet, String, sizeof(ActiveConfig.AltNet));
						ForceTransmit = TRUE;
						InvalidateCircle(hwnd, TRUE, TRUE);
						if (!pList->Entries[id].value)
						{	RememberAltNetChoice(hwnd, &ActiveConfig, String, TRUE);	/* Mark it used */
							SaveConfiguration(hwnd, &ActiveConfig, "AltNetChoice");
						}
					}
				}
			}

			if (id > ID_CONFIGURE_NWS_NEW_OFFICE && id <= ID_CONFIGURE_NWS_NEW_OFFICE+ActiveConfig.NWS.Offices.Count)
			{	id -= ID_CONFIGURE_NWS_NEW_OFFICE+1;
				STRING_LIST_S *pList = &ActiveConfig.NWS.Offices;
#ifdef OLD_WAY
#ifdef USE_TIMED_STRINGS
				char *String = strdup(pList->Entries[id].string);
#else
				char *String = strdup(pList->Strings[id]);
#endif
				size_t Len = strlen(String);
				BOOL Active = (Len==1) || String[Len-1]!='*';
				if (!Active) String[Len-1] = '\0';	/* Wipe out star */
				if (RememberNWSOffice(hwnd, &ActiveConfig, String, !Active))
					SaveConfiguration(hwnd, &ActiveConfig, "NWSOffice");
				TransmitFilter();
				free(String);
#else
				if (!pList->Entries[id].value	/* Newly disabled, ask if deleting or disable */
				&& MessageBox(hwnd, TEXT("Remove NWS Office From List?"), TEXT("NWS Offices"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				{	RemoveTimedStringEntry(pList, id);
				} else	/* Otherwise, just toggle the disable bit */
				{	RememberNWSOffice(hwnd, &ActiveConfig, pList->Entries[id].string, !pList->Entries[id].value);
				}
				SaveConfiguration(hwnd, &ActiveConfig, "NWSOffice:Enable");
				TransmitFilter();
#endif
			}

			if (id >= ID_CONFIGURE_NWS_ENTRY_SERVER && id < ID_CONFIGURE_NWS_ENTRY_SERVER+ActiveConfig.NWSServers.Count)
			{	id -= ID_CONFIGURE_NWS_ENTRY_SERVER;	/* NOT +1! */
				ActiveConfig.NWSServers.Srv[id].Disabled = !ActiveConfig.NWSServers.Srv[id].Disabled;
				SaveConfiguration(hwnd, &ActiveConfig, "NWSServer");
				TransmitFilter();
			}

			if (id >= ID_CONFIGURE_MULTILINE_STYLE && id < ID_CONFIGURE_MULTILINE_STYLE+ActiveConfig.NWSProducts.Count)
			{	id -= ID_CONFIGURE_MULTILINE_STYLE;	/* NOT +1! */
				MULTILINE_STYLE_S *Style = &ActiveConfig.LineStyles.Style[id];
				Style->ActionEnabled = !Style->ActionEnabled;

				size_t Remaining = 80+ActiveConfig.NWSProducts.Count*(sizeof(ActiveConfig.NWSProducts.Prod->PID)+sizeof(ActiveConfig.NWSProducts.Prod->Desc));
				TCHAR *Message = (TCHAR*)malloc(Remaining);
				TCHAR *Next = Message;
				int Count = 0;

				StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
							TEXT("%S Notifications for the following NWS Products:\n"), Style->ActionEnabled?"Enable":"Disable");
				for (unsigned long x=0; x<ActiveConfig.NWSProducts.Count; x++)
				{	NWS_PRODUCT_S *Prod = &ActiveConfig.NWSProducts.Prod[x];
					if (Prod->LineType == *Style->sLineType
					&& Prod->ActionEnabled != Style->ActionEnabled)
					{	StringCbPrintfEx(Next, Remaining, &Next, &Remaining, STRSAFE_IGNORE_NULLS,
										TEXT("\n%S %S"), Prod->PID, Prod->Desc);
						Count++;
					}
				}
				if (Count)
				{	if (MessageBox(hwnd, Message, TEXT("NWS Products"), MB_YESNO | MB_ICONQUESTION) == IDYES)
					{	for (unsigned long x=0; x<ActiveConfig.NWSProducts.Count; x++)
						{	NWS_PRODUCT_S *Prod = &ActiveConfig.NWSProducts.Prod[x];
							if (Prod->LineType == *Style->sLineType)
								Prod->ActionEnabled = Style->ActionEnabled;
						}
					}
				}
				SaveConfiguration(hwnd, &ActiveConfig, "MultiLineStyle");
			}

			if (id > ID_CONFIGURE_NWS_PRODUCTS && id <= ID_CONFIGURE_NWS_PRODUCTS+ActiveConfig.NWSProducts.Count)
			{	id -= ID_CONFIGURE_NWS_PRODUCTS+1;
				ActiveConfig.NWSProducts.Prod[id].ActionEnabled = !ActiveConfig.NWSProducts.Prod[id].ActionEnabled;
				SaveConfiguration(hwnd, &ActiveConfig, "NWSProduct");
			}

#ifdef SUPPORT_SHAPEFILES
			if (id > ID_CONFIGURE_NWS_NEW_SHAPEFILE && id <= ID_CONFIGURE_NWS_NEW_SHAPEFILE+ActiveConfig.NWS.ShapeFiles.Count)
			{	id -= ID_CONFIGURE_NWS_NEW_SHAPEFILE+1;
				TIMED_STRING_LIST_S *pList = &ActiveConfig.NWS.ShapeFiles;
				if (!pList->Entries[id].value	/* Newly disabled, ask if deleting or disable */
				&& MessageBox(hwnd, TEXT("Remove Shapefile From List?"), TEXT("NWS Shapes"), MB_YESNO | MB_ICONQUESTION) == IDYES)
				{	FlushShapeIndexes(pList->Entries[id].string);
					RemoveTimedStringEntry(pList, id);
				} else	/* Otherwise, just toggle the disable bit */
				{	RememberNWSShapeFile(hwnd, &ActiveConfig, pList->Entries[id].string, !pList->Entries[id].value);
					if (pList->Entries[id].value)	/* Disabled? */
						FlushShapeIndexes(pList->Entries[id].string);
				}
				SaveConfiguration(hwnd, &ActiveConfig, "NWSShape:Enable");
			}
#endif

			if (id > ID_CONFIGURE_GPX_NEW && id <= ID_CONFIGURE_GPX_NEW+ActiveConfig.Overlays.Count)
			{	id -= ID_CONFIGURE_GPX_NEW+1;
				OVERLAY_CONFIG_INFO_S *pOver = &ActiveConfig.Overlays.Overlay[id];
				PromptOverlayConfig(hwnd, WM_REFRESH_CIRCLE, pOver, FALSE);
			}

			if (id > ID_CONFIGURE_AUTO_REPLY_NEW && id <= ID_CONFIGURE_AUTO_REPLY_NEW+ActiveConfig.Messaging.AutoAnswer.ReplyChoices.Count)
			{	id -= ID_CONFIGURE_AUTO_REPLY_NEW+1;
				if (id>=0 && id<ActiveConfig.Messaging.AutoAnswer.ReplyChoices.Count)
				{
#ifdef USE_TIMED_STRINGS
					char *This = ActiveConfig.Messaging.AutoAnswer.ReplyChoices.Entries[id].string;
#else
					char *This = ActiveConfig.Messaging.AutoAnswer.ReplyChoices.Strings[id];
#endif
					if (_strnicmp(ActiveConfig.Messaging.AutoAnswer.Reply, This, sizeof(ActiveConfig.Messaging.AutoAnswer.Reply)))
					{	strncpy(ActiveConfig.Messaging.AutoAnswer.Reply, This, sizeof(ActiveConfig.Messaging.AutoAnswer.Reply));
						RememberAutoAnswerChoice(hwnd, &ActiveConfig, This);	/* Mark it used */
						PurgeAutoAnswerStations(hwnd, &ActiveConfig);	/* We haven't sent this to anyone */
						SaveConfiguration(hwnd, &ActiveConfig, "AutoAnswerChoice");
					}
				}
			}
			if (id > ID_CONFIGURE_STATUS_TEXT_NONE && id <= ID_CONFIGURE_STATUS_TEXT_NONE+ActiveConfig.Status.Choices.Count)
			{	id -= ID_CONFIGURE_STATUS_TEXT_NONE+1;
				if (id>=0 && id<ActiveConfig.Status.Choices.Count)
				{
#ifdef USE_TIMED_STRINGS
					char *String = ActiveConfig.Status.Choices.Entries[id].string;
#else
					char *String = ActiveConfig.Status.Choices.Strings[id];
#endif
					if (!ActiveConfig.Status.Enabled
					|| strncmp(ActiveConfig.Status.Text, String, sizeof(ActiveConfig.Status.Text)))
					{	strncpy(ActiveConfig.Status.Text, String, sizeof(ActiveConfig.Status.Text));
						ActiveConfig.Status.Enabled = TRUE;
						TransmitStatusReport(TRUE);
					}
				}
			}
		}
		}
		break;
	}
    case WM_KEYDOWN:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		int RepeatCount = LOWORD(lp);
		if (RepeatCount <= 0) RepeatCount = 1;
		MarkActivity();

        // Allow Ctrl+Q to quit the application. Most users won't ever see
        // this, but it's handy for debugging.
		if (GetKeyState(VK_CONTROL) < 0)
		switch (wp)
		{
//		case 'Q':
		case 'X':
            SendMessage(hwnd, WM_CLOSE, 0, 0);
			break;
		case VK_LEFT:	PanCircle(cInfo, 10*RepeatCount, 0); break;
		case VK_RIGHT:	PanCircle(cInfo, -10*RepeatCount, 0); break;
		case VK_UP:		PanCircle(cInfo, 0, 10*RepeatCount); break;
		case VK_DOWN:	PanCircle(cInfo, 0, -10*RepeatCount); break;
		}
		else switch (wp)
		{
		case VK_NEXT:	/* Page down */
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);
			break;
		case VK_PRIOR:	/* Page up */
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);
			break;
		case VK_LEFT:
			PostMessage(hwnd, WM_COMMAND, ID_FADE_OUT, 0);
			break;
		case VK_RIGHT:
			PostMessage(hwnd, WM_COMMAND, ID_FADE_IN, 0);
			break;
		case VK_UP:
		case VK_DOWN:
		{	int Which = 0;
			if (ActiveConfig.View.ZoomReverse)
			{	if (wp == VK_UP) Which = ID_ZOOM_IN;
				if (wp == VK_DOWN) Which = ID_ZOOM_OUT;
			} else
			{	if (wp == VK_UP) Which = ID_ZOOM_OUT;
				if (wp == VK_DOWN) Which = ID_ZOOM_IN;
			}
			PostMessage(hwnd, WM_COMMAND, Which, 0);
	        break;
		}
		}
		break;
	}
	case WM_CHAR:

		MarkActivity();

		switch (wp)
		{
		case 7:	/* Ctrl-G - Gate filter test */
		{	char *New = StringPromptA(hwnd, "Test Filter", "Enter Filter", 512, TestFilter.FilterText?TestFilter.FilterText:ActiveConfig.IStoRFFilter[0]?ActiveConfig.IStoRFFilter:"", FALSE, TRUE);
			if (New)
			{	if (CheckOptimizedFilter(New, &TestFilter))
				{	DisplayTrace("FilterTest", SW_SHOW, TRUE);
					TraceLog("FilterTest", TRUE, hwnd, "New Filter(%s)\n", New);
				}
				free(New);
			} else
			{	if (IsTraceLogEnabled("FilterTest")
				|| (TestFilter.FilterText && *TestFilter.FilterText))
					DisplayTrace("FilterTest", SW_SHOW, TRUE);
			}
			break;
		}
		case 9:	/* Ctrl-I - IGate filter */
		if (ActiveConfig.Update.Development
		&& ActiveConfig.APRSIS.IStoRFEnabled
		&& IGateEnabled
		&& !IGateReceiveOnly
		&& TestFilter.FilterText
		&& *TestFilter.FilterText
		&& !TestFilter.HasErrors
		&& IsTraceLogEnabled("FilterTest"))
		{	size_t Len = sizeof(TCHAR)*(strlen(TestFilter.FilterText)+80);
			TCHAR *Text = (TCHAR*)malloc(Len);
			StringCbPrintf(Text, Len, TEXT("Set IGate Filter To:\n\n%S\n"), TestFilter.FilterText);
			if (MessageBox(hwnd, Text, TEXT("IGate Filter"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	if (CheckOptimizedFilter(TestFilter.FilterText, &IStoRFFilter))
				{	DisplayTrace("IGate(Filter)", SW_SHOW, TRUE);
					TraceLog("IGate(Filter)", TRUE, hwnd, "New Filter(%s)\n", IStoRFFilter.FilterText);
					strncpy(ActiveConfig.IStoRFFilter, TestFilter.FilterText, sizeof(ActiveConfig.IStoRFFilter));

					if (IGateEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet)
					{	SYSTEMTIME stSystem;
						GetSystemTime(&stSystem);
						char *Temp = (char *) malloc(strlen(IStoRFFilter.FilterText)+80);
						int Len = sprintf(Temp,"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld ISFltr:%s:[%ld]%s",
											(long) stSystem.wYear, 
											(long) stSystem.wMonth, 
											(long) stSystem.wDay, 
											(long) stSystem.wHour, 
											(long) stSystem.wMinute, 
											(long) stSystem.wSecond,
											CALLSIGN, (long) UDPSeq++,
											IStoRFFilter.FilterText);
						if (!tcp_send_udp("aprsisce.dnsalias.net", 3000, Len+1, Temp, 1))	/* Single shot */
							TraceActivity(hwnd, "UDPFailed %.*s\n", (int) Len, Temp);
						free(Temp);
					}
				}
			}
			free(Text);
		}
		break;
		case 12:	/* Ctrl-L - Log rotate */
			if (MessageBox(hwnd, TEXT("Really Rotate *.LOG Files?"), TEXT("Rotate Logs"), MB_YESNO | MB_ICONQUESTION) == IDYES)
			{	ClearTraceFile(hwnd);
				MessageBox(hwnd, TEXT("*.LOG Files Rotated"), TEXT("Rotate Logs"), MB_OK | MB_ICONINFORMATION);
			}
			break;
		case 15:	/* Ctrl-O - ORBITS */
#ifndef UNDER_CE
			if (ActiveConfig.Update.Development)
			{	Satellite(hwnd, WM_PORT_RECEIVED, RFPORT_INTERNAL, MyStation->Station, MyStation->pCoord->lat, MyStation->pCoord->lon, (long) pCloseStations[0]->alt);
			} else MessageBox(hwnd, TEXT("Satellite Forecasting Is Only Supported In Development Mode"), TEXT("Satellites"), MB_OK | MB_ICONWARNING);
#else
			MessageBox(hwnd, TEXT("Satellite Forecasting Is Only Available On APRSIS32"), TEXT("Satellites"), MB_OK | MB_ICONWARNING);
			break;
#endif
			break;
		case 16:	/* Ctrl-P */
		{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			if (cInfo)
			{	char *Packet = StringPromptA(hwnd, "Test Packet", "Enter Test APRS Packet", 1024, "", FALSE, FALSE);
				if (Packet)
				{	AprsLogInternalPacket("PacketTest", hwnd, Packet, TRUE);
				}
			}
			break;
		}
#ifdef SUPPORT_SHAPEFILES
		case 26:
		{	char *Code = StringPromptA(hwnd, "County/Zone", "Enter ShapeFile County/Zone", 16, "", FALSE, FALSE);
			if (Code)
			{	SHAPEFILE_OBJECT_S *Obj = GetShapeObject(Code);
				if (Obj)
				{	PopupTestShape(hwnd, Code);
					FreeShapeObject("Control-Z", Obj);
				} else MessageBox(hwnd, TEXT("Specified Code Not Found In Shapes"), TEXT("Zone Test"), MB_OK | MB_ICONERROR);
				free(Code);
			}
			break;
		}
#endif
		default:
			ProcessWmChar(hwnd, wp);
		}	/* End of WM_CHAR */
		break;

	case WM_RBUTTONUP:
		return DefWindowProc(hwnd, msg, wp, lp);

	case WM_CONTEXTMENU:
		if (lp == MAKELONG(-1,-1))
			return 0;	/* Can't handle non-mouse context menus (yet) */
    case WM_MOUSEWHEEL: 
	{	POINT pt;
		pt.x = LOWORD(lp); 
		pt.y = HIWORD(lp); 
		if (ScreenToClient(hwnd, &pt))
			lp = MAKELONG(pt.x,pt.y);
	}
	case WM_LBUTTONDOWN:
#if defined(USING_SHELL) || defined(CE50)
		if (msg == WM_LBUTTONDOWN)	// Avoid fall-throughs 
		{	SHRGINFO    shrg = {0};
			shrg.cbSize = sizeof(shrg);
			shrg.hwndClient = hwnd;
			shrg.ptDown.x = LOWORD(lp);
			shrg.ptDown.y = HIWORD(lp);
			shrg.dwFlags = SHRG_RETURNCMD /*| SHRG_NOANIMATION*/;
			if (SHRecognizeGesture(&shrg) == GN_CONTEXTMENU)
			{
				return 0;	/* I processed it */
			}
		}
#endif
	case WM_LBUTTONUP:
	case WM_LBUTTONDBLCLK:

	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:

	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:

		MarkActivity();

	case WM_MOUSEMOVE:	/* Not counted as activity */

	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo)
		{
			if (cInfo->Captured)
				cInfo->CaptureHandler(cInfo->ibCapture, hwnd, cInfo, NULL, msg, wp, lp);
			else if (msg != WM_MOUSEMOVE)
			{	int			r;
				POINT		pt;
				pt.x = LOWORD(lp); 
				pt.y = HIWORD(lp); 
	#ifdef SHOW_MOUSE_MESSAGES
	TraceError(hwnd, "Msg:%ld(%ld) @ %ld,%ld (Slider:%ld %ld x %ld %ld)\n",
				  (long) msg, (long) WM_MOUSEWHEEL, (long) pt.x, (long) pt.y,
				  (long) rcSlider.left, (long) rcSlider.top,
				  (long) rcSlider.right, (long) rcSlider.bottom);
	#endif
				for (r=ARRAYSIZE(rcs)-1; r>=0; r--)
				{	if (rcs[r].Handler)
					{	/* RECT rc = rcs[r].Tracker[cInfo->Index].rc*/;
						if (PtInRect(&rcs[r].Tracker[cInfo->Index].rc, pt))
						{	rcs[r].Handler(&rcs[r], hwnd, cInfo, NULL, msg, wp, lp);
							break;	/* Only "last" rectangle gets to handle it! */
						}
					}
				}
			}
		}
	}
	break;

#ifndef UNDER_CE
	case WM_MOVE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		WINDOWPLACEMENT wp;
		if (cInfo && !IsIconic(hwnd) && !IsZoomed(hwnd))
			GetWindowRect(hwnd, &cInfo->rcSize);
		GetWindowPlacement(hwnd, &wp);
		if (wp.showCmd == 1)
		{	SaveMainWindowRect(hwnd, &wp.rcNormalPosition);
		}
		TraceActivity(hwnd, "WM_MOVE:%ld %ld %ld -> %ld %ld (%ld x %ld)", wp.showCmd, (long) wp.rcNormalPosition.left, (long) wp.rcNormalPosition.top, (long) wp.rcNormalPosition.right, (long) wp.rcNormalPosition.bottom, (long) wp.rcNormalPosition.right-(long) wp.rcNormalPosition.left, (long) wp.rcNormalPosition.bottom-(long) wp.rcNormalPosition.top);

		MarkActivity();

		break;
	}
#endif

	case WM_SIZE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		long width = LOWORD(lp), height = HIWORD(lp);

		MarkActivity();

		if (cInfo)	/* If we haven't initialized, don't do this! */
		{	RECT rc;

#if MAX_TRACKERS > 1
#ifndef UNDER_CE
			if (cInfo && !IsIconic(hwnd) && !IsZoomed(hwnd))
				GetWindowRect(hwnd, &cInfo->rcSize);
#endif
#endif

			InvalidateStationPoints(cInfo->Index, "WM_SIZE", TRUE);	/* Need to calc points */
			SetNextCirclePaint(cInfo, 0, "WM_SIZE");

			cInfo->prevSize = cInfo->curSize;
			cInfo->curSize = wp;
	
			GetWindowRect(hwnd, &rc);
			TraceActivity(hwnd, "WM_SIZE: %ld x %ld from Window %ld %ld -> %ld %ld or %ld x %ld\n",
						(long) width, (long) height,
						rc.left, rc.top, rc.right, rc.bottom,
						rc.right - rc.left, rc.bottom - rc.top);
			GetClientRect(hwnd, &rc);
			TraceActivity(hwnd, "WM_SIZE: %ld x %ld from Client %ld %ld -> %ld %ld or %ld x %ld\n",
						(long) width, (long) height,
						rc.left, rc.top, rc.right, rc.bottom,
						rc.right - rc.left, rc.bottom - rc.top);

#ifndef UNDER_CE
			{	WINDOWPLACEMENT wp;
				GetWindowPlacement(hwnd, &wp);
				if (wp.showCmd == 1)
				{	SaveMainWindowRect(hwnd, &wp.rcNormalPosition);
				}
				TraceActivity(hwnd, "WM_SIZE:%ld %ld %ld -> %ld %ld (%ld x %ld)\n", wp.showCmd, (long) wp.rcNormalPosition.left, (long) wp.rcNormalPosition.top, (long) wp.rcNormalPosition.right, (long) wp.rcNormalPosition.bottom, (long) wp.rcNormalPosition.right-(long) wp.rcNormalPosition.left, (long) wp.rcNormalPosition.bottom-(long) wp.rcNormalPosition.top);
			}
#endif

			if (cInfo->Index)	/* Tracker windows are MUCH simpler */
			{	for (int r=0; r<ARRAYSIZE(rcs); r++)
					SetRectEmpty(&rcs[r].Tracker[cInfo->Index].rc);
				GetClientRect(hwnd, &rcCircle(cInfo->Index));
				rcCircle(cInfo->Index).top += cInfo->MenuOffset;
			} else
			{
			HDC hdc = GetDC(hwnd);

			SetRect(&rc, 0, 0, width, height);
			int theight = DrawText(hdc, MaxWidthStationID, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int mwidth = rc.right - rc.left + 2;

			int igdwidth = 0;
#ifndef UNDER_CE	/* CE replaces, not appends */
			if (ActiveConfig.Scroller.ShowIGateOrDigi)
			{	SetRect(&rc, 0, 0, width, height);
				DrawText(hdc, MaxWidthIGateID, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
				igdwidth = rc.right - rc.left + 2;
			}
#endif
			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT("1999.9"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int owidth = rc.right - rc.left + 2;
			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT("H 199999"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int awidth = rc.right - rc.left + 2;


			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT(" 23:59:59 "), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int dwidth = rc.right - rc.left;
			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT(" 2008/08/25 "), -1, &rc,DT_NOPREFIX |  DT_CALCRECT);
			if (rc.right-rc.left > dwidth) dwidth = rc.right-rc.left;

			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT(" 9999xx@999 "), -1, &rc,DT_NOPREFIX |  DT_CALCRECT);
			int destwidth = rc.right - rc.left;
			destwidth += 4;

			if (ActiveConfig.Screen.DateTimePerformance)
			{	SetRect(&rc, 0, 0, width, height);
				DrawText(hdc, TEXT(" 9999+99/9*99+99 "), -1, &rc,DT_NOPREFIX |  DT_CALCRECT);
				if (rc.right-rc.left > dwidth) dwidth = rc.right-rc.left;
			}
			dwidth += 4;

			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT("Fix(D)"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int fwidth = rc.right - rc.left + 4;
			SetRect(&rc, 0, 0, width, height);
			switch (ActiveConfig.Beacon.Precision)
			{case 2: DrawText(hdc, TEXT("WW00ww00ww"), -1, &rc, DT_NOPREFIX | DT_CALCRECT); break;
			 case 1: DrawText(hdc, TEXT("WW00ww00"), -1, &rc, DT_NOPREFIX | DT_CALCRECT); break;
			 case 0:
			 case -1:
			 case -2:
			 case -3:
			 case -4:
			 default: DrawText(hdc, TEXT("WW00ww"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			}
			int gwidth = rc.right - rc.left + 4;
			SetRect(&rc, 0, 0, width, height);
			{	TCHAR *LatLon = APRSLatLon(ActiveConfig.Center.Latitude, ActiveConfig.Center.Longitude, ' ', ' ', ActiveConfig.Beacon.Precision);
				DrawText(hdc, LatLon, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
				free(LatLon);
			}
			int lwidth = rc.right - rc.left + 4;

			HFONT hOld = (HFONT) 0, hFont = LoadPaintFont(TEXT("Tahoma Bold"), g_dwFontSize*3/2, FALSE);
			if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
			SetRect(&rc, 0, 0, width, height);
			int headheight = DrawText(hdc, TEXT("WSW"), -1, &rc, DT_NOPREFIX | DT_CALCRECT) * 5/4;
			int headwidth = rc.right - rc.left + 6;
			if (hOld != (HFONT) 0) SelectObject(hdc, hOld);

			hFont = LoadPaintFont(TEXT("7 Segment"), ActiveConfig.Screen.SpeedSize*g_dwFontSize, FALSE);
			if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
			else hOld = (HFONT) 0;
			SetRect(&rc, 0, 0, width, height);
			int speedheight = DrawText(hdc, MaxSpeedText, -1, &rc, DT_NOPREFIX | DT_CALCRECT) * 21/20;
			int speedwidth = rc.right - rc.left + 6;
			if (hOld != (HFONT) 0) SelectObject(hdc, hOld);

			hFont = LoadPaintFont(TEXT(""), g_dwFontSize*3/4, FALSE);
			if (hFont != NULL) hOld = (HFONT) SelectObject(hdc, hFont);
			else hOld = (HFONT) 0;
			SetRect(&rc, 0, 0, width, height);
			int satheight = DrawText(hdc, TEXT("1"), -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			if (hOld != (HFONT) 0) SelectObject(hdc, hOld);

			ReleaseDC(hwnd, hdc);

#ifdef POPUP
{	TCHAR Buffer[MAX_PATH];
	StringCbPrintf(Buffer, sizeof(Buffer), TEXT("%ldx%ld"), (long) width, (long) height);
	MessageBox(hwnd, Buffer, TEXT("WM_SIZE"), MB_OK | MB_ICONINFORMATION);
}
#endif

//TraceLog("Orientation", TRUE, hwnd, "WM_SIZE: Orientation(%ld)\n", cInfo->Orientation);
			if (cInfo->Orientation==1 ||	/* Portrait */
			(cInfo->Orientation==2 && height > width*2/3))
			{	long stwidth = mwidth + igdwidth + theight;
				long lrwidth = min(width/3,max(stwidth,speedwidth));
				long lrheight = min(max(theight*4,speedheight), height/5);
				long SpeedLeft = ActiveConfig.Screen.SpeedSize?width-speedwidth:width;
				long SpeedBottom = ActiveConfig.Screen.SpeedSize?max(speedheight,theight*2+4+9)+cInfo->MenuOffset:(theight*2+4+9)+cInfo->MenuOffset;
				long SatTop = height;	/* bottom of screen */
				long LatTop, AltTop, FixTop, TimeTop;
				long OdoBottom;

				SetRect(&rcBottomPanel(cInfo->Index), 0, height-width, width, height);

				SetRect(&rcStations(cInfo->Index), 0, cInfo->MenuOffset, stwidth, lrheight - lrheight%theight + theight + cInfo->MenuOffset);
				if (ActiveConfig.Screen.Show.Satellites && GPSEnabled)
				{	SetRect(&rcSatInView(cInfo->Index), 0, height-satheight, width, height);
					SetRect(&rcSatInUse(cInfo->Index), 0, rcSatInView(cInfo->Index).top-satheight, width, rcSatInView(cInfo->Index).top);
					SatTop = rcSatInUse(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcSatInView(cInfo->Index)); SetRectEmpty(&rcSatInUse(cInfo->Index));
				}

				if (ActiveConfig.Screen.Show.LatLon)
				{	SetRect(&rcLatLon(cInfo->Index), 0, SatTop-theight-2, lwidth, SatTop);
					LatTop = rcLatLon(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcLatLon(cInfo->Index));
					LatTop = SatTop;
				}

				if (ActiveConfig.Screen.Show.GridSquare)
				{	SetRect(&rcGridSquare(cInfo->Index), 0, LatTop-theight-2, gwidth, LatTop);
					LatTop = rcGridSquare(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcGridSquare(cInfo->Index));
				}

				if (GPSEnabled)
				{	if (ActiveConfig.Screen.SpeedSize)
						SetRect(&rcSpeed(cInfo->Index), width-speedwidth, cInfo->MenuOffset, width, speedheight + cInfo->MenuOffset);
					else SetRectEmpty(&rcSpeed(cInfo->Index));
					SetRect(&rcHeading(cInfo->Index), width-headwidth, SpeedBottom, width, rcHeading(cInfo->Index).top+headheight);
					SetRect(&rcHeading(cInfo->Index), width-headwidth, SpeedBottom, width, rcHeading(cInfo->Index).top+headheight);
					SetRect(&rcOdometer(cInfo->Index), width-owidth, rcHeading(cInfo->Index).bottom, width, rcOdometer(cInfo->Index).top+theight+2);
					SetRect(&rcOdometer(cInfo->Index), width-owidth, rcHeading(cInfo->Index).bottom, width, rcOdometer(cInfo->Index).top+theight+2);
					OdoBottom = rcOdometer(cInfo->Index).bottom;

					if (ActiveConfig.Screen.Show.Altitude)
					{	SetRect(&rcAltitude(cInfo->Index), 0, LatTop-theight-2, awidth, LatTop);
						AltTop = rcAltitude(cInfo->Index).top;
					} else
					{	SetRectEmpty(&rcAltitude(cInfo->Index));
						AltTop = LatTop;
					}

					SetRect(&rcAPRS(cInfo->Index), rcStations(cInfo->Index).right, cInfo->MenuOffset, SpeedLeft, theight*2+4+9+cInfo->MenuOffset);
				} else
				{	SetRectEmpty(&rcSpeed(cInfo->Index));
					SetRectEmpty(&rcHeading(cInfo->Index));
					SetRectEmpty(&rcAltitude(cInfo->Index));
					SetRect(&rcAPRS(cInfo->Index), rcStations(cInfo->Index).right, cInfo->MenuOffset, width, theight*2+4+9+cInfo->MenuOffset);
					if (Odometer)	/* non-zero? */
					{	SetRect(&rcOdometer(cInfo->Index), width-owidth, rcAPRS(cInfo->Index).bottom, width, rcOdometer(cInfo->Index).top+theight+2);
						SetRect(&rcOdometer(cInfo->Index), width-owidth, rcAPRS(cInfo->Index).bottom, width, rcOdometer(cInfo->Index).top+theight+2);
						OdoBottom = rcOdometer(cInfo->Index).bottom;
					} else
					{	SetRectEmpty(&rcOdometer(cInfo->Index));
						OdoBottom = rcAPRS(cInfo->Index).bottom;
					}
					AltTop = LatTop;
				}

				SetRect(&rcMessage(cInfo->Index), 0, rcStations(cInfo->Index).bottom, mwidth, rcMessage(cInfo->Index).top+theight*3/2);
				SetRect(&rcMessage(cInfo->Index), 0, rcStations(cInfo->Index).bottom, mwidth, rcMessage(cInfo->Index).top+theight*3/2);

				if (ActiveConfig.Screen.DateTimePerformance
				|| (ActiveConfig.Screen.DateTime
				&& (ActiveConfig.Screen.DateTime > 0 || GPSEnabled)))
				{	TimeTop = SatTop-theight-2;
					SetRect(&rcTime(cInfo->Index), width-dwidth, TimeTop, width, SatTop);
				} else
				{	TimeTop = SatTop;
					SetRectEmpty(&rcTime(cInfo->Index));
				}
				SetRect(&rcFix(cInfo->Index), width-fwidth, TimeTop-theight*3/2, width, TimeTop);
				FixTop = rcFix(cInfo->Index).top;
#ifndef UNDER_CE
				if (!HasNMEAPort())
				{	FixTop = rcFix(cInfo->Index).bottom;
					SetRectEmpty(&rcFix(cInfo->Index));
				}
#endif

				SetRect(&rcScale(cInfo->Index), 0, AltTop-theight*3/2, 40, AltTop);

				int ScrollWidth = GetSystemMetrics(SM_CXVSCROLL);
				int SliderWidth = max(15,ScrollWidth);
#define BAR_WIDTH (SliderWidth/2)
				int centcirc = (SatTop+rcAPRS(cInfo->Index).bottom)/2;
				if (rcMessage(cInfo->Index).bottom < centcirc-height/4
				&& rcScale(cInfo->Index).top > centcirc+height/4)
					SetRect(&rcSlider(cInfo->Index), 0, centcirc-height/4, SliderWidth, centcirc+height/4);
				else SetRect(&rcSlider(cInfo->Index), 0, max(rcMessage(cInfo->Index).bottom,rcScale(cInfo->Index).top-height/2), SliderWidth, rcScale(cInfo->Index).top);

				if (MyDestination.lat != 0
				|| MyDestination.lon != 0)
				{	int left = 0;
					if (rcMessage(cInfo->Index).bottom+theight+2 > rcSlider(cInfo->Index).top)
						left = rcSlider(cInfo->Index).right;
				SetRect(&rcDestination(cInfo->Index), left, rcMessage(cInfo->Index).bottom, left+destwidth, rcDestination(cInfo->Index).top+theight+2);
				SetRect(&rcDestination(cInfo->Index), left, rcMessage(cInfo->Index).bottom, left+destwidth, rcDestination(cInfo->Index).top+theight+2);
				} else SetRectEmpty(&rcDestination(cInfo->Index));

				if (ActiveConfig.Screen.Show.Battery)
				{	SetRect(&rcPower(cInfo->Index), width-BAR_WIDTH, OdoBottom, width, FixTop);
					SetRect(&rcStatUsage(cInfo->Index), width-BAR_WIDTH*2, OdoBottom, width-BAR_WIDTH, FixTop);
				} else
				{	SetRectEmpty(&rcPower(cInfo->Index));
					SetRect(&rcStatUsage(cInfo->Index), width-BAR_WIDTH, OdoBottom, width, FixTop);
				}
#undef BAR_WIDTH
				SetRect(&rcCircle(cInfo->Index), rcBottomPanel(cInfo->Index).left, rcAPRS(cInfo->Index).bottom, rcBottomPanel(cInfo->Index).right-5, SatTop);

				SetRectEmpty(&rcClear1(cInfo->Index));
				SetRectEmpty(&rcClear2(cInfo->Index));

			} else	/* height < width - Landscape */
			{	long delta = max(speedwidth, mwidth + igdwidth + theight*3/2);
				long SatTop = height;
				long SpeedBottom;
				long OdoBottom;
				long LatTop, AltTop, FixTop, TimeTop;

				SetRect(&rcBottomPanel(cInfo->Index), delta, cInfo->MenuOffset, width, height);

				if (ActiveConfig.Screen.Show.Satellites && GPSEnabled)
				{	SetRect(&rcSatInView(cInfo->Index), delta, height-satheight, width, height);
					SetRect(&rcSatInUse(cInfo->Index), delta, rcSatInView(cInfo->Index).top-satheight, width, rcSatInView(cInfo->Index).top);
					SatTop = rcSatInUse(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcSatInView(cInfo->Index)); SetRectEmpty(&rcSatInUse(cInfo->Index));
				}

				if (ActiveConfig.Screen.Show.LatLon)
				{	SetRect(&rcLatLon(cInfo->Index), delta, SatTop-theight-2, delta+lwidth, SatTop);
					LatTop = rcLatLon(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcLatLon(cInfo->Index));
					LatTop = SatTop;
				}

				if (ActiveConfig.Screen.Show.GridSquare)
				{	SetRect(&rcGridSquare(cInfo->Index), delta, LatTop-theight-2, delta+gwidth, LatTop);
					LatTop = rcGridSquare(cInfo->Index).top;
				} else
				{	SetRectEmpty(&rcGridSquare(cInfo->Index));
				}

				if (GPSEnabled)
				{	if (ActiveConfig.Screen.SpeedSize)
						SetRect(&rcSpeed(cInfo->Index), 0, cInfo->MenuOffset, delta, speedheight+cInfo->MenuOffset);
					else SetRectEmpty(&rcSpeed(cInfo->Index));
					SetRect(&rcHeading(cInfo->Index), delta, cInfo->MenuOffset, rcHeading(cInfo->Index).left+headwidth, rcHeading(cInfo->Index).top+headheight);
					SetRect(&rcHeading(cInfo->Index), delta, cInfo->MenuOffset, rcHeading(cInfo->Index).left+headwidth, rcHeading(cInfo->Index).top+headheight);
					SetRect(&rcOdometer(cInfo->Index), delta, rcHeading(cInfo->Index).bottom, delta+owidth, rcOdometer(cInfo->Index).top+theight+2);
					SetRect(&rcOdometer(cInfo->Index), delta, rcHeading(cInfo->Index).bottom, delta+owidth, rcOdometer(cInfo->Index).top+theight+2);

					if (ActiveConfig.Screen.Show.Altitude)
					{	SetRect(&rcAltitude(cInfo->Index), delta, LatTop-theight-2, delta+awidth, LatTop);
						AltTop = rcAltitude(cInfo->Index).top;
					} else
					{	SetRectEmpty(&rcAltitude(cInfo->Index));
						AltTop = LatTop;
					}
				
					SpeedBottom = ActiveConfig.Screen.SpeedSize?rcSpeed(cInfo->Index).bottom:cInfo->MenuOffset;
					OdoBottom = rcOdometer(cInfo->Index).bottom;
				} else
				{	SetRectEmpty(&rcSpeed(cInfo->Index));
					SetRectEmpty(&rcHeading(cInfo->Index));
					SetRectEmpty(&rcAltitude(cInfo->Index));
					SpeedBottom = cInfo->MenuOffset;
					AltTop = LatTop;
					if (Odometer)	/* non-zero? */
					{	SetRect(&rcOdometer(cInfo->Index), delta, cInfo->MenuOffset, delta+owidth, rcOdometer(cInfo->Index).top+theight+2+cInfo->MenuOffset);
						SetRect(&rcOdometer(cInfo->Index), delta, cInfo->MenuOffset, delta+owidth, rcOdometer(cInfo->Index).top+theight+2+cInfo->MenuOffset);
						OdoBottom = rcOdometer(cInfo->Index).bottom;
					} else
					{	SetRectEmpty(&rcOdometer(cInfo->Index));
						OdoBottom = 0;
					}
				}

				SetRect(&rcAPRS(cInfo->Index), 0, SpeedBottom, delta, rcAPRS(cInfo->Index).top+theight*2+4+9);
				SetRect(&rcAPRS(cInfo->Index), 0, SpeedBottom, delta, rcAPRS(cInfo->Index).top+theight*2+4+9);

				SetRect(&rcStations(cInfo->Index), 0, rcAPRS(cInfo->Index).bottom, delta, height);	/* Remainder of the height */

				SetRect(&rcMessage(cInfo->Index), width-mwidth, cInfo->MenuOffset, width, rcMessage(cInfo->Index).top+theight*3/2);
				SetRect(&rcMessage(cInfo->Index), width-mwidth, cInfo->MenuOffset, width, rcMessage(cInfo->Index).top+theight*3/2);

				if (ActiveConfig.Screen.DateTimePerformance
				|| (ActiveConfig.Screen.DateTime
				&& (ActiveConfig.Screen.DateTime > 0 || GPSEnabled)))
				{	TimeTop = SatTop-theight-2;
					SetRect(&rcTime(cInfo->Index), width-dwidth, TimeTop, width, SatTop);
				} else
				{	TimeTop = SatTop;
					SetRectEmpty(&rcTime(cInfo->Index));
				}
				SetRect(&rcFix(cInfo->Index), width-fwidth, TimeTop-theight*3/2, width, TimeTop);
				FixTop = rcFix(cInfo->Index).top;
#ifndef UNDER_CE
				if (!HasNMEAPort())
				{	FixTop = rcFix(cInfo->Index).bottom;
					SetRectEmpty(&rcFix(cInfo->Index));
				}
#endif

				SetRect(&rcScale(cInfo->Index), delta, AltTop-theight*3/2, delta+40, AltTop);

				int ScrollWidth = GetSystemMetrics(SM_CXVSCROLL);
				int SliderWidth = max(15,ScrollWidth);
#define BAR_WIDTH (SliderWidth/2)
				int centcirc = (SatTop+rcBottomPanel(cInfo->Index).top)/2;
				if (OdoBottom < centcirc-height/4
				&& rcScale(cInfo->Index).top > centcirc+height/4)
					SetRect(&rcSlider(cInfo->Index), delta, centcirc-height/4, delta+SliderWidth, centcirc+height/4);
				else SetRect(&rcSlider(cInfo->Index), delta, max(OdoBottom,rcScale(cInfo->Index).top-height/2), delta+SliderWidth, rcScale(cInfo->Index).top);

				if (ActiveConfig.Screen.Show.Battery)
				{	SetRect(&rcPower(cInfo->Index), width-BAR_WIDTH, rcMessage(cInfo->Index).bottom, width, FixTop);
					SetRect(&rcStatUsage(cInfo->Index), width-BAR_WIDTH*2, rcMessage(cInfo->Index).bottom, width-BAR_WIDTH, FixTop);
				} else
				{	SetRectEmpty(&rcPower(cInfo->Index));
					SetRect(&rcStatUsage(cInfo->Index), width-BAR_WIDTH, rcMessage(cInfo->Index).bottom, width, FixTop);
				}
#undef BAR_WIDTH

				if (MyDestination.lat != 0
				|| MyDestination.lon != 0)
				{	int right = width;
					if (rcMessage(cInfo->Index).bottom+theight+2 > rcStatUsage(cInfo->Index).top)
						right = rcStatUsage(cInfo->Index).left;
				SetRect(&rcDestination(cInfo->Index), right-destwidth, rcMessage(cInfo->Index).bottom, right, rcDestination(cInfo->Index).top+theight+2);
				SetRect(&rcDestination(cInfo->Index), right-destwidth, rcMessage(cInfo->Index).bottom, right, rcDestination(cInfo->Index).top+theight+2);
				} else SetRectEmpty(&rcDestination(cInfo->Index));

				SetRect(&rcCircle(cInfo->Index), rcBottomPanel(cInfo->Index).left, rcBottomPanel(cInfo->Index).top, rcBottomPanel(cInfo->Index).right-5, SatTop);

				SetRectEmpty(&rcClear1(cInfo->Index));
				SetRectEmpty(&rcClear2(cInfo->Index));
			}
			}

			TraceActivityBegin(hwnd, "WM_SIZE: %ld x %ld\n", (long) height, (long) width);
#define RECT(x,w) Trace##x(hwnd, "%s: %ld %ld -> %ld %ld (%ldx%ld)\n", \
				#w, rc##w(cInfo->Index).left, rc##w(cInfo->Index).top, \
				rc##w(cInfo->Index).right, rc##w(cInfo->Index).bottom, \
				rc##w(cInfo->Index).bottom-rc##w(cInfo->Index).top, \
				rc##w(cInfo->Index).right-rc##w(cInfo->Index).left);

			RECT(Activity,BottomPanel)
			RECT(Activity,Speed)
			RECT(Activity,Heading)
			RECT(Activity,Odometer)
			RECT(Activity,APRS)
			RECT(Activity,Stations)
			RECT(Activity,Message)
			RECT(Activity,Slider)
			RECT(Activity,SatInView)
			RECT(Activity,SatInUse)
			RECT(Activity,Scale)
			RECT(Activity,Altitude)
			RECT(Activity,Fix)
			RECT(Activity,Time)
			RECT(Activity,Power)
			RECT(Activity,StatUsage)
			RECT(ActivityEnd,Circle)
#undef RECT

#ifdef X_DO_OSM
			if (wp == SIZE_MAXIMIZED
//			|| wp == SIZE_MAXSHOW
			|| wp == SIZE_RESTORED)
				PostMessage(hwnd, WM_RELOAD_OSM, 0, 0);
#endif

			if (hwndFirstRun && !cInfo->Index)
			{	RECT rcMine = rcCircle(0);
				RECT rc = rcMine;
				TCHAR *Text = (TCHAR*) malloc(1024);
				GetWindowText(hwndFirstRun, Text, 1024/sizeof(TCHAR));
				HDC hdc = GetDC(hwnd);
				int theight = DrawText(hdc, Text, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
				int twidth = rc.right-rc.left;
				int cwidth = rcMine.right-rcMine.left;
				ReleaseDC(hwnd, hdc);
				SetWindowPos(hwndFirstRun, HWND_TOP,
							rcMine.left+(cwidth-twidth)/2, rcMine.bottom-theight,
							rcMine.left+twidth, rcMine.bottom, 0);
				free(Text);
			}
			cInfo->msLastSigChange = llGetMsec();
		} else TraceError(hwnd, "WM_SIZE: %ld x %ld NO CINFO!\n", (long) height, (long) width);

		break;
	}
	case WM_TIMER:
		if (OnMainWindowTimer(hwnd, wp))
		{	MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
			return TRUE;
		}
		break;

	case WM_AUTO_ZOOM:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo)
		{	//TraceLog("AutoZoom", TRUE, hwnd, "[%ld] WM_AUTO_ZOOM(%ld)\n", cInfo->Index, wp);
			AutoZoomMultiLine(hwnd,wp);
		}
		break;
	}

	case WM_PAINT:
		if (!PaintingDisabled)
			PaintMainWindow(hwnd);
		else
		{	PAINTSTRUCT ps;
			BeginPaint(hwnd, &ps);
			EndPaint(hwnd, &ps);
		}
		MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
		return 0;

#ifndef UNDER_CE
	case WM_ENDSESSION:
		TraceLog("Activity", TRUE, hwnd, "WM_ENDSESSION(%ld,0x%lX)\n", wp, lp);
		SaveAndClose(hwnd, "WM_ENDSESSION", TRUE);
		return 0;
#endif

	case WM_CLOSE:
		if (!SaveAndClose(hwnd, "WM_CLOSE", FALSE))
		{	MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
			return 0;
		}
		MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
		break;	/* Let the default window handler destroy the window */

	case WM_DESTROY:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

#ifdef USING_SHELL
		RemoveNotificationAll(cInfo);	/* Clean up our pending notifications */
#elif !defined(UNDER_CE)
		DestroyNotifyIcon(hwnd,1);
		DestroyNotifyIcon(hwnd,2);
#endif
#ifdef USING_COMM_MGR
		ConnMgrReleaseConnection(hConnection, 1);	/* Clean up the Connection Manager connection */
		hConnection = NULL;
#endif
#ifdef MONITOR_PHONE
		if (hNotifySignalStrength)
			RegistryCloseNotification(hNotifySignalStrength);
		if (hNotifyOperatorName)
			RegistryCloseNotification(hNotifyOperatorName);
		if (hNotifyCellBroadcast)
			RegistryCloseNotification(hNotifyCellBroadcast);
#endif
		FreePaintImage();
		FreePaintFont();

		TraceActivity(hwnd, "WM_DESTROY calling PostQuitMessage()\n");
		SetEvent(hExitProgram);
#ifdef DO_OSM
		if (cInfo->ts) OSMFreeTileSet(cInfo->ts);
		OSMFlushTileCache(0);
#endif

// When this window is destroyed, it's time to quit the application
        PostQuitMessage(0);
        break;
	}
    }

#ifdef USING_SHELL
	if (msg == g_uMsgMetricChange)
	{
		DWORD dwFontSize;

		// The UI metrics have changed. This is how we get notified when the
		// user changes their preferred font size (PPC only). We free our
		// cached font and save the new size for the next time we paint.
		if (SUCCEEDED(SHGetUIMetrics(SHUIM_FONTSIZE_PIXEL,
			&dwFontSize, sizeof(dwFontSize), NULL)) &&
			dwFontSize != g_dwFontSize)
		{
			g_dwFontSize = dwFontSize;
			FreePaintFont();
			InvalidateRect(hwnd, NULL, TRUE);
		}
	}
#endif

	MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);

    return DefWindowProc(hwnd, msg, wp, lp);
}

#if MAX_TRACKERS > 1
void PaintTrackerWindow(HWND hwnd)
{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

	PAINTSTRUCT ps;
	int			r;
	RECT        rcPaint;
	HRGN rgnPaint = CreateRectRgn(0,0,0,0);
	int rgnStat = GetUpdateRgn(hwnd, rgnPaint, FALSE);
	BOOL UseRect = (rgnStat==ERROR) || (rgnStat==SIMPLEREGION);
	HANDLE hProc = GetCurrentProcess();
#ifndef UNDER_CE
	DWORD cGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
	DWORD cUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
#endif
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;

// Start the paint operation
	if (!GetUpdateRect(hwnd, &rcPaint, FALSE)
	|| BeginPaint(hwnd, &ps) == NULL)
	{
TraceError(hwnd, "NOOP WM_PAINT\n");
		DeleteObject(rgnPaint);
		return;
	}
Start = DebugTimer("Paint","BeginPaint",Start,&msMax,&msLast,hwnd);

//	ActualValidateRects(hwnd);	/* start a new invalidation deferral */

#ifdef SHADOW_SCREEN
		HDC hdcShadow = CreateCompatibleDC(ps.hdc);
		HGDIOBJ hOrgMap = 0;
		long width=0, height=0;
		if (hdcShadow)
		{	RECT rcClient;
			//GetWindowRect(hwnd, &rc);
			//width = rc.right - rc.left;
			//height = rc.bottom - rc.top;
			GetClientRect(hwnd, &rcClient);
			width = rcClient.right - rcClient.left;
			height = rcClient.bottom - rcClient.top;
			if (cInfo->hShadowMap
			&& (width != cInfo->shadowWidth || height != cInfo->shadowHeight))
			{	DeleteObject(cInfo->hShadowMap);
				TraceError(hwnd, "PaintTrackerWindow:Deleted ShadowMap(0x%lX) %ld!=%ld or %ld!=%ld\n",
							(long) cInfo->hShadowMap,
							(long) width, (long) cInfo->shadowWidth,
							(long) height, (long) cInfo->shadowHeight);
				cInfo->hShadowMap = 0;
			}
			if (!cInfo->hShadowMap)
			{	cInfo->hShadowMap = CreateCompatibleBitmap(ps.hdc, width, height);
				cInfo->shadowWidth = width;
				cInfo->shadowHeight = height;
				TraceError(hwnd, "PaintTrackerWindow:New ShadowMap(0x%lX) %ld x %ld\n",
							(long) cInfo->hShadowMap,
							(long) cInfo->shadowWidth,
							(long) cInfo->shadowHeight);
			}
			if (cInfo->hShadowMap)
			{	hOrgMap = SelectObject(hdcShadow, cInfo->hShadowMap);
				FillRect(hdcShadow, &rcPaint, GetSysColorBrush(COLOR_WINDOW));
			} else
			{	DeleteDC(hdcShadow);
				hdcShadow = ps.hdc;
				TraceError(hwnd, "PaintTrackerWindow:NULL hShadowMap from CreateCompatibleBitmap, LastError = %ld\n", (long) GetLastError());
				MessageBeep(MB_ICONHAND);
			}
		} else
		{	hdcShadow = ps.hdc;
			MessageBox(hwnd, TEXT("NULL hdcShadow"), TEXT("CreateCompatibleDC"), MB_OK | MB_ICONERROR);
		}
Start = DebugTimer("Paint","Shadow",Start,&msMax,NULL,hwnd);
#define hdc hdcShadow
#else
#define hdc ps.hdc
#endif

//TraceActivityBegin(hwnd, "WM_PAINT:\n");

	COLORREF prevBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
	COLORREF prevText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	HBRUSH prevBrush = (HBRUSH) SelectObject(hdc, GetSysColorBrush(COLOR_WINDOW));
	for (r=0; r<ARRAYSIZE(rcs); r++)
	{	if (rcs[r].Handler && !IsRectEmpty(&rcs[r].Tracker[cInfo->Index].rc))
		{	RECT rc = rcs[r].Tracker[cInfo->Index].rc, rcIntersection;
			BOOL PaintIt = UseRect?IntersectRect(&rcIntersection, &rcs[r].Tracker[cInfo->Index].rc, &rcPaint):RectInRegion(rgnPaint,&rcs[r].Tracker[cInfo->Index].rc);
			if (PaintIt)
			{	__int64 Start = llGetMsec();
			static __int64 msMax=0, msLast=0;

				if (rcs[r].PaintRect)
				{	rc = rcs[r].Tracker[cInfo->Index].rc; rc.right++; rc.bottom++;
					Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
				}

//#define TRACK_PAINT_GDI

#ifdef TRACK_PAINT_GDI
DWORD nGDIObjects = GetGuiResources(hProc, GR_GDIOBJECTS);
DWORD nUserObjects = GetGuiResources(hProc, GR_USEROBJECTS);
#endif
//TraceActivity(hwnd, "Painting %S (%ld %ld %ld %ld) vs (%ld %ld %ld %ld)", rcs[r].Label, (long) rc.left, (long) rc.top, (long) rc.right, (long) rc.bottom, (long) rcs[r].rc.left, (long) rcs[r].rc.top, (long) rcs[r].rc.right, (long) rcs[r].rc.bottom);
				//if (rcs[r].Handler != CircleHandler)
				rcs[r].Handler(&rcs[r], hwnd, cInfo, hdc, WM_PAINT, 0, 0);

#ifdef TRACK_PAINT_GDI
DWORD dGDI = GetGuiResources(hProc, GR_GDIOBJECTS) - nGDIObjects;
DWORD dUser = GetGuiResources(hProc, GR_USEROBJECTS) - nUserObjects;
if (dGDI || dUser) TraceError(hwnd, "Paint(%S) Consumed %ld GDI (%ld) and %ld User (%ld) Objects\n", rcs[r].Label, (long) dGDI, (long) nGDIObjects+dGDI, (long) dUser, (long) nUserObjects+dUser);
#endif

{	char Buffer[80];
sprintf(Buffer,"%s:%ldx%ld", rcs[r].aLabel,
		(long)(rcs[r].Tracker[cInfo->Index].rc.right-rcs[r].Tracker[cInfo->Index].rc.left),
		(long)(rcs[r].Tracker[cInfo->Index].rc.bottom-rcs[r].Tracker[cInfo->Index].rc.top));
Start = DebugTimer("rcPaint",Buffer,Start,&msMax,&msLast,hwnd);
}
			}
//else TraceActivity(hwnd, "NOT Painting %S (%ld %ld %ld %ld)", rcs[r].Label, (long) rcs[r].rc.left, (long) rcs[r].rc.top, (long) rcs[r].rc.right, (long) rcs[r].rc.bottom);

		}
	}
	SelectObject(hdc, prevBrush);
	SetTextColor(hdc, prevText);
	SetBkColor(hdc, prevBack);
	#undef hdc
Start = DebugTimer("Paint","RCs",Start,&msMax,NULL,hwnd);

//TraceActivityEnd(hwnd, "WM_PAINT: Done\n");

#ifdef SHADOW_SCREEN
		if (hdcShadow != ps.hdc)
		{	if (!BitBlt(ps.hdc, 0, 0, width, height, hdcShadow, 0, 0, SRCCOPY))
			{	DWORD Error = GetLastError();
				TraceError(hwnd, "PaintTrackerWindow:Shadow BitBlt(0x%lX vs 0x%lX) Failed in %s line %ld Error %ld\n", (long) hdcShadow, (long) ps.hdc, __FILE__, (long) __LINE__, (long) Error);
				if (Error != ERROR_INVALID_HANDLE)
				{	TCHAR *Buffer=(TCHAR*)malloc(sizeof(*Buffer)*256);
					StringCbPrintf(Buffer, sizeof(*Buffer)*256,
									TEXT("BitBlt Failed at line %ld Error %ld"),
									(long) __LINE__, (long) Error);
					MessageBox(hwnd, Buffer, TEXT("BitBlt"), MB_OK | MB_ICONERROR);
					free(Buffer);
				}
			}
			SelectObject(hdcShadow, hOrgMap);
			DeleteDC(hdcShadow);
		}
Start = DebugTimer("Paint","UnShadow",Start,&msMax,NULL,hwnd);
#endif

	// Always need to finish!!
	DeleteObject(rgnPaint);
	EndPaint(hwnd, &ps);
Start = DebugTimer("Paint","EndPaint",Start,&msMax,NULL,hwnd);
#ifndef UNDER_CE
	DWORD dGDI = GetGuiResources(hProc, GR_GDIOBJECTS) - cGDIObjects;
	DWORD dUser = GetGuiResources(hProc, GR_USEROBJECTS) - cUserObjects;
	if (dGDI || dUser) TraceLog("Activity", dGDI>5||dUser>5, hwnd, "Paint Consumed %ld GDI and %ld User Objects\n", (long) dGDI, (long) dUser);
Start = DebugTimer("Paint","Resources",Start,&msMax,NULL,hwnd);
#endif
}

BOOL OnCreateTrackerWindow(HWND hwnd, CREATESTRUCT *cs)
{	CLIENT_INFO_S *Info = &cInfos[(int) cs->lpCreateParams];
//	memset(Info, 0, sizeof(*Info));
//	Info = (CLIENT_INFO_S *) calloc(1,sizeof(*Info));

#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG) Info);
#else
	SetWindowLong(hwnd, GWL_USERDATA, (LONG) Info);
#endif
	Info->hwnd = hwnd;
#ifndef UNDER_CE
	Info->hMenu = GetMenu(hwnd);
#else
/* Need To Fix This for CE! */
#endif
	Info->tsInfo = ActiveConfig.OSM;

	Info->Index = (int) cs->lpCreateParams;
	Info->Active = TRUE;

	Info->viewBits = VIEW_ALL;
	CheckMenuItem (Info->hMenu, ID_VIEW_ALL, MF_CHECKED);
	Info->Scale = ActiveConfig.MultiTrack.Scale;
#ifdef DO_OSM
	Info->zoom = ActiveConfig.MultiTrack.Zoom;
#endif
	Info->Percent = ActiveConfig.MultiTrack.Percent;

	Info->Orientation = ActiveConfig.MultiTrack.Orientation;

	SetOrientation(hwnd, ActiveConfig.MultiTrack.Orientation);

#ifndef UNDER_CE
	if (Info->Flashing)
	{	FLASHWINFO fw = {0};
		fw.cbSize = sizeof(fw);
		fw.hwnd = hwnd;
		fw.dwFlags = FLASHW_STOP;	/* But stop the window flashing! */
		FlashWindowEx(&fw);
		Info->Flashing = FALSE;
	}
	Info->FlashingAcked = FALSE;
	if (Info->CenterStation && Info->CenterStation->MicEIndex)
	{	MICE_ACTION_S *Action = &ActiveConfig.MicEs.MicE[Info->CenterStation->MicEIndex];
		if (Action->Enabled)
		if (Action->FlashOnCenter)
		if (ActiveConfig.Enables.MicENotification
		|| (ActiveConfig.Enables.MicEEmergency && Info->CenterStation->MicEIndex == 1))
		{	FLASHWINFO fw = {0};
			fw.cbSize = sizeof(fw);
			fw.hwnd = hwnd;
			fw.dwFlags = FLASHW_ALL | FLASHW_TIMER;
			FlashWindowEx(&fw);
			Info->Flashing = TRUE;
		}
	}
#endif
	// Success
	return TRUE;
}

BOOL OnTrackerWindowTimer(HWND hwnd, WORD idTimer)
{
#ifdef FUTURE
	switch (idTimer)
	{
	default:
	{	return OnSharedTimer(hwnd, idTimer);
	}
	}
	return FALSE;
#else
	return OnSharedTimer(hwnd, idTimer);
#endif
}

LRESULT CALLBACK TrackerWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
	__int64 Start = llGetMsec();
static __int64 msMax=0, msLast=0;

#ifdef TRACE_MESSAGES
if (TraceMessages) TraceLogThread("WinMsg", TRUE, "hwndMain: %lX msg: %s(%lX) wp: %lX lp: %lX\n", (long) hwnd, MsgToText(msg), (long) msg, (long) wp, (long) lp);
#endif
	switch (msg)
    {
    case WM_CREATE:
		// Initialize the static window state information. The shell helper functions
		// will use this buffer to store their state.
		// Initialize the window (if we fail, return -1)
        return (OnCreateTrackerWindow(hwnd, (CREATESTRUCT*) lp) ? 0 : -1);
	case WM_TILES_LOADED:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		BOOL Force = wp==-1 || (int)cInfo->zoom==(int)wp;
		InvalidateCircle(OSMGetQueueStats(NULL,NULL)?hwnd:NULL, Force);
		break;
	}
	case WM_CENTER_STATION:	/* lp=text, wp=title */
	{	char *Station = (char*)wp;
		char *Owner = (char*)lp;
		STATION_INFO_S *pStation = FindStationCall(Station, Owner);
		if (pStation)
		{	SetCenterTracking(hwnd, pStation);
		}
		if (Owner) free(Owner);
		if (Station) free(Station);
		break;
	}
	case WM_REFRESH_CIRCLE:	/* wp = TRUE for ALL circles */
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		InvalidateStationPoints(cInfo->Index, "RefreshCircle", FALSE);
		InvalidateCircle(wp?NULL:hwnd, TRUE, TRUE);
		break;
	}

	case WM_ASYNC_MSG_BOX:	/* lp=text, wp=title */
		MessageBox(hwnd, (LPCWSTR) lp, (LPCWSTR) wp, MB_OK | MB_ICONINFORMATION);
		free((void*)lp); free((void*)wp);
		break;


	case WM_INITMENUPOPUP:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		HMENU hmenu = (HMENU) wp;
	    int  cMenuItems = GetMenuItemCount(hmenu); 
	    UINT id = GetMenuItemID(hmenu, 0);

		MarkActivity();

//TraceLog("Menu", TRUE, hwnd, "INITMENUPOPUP(%ld)\n", (long) id);

#ifndef UNDER_CE
		MENUITEMINFO mi = {0};
		mi.cbSize = sizeof(mi);
		mi.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_FTYPE | MIIM_STATE | MIIM_STRING | MIIM_SUBMENU;
		GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
		if (mi.fType == MFT_STRING)
		{	mi.dwTypeData = (LPWSTR) malloc(sizeof(TCHAR)*++mi.cch);
			GetMenuItemInfo(hmenu, id, MF_BYCOMMAND, &mi);
//			TraceLog("Menu", TRUE, hwnd, "INITMENUPOPUP(%ld)(%S) is fType(0x%lX) fState(0x%lX)\n", id, mi.dwTypeData, mi.fType, mi.fState);
		}// else TraceLog("Menu", TRUE, hwnd, "INITMENUPOPUP(%ld) is fType(0x%lX) fState(0x%lX)\n", id, mi.fType, mi.fState);
		if (mi.fType == MFT_STRING) free(mi.dwTypeData);
#endif

		if (id == ID_SELECT_TILE_SERVER+1)	/* First element of the sub menu */
		{	unsigned long p;
			for (p=cMenuItems-1; p>=0; p--)	/* 0 original elements */
			{	DeleteMenu(hmenu, p, MF_BYPOSITION);
				if (!p) break;	/* Unsigneds don't go negative */
			}
			for (p=0; p<ActiveConfig.TileServers.Count; p++)
			{	TCHAR Name[80+sizeof(ActiveConfig.TileServers.Server[0].Name)];
				TILE_SERVER_INFO_S *Server = &ActiveConfig.TileServers.Server[p];
				StringCbPrintf(Name, sizeof(Name), TEXT("%S"), Server->Name);
				AppendMenu(hmenu, MF_STRING, ID_SELECT_TILE_SERVER+(p+1), Name);
				CheckMenuItem(hmenu, ID_SELECT_TILE_SERVER+(p+1), 
							!_strnicmp(Server->Name,cInfo->tsInfo.Name,sizeof(Server->Name))?MF_CHECKED:MF_UNCHECKED);
			}
		}

		CheckMenuItem (hmenu, ID_SCREEN_PATHS_NETWORK, cInfo->Paths.Network?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_STATION, cInfo->Paths.Station?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_MYSTATION, cInfo->Paths.MyStation?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_PATHS_RFONLY, cInfo->Paths.LclRF?MF_CHECKED:MF_UNCHECKED);

		CheckMenuItem (hmenu, ID_VIEW_PREFERRED_MULTITRACK_NONE, ActiveConfig.MultiTrack.ViewNone?MF_CHECKED:MF_UNCHECKED);

		FixUpViewMenu(cInfo, hmenu, id);

		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW, cInfo->AutoZoomViewOut&&cInfo->AutoZoomViewIn?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_CTR, cInfo->AutoZoomViewCtr?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_AUTOZOOM_VIEW_CTR, cInfo->AutoZoomViewOut?MF_ENABLED:MF_GRAYED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_OUT, cInfo->AutoZoomViewOut?MF_CHECKED:MF_UNCHECKED);
		CheckMenuItem (hmenu, ID_SCREEN_AUTOZOOM_VIEW_IN, cInfo->AutoZoomViewOut&&cInfo->AutoZoomViewIn?MF_CHECKED:MF_UNCHECKED);
		EnableMenuItem(hmenu, ID_SCREEN_AUTOZOOM_VIEW_IN, cInfo->AutoZoomViewOut?MF_ENABLED:MF_GRAYED);

		CheckMenuItem (hmenu, ID_SCREEN_CENTER_TRACKED, (cInfo->CenterTracking && cInfo->CenterStation!=MyStation?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_SCREEN_TRACK_ME, (cInfo->CenterTracking && cInfo->CenterStation==MyStation?MF_CHECKED:MF_UNCHECKED));
		CheckMenuItem (hmenu, ID_SCREEN_TRACK_LOCKED, cInfo->Locked?MF_CHECKED:MF_UNCHECKED);

#ifdef CE50	/* Hack for lack of INITMENUPOPUP for sub menus */
		{	MENUITEMINFO mii = {0};
			mii.cbSize = sizeof(mii); 
			mii.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
			for (UINT i=0; GetMenuItemInfo(hmenu, i, TRUE, &mii); i++)
			{
				if (mii.hSubMenu)
				{
					if (mii.fType == MFT_STRING)
					{	mii.dwTypeData = (TCHAR*)malloc(sizeof(TCHAR)*++mii.cch);
						if (GetMenuItemInfo(hmenu, i, TRUE, &mii))
							TraceLogThread("Menu", FALSE, "mii[%ld](%ld) is SubMenu(%S)\n", (long) i, (long) mii.wID, mii.dwTypeData);
						free(mii.dwTypeData);
						mii.dwTypeData = NULL;
					}
					PostMessage(hwnd, WM_INITMENUPOPUP, (WPARAM) mii.hSubMenu, lp);
				}
			}
		}
#endif
		break;
	}

	case WM_COMMAND:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

		MarkActivity();

		switch (LOWORD(wp))
		{
		case ID_EXIT:
			SendMessage(hwnd, WM_CLOSE, 0, 0);
			break;
		case ID_FADE_IN:
		case ID_FADE_OUT:
			if (LOWORD(wp) == ID_FADE_OUT) cInfo->Percent -= 5;
			if (LOWORD(wp) == ID_FADE_IN) cInfo->Percent += 5;
			if (((int)cInfo->Percent) < 0) cInfo->Percent = 0;
			if (cInfo->Percent > 100) cInfo->Percent = 100;
			ActiveConfig.OSMPercent = cInfo->Percent;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_SCREEN_AUTOZOOM_VIEW:
			if (cInfo->AutoZoomViewIn && cInfo->AutoZoomViewOut)
			{	cInfo->AutoZoomViewIn = cInfo->AutoZoomViewOut = cInfo->AutoZoomViewCtr = FALSE;
				cInfo->Locked = TRUE;	/* Maybe should have saved this */
			} else
			{	cInfo->AutoZoomViewIn = cInfo->AutoZoomViewOut = TRUE;
				cInfo->Locked = FALSE;
				if (!cInfo->Locked) cInfo->AutoZoomViewCtr = TRUE;
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			}
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_CTR:
			if (cInfo->AutoZoomViewCtr = !cInfo->AutoZoomViewCtr)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_IN:
			if (cInfo->AutoZoomViewIn = !cInfo->AutoZoomViewIn)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;
		case ID_SCREEN_AUTOZOOM_VIEW_OUT:
			if (cInfo->AutoZoomViewOut = !cInfo->AutoZoomViewOut)
				InvalidateCircle(hwnd, TRUE, TRUE);	/* Kick a Paint */
			break;

		case ID_ZOOM_IN:
		case ID_ZOOM_OUT:
#ifdef DO_OSM
		{	int OrgZoom = cInfo->zoom;
			if (LOWORD(wp) == ID_ZOOM_IN) cInfo->zoom++;
			if (LOWORD(wp) == ID_ZOOM_OUT) cInfo->zoom--;
			if (cInfo->zoom < ActiveConfig.View.ZoomMin) cInfo->zoom = ActiveConfig.View.ZoomMin;
			if (cInfo->zoom > ActiveConfig.View.ZoomMax) cInfo->zoom = ActiveConfig.View.ZoomMax;
			if (cInfo->zoom != OrgZoom)
			{
				if (ActiveConfig.Screen.Show.CrossHairs > 0)
				{	cInfo->CrossHairs = TRUE;
					SetTimer(hwnd, CROSSHAIR_TIMER, ActiveConfig.Screen.Show.CrossHairTime,NULL);
				}
				cInfo->msLastSigChange = llGetMsec();
				InvalidateScale(hwnd, FALSE);
				InvalidateCircle(hwnd, FALSE);
#ifdef UNDER_CE
				InvalidateStations(hwnd, TRUE);
#else
				InvalidateStations(hwnd, GetInputState()?FALSE:TRUE);	/* Force if no more input */
#endif
			}
			break;
		}
#else
		{	double OrgScale = cInfo->Scale;
			if (LOWORD(wp) == ID_ZOOM_out) cInfo->Scale *= 2;
			if (LOWORD(wp) == ID_ZOOM_IN) cInfo->Scale /= 2;
			if (cInfo->Scale < MIN_SCALE) cInfo->Scale = MIN_SCALE;
			if (cInfo->Scale > MAX_SCALE) cInfo->Scale = MAX_SCALE;
			if (cInfo->Scale != OrgScale)
			{	InvalidateScale(hwnd, FALSE);
				InvalidateCircle(hwnd, FALSE);
#ifdef UNDER_CE
				InvalidateStations(hwnd, TRUE);
#else
				InvalidateStations(hwnd, GetInputState()?FALSE:TRUE);	/* Force if no more input */
#endif
			}
	        break;
		}
#endif
		case ID_VIEW_PREFERRED_MULTITRACK_NONE:
		{	ActiveConfig.MultiTrack.ViewNone = !ActiveConfig.MultiTrack.ViewNone;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_SIZE:
		{	RECT rc;
			GetWindowRect(hwnd, &rc);
			ActiveConfig.MultiTrack.width = rc.right-rc.left;
			ActiveConfig.MultiTrack.height = rc.bottom-rc.top;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_ZOOM:
		{	ActiveConfig.MultiTrack.Zoom = cInfo->zoom;
			ActiveConfig.MultiTrack.Scale = cInfo->Scale;
			break;
		}
		case ID_VIEW_PREFERRED_MULTITRACK_PERCENT:
		{	ActiveConfig.MultiTrack.Percent = cInfo->Percent;
			break;
		}

		case ID_SCREEN_TRACK_FIND:
		{	unsigned long s = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_FIND_STATION),
											hwnd, FindStationDlgProc, (LPARAM) cInfo);
			if (s >= 0 && s < CloseStationCount) SetCenterTracking(hwnd,pCloseStations[s]);
			break;
		}
		case ID_SCREEN_TRACK_ME:
			SetCenterTracking(hwnd, MyStation);
			break;
		case ID_SCREEN_CENTER_TRACKED:
			SetCenterTracking(hwnd, cInfo->CenterStation);
			break;
		case ID_SCREEN_TRACK_LOCKED:
			cInfo->Locked = !cInfo->Locked;
			if (cInfo->Locked && cInfo->CenterStation)
				SetCenterTracking(hwnd, cInfo->CenterStation);
			else InvalidateCircle(hwnd, TRUE, TRUE, 0);
			break;

		case ID_SCREEN_PATHS_NETWORK:
			cInfo->Paths.Network = !cInfo->Paths.Network;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_STATION:
			cInfo->Paths.Station = !cInfo->Paths.Station;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_MYSTATION:
			cInfo->Paths.MyStation = !cInfo->Paths.MyStation;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_SCREEN_PATHS_RFONLY:
			cInfo->Paths.LclRF = !cInfo->Paths.LclRF;
			InvalidateStationPoints(cInfo->Index, "Paths", FALSE);
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;
		case ID_CONFIGURE_PATHS:
			if (cInfo->hwndPathConfig && IsWindow(cInfo->hwndPathConfig))
				ShowWindow(cInfo->hwndPathConfig, SW_SHOW);
			else cInfo->hwndPathConfig = PromptPathConfig(hwnd, WM_REFRESH_CIRCLE, &cInfo->Paths, FALSE);
			break;

		case ID_VIEW_LANDSCAPE:
			SetOrientation(hwnd,0);
			break;
	
		case ID_VIEW_PORTRAIT:
			SetOrientation(hwnd,1);
			break;
	
		case ID_VIEW_AUTOMATIC:
			SetOrientation(hwnd,2);
			break;

		case ID_VIEW_ECHOLINKS:
			cInfo->viewBits ^= VIEW_ECHOLINKS;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		case ID_VIEW_GEOCACHES:
			cInfo->viewBits ^= VIEW_GEOCACHES;
			InvalidateCircle(hwnd, TRUE, TRUE);
			break;

		default:
		{	UINT id = LOWORD(wp);
#ifdef SUPPORT_TRACE_LOGS
			ProcessTraceLogEnableMenu(id);
			ProcessTraceLogViewMenu(id);
#endif
			ProcessViewMenu(hwnd, cInfo,id);

			if (id > ID_SELECT_TILE_SERVER && id <= ID_SELECT_TILE_SERVER+ActiveConfig.TileServers.Count)
			{	id -= ID_SELECT_TILE_SERVER+1;
				if (id>=0 && id<ActiveConfig.TileServers.Count)
				{	if (VerifyOSMPath(hwnd, &ActiveConfig.TileServers.Server[id], FALSE, NULL))
					{	cInfo->tsInfo = ActiveConfig.TileServers.Server[id];
						InvalidateCircle(hwnd, TRUE, TRUE);
					}
				}
			}

		}
		}
		break;
	}

	case WM_KEYDOWN:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		int RepeatCount = LOWORD(lp);
		if (RepeatCount <= 0) RepeatCount = 1;

		MarkActivity();

        // Allow Ctrl+Q to quit the application. Most users won't ever see
        // this, but it's handy for debugging.
		if (GetKeyState(VK_CONTROL) < 0)
		switch (wp)
		{
		case VK_LEFT:	PanCircle(cInfo, 10*RepeatCount, 0); break;
		case VK_RIGHT:	PanCircle(cInfo, -10*RepeatCount, 0); break;
		case VK_UP:		PanCircle(cInfo, 0, 10*RepeatCount); break;
		case VK_DOWN:	PanCircle(cInfo, 0, -10*RepeatCount); break;
		}
		else switch (wp)
		{
		case VK_NEXT:	/* Page down */
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_OUT, 0);
			break;
		case VK_PRIOR:	/* Page up */
			PostMessage(hwnd, WM_COMMAND, ID_ZOOM_IN, 0);
			break;
		case VK_LEFT:
			PostMessage(hwnd, WM_COMMAND, ID_FADE_OUT, 0);
			break;
		case VK_RIGHT:
			PostMessage(hwnd, WM_COMMAND, ID_FADE_IN, 0);
			break;
		case VK_UP:
		case VK_DOWN:
		{	int Which = 0;
			if (ActiveConfig.View.ZoomReverse)
			{	if (wp == VK_UP) Which = ID_ZOOM_IN;
				if (wp == VK_DOWN) Which = ID_ZOOM_OUT;
			} else
			{	if (wp == VK_UP) Which = ID_ZOOM_OUT;
				if (wp == VK_DOWN) Which = ID_ZOOM_IN;
			}
			PostMessage(hwnd, WM_COMMAND, Which, 0);
	        break;
		}
		}
		break;
	}
	case WM_CHAR:

		MarkActivity();

		switch (wp)
		{
		case 26:	/* Ctrl-Z - Zoom */
			PostMessage(hwnd, WM_AUTO_ZOOM, TRUE, 0);
			break;
		default:
			ProcessWmChar(hwnd, wp);
		}
		break;

	case WM_RBUTTONUP:
		return DefWindowProc(hwnd, msg, wp, lp);

	case WM_CONTEXTMENU:
		if (lp == MAKELONG(-1,-1))
			return 0;	/* Can't handle non-mouse context menus (yet) */
    case WM_MOUSEWHEEL: 
	{	POINT pt;
		pt.x = LOWORD(lp); 
		pt.y = HIWORD(lp); 
		if (ScreenToClient(hwnd, &pt))
			lp = MAKELONG(pt.x,pt.y);
	}
	case WM_LBUTTONDOWN:
#ifdef UNDER_CE
		if (msg == WM_LBUTTONDOWN)	// Avoid fall-throughs 
		{	SHRGINFO    shrg = {0};
			shrg.cbSize = sizeof(shrg);
			shrg.hwndClient = hwnd;
			shrg.ptDown.x = LOWORD(lp);
			shrg.ptDown.y = HIWORD(lp);
			shrg.dwFlags = SHRG_RETURNCMD /*| SHRG_NOANIMATION*/;
			if (SHRecognizeGesture(&shrg) == GN_CONTEXTMENU)
			{
				return 0;	/* I processed it */
			}
		}
#endif
	case WM_LBUTTONUP:
	case WM_LBUTTONDBLCLK:

	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_MBUTTONDBLCLK:

	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:

		MarkActivity();

	case WM_MOUSEMOVE: 

	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo)
		{
			if (cInfo->Captured)
				cInfo->CaptureHandler(cInfo->ibCapture, hwnd, cInfo, NULL, msg, wp, lp);
			else if (msg != WM_MOUSEMOVE)
			{	int			r;
				POINT		pt;
				pt.x = LOWORD(lp); 
				pt.y = HIWORD(lp); 
	#ifdef SHOW_MOUSE_MESSAGES
	TraceError(hwnd, "Msg:%ld(%ld) @ %ld,%ld (Slider:%ld %ld x %ld %ld)\n",
				  (long) msg, (long) WM_MOUSEWHEEL, (long) pt.x, (long) pt.y,
				  (long) rcSlider.left, (long) rcSlider.top,
				  (long) rcSlider.right, (long) rcSlider.bottom);
	#endif
				for (r=ARRAYSIZE(rcs)-1; r>=0; r--)
				{	if (rcs[r].Handler)
					{	//RECT rc = rcs[r].Tracker[cInfo->Index].rc;
						if (PtInRect(&rcs[r].Tracker[cInfo->Index].rc, pt))
						{	rcs[r].Handler(&rcs[r], hwnd, cInfo, NULL, msg, wp, lp);
							break;	/* Only "last" rectangle gets to handle it! */
						}
					}
				}
			}
		}
	}
	break;

#ifndef UNDER_CE
	case WM_MOVE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo && !IsIconic(hwnd) && !IsZoomed(hwnd))
			GetWindowRect(hwnd, &cInfo->rcSize);
		SaveTrackerWindowRect(hwnd, cInfo);
		MarkActivity();
		break;
	}
#endif

	case WM_SIZE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

		MarkActivity();

		if (cInfo)	/* If we haven't initialized, don't do this! */
		{	long width = LOWORD(lp), height = HIWORD(lp);
			RECT rc;

#ifndef UNDER_CE
			if (cInfo && !IsIconic(hwnd) && !IsZoomed(hwnd))
				GetWindowRect(hwnd, &cInfo->rcSize);
#endif

			InvalidateStationPoints(cInfo->Index, "WM_SIZE", TRUE);	/* Need to calc points */

			cInfo->prevSize = cInfo->curSize;
			cInfo->curSize = wp;
	
			GetWindowRect(hwnd, &rc);
			TraceActivity(hwnd, "WM_SIZE: %ld x %ld from Window %ld %ld -> %ld %ld or %ld x %ld\n",
						(long) width, (long) height,
						rc.left, rc.top, rc.right, rc.bottom,
						rc.right - rc.left, rc.bottom - rc.top);
			GetClientRect(hwnd, &rc);
			TraceActivity(hwnd, "WM_SIZE: %ld x %ld from Client %ld %ld -> %ld %ld or %ld x %ld\n",
						(long) width, (long) height,
						rc.left, rc.top, rc.right, rc.bottom,
						rc.right - rc.left, rc.bottom - rc.top);

#ifndef UNDER_CE
			SaveTrackerWindowRect(hwnd, cInfo);
#endif

			HDC hdc = GetDC(hwnd);
			SetRect(&rc, 0, 0, width, height);

			int theight = DrawText(hdc, MaxWidthStationID, -1, &rc, DT_NOPREFIX | DT_CALCRECT);
			int mwidth = rc.right - rc.left + 2;

			SetRect(&rc, 0, 0, width, height);
			DrawText(hdc, TEXT(" 9999+99/9*99+99 "), -1, &rc,DT_NOPREFIX |  DT_CALCRECT);
			int dwidth = rc.right - rc.left;
			dwidth += 4;

			ReleaseDC(hwnd, hdc);

			for (int r=0; r<ARRAYSIZE(rcs); r++)
				SetRectEmpty(&rcs[r].Tracker[cInfo->Index].rc);
			SetRect(&rcBottomPanel(cInfo->Index), 0, height-width, width, height);
			SetRect(&rcCircle(cInfo->Index), 0, 0, width, height);

			SetRect(&rcScale(cInfo->Index), 0, rcCircle(cInfo->Index).bottom-theight*3/2, 40, rcCircle(cInfo->Index).bottom);

			if (ActiveConfig.Screen.DateTimePerformance)
				SetRect(&rcTime(cInfo->Index), width-dwidth, height-theight-2, width, height);

			int ScrollWidth = GetSystemMetrics(SM_CXVSCROLL);
			int SliderWidth = max(15,ScrollWidth);
			int centcirc = (rcCircle(cInfo->Index).bottom+rcCircle(cInfo->Index).top)/2;
			SetRect(&rcSlider(cInfo->Index), 0, centcirc-height/4, SliderWidth, centcirc+height/4);

			TraceActivityBegin(hwnd, "WM_SIZE: %ld x %ld\n", (long) height, (long) width);
#define RECT(x,w) Trace##x(hwnd, "%s: %ld %ld -> %ld %ld (%ldx%ld)\n", \
				#w, rc##w(cInfo->Index).left, rc##w(cInfo->Index).top, \
				rc##w(cInfo->Index).right, rc##w(cInfo->Index).bottom, \
				rc##w(cInfo->Index).bottom-rc##w(cInfo->Index).top, \
				rc##w(cInfo->Index).right-rc##w(cInfo->Index).left);

			RECT(Activity,BottomPanel)
			RECT(Activity,Speed)
			RECT(Activity,Heading)
			RECT(Activity,Odometer)
			RECT(Activity,APRS)
			RECT(Activity,Stations)
			RECT(Activity,Message)
			RECT(Activity,Slider)
			RECT(Activity,SatInView)
			RECT(Activity,SatInUse)
			RECT(Activity,Scale)
			RECT(Activity,Altitude)
			RECT(Activity,Fix)
			RECT(Activity,Time)
			RECT(Activity,Power)
			RECT(Activity,StatUsage)
			RECT(ActivityEnd,Circle)
#undef RECT
		}
		break;
	}
	case WM_TIMER:
		if (OnTrackerWindowTimer(hwnd, wp))
		{	MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
			return TRUE;
		}
		break;
	case WM_AUTO_ZOOM:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
		if (cInfo)
		{	//TraceLog("AutoZoom", TRUE, hwnd, "[%ld] WM_AUTO_ZOOM(%ld)\n", cInfo->Index, wp);
			AutoZoomMultiLine(hwnd,wp);
		}
		break;
	}
	case WM_PAINT:
		PaintTrackerWindow(hwnd);
		MessageTimer("MainWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);
		return 0;

	case WM_CLOSE:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);

TraceError(hwnd, "WM_CLOSE Tracker[%ld]\n", (long) cInfo->Index);

		SaveTrackerWindowRect(hwnd, cInfo);

		cInfo->Active = FALSE;
		hwndTracker[cInfo->Index] = NULL;
		TrackersActive--;
		TransmitFilter();	/* Remove from filter, if no longer needed (James VE6SRV) */

		DestroyWindow(hwnd);

		return 0;	/* Let's not close just yet! */
	}

	case WM_DESTROY:
	{	CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
TraceError(hwnd, "WM_DESTROY Tracker[%ld] Freeing TileSet %p!\n", (long) cInfo->Index, cInfo->ts);
		if (cInfo->ts) OSMFreeTileSet(cInfo->ts);
		OSMFlushTileQueue(FALSE, hwnd, TRUE);
        break;
	}
    }

	MessageTimer("TrackerWindowProc", Start, &msMax, &msLast, hwnd, msg, wp, lp);

    return DefWindowProc(hwnd, msg, wp, lp);
}
#endif

HBITMAP LoadPaintImage(int Page)
{
	if (Page < 0 || Page >= ARRAYSIZE(g_hBitmapPaints)) return NULL;

	// Load the current image
	if (g_hBitmapPaints[Page] == NULL)
	{
#if defined(USING_SHELL) && defined(NOT_ANY_MORE)
		// Note that the resource type must be "GIF", but actually the resource
		// data can contain a BMP, GIF, JPG, or PNG image. This enables us to
		// pick the best image format for our purposes (quality, size, etc).
		g_hBitmapPaints[Page] = SHLoadImageResource(g_hInstance,
			IDR_GIF1 + Page);
#else
		g_hBitmapPaints[Page] = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(IDR_BITMAP0 + Page),
													IMAGE_BITMAP, 0, 0, 0);
		if (!g_hBitmapPaints[Page]) printf("LoadImage(%ld) Failed Error %ld\n", (long) Page, (long) GetLastError());
#endif
	}

	// Return the cached image handle
	return g_hBitmapPaints[Page];
}

void FreePaintImage()
{	int p;
	for (p=0; p<ARRAYSIZE(g_hBitmapPaints); p++)
	if (g_hBitmapPaints[p] != NULL)
	{
		DeleteObject(g_hBitmapPaints[p]);
		g_hBitmapPaints[p] = NULL;
	}
}

//TCHAR tszAppName[] = TEXT("PMSAMPLE");
//TCHAR tszTitle[]   = TEXT("Power Manager Sample");

//HINSTANCE g_hInst = NULL;                     // Local copy of hInstance
//HWND      g_hSystemState = NULL;


#ifdef UNUSED
//***************************************************************************
// Function Name: SetBacklightRequirement
//
// Purpose: Sets or releases the device power requirement to keep the 
//          backlight at D0
//
// Arguments:
//  IN BOOL fBacklightOn - TRUE to leave the backlight on
//
void SetBacklightRequirement(BOOL fBacklightOn)
{
    // the name of the backlight device
    TCHAR tszBacklightName[] = TEXT("BKL1:"); 

    static HANDLE s_hBacklightReq = NULL;
    
    if (fBacklightOn) 
    {
        if (NULL == s_hBacklightReq) 
        {
            // Set the requirement that the backlight device must remain
            // in device state D0 (full power)
            s_hBacklightReq = SetPowerRequirement(tszBacklightName, D0, 
                                                  POWER_NAME, NULL, 0);
            if (!s_hBacklightReq)
            {	MessageBox(NULL, TEXT("SetPowerRequirement failed"), TEXT("SetBacklight"), MB_OK | MB_ICONERROR);
            }
        }
    } 
    else 
    {
        if (s_hBacklightReq) 
        {
            if (ERROR_SUCCESS != ReleasePowerRequirement(s_hBacklightReq))
            {	MessageBox(NULL, TEXT("ReleasePowerRequirement failed"), TEXT("SetBacklight"), MB_OK | MB_ICONERROR);
            }
            s_hBacklightReq = NULL;
        }
    }
}
#endif

#ifdef UNUSED
//***************************************************************************
// Function Name: UpdatePowerState
//
// Purpose: Updates the name of the current power state in the dialog
//
void UpdatePowerState( void ) 
{
    TCHAR szState[MAX_PATH];
    DWORD dwState;

    if (g_hSystemState) 
    {
        if (ERROR_SUCCESS == GetSystemPowerState(szState, MAX_PATH, &dwState)) 
        {
            SetWindowText(g_hSystemState, szState);
        }
    }

}
#endif

#ifdef WAYS_TO_DO_THINGS
SetBacklightRequirement((BST_CHECKED == SendMessage(hwndBacklight, 
                                             BM_GETCHECK, 0, 0)));
                        // Some platforms may restrict which system power 
                        // states can be set by applications.  
                        // Can also send the system to other POWER_STATES 
                        // using this API (POWER_STATE_SUSPEND, etc.)
                        DWORD dwRet = SetSystemPowerState(NULL, POWER_STATE_IDLE, 0);
                        if (ERROR_SUCCESS == dwRet) 
                        {
                            s_fIdled = TRUE;
                            SetTimer(hwnd, 1, 5000, NULL);
                        }
                        else 
                        {
                            RETAILMSG(1, (L"SetSystemPowerState failed, error: %X\n",
                                          dwRet));
                        }
            // Set the system state to full power
            KillTimer(hwnd, 1);
            SetSystemPowerState(NULL, POWER_STATE_ON, 0);
            s_fIdled = FALSE;
            break;

        case WM_DESTROY:
            SetBacklightRequirement(FALSE);

#endif

#ifdef OLD_WAY
//***************************************************************************
// Function Name: PowerNotificationThread
//
// Purpose: listens for power change notifications
//
DWORD PowerNotificationThread(LPVOID pVoid)
{
    // size of a POWER_BROADCAST message
    DWORD cbPowerMsgSize = sizeof POWER_BROADCAST + (MAX_PATH * sizeof TCHAR);

    // Initialize our MSGQUEUEOPTIONS structure
    MSGQUEUEOPTIONS mqo;
    mqo.dwSize = sizeof(MSGQUEUEOPTIONS); 
    mqo.dwFlags = MSGQUEUE_NOPRECOMMIT;
    mqo.dwMaxMessages = 4;
    mqo.cbMaxMessage = cbPowerMsgSize;
    mqo.bReadAccess = TRUE;
                                         
    // Create a message queue to receive power notifications
    HANDLE hPowerMsgQ = CreateMsgQueue(NULL, &mqo);
    if (NULL == hPowerMsgQ) 
    {
        RETAILMSG(1, (L"CreateMsgQueue failed: %x\n", GetLastError()));
        goto Error;
    }

    // Request power notifications 
    HANDLE hPowerNotifications = RequestPowerNotifications(hPowerMsgQ,
                                                           PBT_TRANSITION | 
                                                           PBT_RESUME | 
                                                           PBT_POWERINFOCHANGE);
    if (NULL == hPowerNotifications) 
    {
        RETAILMSG(1, (L"RequestPowerNotifications failed: %x\n", GetLastError()));
        goto Error;
    }

    HANDLE rgHandles[2] = {0};
    rgHandles[0] = hPowerMsgQ;
    rgHandles[1] = g_hEventShutDown;

    // Wait for a power notification or for the app to exit
    while(WaitForMultipleObjects(2, rgHandles, FALSE, INFINITE) == WAIT_OBJECT_0)
    {
        DWORD cbRead;
        DWORD dwFlags;
        POWER_BROADCAST *ppb = (POWER_BROADCAST*) new BYTE[cbPowerMsgSize];
            
        // loop through in case there is more than 1 msg 
        while(ReadMsgQueue(hPowerMsgQ, ppb, cbPowerMsgSize, &cbRead, 
                           0, &dwFlags))
        {
            switch (ppb->Message)
            {
                case PBT_TRANSITION:
                    RETAILMSG(1,(L"Power Notification Message: PBT_TRANSITION\n"));
                    RETAILMSG(1,(L"Flags: %lx", ppb->Flags));
                    RETAILMSG(1,(L"Length: %d", ppb->Length));
                    if (ppb->Length)
                    {
                        RETAILMSG(1,(L"SystemPowerState: %s\n", ppb->SystemPowerState));
                    }
                    break;

                case PBT_RESUME:
                    RETAILMSG(1,(L"Power Notification Message: PBT_RESUME\n"));
                    break;

                case PBT_POWERINFOCHANGE:
                {
                    RETAILMSG(1,(L"Power Notification Message: PBT_POWERINFOCHANGE\n"));

                    // PBT_POWERINFOCHANGE message embeds a 
                    // POWER_BROADCAST_POWER_INFO structure into the 
                    // SystemPowerState field
                    PPOWER_BROADCAST_POWER_INFO ppbpi =
                        (PPOWER_BROADCAST_POWER_INFO) ppb->SystemPowerState;
                    if (ppbpi) 
                    {	pbpi = *ppbpi;	/* Remember for window painting */
                        RETAILMSG(1,(L"\nLength: %d\n", ppb->Length));
                        RETAILMSG(1,(L"BatteryLifeTime = %d\n",ppbpi->dwBatteryLifeTime));
                        RETAILMSG(1,(L"BatterFullLifeTime = %d\n",
                                     ppbpi->dwBatteryFullLifeTime));
                        RETAILMSG(1,(L"BackupBatteryLifeTime = %d\n",
                                     ppbpi->dwBackupBatteryLifeTime));
                        RETAILMSG(1,(L"BackupBatteryFullLifeTime = %d\n",
                                     ppbpi->dwBackupBatteryFullLifeTime));
                        RETAILMSG(1,(L"ACLineStatus = %d\n",ppbpi->bACLineStatus));
                        RETAILMSG(1,(L"BatteryFlag = %d\n",ppbpi->bBatteryFlag));
                        RETAILMSG(1,(L"BatteryLifePercent = %d\n",
                                     ppbpi->bBatteryLifePercent));
                        RETAILMSG(1,(L"BackupBatteryFlag = %d\n",
                                     ppbpi->bBackupBatteryFlag));
                        RETAILMSG(1,(L"BackupBatteryLifePercent = %d\n\n",
                                     ppbpi->bBackupBatteryLifePercent));
						InvalidatePower(hwndMain, TRUE);
                    }
                    break;
                }

                default:
                    break;
            }

//            UpdatePowerState();
        }

        delete[] ppb;
    }

Error:
    if (hPowerNotifications)
        StopPowerNotifications(hPowerNotifications);

    if (hPowerMsgQ)
        CloseMsgQueue(hPowerMsgQ);

    return NULL;
}
#endif



#ifdef POWER_MANAGEMENT_SAMPLE
C:\Program Files\Windows Mobile 6 SDK\Samples\Common\CPP\Win32\PowerManager
#endif


#ifdef FUTURE
static const DWORD maxMsgQueueMsgSize = sizeof(POWER_BROADCAST_POWER_INFO) + sizeof(POWER_BROADCAST) + MAX_PATH;

// create stop event
HANDLE hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

// create event for GPS change
HANDLE hDeviceStateChanged = CreateEvent(NULL, FALSE, FALSE, NULL);

// Create message queue
MSGQUEUEOPTIONS msgQueueOptions;
ZeroMemory(&msgQueueOptions, sizeof(msgQueueOptions));
msgQueueOptions.dwSize = sizeof(msgQueueOptions);
msgQueueOptions.dwFlags = MSGQUEUE_NOPRECOMMIT ;
msgQueueOptions.cbMaxMessage = maxMsgQueueMsgSize;
msgQueueOptions.bReadAccess = TRUE;

HANDLE hMsgQueue = ::CreateMsgQueue(NULL,  &msgQueueOptions);
HANDLE hPowerNotification = ::RequestPowerNotifications(hMsgQueue, PBT_POWERINFOCHANGE | PBT_TRANSITION);

// opening GPS device
HANDLE hGPSDevice = ::GPSOpenDevice( 0, hDeviceStateChanged, NULL, 0);

bool bRun = true; // run loop
bool bHasSignal = false; 

// change power requirement for GPS device and SD card
HANDLE hGPSPowerReq = ::SetPowerRequirement(L"GPS0:", D0, POWER_NAME|POWER_FORCE, NULL, NULL);
HANDLE hPowerReq = ::SetPowerRequirement(L"DSK1:", D0, POWER_NAME|POWER_FORCE, NULL, NULL);

// change to Unattended mode
::PowerPolicyNotify(PPN_UNATTENDEDMODE, TRUE);

// LOOOP
HANDLE events[3] = {hDeviceStateChanged, hStopEvent, hMsgQueue} ;
while (bRun)
{
	DWORD dwWaitRes = ::WaitForMultipleObjects(3, events, FALSE, 1000 ); // read every 1. sec.
	switch (dwWaitRes)
	{
	case WAIT_OBJECT_0:
		// device status changed
		{
			GPS_DEVICE dev;
			ZeroMemory(&dev, sizeof(dev));
			dev.dwVersion = GPS_VERSION_1;
			if (ERROR_SUCCESS == ::GPSGetDeviceState(&dev))
			{
				// do something... 
			}
		}
		break;
	case WAIT_OBJECT_0+1:
		// exit requested from exit event.. this is done from other thread by calling SetEvent(hExitEvent)
		bRun = false;
		break;
	case WAIT_OBJECT_0+2:
		// if we are on low power, stop monitoring
		{
			// there is a message in EventQueue.. read queue
			BYTE buffer[maxMsgQueueMsgSize];
			DWORD NumberOfBytesRead = 0;
			ZeroMemory(buffer, maxMsgQueueMsgSize);

			DWORD dwFlags;
			if (::ReadMsgQueue(m_hMsgQueue, buffer, maxMsgQueueMsgSize,&NumberOfBytesRead, 0, &dwFlags ) && NumberOfBytesRead>=sizeof(POWER_BROADCAST))
			{
				POWER_BROADCAST* pPwrBrodcast = (POWER_BROADCAST*)(buffer);
				switch(pPwrBrodcast->Message)
				{
				case PBT_POWERINFOCHANGE:
					{
						// if battery level is to low, finish with GPS reading
						POWER_BROADCAST_POWER_INFO* pPowerInfo = (POWER_BROADCAST_POWER_INFO*)pPwrBrodcast->SystemPowerState;
						if ((pPowerInfo->bBatteryFlag==2 || pPowerInfo->bBatteryFlag==4) && (pPowerInfo->bACLineStatus==0))
							bRun = false;
					}
					break;
				case PBT_TRANSITION:
					{
						std::wstring powerState = pPwrBrodcast->SystemPowerState;
						// handle power states
						if (powerState==L"resuming")
							::PowerPolicyNotify(PPN_UNATTENDEDMODE, TRUE); // basicaly should never happen, because we do not allow to go in 
						if (powerState==L"unattended")
							SystemIdleTimerReset();
					}
					break;
				default:
					ASSERT(!"Unknown message");
				}

			}
		break; 
	case WAIT_TIMEOUT:
		// new location
		break;
	}
	// DO SOMETHING... e.g. Read position from GPS PORT
}
// ENDLOOP

::PowerPolicyNotify(PPN_UNATTENDEDMODE, FALSE); // Leave unattended mode
::ReleasePowerRequirement(hGPSPowerReq);		// allow GPS device to go in sleep
::ReleasePowerRequirement(hPowerReq);

::GPSCloseDevice(hGPSDevice); // close GPS device

StopPowerNotifications(hPowerNotification);
CloseMsgQueue(hMsgQueue);
CloseHandle(hPowerNotification);
CloseHandle(hMsgQueue);
#endif

#ifdef MORE_FUTURE_CODE
// John Baik: Sample code for Power Notification

#include <windows.h>
#include <PM.h>
// from pmimpl.h file.
#ifndef QUEUE_ENTRIES
#define QUEUE_ENTRIES 3
#endif
#ifndef MAX_NAMELEN
#define MAX_NAMELEN 128
#endif

#ifndef QUEUE_SIZE
#define QUEUE_SIZE (QUEUE_ENTRIES * (sizeof(POWER_BROADCAST) +
(MAX_NAMELEN * sizeof(TCHAR))))
#endif

int WINAPI PMNotifyThread(LPVOID pvParam);
hPMThread = CreateThread(NULL, 0,
(LPTHREAD_START_ROUTINE )PMNotifyThread, NULL, 0, NULL);
void PMNotification(HANDLE hMsgQ);

HANDLE ghPMNotifyQ = NULL;

int WINAPI WinMain(HINSTANCE hInstance,
HINSTANCE hPrevInstance,
LPTSTR lpCmdLine,
int nCmdShow)
{
MSGQUEUEOPTIONS msgQpm = {0};
HANDLE hPwrNotify=NULL; // Power manager handle
HANDLE hPMThread=NULL;

// create a message queue for Power Manager notifications
msgQpm.dwSize = sizeof(MSGQUEUEOPTIONS);
msgQpm.dwFlags = 0;
msgQpm.dwMaxMessages = QUEUE_ENTRIES;
msgQpm.cbMaxMessage = sizeof(POWER_BROADCAST) + MAX_NAMELEN;
msgQpm.bReadAccess = TRUE;

ghPMNotifyQ= CreateMsgQueue(NULL, &msgQpm);

if (ghPMNotifyQ == NULL)
{
DWORD dwErr = GetLastError();
RETAILMSG(1, (TEXT(" PMNotify:CreateMessageQueue ERROR:%d \r\n"), dwErr));
return 1;
}

// request Power notifications
hPwrNotify = RequestPowerNotifications(ghPMNotifyQ, PBT_TRANSITION |
PBT_RESUME);

if (hPwrNotify == NULL)
{
DWORD dwErr = GetLastError();
RETAILMSG(1, (TEXT(" PMNotify:RequestPowerNotifications ERROR:%d\r\n"), dwErr));
return 2;
}

int WINAPI PMNotifyThread(LPVOID pvParam);
// Create PMNotifyThread
hPMThread = CreateThread(NULL, 0,
(LPTHREAD_START_ROUTINE )PMNotifyThread, NULL, 0, NULL);

if(hPMThread)
{
// wait for PMNotifyThread done
WaitForSingleObject(hPMThread, INFINITE);
CloseHandle(hPMThread);

if(hPwrNotify)
{
StopPowerNotifications(hPwrNotify);
}
}

return 0;

}

// PMNotifyThread: Wait for Message from PM Driver.
//
int WINAPI PMNotifyThread(LPVOID pvParam)
{
int WINAPI PMNotifyThread(LPVOID pvParam);
// Create PMNotifyThread
hPMThread = CreateThread(NULL, 0,
(LPTHREAD_START_ROUTINE )PMNotifyThread, NULL, 0, NULL);

if(hPMThread)
{
// wait for PMNotifyThread done
WaitForSingleObject(hPMThread, INFINITE);
CloseHandle(hPMThread);

DWORD dwStatus;

while (TRUE)
{
dwStatus = WaitForSingleObject(ghPMNotifyQ, INFINITE);

if(dwStatus == WAIT_OBJECT_0)
{
PMNotification(ghPMNotifyQ);
}
else
{
RETAILMSG(1, (TEXT(" PMNotify: WaitForSingleObject returned %d (error %d)\r\n"),dwStatus, GetLastError()));
break;
}
}

return 0;
}

void PMNotification(HANDLE hMsgQ)
{
UCHAR pmbuf[QUEUE_SIZE];
int nBytesRead=0;
DWORD dwFlags = 0;
int dwCount = 0;

memset(pmbuf, 0, sizeof(pmbuf));

if ( !ReadMsgQueue(hMsgQ,
pmbuf,
QUEUE_SIZE,
(LPDWORD)&nBytesRead,
INFINITE, // Timeout
&dwFlags))
{
DWORD dwErr = GetLastError();
RETAILMSG(1, (TEXT(" ProcessPowerNotification: ReadMsgQueue: ERROR:%d\n"), dwErr));
}
else if(nBytesRead >= sizeof(POWER_BROADCAST))
{
// process power notifications
//-----------------------------
PPOWER_BROADCAST pPB = (PPOWER_BROADCAST) pmbuf;

switch (pPB->Message)
{
case PBT_RESUME:
RETAILMSG(1, (TEXT(" PMNotify:PBT_RESUME \r\n")));
break;

case PBT_POWERSTATUSCHANGE:
RETAILMSG(1, (TEXT(" PMNotify:PBT_POWERSTATUSCHANGE: \r\n")));
break;

case PBT_POWERINFOCHANGE:
RETAILMSG(1, (TEXT(" PMNotify:PBT_POWERSTATUSCHANGE: \r\n")));
break;

case PBT_TRANSITION:
{
switch (POWER_STATE(pPB->Flags))
{
case POWER_STATE_ON:
break;
case POWER_STATE_OFF:
break;
case POWER_STATE_CRITICAL:
break;
case POWER_STATE_BOOT:
break;
case POWER_STATE_IDLE:
break;
case POWER_STATE_SUSPEND:
break;
case POWER_STATE_RESET:
break;
default:
break;
}
break;
}

default:
break;
}
}
}
#endif

#ifdef OBSOLETE
		{	unsigned long s = FindStationCall(To);
			/* -IS only if I'm enabled, connected, and the station isn't on RF */
			BOOL ISOnly = APRSEnabled && ActiveConfig.Enables.APRSIS && ActiveConfig.Enables.Internet && (s!=-1&&!CloseStations[s].HeardOnRF);
			CLIENT_INFO_S *cInfo = (CLIENT_INFO_S *) GetWindowLong(hwnd, GWL_USERDATA);
			strncpy(PendingMsgs[m].MsgAckFrom, To, sizeof(PendingMsgs[m].MsgAckFrom));
			TraceLog("Messages", FALSE, hwnd, "%s", PendingMsgs[m].Message);
			QueueToTransmit(MESSAGE_PACKET, PendingMsgs[m].Message, FALSE, ISOnly);
			PendingMsgs[m].msNextSend = NEXT_MSG_SEND(0);	/* Bootstrap the retries */
			if (MsgAckID > MAX_ACK) MsgAckID = 1;
			if (!Ack) PendingMsgCount--;	/* Don't keep in the pending list */
			if (PendingMsgCount)
			{	EnableMenuItem(cInfo->hMenu, ID_PENDING_MESSAGES, MF_ENABLED);
				InvalidateMessage(hwnd, TRUE);
			}
		}

				{	BOOL ISOnly = FALSE;
					if (APRSEnabled && ActiveConfig.Enables.APRSIS	/* APRS-IS enabled? */
					&& ActiveConfig.Enables.Internet	/* Internet enabled? */
					&& !PendingMsgs[m].Retriggered)
					{	unsigned long s = FindStationCall(PendingMsgs[m].aTo);
						ISOnly = (s!=-1 && !CloseStations[s].HeardOnRF);	/* Not on RF? */
					}
					
					QueueToTransmit(MESSAGE_PACKET, PendingMsgs[m].Message, FALSE, ISOnly);
					if (++PendingMsgs[m].Retries < MAX_MSG_RETRIES)
						PendingMsgs[m].msNextSend = NEXT_MSG_SEND(PendingMsgs[m].Retries);
					else if (!PendingMsgs[m].Retriggered)
					{	unsigned int s = FindStationCall(PendingMsgs[m].MsgAckFrom);
						if (s != -1)
						{	CloseStations[s].MessagePending = TRUE;	/* Flag this one for retry restart */
							TraceLog("Messages", TRUE, hwnd, "MSG:Flagging(%.*s) For Message Retry restart\n", STRING(CloseStations[s].Station));
						}
					} else TraceLog("Messages", TRUE, hwnd, "MSG:Message(%.*s) Exhausted Retries TWICE!\n", STRING(PendingMsgs[m].MsgAckFrom));
				}
#endif

